import {
  RELAY_JSONRPC,
  detect,
  require_chacha20poly1305,
  require_cjs,
  require_cjs2,
  require_cjs3,
  require_decode_uri_component,
  require_filter_obj,
  require_hkdf,
  require_random,
  require_sha256,
  require_split_on_first,
  require_strict_uri_encode,
  require_x25519
} from "./chunk-CU6BV7PM.js";
import {
  bases,
  init_basics
} from "./chunk-J7OBOGMR.js";
import {
  __commonJS,
  __toESM
} from "./chunk-P3R5BNFQ.js";

// node_modules/@walletconnect/utils/node_modules/query-string/index.js
var require_query_string = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/query-string/index.js"(exports) {
    "use strict";
    var strictUriEncode = require_strict_uri_encode();
    var decodeComponent = require_decode_uri_component();
    var splitOnFirst = require_split_on_first();
    var filterObject = require_filter_obj();
    var isNullOrUndefined = (value) => value === null || value === void 0;
    var encodeFragmentIdentifier = Symbol("encodeFragmentIdentifier");
    function encoderForArrayFormat(options) {
      switch (options.arrayFormat) {
        case "index":
          return (key) => (result, value) => {
            const index = result.length;
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode(key, options), "[", index, "]"].join("")];
            }
            return [
              ...result,
              [encode(key, options), "[", encode(index, options), "]=", encode(value, options)].join("")
            ];
          };
        case "bracket":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode(key, options), "[]"].join("")];
            }
            return [...result, [encode(key, options), "[]=", encode(value, options)].join("")];
          };
        case "colon-list-separator":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode(key, options), ":list="].join("")];
            }
            return [...result, [encode(key, options), ":list=", encode(value, options)].join("")];
          };
        case "comma":
        case "separator":
        case "bracket-separator": {
          const keyValueSep = options.arrayFormat === "bracket-separator" ? "[]=" : "=";
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            value = value === null ? "" : value;
            if (result.length === 0) {
              return [[encode(key, options), keyValueSep, encode(value, options)].join("")];
            }
            return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
          };
        }
        default:
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, encode(key, options)];
            }
            return [...result, [encode(key, options), "=", encode(value, options)].join("")];
          };
      }
    }
    function parserForArrayFormat(options) {
      let result;
      switch (options.arrayFormat) {
        case "index":
          return (key, value, accumulator) => {
            result = /\[(\d*)\]$/.exec(key);
            key = key.replace(/\[\d*\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = {};
            }
            accumulator[key][result[1]] = value;
          };
        case "bracket":
          return (key, value, accumulator) => {
            result = /(\[\])$/.exec(key);
            key = key.replace(/\[\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "colon-list-separator":
          return (key, value, accumulator) => {
            result = /(:list)$/.exec(key);
            key = key.replace(/:list$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "comma":
        case "separator":
          return (key, value, accumulator) => {
            const isArray = typeof value === "string" && value.includes(options.arrayFormatSeparator);
            const isEncodedArray = typeof value === "string" && !isArray && decode(value, options).includes(options.arrayFormatSeparator);
            value = isEncodedArray ? decode(value, options) : value;
            const newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map((item) => decode(item, options)) : value === null ? value : decode(value, options);
            accumulator[key] = newValue;
          };
        case "bracket-separator":
          return (key, value, accumulator) => {
            const isArray = /(\[\])$/.test(key);
            key = key.replace(/\[\]$/, "");
            if (!isArray) {
              accumulator[key] = value ? decode(value, options) : value;
              return;
            }
            const arrayValue = value === null ? [] : value.split(options.arrayFormatSeparator).map((item) => decode(item, options));
            if (accumulator[key] === void 0) {
              accumulator[key] = arrayValue;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], arrayValue);
          };
        default:
          return (key, value, accumulator) => {
            if (accumulator[key] === void 0) {
              accumulator[key] = value;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
      }
    }
    function validateArrayFormatSeparator(value) {
      if (typeof value !== "string" || value.length !== 1) {
        throw new TypeError("arrayFormatSeparator must be single character string");
      }
    }
    function encode(value, options) {
      if (options.encode) {
        return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
      }
      return value;
    }
    function decode(value, options) {
      if (options.decode) {
        return decodeComponent(value);
      }
      return value;
    }
    function keysSorter(input) {
      if (Array.isArray(input)) {
        return input.sort();
      }
      if (typeof input === "object") {
        return keysSorter(Object.keys(input)).sort((a, b) => Number(a) - Number(b)).map((key) => input[key]);
      }
      return input;
    }
    function removeHash(input) {
      const hashStart = input.indexOf("#");
      if (hashStart !== -1) {
        input = input.slice(0, hashStart);
      }
      return input;
    }
    function getHash(url) {
      let hash = "";
      const hashStart = url.indexOf("#");
      if (hashStart !== -1) {
        hash = url.slice(hashStart);
      }
      return hash;
    }
    function extract(input) {
      input = removeHash(input);
      const queryStart = input.indexOf("?");
      if (queryStart === -1) {
        return "";
      }
      return input.slice(queryStart + 1);
    }
    function parseValue(value, options) {
      if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
        value = Number(value);
      } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
        value = value.toLowerCase() === "true";
      }
      return value;
    }
    function parse2(query, options) {
      options = Object.assign({
        decode: true,
        sort: true,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: false,
        parseBooleans: false
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const formatter = parserForArrayFormat(options);
      const ret = /* @__PURE__ */ Object.create(null);
      if (typeof query !== "string") {
        return ret;
      }
      query = query.trim().replace(/^[?#&]/, "");
      if (!query) {
        return ret;
      }
      for (const param of query.split("&")) {
        if (param === "") {
          continue;
        }
        let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, " ") : param, "=");
        value = value === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(options.arrayFormat) ? value : decode(value, options);
        formatter(decode(key, options), value, ret);
      }
      for (const key of Object.keys(ret)) {
        const value = ret[key];
        if (typeof value === "object" && value !== null) {
          for (const k2 of Object.keys(value)) {
            value[k2] = parseValue(value[k2], options);
          }
        } else {
          ret[key] = parseValue(value, options);
        }
      }
      if (options.sort === false) {
        return ret;
      }
      return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
        const value = ret[key];
        if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
          result[key] = keysSorter(value);
        } else {
          result[key] = value;
        }
        return result;
      }, /* @__PURE__ */ Object.create(null));
    }
    exports.extract = extract;
    exports.parse = parse2;
    exports.stringify = (object, options) => {
      if (!object) {
        return "";
      }
      options = Object.assign({
        encode: true,
        strict: true,
        arrayFormat: "none",
        arrayFormatSeparator: ","
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const shouldFilter = (key) => options.skipNull && isNullOrUndefined(object[key]) || options.skipEmptyString && object[key] === "";
      const formatter = encoderForArrayFormat(options);
      const objectCopy = {};
      for (const key of Object.keys(object)) {
        if (!shouldFilter(key)) {
          objectCopy[key] = object[key];
        }
      }
      const keys = Object.keys(objectCopy);
      if (options.sort !== false) {
        keys.sort(options.sort);
      }
      return keys.map((key) => {
        const value = object[key];
        if (value === void 0) {
          return "";
        }
        if (value === null) {
          return encode(key, options);
        }
        if (Array.isArray(value)) {
          if (value.length === 0 && options.arrayFormat === "bracket-separator") {
            return encode(key, options) + "[]";
          }
          return value.reduce(formatter(key), []).join("&");
        }
        return encode(key, options) + "=" + encode(value, options);
      }).filter((x2) => x2.length > 0).join("&");
    };
    exports.parseUrl = (url, options) => {
      options = Object.assign({
        decode: true
      }, options);
      const [url_, hash] = splitOnFirst(url, "#");
      return Object.assign(
        {
          url: url_.split("?")[0] || "",
          query: parse2(extract(url), options)
        },
        options && options.parseFragmentIdentifier && hash ? { fragmentIdentifier: decode(hash, options) } : {}
      );
    };
    exports.stringifyUrl = (object, options) => {
      options = Object.assign({
        encode: true,
        strict: true,
        [encodeFragmentIdentifier]: true
      }, options);
      const url = removeHash(object.url).split("?")[0] || "";
      const queryFromUrl = exports.extract(object.url);
      const parsedQueryFromUrl = exports.parse(queryFromUrl, { sort: false });
      const query = Object.assign(parsedQueryFromUrl, object.query);
      let queryString = exports.stringify(query, options);
      if (queryString) {
        queryString = `?${queryString}`;
      }
      let hash = getHash(object.url);
      if (object.fragmentIdentifier) {
        hash = `#${options[encodeFragmentIdentifier] ? encode(object.fragmentIdentifier, options) : object.fragmentIdentifier}`;
      }
      return `${url}${queryString}${hash}`;
    };
    exports.pick = (input, filter, options) => {
      options = Object.assign({
        parseFragmentIdentifier: true,
        [encodeFragmentIdentifier]: false
      }, options);
      const { url, query, fragmentIdentifier } = exports.parseUrl(input, options);
      return exports.stringifyUrl({
        url,
        query: filterObject(query, filter),
        fragmentIdentifier
      }, options);
    };
    exports.exclude = (input, filter, options) => {
      const exclusionFilter = Array.isArray(filter) ? (key) => !filter.includes(key) : (key, value) => !filter(key, value);
      return exports.pick(input, exclusionFilter, options);
    };
  }
});

// node_modules/@walletconnect/utils/dist/index.es.js
var import_chacha20poly1305 = __toESM(require_chacha20poly1305());
var import_hkdf = __toESM(require_hkdf());
var import_random = __toESM(require_random());
var import_sha256 = __toESM(require_sha256());
var fe = __toESM(require_x25519());

// node_modules/@walletconnect/utils/node_modules/uint8arrays/esm/src/util/as-uint8array.js
function asUint8Array(buf) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  return buf;
}

// node_modules/@walletconnect/utils/node_modules/uint8arrays/esm/src/alloc.js
function allocUnsafe(size = 0) {
  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
    return asUint8Array(globalThis.Buffer.allocUnsafe(size));
  }
  return new Uint8Array(size);
}

// node_modules/@walletconnect/utils/node_modules/uint8arrays/esm/src/concat.js
function concat(arrays, length) {
  if (!length) {
    length = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output = allocUnsafe(length);
  let offset = 0;
  for (const arr of arrays) {
    output.set(arr, offset);
    offset += arr.length;
  }
  return asUint8Array(output);
}

// node_modules/@walletconnect/utils/node_modules/uint8arrays/esm/src/util/bases.js
init_basics();
function createCodec(name, prefix, encode, decode) {
  return {
    name,
    prefix,
    encoder: {
      name,
      prefix,
      encode
    },
    decoder: { decode }
  };
}
var string = createCodec("utf8", "u", (buf) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf);
}, (str) => {
  const encoder = new TextEncoder();
  return encoder.encode(str.substring(1));
});
var ascii = createCodec("ascii", "a", (buf) => {
  let string2 = "a";
  for (let i = 0; i < buf.length; i++) {
    string2 += String.fromCharCode(buf[i]);
  }
  return string2;
}, (str) => {
  str = str.substring(1);
  const buf = allocUnsafe(str.length);
  for (let i = 0; i < str.length; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
});
var BASES = {
  utf8: string,
  "utf-8": string,
  hex: bases.base16,
  latin1: ascii,
  ascii,
  binary: ascii,
  ...bases
};
var bases_default = BASES;

// node_modules/@walletconnect/utils/node_modules/uint8arrays/esm/src/from-string.js
function fromString(string2, encoding = "utf8") {
  const base = bases_default[encoding];
  if (!base) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8Array(globalThis.Buffer.from(string2, "utf-8"));
  }
  return base.decoder.decode(`${base.prefix}${string2}`);
}

// node_modules/@walletconnect/utils/node_modules/uint8arrays/esm/src/to-string.js
function toString(array, encoding = "utf8") {
  const base = bases_default[encoding];
  if (!base) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
  }
  return base.encoder.encode(array).substring(1);
}

// node_modules/@walletconnect/utils/dist/index.es.js
var import_time = __toESM(require_cjs());
var import_window_getters = __toESM(require_cjs2());
var import_window_metadata = __toESM(require_cjs3());
var V = __toESM(require_query_string());
var M = ":";
function ve(e) {
  const [n, t] = e.split(M);
  return { namespace: n, reference: t };
}
function Rn(e, n = []) {
  const t = [];
  return Object.keys(e).forEach((r) => {
    if (n.length && !n.includes(r))
      return;
    const o = e[r];
    t.push(...o.accounts);
  }), t;
}
function K(e, n) {
  return e.includes(":") ? [e] : n.chains || [];
}
var J = "base10";
var p = "base16";
var x = "base64pad";
var F = "utf8";
var Q = 0;
var _ = 1;
var $n = 0;
var Ie = 1;
var Z = 12;
var X = 32;
function jn() {
  const e = fe.generateKeyPair();
  return { privateKey: toString(e.secretKey, p), publicKey: toString(e.publicKey, p) };
}
function Dn() {
  const e = (0, import_random.randomBytes)(X);
  return toString(e, p);
}
function kn(e, n) {
  const t = fe.sharedKey(fromString(e, p), fromString(n, p), true), r = new import_hkdf.HKDF(import_sha256.SHA256, t).expand(X);
  return toString(r, p);
}
function Vn(e) {
  const n = (0, import_sha256.hash)(fromString(e, p));
  return toString(n, p);
}
function Mn(e) {
  const n = (0, import_sha256.hash)(fromString(e, F));
  return toString(n, p);
}
function Pe(e) {
  return fromString(`${e}`, J);
}
function $(e) {
  return Number(toString(e, J));
}
function Kn(e) {
  const n = Pe(typeof e.type < "u" ? e.type : Q);
  if ($(n) === _ && typeof e.senderPublicKey > "u")
    throw new Error("Missing sender public key for type 1 envelope");
  const t = typeof e.senderPublicKey < "u" ? fromString(e.senderPublicKey, p) : void 0, r = typeof e.iv < "u" ? fromString(e.iv, p) : (0, import_random.randomBytes)(Z), o = new import_chacha20poly1305.ChaCha20Poly1305(fromString(e.symKey, p)).seal(r, fromString(e.message, F));
  return Te({ type: n, sealed: o, iv: r, senderPublicKey: t });
}
function Ln(e) {
  const n = new import_chacha20poly1305.ChaCha20Poly1305(fromString(e.symKey, p)), { sealed: t, iv: r } = ee(e.encoded), o = n.open(r, t);
  if (o === null)
    throw new Error("Failed to decrypt");
  return toString(o, F);
}
function Te(e) {
  if ($(e.type) === _) {
    if (typeof e.senderPublicKey > "u")
      throw new Error("Missing sender public key for type 1 envelope");
    return toString(concat([e.type, e.senderPublicKey, e.iv, e.sealed]), x);
  }
  return toString(concat([e.type, e.iv, e.sealed]), x);
}
function ee(e) {
  const n = fromString(e, x), t = n.slice($n, Ie), r = Ie;
  if ($(t) === _) {
    const l = r + X, d = l + Z, c = n.slice(r, l), u = n.slice(l, d), a = n.slice(d);
    return { type: t, sealed: a, iv: u, senderPublicKey: c };
  }
  const o = r + Z, s = n.slice(r, o), i = n.slice(o);
  return { type: t, sealed: i, iv: s };
}
function xn(e, n) {
  const t = ee(e);
  return Re({ type: $(t.type), senderPublicKey: typeof t.senderPublicKey < "u" ? toString(t.senderPublicKey, p) : void 0, receiverPublicKey: n == null ? void 0 : n.receiverPublicKey });
}
function Re(e) {
  const n = (e == null ? void 0 : e.type) || Q;
  if (n === _) {
    if (typeof (e == null ? void 0 : e.senderPublicKey) > "u")
      throw new Error("missing sender public key");
    if (typeof (e == null ? void 0 : e.receiverPublicKey) > "u")
      throw new Error("missing receiver public key");
  }
  return { type: n, senderPublicKey: e == null ? void 0 : e.senderPublicKey, receiverPublicKey: e == null ? void 0 : e.receiverPublicKey };
}
function Fn(e) {
  return e.type === _ && typeof e.senderPublicKey == "string" && typeof e.receiverPublicKey == "string";
}
var Hn = Object.defineProperty;
var Ae = Object.getOwnPropertySymbols;
var qn = Object.prototype.hasOwnProperty;
var Bn = Object.prototype.propertyIsEnumerable;
var Ue = (e, n, t) => n in e ? Hn(e, n, { enumerable: true, configurable: true, writable: true, value: t }) : e[n] = t;
var _e = (e, n) => {
  for (var t in n || (n = {}))
    qn.call(n, t) && Ue(e, t, n[t]);
  if (Ae)
    for (var t of Ae(n))
      Bn.call(n, t) && Ue(e, t, n[t]);
  return e;
};
var Ce = "ReactNative";
var m = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" };
var je = "js";
function te() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
function j() {
  return !(0, import_window_getters.getDocument)() && !!(0, import_window_getters.getNavigator)() && navigator.product === Ce;
}
function q() {
  return !te() && !!(0, import_window_getters.getNavigator)();
}
function R() {
  return j() ? m.reactNative : te() ? m.node : q() ? m.browser : m.unknown;
}
function De(e, n) {
  let t = V.parse(e);
  return t = _e(_e({}, t), n), e = V.stringify(t), e;
}
function zn() {
  return (0, import_window_metadata.getWindowMetadata)() || { name: "", description: "", url: "", icons: [""] };
}
function ke() {
  if (R() === m.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
    const { OS: t, Version: r } = global.Platform;
    return [t, r].join("-");
  }
  const e = detect();
  if (e === null)
    return "unknown";
  const n = e.os ? e.os.replace(" ", "").toLowerCase() : "unknown";
  return e.type === "browser" ? [n, e.name, e.version].join("-") : [n, e.version].join("-");
}
function Ve() {
  var e;
  const n = R();
  return n === m.browser ? [n, ((e = (0, import_window_getters.getLocation)()) == null ? void 0 : e.host) || "unknown"].join(":") : n;
}
function Me(e, n, t) {
  const r = ke(), o = Ve();
  return [[e, n].join("-"), [je, t].join("-"), r, o].join("/");
}
function Jn({ protocol: e, version: n, relayUrl: t, sdkVersion: r, auth: o, projectId: s, useOnCloseEvent: i }) {
  const l = t.split("?"), d = Me(e, n, r), c = { auth: o, ua: d, projectId: s, useOnCloseEvent: i || void 0 }, u = De(l[1] || "", c);
  return l[0] + "?" + u;
}
function O(e, n) {
  return e.filter((t) => n.includes(t)).length === e.length;
}
function et(e) {
  return Object.fromEntries(e.entries());
}
function nt(e) {
  return new Map(Object.entries(e));
}
function st(e = import_time.FIVE_MINUTES, n) {
  const t = (0, import_time.toMiliseconds)(e || import_time.FIVE_MINUTES);
  let r, o, s;
  return { resolve: (i) => {
    s && r && (clearTimeout(s), r(i));
  }, reject: (i) => {
    s && o && (clearTimeout(s), o(i));
  }, done: () => new Promise((i, l) => {
    s = setTimeout(() => {
      l(new Error(n));
    }, t), r = i, o = l;
  }) };
}
function it(e, n, t) {
  return new Promise(async (r, o) => {
    const s = setTimeout(() => o(new Error(t)), n);
    try {
      const i = await e;
      r(i);
    } catch (i) {
      o(i);
    }
    clearTimeout(s);
  });
}
function re(e, n) {
  if (typeof n == "string" && n.startsWith(`${e}:`))
    return n;
  if (e.toLowerCase() === "topic") {
    if (typeof n != "string")
      throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${n}`;
  } else if (e.toLowerCase() === "id") {
    if (typeof n != "number")
      throw new Error('Value must be "number" for expirer target type: id');
    return `id:${n}`;
  }
  throw new Error(`Unknown expirer target type: ${e}`);
}
function ct(e) {
  return re("topic", e);
}
function at(e) {
  return re("id", e);
}
function ut(e) {
  const [n, t] = e.split(":"), r = { id: void 0, topic: void 0 };
  if (n === "topic" && typeof t == "string")
    r.topic = t;
  else if (n === "id" && Number.isInteger(Number(t)))
    r.id = Number(t);
  else
    throw new Error(`Invalid target, expected id:number or topic:string, got ${n}:${t}`);
  return r;
}
function lt(e, n) {
  return (0, import_time.fromMiliseconds)((n || Date.now()) + (0, import_time.toMiliseconds)(e));
}
function dt(e) {
  return Date.now() >= (0, import_time.toMiliseconds)(e);
}
function ft(e, n) {
  return `${e}${n ? `:${n}` : ""}`;
}
function S(e = [], n = []) {
  return [.../* @__PURE__ */ new Set([...e, ...n])];
}
async function pt({ id: e, topic: n, wcDeepLink: t }) {
  try {
    if (!t)
      return;
    const r = typeof t == "string" ? JSON.parse(t) : t;
    let o = r == null ? void 0 : r.href;
    if (typeof o != "string")
      return;
    o.endsWith("/") && (o = o.slice(0, -1));
    const s = `${o}/wc?requestId=${e}&sessionTopic=${n}`, i = R();
    i === m.browser ? s.startsWith("https://") ? window.open(s, "_blank", "noreferrer noopener") : window.open(s, "_self", "noreferrer noopener") : i === m.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(s);
  } catch (r) {
    console.error(r);
  }
}
var Fe = "irn";
function mt(e) {
  return (e == null ? void 0 : e.relay) || { protocol: Fe };
}
function yt(e) {
  const n = RELAY_JSONRPC[e];
  if (typeof n > "u")
    throw new Error(`Relay Protocol not supported: ${e}`);
  return n;
}
var ht = Object.defineProperty;
var He = Object.getOwnPropertySymbols;
var vt = Object.prototype.hasOwnProperty;
var gt = Object.prototype.propertyIsEnumerable;
var qe = (e, n, t) => n in e ? ht(e, n, { enumerable: true, configurable: true, writable: true, value: t }) : e[n] = t;
var Et = (e, n) => {
  for (var t in n || (n = {}))
    vt.call(n, t) && qe(e, t, n[t]);
  if (He)
    for (var t of He(n))
      gt.call(n, t) && qe(e, t, n[t]);
  return e;
};
function Be(e, n = "-") {
  const t = {}, r = "relay" + n;
  return Object.keys(e).forEach((o) => {
    if (o.startsWith(r)) {
      const s = o.replace(r, ""), i = e[o];
      t[s] = i;
    }
  }), t;
}
function bt(e) {
  const n = e.indexOf(":"), t = e.indexOf("?") !== -1 ? e.indexOf("?") : void 0, r = e.substring(0, n), o = e.substring(n + 1, t).split("@"), s = typeof t < "u" ? e.substring(t) : "", i = V.parse(s);
  return { protocol: r, topic: Ge(o[0]), version: parseInt(o[1], 10), symKey: i.symKey, relay: Be(i) };
}
function Ge(e) {
  return e.startsWith("//") ? e.substring(2) : e;
}
function We(e, n = "-") {
  const t = "relay", r = {};
  return Object.keys(e).forEach((o) => {
    const s = t + n + o;
    e[o] && (r[s] = e[o]);
  }), r;
}
function Nt(e) {
  return `${e.protocol}:${e.topic}@${e.version}?` + V.stringify(Et({ symKey: e.symKey }, We(e.relay)));
}
var Ot = Object.defineProperty;
var St = Object.defineProperties;
var wt = Object.getOwnPropertyDescriptors;
var ze = Object.getOwnPropertySymbols;
var It = Object.prototype.hasOwnProperty;
var Pt = Object.prototype.propertyIsEnumerable;
var Ye = (e, n, t) => n in e ? Ot(e, n, { enumerable: true, configurable: true, writable: true, value: t }) : e[n] = t;
var Tt = (e, n) => {
  for (var t in n || (n = {}))
    It.call(n, t) && Ye(e, t, n[t]);
  if (ze)
    for (var t of ze(n))
      Pt.call(n, t) && Ye(e, t, n[t]);
  return e;
};
var Rt = (e, n) => St(e, wt(n));
function A(e) {
  const n = [];
  return e.forEach((t) => {
    const [r, o] = t.split(":");
    n.push(`${r}:${o}`);
  }), n;
}
function Je(e) {
  const n = [];
  return Object.values(e).forEach((t) => {
    n.push(...A(t.accounts));
  }), n;
}
function Qe(e, n) {
  const t = [];
  return Object.values(e).forEach((r) => {
    A(r.accounts).includes(n) && t.push(...r.methods);
  }), t;
}
function Ze(e, n) {
  const t = [];
  return Object.values(e).forEach((r) => {
    A(r.accounts).includes(n) && t.push(...r.events);
  }), t;
}
function At(e, n) {
  const t = cn(e, n);
  if (t)
    throw new Error(t.message);
  const r = {};
  for (const [o, s] of Object.entries(e))
    r[o] = { methods: s.methods, events: s.events, chains: s.accounts.map((i) => `${i.split(":")[0]}:${i.split(":")[1]}`) };
  return r;
}
function oe(e) {
  return e.includes(":");
}
function Xe(e) {
  return oe(e) ? e.split(":")[0] : e;
}
function se(e) {
  var n, t, r;
  const o = {};
  if (!B(e))
    return o;
  for (const [s, i] of Object.entries(e)) {
    const l = oe(s) ? [s] : i.chains, d = i.methods || [], c = i.events || [], u = Xe(s);
    o[u] = Rt(Tt({}, o[u]), { chains: S(l, (n = o[u]) == null ? void 0 : n.chains), methods: S(d, (t = o[u]) == null ? void 0 : t.methods), events: S(c, (r = o[u]) == null ? void 0 : r.events) });
  }
  return o;
}
var _t = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } };
var Ct = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function N(e, n) {
  const { message: t, code: r } = Ct[e];
  return { message: n ? `${t} ${n}` : t, code: r };
}
function U(e, n) {
  const { message: t, code: r } = _t[e];
  return { message: n ? `${t} ${n}` : t, code: r };
}
function D(e, n) {
  return Array.isArray(e) ? typeof n < "u" && e.length ? e.every(n) : true : false;
}
function B(e) {
  return Object.getPrototypeOf(e) === Object.prototype && Object.keys(e).length;
}
function w(e) {
  return typeof e > "u";
}
function h(e, n) {
  return n && w(e) ? true : typeof e == "string" && !!e.trim().length;
}
function G(e, n) {
  return n && w(e) ? true : typeof e == "number" && !isNaN(e);
}
function $t(e, n) {
  const { requiredNamespaces: t } = n, r = Object.keys(e.namespaces), o = Object.keys(t);
  let s = true;
  return O(o, r) ? (r.forEach((i) => {
    const { accounts: l, methods: d, events: c } = e.namespaces[i], u = A(l), a = t[i];
    (!O(K(i, a), u) || !O(a.methods, d) || !O(a.events, c)) && (s = false);
  }), s) : false;
}
function k(e) {
  return h(e, false) && e.includes(":") ? e.split(":").length === 2 : false;
}
function en(e) {
  if (h(e, false) && e.includes(":")) {
    const n = e.split(":");
    if (n.length === 3) {
      const t = n[0] + ":" + n[1];
      return !!n[2] && k(t);
    }
  }
  return false;
}
function jt(e) {
  if (h(e, false))
    try {
      return typeof new URL(e) < "u";
    } catch {
      return false;
    }
  return false;
}
function Dt(e) {
  var n;
  return (n = e == null ? void 0 : e.proposer) == null ? void 0 : n.publicKey;
}
function kt(e) {
  return e == null ? void 0 : e.topic;
}
function Vt(e, n) {
  let t = null;
  return h(e == null ? void 0 : e.publicKey, false) || (t = N("MISSING_OR_INVALID", `${n} controller public key should be a string`)), t;
}
function ie(e) {
  let n = true;
  return D(e) ? e.length && (n = e.every((t) => h(t, false))) : n = false, n;
}
function nn(e, n, t) {
  let r = null;
  return D(n) && n.length ? n.forEach((o) => {
    r || k(o) || (r = U("UNSUPPORTED_CHAINS", `${t}, chain ${o} should be a string and conform to "namespace:chainId" format`));
  }) : k(e) || (r = U("UNSUPPORTED_CHAINS", `${t}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), r;
}
function tn(e, n, t) {
  let r = null;
  return Object.entries(e).forEach(([o, s]) => {
    if (r)
      return;
    const i = nn(o, K(o, s), `${n} ${t}`);
    i && (r = i);
  }), r;
}
function rn(e, n) {
  let t = null;
  return D(e) ? e.forEach((r) => {
    t || en(r) || (t = U("UNSUPPORTED_ACCOUNTS", `${n}, account ${r} should be a string and conform to "namespace:chainId:address" format`));
  }) : t = U("UNSUPPORTED_ACCOUNTS", `${n}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), t;
}
function on(e, n) {
  let t = null;
  return Object.values(e).forEach((r) => {
    if (t)
      return;
    const o = rn(r == null ? void 0 : r.accounts, `${n} namespace`);
    o && (t = o);
  }), t;
}
function sn(e, n) {
  let t = null;
  return ie(e == null ? void 0 : e.methods) ? ie(e == null ? void 0 : e.events) || (t = U("UNSUPPORTED_EVENTS", `${n}, events should be an array of strings or empty array for no events`)) : t = U("UNSUPPORTED_METHODS", `${n}, methods should be an array of strings or empty array for no methods`), t;
}
function ce(e, n) {
  let t = null;
  return Object.values(e).forEach((r) => {
    if (t)
      return;
    const o = sn(r, `${n}, namespace`);
    o && (t = o);
  }), t;
}
function Mt(e, n, t) {
  let r = null;
  if (e && B(e)) {
    const o = ce(e, n);
    o && (r = o);
    const s = tn(e, n, t);
    s && (r = s);
  } else
    r = N("MISSING_OR_INVALID", `${n}, ${t} should be an object with data`);
  return r;
}
function cn(e, n) {
  let t = null;
  if (e && B(e)) {
    const r = ce(e, n);
    r && (t = r);
    const o = on(e, n);
    o && (t = o);
  } else
    t = N("MISSING_OR_INVALID", `${n}, namespaces should be an object with data`);
  return t;
}
function an(e) {
  return h(e.protocol, true);
}
function Kt(e, n) {
  let t = false;
  return n && !e ? t = true : e && D(e) && e.length && e.forEach((r) => {
    t = an(r);
  }), t;
}
function Lt(e) {
  return typeof e == "number";
}
function xt(e) {
  return typeof e < "u" && typeof e !== null;
}
function Ft(e) {
  return !(!e || typeof e != "object" || !e.code || !G(e.code, false) || !e.message || !h(e.message, false));
}
function Ht(e) {
  return !(w(e) || !h(e.method, false));
}
function qt(e) {
  return !(w(e) || w(e.result) && w(e.error) || !G(e.id, false) || !h(e.jsonrpc, false));
}
function Bt(e) {
  return !(w(e) || !h(e.name, false));
}
function Gt(e, n) {
  return !(!k(n) || !Je(e).includes(n));
}
function Wt(e, n, t) {
  return h(t, false) ? Qe(e, n).includes(t) : false;
}
function zt(e, n, t) {
  return h(t, false) ? Ze(e, n).includes(t) : false;
}
function un(e, n, t) {
  let r = null;
  const o = Yt(e), s = Jt(n), i = Object.keys(o), l = Object.keys(s), d = ln(Object.keys(e)), c = ln(Object.keys(n)), u = d.filter((a) => !c.includes(a));
  return u.length && (r = N("NON_CONFORMING_NAMESPACES", `${t} namespaces keys don't satisfy requiredNamespaces.
      Required: ${u.toString()}
      Received: ${Object.keys(n).toString()}`)), O(i, l) || (r = N("NON_CONFORMING_NAMESPACES", `${t} namespaces chains don't satisfy required namespaces.
      Required: ${i.toString()}
      Approved: ${l.toString()}`)), Object.keys(n).forEach((a) => {
    if (!a.includes(":") || r)
      return;
    const b = A(n[a].accounts);
    b.includes(a) || (r = N("NON_CONFORMING_NAMESPACES", `${t} namespaces accounts don't satisfy namespace accounts for ${a}
        Required: ${a}
        Approved: ${b.toString()}`));
  }), i.forEach((a) => {
    r || (O(o[a].methods, s[a].methods) ? O(o[a].events, s[a].events) || (r = N("NON_CONFORMING_NAMESPACES", `${t} namespaces events don't satisfy namespace events for ${a}`)) : r = N("NON_CONFORMING_NAMESPACES", `${t} namespaces methods don't satisfy namespace methods for ${a}`));
  }), r;
}
function Yt(e) {
  const n = {};
  return Object.keys(e).forEach((t) => {
    var r;
    t.includes(":") ? n[t] = e[t] : (r = e[t].chains) == null || r.forEach((o) => {
      n[o] = { methods: e[t].methods, events: e[t].events };
    });
  }), n;
}
function ln(e) {
  return [...new Set(e.map((n) => n.includes(":") ? n.split(":")[0] : n))];
}
function Jt(e) {
  const n = {};
  return Object.keys(e).forEach((t) => {
    if (t.includes(":"))
      n[t] = e[t];
    else {
      const r = A(e[t].accounts);
      r == null ? void 0 : r.forEach((o) => {
        n[o] = { accounts: e[t].accounts.filter((s) => s.includes(`${o}:`)), methods: e[t].methods, events: e[t].events };
      });
    }
  }), n;
}
function Qt(e, n) {
  return G(e, false) && e <= n.max && e >= n.min;
}
function Zt() {
  const e = R();
  return new Promise((n) => {
    switch (e) {
      case m.browser:
        n(dn());
        break;
      case m.reactNative:
        n(fn());
        break;
      case m.node:
        n(pn());
        break;
      default:
        n(true);
    }
  });
}
function dn() {
  return q() && (navigator == null ? void 0 : navigator.onLine);
}
async function fn() {
  if (j() && typeof global < "u" && global != null && global.NetInfo) {
    const e = await (global == null ? void 0 : global.NetInfo.fetch());
    return e == null ? void 0 : e.isConnected;
  }
  return true;
}
function pn() {
  return true;
}
function Xt(e) {
  switch (R()) {
    case m.browser:
      mn(e);
      break;
    case m.reactNative:
      yn(e);
      break;
    case m.node:
      break;
  }
}
function mn(e) {
  !j() && q() && (window.addEventListener("online", () => e(true)), window.addEventListener("offline", () => e(false)));
}
function yn(e) {
  j() && typeof global < "u" && global != null && global.NetInfo && (global == null ? void 0 : global.NetInfo.addEventListener((n) => e(n == null ? void 0 : n.isConnected)));
}
var ae = {};
var er = class {
  static get(n) {
    return ae[n];
  }
  static set(n, t) {
    ae[n] = t;
  }
  static delete(n) {
    delete ae[n];
  }
};

export {
  ve,
  Rn,
  p,
  _,
  jn,
  Dn,
  kn,
  Vn,
  Mn,
  $,
  Kn,
  Ln,
  ee,
  xn,
  Re,
  Fn,
  te,
  j,
  q,
  zn,
  Jn,
  et,
  nt,
  st,
  it,
  ct,
  at,
  ut,
  lt,
  dt,
  ft,
  S,
  pt,
  mt,
  yt,
  bt,
  Nt,
  At,
  oe,
  Xe,
  se,
  N,
  U,
  D,
  B,
  w,
  h,
  $t,
  jt,
  Dt,
  kt,
  Vt,
  Mt,
  cn,
  an,
  Kt,
  Lt,
  xt,
  Ft,
  Ht,
  qt,
  Bt,
  Gt,
  Wt,
  zt,
  un,
  Qt,
  Zt,
  Xt,
  er
};
//# sourceMappingURL=chunk-VBLBZZIL.js.map
