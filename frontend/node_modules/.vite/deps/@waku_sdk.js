import {
  merge_options_default,
  require_err_code
} from "./chunk-A3MXMSXX.js";
import {
  Field,
  FpSqrtEven,
  SHA2,
  bytesToHex,
  bytesToNumberLE,
  concatBytes as concatBytes2,
  createHasher,
  ensureBytes,
  equalBytes,
  hmac,
  isNegativeLE,
  mod,
  numberToBytesLE,
  pow,
  pow2,
  secp256k1,
  sha256,
  validateBasic,
  validateObject,
  wNAF
} from "./chunk-CQE7FCMF.js";
import {
  u64_default
} from "./chunk-VBQNANJG.js";
import {
  concatBytes,
  hash,
  number,
  randomBytes,
  toBytes,
  utf8ToBytes as utf8ToBytes2,
  wrapConstructor
} from "./chunk-WEXDO3WJ.js";
import {
  require_index_minimal
} from "./chunk-XC2JMRNX.js";
import "./chunk-XQZ64X3E.js";
import {
  WebSockets,
  WebSocketsSecure,
  defaultLogger,
  logger
} from "./chunk-U3422VRE.js";
import {
  EnrDecoder,
  Logger,
  bytesToUtf8,
  concat as concat2,
  decodeMessage,
  decodeRelayShard,
  dist_exports,
  encodeMessage,
  encodeRelayShard,
  enrTree,
  ensurePubsubTopicIsConfigured,
  enumeration,
  groupByContentTopic,
  isDefined,
  isMessageSizeUnderCap,
  isWireSizeUnderCap,
  message,
  pushOrInitMapSet,
  require_aes,
  require_asn1,
  require_forge,
  require_jsbn,
  require_pbe,
  require_pbkdf2,
  require_rsa,
  require_sha512,
  require_util,
  shardInfoToPubSubTopics,
  toAsyncIterator,
  utf8ToBytes,
  wakuDnsDiscovery
} from "./chunk-NSEMFCB3.js";
import "./chunk-WL3JM6LY.js";
import {
  require_crypto
} from "./chunk-LI7O2WKS.js";
import {
  AbortError,
  CodeError,
  CustomEvent,
  InvalidCryptoExchangeError,
  TypedEventEmitter,
  UnexpectedPeerError,
  alloc,
  allocUnsafe,
  concat,
  convertToString,
  decode,
  encode,
  encodingLength,
  equals,
  fromString,
  getProtocol,
  isIP,
  isIPv4,
  isIPv6,
  isMultiaddr,
  isPeerId,
  multiaddr,
  peerDiscovery,
  peerIdFromBytes,
  peerIdFromKeys,
  peerIdFromPeerId,
  peerIdFromString,
  resolvers,
  setMaxListeners,
  toString
} from "./chunk-DBLPKOPF.js";
import {
  require_browser
} from "./chunk-GRGIYPWK.js";
import {
  __commonJS,
  __export,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __publicField,
  __require,
  __toESM
} from "./chunk-P3R5BNFQ.js";

// node_modules/rate-limiter-flexible/lib/RateLimiterAbstract.js
var require_RateLimiterAbstract = __commonJS({
  "node_modules/rate-limiter-flexible/lib/RateLimiterAbstract.js"(exports, module) {
    module.exports = class RateLimiterAbstract {
      /**
       *
       * @param opts Object Defaults {
       *   points: 4, // Number of points
       *   duration: 1, // Per seconds
       *   blockDuration: 0, // Block if consumed more than points in current duration for blockDuration seconds
       *   execEvenly: false, // Execute allowed actions evenly over duration
       *   execEvenlyMinDelayMs: duration * 1000 / points, // ms, works with execEvenly=true option
       *   keyPrefix: 'rlflx',
       * }
       */
      constructor(opts = {}) {
        this.points = opts.points;
        this.duration = opts.duration;
        this.blockDuration = opts.blockDuration;
        this.execEvenly = opts.execEvenly;
        this.execEvenlyMinDelayMs = opts.execEvenlyMinDelayMs;
        this.keyPrefix = opts.keyPrefix;
      }
      get points() {
        return this._points;
      }
      set points(value) {
        this._points = value >= 0 ? value : 4;
      }
      get duration() {
        return this._duration;
      }
      set duration(value) {
        this._duration = typeof value === "undefined" ? 1 : value;
      }
      get msDuration() {
        return this.duration * 1e3;
      }
      get blockDuration() {
        return this._blockDuration;
      }
      set blockDuration(value) {
        this._blockDuration = typeof value === "undefined" ? 0 : value;
      }
      get msBlockDuration() {
        return this.blockDuration * 1e3;
      }
      get execEvenly() {
        return this._execEvenly;
      }
      set execEvenly(value) {
        this._execEvenly = typeof value === "undefined" ? false : Boolean(value);
      }
      get execEvenlyMinDelayMs() {
        return this._execEvenlyMinDelayMs;
      }
      set execEvenlyMinDelayMs(value) {
        this._execEvenlyMinDelayMs = typeof value === "undefined" ? Math.ceil(this.msDuration / this.points) : value;
      }
      get keyPrefix() {
        return this._keyPrefix;
      }
      set keyPrefix(value) {
        if (typeof value === "undefined") {
          value = "rlflx";
        }
        if (typeof value !== "string") {
          throw new Error("keyPrefix must be string");
        }
        this._keyPrefix = value;
      }
      _getKeySecDuration(options = {}) {
        return options && options.customDuration >= 0 ? options.customDuration : this.duration;
      }
      getKey(key) {
        return this.keyPrefix.length > 0 ? `${this.keyPrefix}:${key}` : key;
      }
      parseKey(rlKey) {
        return rlKey.substring(this.keyPrefix.length);
      }
      consume() {
        throw new Error("You have to implement the method 'consume'!");
      }
      penalty() {
        throw new Error("You have to implement the method 'penalty'!");
      }
      reward() {
        throw new Error("You have to implement the method 'reward'!");
      }
      get() {
        throw new Error("You have to implement the method 'get'!");
      }
      set() {
        throw new Error("You have to implement the method 'set'!");
      }
      block() {
        throw new Error("You have to implement the method 'block'!");
      }
      delete() {
        throw new Error("You have to implement the method 'delete'!");
      }
    };
  }
});

// node_modules/rate-limiter-flexible/lib/component/BlockedKeys/BlockedKeys.js
var require_BlockedKeys = __commonJS({
  "node_modules/rate-limiter-flexible/lib/component/BlockedKeys/BlockedKeys.js"(exports, module) {
    module.exports = class BlockedKeys {
      constructor() {
        this._keys = {};
        this._addedKeysAmount = 0;
      }
      collectExpired() {
        const now = Date.now();
        Object.keys(this._keys).forEach((key) => {
          if (this._keys[key] <= now) {
            delete this._keys[key];
          }
        });
        this._addedKeysAmount = Object.keys(this._keys).length;
      }
      /**
       * Add new blocked key
       *
       * @param key String
       * @param sec Number
       */
      add(key, sec) {
        this.addMs(key, sec * 1e3);
      }
      /**
       * Add new blocked key for ms
       *
       * @param key String
       * @param ms Number
       */
      addMs(key, ms) {
        this._keys[key] = Date.now() + ms;
        this._addedKeysAmount++;
        if (this._addedKeysAmount > 999) {
          this.collectExpired();
        }
      }
      /**
       * 0 means not blocked
       *
       * @param key
       * @returns {number}
       */
      msBeforeExpire(key) {
        const expire = this._keys[key];
        if (expire && expire >= Date.now()) {
          this.collectExpired();
          const now = Date.now();
          return expire >= now ? expire - now : 0;
        }
        return 0;
      }
      /**
       * If key is not given, delete all data in memory
       * 
       * @param {string|undefined} key
       */
      delete(key) {
        if (key) {
          delete this._keys[key];
        } else {
          Object.keys(this._keys).forEach((key2) => {
            delete this._keys[key2];
          });
        }
      }
    };
  }
});

// node_modules/rate-limiter-flexible/lib/component/BlockedKeys/index.js
var require_BlockedKeys2 = __commonJS({
  "node_modules/rate-limiter-flexible/lib/component/BlockedKeys/index.js"(exports, module) {
    var BlockedKeys = require_BlockedKeys();
    module.exports = BlockedKeys;
  }
});

// node_modules/rate-limiter-flexible/lib/RateLimiterRes.js
var require_RateLimiterRes = __commonJS({
  "node_modules/rate-limiter-flexible/lib/RateLimiterRes.js"(exports, module) {
    module.exports = class RateLimiterRes {
      constructor(remainingPoints, msBeforeNext, consumedPoints, isFirstInDuration) {
        this.remainingPoints = typeof remainingPoints === "undefined" ? 0 : remainingPoints;
        this.msBeforeNext = typeof msBeforeNext === "undefined" ? 0 : msBeforeNext;
        this.consumedPoints = typeof consumedPoints === "undefined" ? 0 : consumedPoints;
        this.isFirstInDuration = typeof isFirstInDuration === "undefined" ? false : isFirstInDuration;
      }
      get msBeforeNext() {
        return this._msBeforeNext;
      }
      set msBeforeNext(ms) {
        this._msBeforeNext = ms;
        return this;
      }
      get remainingPoints() {
        return this._remainingPoints;
      }
      set remainingPoints(p) {
        this._remainingPoints = p;
        return this;
      }
      get consumedPoints() {
        return this._consumedPoints;
      }
      set consumedPoints(p) {
        this._consumedPoints = p;
        return this;
      }
      get isFirstInDuration() {
        return this._isFirstInDuration;
      }
      set isFirstInDuration(value) {
        this._isFirstInDuration = Boolean(value);
      }
      _getDecoratedProperties() {
        return {
          remainingPoints: this.remainingPoints,
          msBeforeNext: this.msBeforeNext,
          consumedPoints: this.consumedPoints,
          isFirstInDuration: this.isFirstInDuration
        };
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return this._getDecoratedProperties();
      }
      toString() {
        return JSON.stringify(this._getDecoratedProperties());
      }
      toJSON() {
        return this._getDecoratedProperties();
      }
    };
  }
});

// node_modules/rate-limiter-flexible/lib/RateLimiterStoreAbstract.js
var require_RateLimiterStoreAbstract = __commonJS({
  "node_modules/rate-limiter-flexible/lib/RateLimiterStoreAbstract.js"(exports, module) {
    var RateLimiterAbstract = require_RateLimiterAbstract();
    var BlockedKeys = require_BlockedKeys2();
    var RateLimiterRes = require_RateLimiterRes();
    module.exports = class RateLimiterStoreAbstract extends RateLimiterAbstract {
      /**
       *
       * @param opts Object Defaults {
       *   ... see other in RateLimiterAbstract
       *
       *   inMemoryBlockOnConsumed: 40, // Number of points when key is blocked
       *   inMemoryBlockDuration: 10, // Block duration in seconds
       *   insuranceLimiter: RateLimiterAbstract
       * }
       */
      constructor(opts = {}) {
        super(opts);
        this.inMemoryBlockOnConsumed = opts.inMemoryBlockOnConsumed;
        this.inMemoryBlockDuration = opts.inMemoryBlockDuration;
        this.insuranceLimiter = opts.insuranceLimiter;
        this._inMemoryBlockedKeys = new BlockedKeys();
      }
      get client() {
        return this._client;
      }
      set client(value) {
        if (typeof value === "undefined") {
          throw new Error("storeClient is not set");
        }
        this._client = value;
      }
      /**
       * Have to be launched after consume
       * It blocks key and execute evenly depending on result from store
       *
       * It uses _getRateLimiterRes function to prepare RateLimiterRes from store result
       *
       * @param resolve
       * @param reject
       * @param rlKey
       * @param changedPoints
       * @param storeResult
       * @param {Object} options
       * @private
       */
      _afterConsume(resolve, reject, rlKey, changedPoints, storeResult, options = {}) {
        const res = this._getRateLimiterRes(rlKey, changedPoints, storeResult);
        if (this.inMemoryBlockOnConsumed > 0 && !(this.inMemoryBlockDuration > 0) && res.consumedPoints >= this.inMemoryBlockOnConsumed) {
          this._inMemoryBlockedKeys.addMs(rlKey, res.msBeforeNext);
          if (res.consumedPoints > this.points) {
            return reject(res);
          } else {
            return resolve(res);
          }
        } else if (res.consumedPoints > this.points) {
          let blockPromise = Promise.resolve();
          if (this.blockDuration > 0 && res.consumedPoints <= this.points + changedPoints) {
            res.msBeforeNext = this.msBlockDuration;
            blockPromise = this._block(rlKey, res.consumedPoints, this.msBlockDuration, options);
          }
          if (this.inMemoryBlockOnConsumed > 0 && res.consumedPoints >= this.inMemoryBlockOnConsumed) {
            this._inMemoryBlockedKeys.add(rlKey, this.inMemoryBlockDuration);
            res.msBeforeNext = this.msInMemoryBlockDuration;
          }
          blockPromise.then(() => {
            reject(res);
          }).catch((err) => {
            reject(err);
          });
        } else if (this.execEvenly && res.msBeforeNext > 0 && !res.isFirstInDuration) {
          let delay = Math.ceil(res.msBeforeNext / (res.remainingPoints + 2));
          if (delay < this.execEvenlyMinDelayMs) {
            delay = res.consumedPoints * this.execEvenlyMinDelayMs;
          }
          setTimeout(resolve, delay, res);
        } else {
          resolve(res);
        }
      }
      _handleError(err, funcName, resolve, reject, key, data = false, options = {}) {
        if (!(this.insuranceLimiter instanceof RateLimiterAbstract)) {
          reject(err);
        } else {
          this.insuranceLimiter[funcName](key, data, options).then((res) => {
            resolve(res);
          }).catch((res) => {
            reject(res);
          });
        }
      }
      getInMemoryBlockMsBeforeExpire(rlKey) {
        if (this.inMemoryBlockOnConsumed > 0) {
          return this._inMemoryBlockedKeys.msBeforeExpire(rlKey);
        }
        return 0;
      }
      get inMemoryBlockOnConsumed() {
        return this._inMemoryBlockOnConsumed;
      }
      set inMemoryBlockOnConsumed(value) {
        this._inMemoryBlockOnConsumed = value ? parseInt(value) : 0;
        if (this.inMemoryBlockOnConsumed > 0 && this.points > this.inMemoryBlockOnConsumed) {
          throw new Error('inMemoryBlockOnConsumed option must be greater or equal "points" option');
        }
      }
      get inMemoryBlockDuration() {
        return this._inMemoryBlockDuration;
      }
      set inMemoryBlockDuration(value) {
        this._inMemoryBlockDuration = value ? parseInt(value) : 0;
        if (this.inMemoryBlockDuration > 0 && this.inMemoryBlockOnConsumed === 0) {
          throw new Error("inMemoryBlockOnConsumed option must be set up");
        }
      }
      get msInMemoryBlockDuration() {
        return this._inMemoryBlockDuration * 1e3;
      }
      get insuranceLimiter() {
        return this._insuranceLimiter;
      }
      set insuranceLimiter(value) {
        if (typeof value !== "undefined" && !(value instanceof RateLimiterAbstract)) {
          throw new Error("insuranceLimiter must be instance of RateLimiterAbstract");
        }
        this._insuranceLimiter = value;
        if (this._insuranceLimiter) {
          this._insuranceLimiter.blockDuration = this.blockDuration;
          this._insuranceLimiter.execEvenly = this.execEvenly;
        }
      }
      /**
       * Block any key for secDuration seconds
       *
       * @param key
       * @param secDuration
       * @param {Object} options
       *
       * @return Promise<RateLimiterRes>
       */
      block(key, secDuration, options = {}) {
        const msDuration = secDuration * 1e3;
        return this._block(this.getKey(key), this.points + 1, msDuration, options);
      }
      /**
       * Set points by key for any duration
       *
       * @param key
       * @param points
       * @param secDuration
       * @param {Object} options
       *
       * @return Promise<RateLimiterRes>
       */
      set(key, points, secDuration, options = {}) {
        const msDuration = (secDuration >= 0 ? secDuration : this.duration) * 1e3;
        return this._block(this.getKey(key), points, msDuration, options);
      }
      /**
       *
       * @param key
       * @param pointsToConsume
       * @param {Object} options
       * @returns Promise<RateLimiterRes>
       */
      consume(key, pointsToConsume = 1, options = {}) {
        return new Promise((resolve, reject) => {
          const rlKey = this.getKey(key);
          const inMemoryBlockMsBeforeExpire = this.getInMemoryBlockMsBeforeExpire(rlKey);
          if (inMemoryBlockMsBeforeExpire > 0) {
            return reject(new RateLimiterRes(0, inMemoryBlockMsBeforeExpire));
          }
          this._upsert(rlKey, pointsToConsume, this._getKeySecDuration(options) * 1e3, false, options).then((res) => {
            this._afterConsume(resolve, reject, rlKey, pointsToConsume, res);
          }).catch((err) => {
            this._handleError(err, "consume", resolve, reject, key, pointsToConsume, options);
          });
        });
      }
      /**
       *
       * @param key
       * @param points
       * @param {Object} options
       * @returns Promise<RateLimiterRes>
       */
      penalty(key, points = 1, options = {}) {
        const rlKey = this.getKey(key);
        return new Promise((resolve, reject) => {
          this._upsert(rlKey, points, this._getKeySecDuration(options) * 1e3, false, options).then((res) => {
            resolve(this._getRateLimiterRes(rlKey, points, res));
          }).catch((err) => {
            this._handleError(err, "penalty", resolve, reject, key, points, options);
          });
        });
      }
      /**
       *
       * @param key
       * @param points
       * @param {Object} options
       * @returns Promise<RateLimiterRes>
       */
      reward(key, points = 1, options = {}) {
        const rlKey = this.getKey(key);
        return new Promise((resolve, reject) => {
          this._upsert(rlKey, -points, this._getKeySecDuration(options) * 1e3, false, options).then((res) => {
            resolve(this._getRateLimiterRes(rlKey, -points, res));
          }).catch((err) => {
            this._handleError(err, "reward", resolve, reject, key, points, options);
          });
        });
      }
      /**
       *
       * @param key
       * @param {Object} options
       * @returns Promise<RateLimiterRes>|null
       */
      get(key, options = {}) {
        const rlKey = this.getKey(key);
        return new Promise((resolve, reject) => {
          this._get(rlKey, options).then((res) => {
            if (res === null || typeof res === "undefined") {
              resolve(null);
            } else {
              resolve(this._getRateLimiterRes(rlKey, 0, res));
            }
          }).catch((err) => {
            this._handleError(err, "get", resolve, reject, key, options);
          });
        });
      }
      /**
       *
       * @param key
       * @param {Object} options
       * @returns Promise<boolean>
       */
      delete(key, options = {}) {
        const rlKey = this.getKey(key);
        return new Promise((resolve, reject) => {
          this._delete(rlKey, options).then((res) => {
            this._inMemoryBlockedKeys.delete(rlKey);
            resolve(res);
          }).catch((err) => {
            this._handleError(err, "delete", resolve, reject, key, options);
          });
        });
      }
      /**
       * Cleanup keys no-matter expired or not.
       */
      deleteInMemoryBlockedAll() {
        this._inMemoryBlockedKeys.delete();
      }
      /**
       * Get RateLimiterRes object filled depending on storeResult, which specific for exact store
       *
       * @param rlKey
       * @param changedPoints
       * @param storeResult
       * @private
       */
      _getRateLimiterRes(rlKey, changedPoints, storeResult) {
        throw new Error("You have to implement the method '_getRateLimiterRes'!");
      }
      /**
       * Block key for this.msBlockDuration milliseconds
       * Usually, it just prolongs lifetime of key
       *
       * @param rlKey
       * @param initPoints
       * @param msDuration
       * @param {Object} options
       *
       * @return Promise<any>
       */
      _block(rlKey, initPoints, msDuration, options = {}) {
        return new Promise((resolve, reject) => {
          this._upsert(rlKey, initPoints, msDuration, true, options).then(() => {
            resolve(new RateLimiterRes(0, msDuration > 0 ? msDuration : -1, initPoints));
          }).catch((err) => {
            this._handleError(err, "block", resolve, reject, this.parseKey(rlKey), msDuration / 1e3, options);
          });
        });
      }
      /**
       * Have to be implemented in every limiter
       * Resolve with raw result from Store OR null if rlKey is not set
       * or Reject with error
       *
       * @param rlKey
       * @param {Object} options
       * @private
       *
       * @return Promise<any>
       */
      _get(rlKey, options = {}) {
        throw new Error("You have to implement the method '_get'!");
      }
      /**
       * Have to be implemented
       * Resolve with true OR false if rlKey doesn't exist
       * or Reject with error
       *
       * @param rlKey
       * @param {Object} options
       * @private
       *
       * @return Promise<any>
       */
      _delete(rlKey, options = {}) {
        throw new Error("You have to implement the method '_delete'!");
      }
      /**
       * Have to be implemented
       * Resolve with object used for {@link _getRateLimiterRes} to generate {@link RateLimiterRes}
       *
       * @param {string} rlKey
       * @param {number} points
       * @param {number} msDuration
       * @param {boolean} forceExpire
       * @param {Object} options
       * @abstract
       *
       * @return Promise<Object>
       */
      _upsert(rlKey, points, msDuration, forceExpire = false, options = {}) {
        throw new Error("You have to implement the method '_upsert'!");
      }
    };
  }
});

// node_modules/rate-limiter-flexible/lib/RateLimiterRedis.js
var require_RateLimiterRedis = __commonJS({
  "node_modules/rate-limiter-flexible/lib/RateLimiterRedis.js"(exports, module) {
    var RateLimiterStoreAbstract = require_RateLimiterStoreAbstract();
    var RateLimiterRes = require_RateLimiterRes();
    var incrTtlLuaScript = `redis.call('set', KEYS[1], 0, 'EX', ARGV[2], 'NX') local consumed = redis.call('incrby', KEYS[1], ARGV[1]) local ttl = redis.call('pttl', KEYS[1]) if ttl == -1 then   redis.call('expire', KEYS[1], ARGV[2])   ttl = 1000 * ARGV[2] end return {consumed, ttl} `;
    var RateLimiterRedis = class extends RateLimiterStoreAbstract {
      /**
       *
       * @param {Object} opts
       * Defaults {
       *   ... see other in RateLimiterStoreAbstract
       *
       *   redis: RedisClient
       *   rejectIfRedisNotReady: boolean = false - reject / invoke insuranceLimiter immediately when redis connection is not "ready"
       * }
       */
      constructor(opts) {
        super(opts);
        this.client = opts.storeClient;
        this._rejectIfRedisNotReady = !!opts.rejectIfRedisNotReady;
        this.useRedisPackage = opts.useRedisPackage || this.client.constructor.name === "Commander" || false;
        this.useRedis3AndLowerPackage = opts.useRedis3AndLowerPackage;
        if (typeof this.client.defineCommand === "function") {
          this.client.defineCommand("rlflxIncr", {
            numberOfKeys: 1,
            lua: incrTtlLuaScript
          });
        }
      }
      /**
       * Prevent actual redis call if redis connection is not ready
       * Because of different connection state checks for ioredis and node-redis, only this clients would be actually checked.
       * For any other clients all the requests would be passed directly to redis client
       * @return {boolean}
       * @private
       */
      _isRedisReady() {
        if (!this._rejectIfRedisNotReady) {
          return true;
        }
        if (this.client.status && this.client.status !== "ready") {
          return false;
        }
        if (typeof this.client.isReady === "function" && !this.client.isReady()) {
          return false;
        }
        return true;
      }
      _getRateLimiterRes(rlKey, changedPoints, result) {
        let [consumed, resTtlMs] = result;
        if (Array.isArray(consumed)) {
          [, consumed] = consumed;
          [, resTtlMs] = resTtlMs;
        }
        const res = new RateLimiterRes();
        res.consumedPoints = parseInt(consumed);
        res.isFirstInDuration = res.consumedPoints === changedPoints;
        res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
        res.msBeforeNext = resTtlMs;
        return res;
      }
      async _upsert(rlKey, points, msDuration, forceExpire = false) {
        if (!this._isRedisReady()) {
          throw new Error("Redis connection is not ready");
        }
        const secDuration = Math.floor(msDuration / 1e3);
        const multi = this.client.multi();
        if (forceExpire) {
          if (secDuration > 0) {
            if (!this.useRedisPackage && !this.useRedis3AndLowerPackage) {
              multi.set(rlKey, points, "EX", secDuration);
            } else {
              multi.set(rlKey, points, { EX: secDuration });
            }
          } else {
            multi.set(rlKey, points);
          }
          if (!this.useRedisPackage && !this.useRedis3AndLowerPackage) {
            return multi.pttl(rlKey).exec(true);
          }
          return multi.pTTL(rlKey).exec(true);
        }
        if (secDuration > 0) {
          if (!this.useRedisPackage && !this.useRedis3AndLowerPackage) {
            return this.client.rlflxIncr(
              [rlKey].concat([String(points), String(secDuration)])
            );
          }
          if (this.useRedis3AndLowerPackage) {
            return new Promise((resolve, reject) => {
              const incrCallback = function(err, result) {
                if (err) {
                  return reject(err);
                }
                return resolve(result);
              };
              if (typeof this.client.rlflxIncr === "function") {
                this.client.rlflxIncr(rlKey, points, secDuration, incrCallback);
              } else {
                this.client.eval(incrTtlLuaScript, 1, rlKey, points, secDuration, incrCallback);
              }
            });
          } else {
            return this.client.eval(incrTtlLuaScript, {
              keys: [rlKey],
              arguments: [String(points), String(secDuration)]
            });
          }
        } else {
          if (!this.useRedisPackage && !this.useRedis3AndLowerPackage) {
            return multi.incrby(rlKey, points).pttl(rlKey).exec(true);
          }
          return multi.incrBy(rlKey, points).pTTL(rlKey).exec(true);
        }
      }
      async _get(rlKey) {
        if (!this._isRedisReady()) {
          throw new Error("Redis connection is not ready");
        }
        if (!this.useRedisPackage && !this.useRedis3AndLowerPackage) {
          return this.client.multi().get(rlKey).pttl(rlKey).exec().then((result) => {
            const [[, points]] = result;
            if (points === null)
              return null;
            return result;
          });
        }
        return this.client.multi().get(rlKey).pTTL(rlKey).exec(true).then((result) => {
          const [points] = result;
          if (points === null)
            return null;
          return result;
        });
      }
      _delete(rlKey) {
        return this.client.del(rlKey).then((result) => result > 0);
      }
    };
    module.exports = RateLimiterRedis;
  }
});

// node_modules/rate-limiter-flexible/lib/RateLimiterMongo.js
var require_RateLimiterMongo = __commonJS({
  "node_modules/rate-limiter-flexible/lib/RateLimiterMongo.js"(exports, module) {
    var RateLimiterStoreAbstract = require_RateLimiterStoreAbstract();
    var RateLimiterRes = require_RateLimiterRes();
    function getDriverVersion(client) {
      try {
        const _client = client.client ? client.client : client;
        const { version: version2 } = _client.topology.s.options.metadata.driver;
        const _v = version2.split(".").map((v) => parseInt(v));
        return {
          major: _v[0],
          feature: _v[1],
          patch: _v[2]
        };
      } catch (err) {
        return { major: 0, feature: 0, patch: 0 };
      }
    }
    var RateLimiterMongo = class _RateLimiterMongo extends RateLimiterStoreAbstract {
      /**
       *
       * @param {Object} opts
       * Defaults {
       *   indexKeyPrefix: {attr1: 1, attr2: 1}
       *   ... see other in RateLimiterStoreAbstract
       *
       *   mongo: MongoClient
       * }
       */
      constructor(opts) {
        super(opts);
        this.dbName = opts.dbName;
        this.tableName = opts.tableName;
        this.indexKeyPrefix = opts.indexKeyPrefix;
        if (opts.mongo) {
          this.client = opts.mongo;
        } else {
          this.client = opts.storeClient;
        }
        if (typeof this.client.then === "function") {
          this.client.then((conn) => {
            this.client = conn;
            this._initCollection();
            this._driverVersion = getDriverVersion(this.client);
          });
        } else {
          this._initCollection();
          this._driverVersion = getDriverVersion(this.client);
        }
      }
      get dbName() {
        return this._dbName;
      }
      set dbName(value) {
        this._dbName = typeof value === "undefined" ? _RateLimiterMongo.getDbName() : value;
      }
      static getDbName() {
        return "node-rate-limiter-flexible";
      }
      get tableName() {
        return this._tableName;
      }
      set tableName(value) {
        this._tableName = typeof value === "undefined" ? this.keyPrefix : value;
      }
      get client() {
        return this._client;
      }
      set client(value) {
        if (typeof value === "undefined") {
          throw new Error("mongo is not set");
        }
        this._client = value;
      }
      get indexKeyPrefix() {
        return this._indexKeyPrefix;
      }
      set indexKeyPrefix(obj) {
        this._indexKeyPrefix = obj || {};
      }
      _initCollection() {
        const db = typeof this.client.db === "function" ? this.client.db(this.dbName) : this.client;
        const collection = db.collection(this.tableName);
        collection.createIndex({ expire: -1 }, { expireAfterSeconds: 0 });
        collection.createIndex(Object.assign({}, this.indexKeyPrefix, { key: 1 }), { unique: true });
        this._collection = collection;
      }
      _getRateLimiterRes(rlKey, changedPoints, result) {
        const res = new RateLimiterRes();
        let doc;
        if (typeof result.value === "undefined") {
          doc = result;
        } else {
          doc = result.value;
        }
        res.isFirstInDuration = doc.points === changedPoints;
        res.consumedPoints = doc.points;
        res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
        res.msBeforeNext = doc.expire !== null ? Math.max(new Date(doc.expire).getTime() - Date.now(), 0) : -1;
        return res;
      }
      _upsert(key, points, msDuration, forceExpire = false, options = {}) {
        if (!this._collection) {
          return Promise.reject(Error("Mongo connection is not established"));
        }
        const docAttrs = options.attrs || {};
        let where;
        let upsertData;
        if (forceExpire) {
          where = { key };
          where = Object.assign(where, docAttrs);
          upsertData = {
            $set: {
              key,
              points,
              expire: msDuration > 0 ? new Date(Date.now() + msDuration) : null
            }
          };
          upsertData.$set = Object.assign(upsertData.$set, docAttrs);
        } else {
          where = {
            $or: [
              { expire: { $gt: /* @__PURE__ */ new Date() } },
              { expire: { $eq: null } }
            ],
            key
          };
          where = Object.assign(where, docAttrs);
          upsertData = {
            $setOnInsert: {
              key,
              expire: msDuration > 0 ? new Date(Date.now() + msDuration) : null
            },
            $inc: { points }
          };
          upsertData.$setOnInsert = Object.assign(upsertData.$setOnInsert, docAttrs);
        }
        const upsertOptions = {
          upsert: true
        };
        if (this._driverVersion.major >= 4 || (this._driverVersion.major === 3 && this._driverVersion.feature >= 7 || this._driverVersion.feature >= 6 && this._driverVersion.patch >= 7)) {
          upsertOptions.returnDocument = "after";
        } else {
          upsertOptions.returnOriginal = false;
        }
        return new Promise((resolve, reject) => {
          this._collection.findOneAndUpdate(
            where,
            upsertData,
            upsertOptions
          ).then((res) => {
            resolve(res);
          }).catch((errUpsert) => {
            if (errUpsert && errUpsert.code === 11e3) {
              const replaceWhere = Object.assign({
                // try to replace OLD limit doc
                $or: [
                  { expire: { $lte: /* @__PURE__ */ new Date() } },
                  { expire: { $eq: null } }
                ],
                key
              }, docAttrs);
              const replaceTo = {
                $set: Object.assign({
                  key,
                  points,
                  expire: msDuration > 0 ? new Date(Date.now() + msDuration) : null
                }, docAttrs)
              };
              this._collection.findOneAndUpdate(
                replaceWhere,
                replaceTo,
                upsertOptions
              ).then((res) => {
                resolve(res);
              }).catch((errReplace) => {
                if (errReplace && errReplace.code === 11e3) {
                  this._upsert(key, points, msDuration, forceExpire).then((res) => resolve(res)).catch((err) => reject(err));
                } else {
                  reject(errReplace);
                }
              });
            } else {
              reject(errUpsert);
            }
          });
        });
      }
      _get(rlKey, options = {}) {
        if (!this._collection) {
          return Promise.reject(Error("Mongo connection is not established"));
        }
        const docAttrs = options.attrs || {};
        const where = Object.assign({
          key: rlKey,
          $or: [
            { expire: { $gt: /* @__PURE__ */ new Date() } },
            { expire: { $eq: null } }
          ]
        }, docAttrs);
        return this._collection.findOne(where);
      }
      _delete(rlKey, options = {}) {
        if (!this._collection) {
          return Promise.reject(Error("Mongo connection is not established"));
        }
        const docAttrs = options.attrs || {};
        const where = Object.assign({ key: rlKey }, docAttrs);
        return this._collection.deleteOne(where).then((res) => res.deletedCount > 0);
      }
    };
    module.exports = RateLimiterMongo;
  }
});

// node_modules/rate-limiter-flexible/lib/RateLimiterMySQL.js
var require_RateLimiterMySQL = __commonJS({
  "node_modules/rate-limiter-flexible/lib/RateLimiterMySQL.js"(exports, module) {
    var RateLimiterStoreAbstract = require_RateLimiterStoreAbstract();
    var RateLimiterRes = require_RateLimiterRes();
    var RateLimiterMySQL = class extends RateLimiterStoreAbstract {
      /**
       * @callback callback
       * @param {Object} err
       *
       * @param {Object} opts
       * @param {callback} cb
       * Defaults {
       *   ... see other in RateLimiterStoreAbstract
       *
       *   storeClient: anySqlClient,
       *   storeType: 'knex', // required only for Knex instance
       *   dbName: 'string',
       *   tableName: 'string',
       * }
       */
      constructor(opts, cb = null) {
        super(opts);
        this.client = opts.storeClient;
        this.clientType = opts.storeType;
        this.dbName = opts.dbName;
        this.tableName = opts.tableName;
        this.clearExpiredByTimeout = opts.clearExpiredByTimeout;
        this.tableCreated = opts.tableCreated;
        if (!this.tableCreated) {
          this._createDbAndTable().then(() => {
            this.tableCreated = true;
            if (this.clearExpiredByTimeout) {
              this._clearExpiredHourAgo();
            }
            if (typeof cb === "function") {
              cb();
            }
          }).catch((err) => {
            if (typeof cb === "function") {
              cb(err);
            } else {
              throw err;
            }
          });
        } else {
          if (this.clearExpiredByTimeout) {
            this._clearExpiredHourAgo();
          }
          if (typeof cb === "function") {
            cb();
          }
        }
      }
      clearExpired(expire) {
        return new Promise((resolve) => {
          this._getConnection().then((conn) => {
            conn.query(`DELETE FROM ??.?? WHERE expire < ?`, [this.dbName, this.tableName, expire], () => {
              this._releaseConnection(conn);
              resolve();
            });
          }).catch(() => {
            resolve();
          });
        });
      }
      _clearExpiredHourAgo() {
        if (this._clearExpiredTimeoutId) {
          clearTimeout(this._clearExpiredTimeoutId);
        }
        this._clearExpiredTimeoutId = setTimeout(() => {
          this.clearExpired(Date.now() - 36e5).then(() => {
            this._clearExpiredHourAgo();
          });
        }, 3e5);
        this._clearExpiredTimeoutId.unref();
      }
      /**
       *
       * @return Promise<any>
       * @private
       */
      _getConnection() {
        switch (this.clientType) {
          case "pool":
            return new Promise((resolve, reject) => {
              this.client.getConnection((errConn, conn) => {
                if (errConn) {
                  return reject(errConn);
                }
                resolve(conn);
              });
            });
          case "sequelize":
            return this.client.connectionManager.getConnection();
          case "knex":
            return this.client.client.acquireConnection();
          default:
            return Promise.resolve(this.client);
        }
      }
      _releaseConnection(conn) {
        switch (this.clientType) {
          case "pool":
            return conn.release();
          case "sequelize":
            return this.client.connectionManager.releaseConnection(conn);
          case "knex":
            return this.client.client.releaseConnection(conn);
          default:
            return true;
        }
      }
      /**
       *
       * @returns {Promise<any>}
       * @private
       */
      _createDbAndTable() {
        return new Promise((resolve, reject) => {
          this._getConnection().then((conn) => {
            conn.query(`CREATE DATABASE IF NOT EXISTS \`${this.dbName}\`;`, (errDb) => {
              if (errDb) {
                this._releaseConnection(conn);
                return reject(errDb);
              }
              conn.query(this._getCreateTableStmt(), (err) => {
                if (err) {
                  this._releaseConnection(conn);
                  return reject(err);
                }
                this._releaseConnection(conn);
                resolve();
              });
            });
          }).catch((err) => {
            reject(err);
          });
        });
      }
      _getCreateTableStmt() {
        return `CREATE TABLE IF NOT EXISTS \`${this.dbName}\`.\`${this.tableName}\` (\`key\` VARCHAR(255) CHARACTER SET utf8 NOT NULL,\`points\` INT(9) NOT NULL default 0,\`expire\` BIGINT UNSIGNED,PRIMARY KEY (\`key\`)) ENGINE = INNODB;`;
      }
      get clientType() {
        return this._clientType;
      }
      set clientType(value) {
        if (typeof value === "undefined") {
          if (this.client.constructor.name === "Connection") {
            value = "connection";
          } else if (this.client.constructor.name === "Pool") {
            value = "pool";
          } else if (this.client.constructor.name === "Sequelize") {
            value = "sequelize";
          } else {
            throw new Error("storeType is not defined");
          }
        }
        this._clientType = value.toLowerCase();
      }
      get dbName() {
        return this._dbName;
      }
      set dbName(value) {
        this._dbName = typeof value === "undefined" ? "rtlmtrflx" : value;
      }
      get tableName() {
        return this._tableName;
      }
      set tableName(value) {
        this._tableName = typeof value === "undefined" ? this.keyPrefix : value;
      }
      get tableCreated() {
        return this._tableCreated;
      }
      set tableCreated(value) {
        this._tableCreated = typeof value === "undefined" ? false : !!value;
      }
      get clearExpiredByTimeout() {
        return this._clearExpiredByTimeout;
      }
      set clearExpiredByTimeout(value) {
        this._clearExpiredByTimeout = typeof value === "undefined" ? true : Boolean(value);
      }
      _getRateLimiterRes(rlKey, changedPoints, result) {
        const res = new RateLimiterRes();
        const [row] = result;
        res.isFirstInDuration = changedPoints === row.points;
        res.consumedPoints = res.isFirstInDuration ? changedPoints : row.points;
        res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
        res.msBeforeNext = row.expire ? Math.max(row.expire - Date.now(), 0) : -1;
        return res;
      }
      _upsertTransaction(conn, key, points, msDuration, forceExpire) {
        return new Promise((resolve, reject) => {
          conn.query("BEGIN", (errBegin) => {
            if (errBegin) {
              conn.rollback();
              return reject(errBegin);
            }
            const dateNow = Date.now();
            const newExpire = msDuration > 0 ? dateNow + msDuration : null;
            let q;
            let values;
            if (forceExpire) {
              q = `INSERT INTO ??.?? VALUES (?, ?, ?)
          ON DUPLICATE KEY UPDATE 
            points = ?, 
            expire = ?;`;
              values = [
                this.dbName,
                this.tableName,
                key,
                points,
                newExpire,
                points,
                newExpire
              ];
            } else {
              q = `INSERT INTO ??.?? VALUES (?, ?, ?)
          ON DUPLICATE KEY UPDATE 
            points = IF(expire <= ?, ?, points + (?)), 
            expire = IF(expire <= ?, ?, expire);`;
              values = [
                this.dbName,
                this.tableName,
                key,
                points,
                newExpire,
                dateNow,
                points,
                points,
                dateNow,
                newExpire
              ];
            }
            conn.query(q, values, (errUpsert) => {
              if (errUpsert) {
                conn.rollback();
                return reject(errUpsert);
              }
              conn.query("SELECT points, expire FROM ??.?? WHERE `key` = ?;", [this.dbName, this.tableName, key], (errSelect, res) => {
                if (errSelect) {
                  conn.rollback();
                  return reject(errSelect);
                }
                conn.query("COMMIT", (err) => {
                  if (err) {
                    conn.rollback();
                    return reject(err);
                  }
                  resolve(res);
                });
              });
            });
          });
        });
      }
      _upsert(key, points, msDuration, forceExpire = false) {
        if (!this.tableCreated) {
          return Promise.reject(Error("Table is not created yet"));
        }
        return new Promise((resolve, reject) => {
          this._getConnection().then((conn) => {
            this._upsertTransaction(conn, key, points, msDuration, forceExpire).then((res) => {
              resolve(res);
              this._releaseConnection(conn);
            }).catch((err) => {
              reject(err);
              this._releaseConnection(conn);
            });
          }).catch((err) => {
            reject(err);
          });
        });
      }
      _get(rlKey) {
        if (!this.tableCreated) {
          return Promise.reject(Error("Table is not created yet"));
        }
        return new Promise((resolve, reject) => {
          this._getConnection().then((conn) => {
            conn.query(
              "SELECT points, expire FROM ??.?? WHERE `key` = ? AND (`expire` > ? OR `expire` IS NULL)",
              [this.dbName, this.tableName, rlKey, Date.now()],
              (err, res) => {
                if (err) {
                  reject(err);
                } else if (res.length === 0) {
                  resolve(null);
                } else {
                  resolve(res);
                }
                this._releaseConnection(conn);
              }
              // eslint-disable-line
            );
          }).catch((err) => {
            reject(err);
          });
        });
      }
      _delete(rlKey) {
        if (!this.tableCreated) {
          return Promise.reject(Error("Table is not created yet"));
        }
        return new Promise((resolve, reject) => {
          this._getConnection().then((conn) => {
            conn.query(
              "DELETE FROM ??.?? WHERE `key` = ?",
              [this.dbName, this.tableName, rlKey],
              (err, res) => {
                if (err) {
                  reject(err);
                } else {
                  resolve(res.affectedRows > 0);
                }
                this._releaseConnection(conn);
              }
              // eslint-disable-line
            );
          }).catch((err) => {
            reject(err);
          });
        });
      }
    };
    module.exports = RateLimiterMySQL;
  }
});

// node_modules/rate-limiter-flexible/lib/RateLimiterPostgres.js
var require_RateLimiterPostgres = __commonJS({
  "node_modules/rate-limiter-flexible/lib/RateLimiterPostgres.js"(exports, module) {
    var RateLimiterStoreAbstract = require_RateLimiterStoreAbstract();
    var RateLimiterRes = require_RateLimiterRes();
    var RateLimiterPostgres = class extends RateLimiterStoreAbstract {
      /**
       * @callback callback
       * @param {Object} err
       *
       * @param {Object} opts
       * @param {callback} cb
       * Defaults {
       *   ... see other in RateLimiterStoreAbstract
       *
       *   storeClient: postgresClient,
       *   storeType: 'knex', // required only for Knex instance
       *   tableName: 'string',
       *   schemaName: 'string', // optional
       * }
       */
      constructor(opts, cb = null) {
        super(opts);
        this.client = opts.storeClient;
        this.clientType = opts.storeType;
        this.tableName = opts.tableName;
        this.schemaName = opts.schemaName;
        this.clearExpiredByTimeout = opts.clearExpiredByTimeout;
        this.tableCreated = opts.tableCreated;
        if (!this.tableCreated) {
          this._createTable().then(() => {
            this.tableCreated = true;
            if (this.clearExpiredByTimeout) {
              this._clearExpiredHourAgo();
            }
            if (typeof cb === "function") {
              cb();
            }
          }).catch((err) => {
            if (typeof cb === "function") {
              cb(err);
            } else {
              throw err;
            }
          });
        } else {
          if (this.clearExpiredByTimeout) {
            this._clearExpiredHourAgo();
          }
          if (typeof cb === "function") {
            cb();
          }
        }
      }
      _getTableIdentifier() {
        return this.schemaName ? `"${this.schemaName}"."${this.tableName}"` : `"${this.tableName}"`;
      }
      clearExpired(expire) {
        return new Promise((resolve) => {
          const q = {
            name: "rlflx-clear-expired",
            text: `DELETE FROM ${this._getTableIdentifier()} WHERE expire < $1`,
            values: [expire]
          };
          this._query(q).then(() => {
            resolve();
          }).catch(() => {
            resolve();
          });
        });
      }
      /**
       * Delete all rows expired 1 hour ago once per 5 minutes
       *
       * @private
       */
      _clearExpiredHourAgo() {
        if (this._clearExpiredTimeoutId) {
          clearTimeout(this._clearExpiredTimeoutId);
        }
        this._clearExpiredTimeoutId = setTimeout(() => {
          this.clearExpired(Date.now() - 36e5).then(() => {
            this._clearExpiredHourAgo();
          });
        }, 3e5);
        this._clearExpiredTimeoutId.unref();
      }
      /**
       *
       * @return Promise<any>
       * @private
       */
      _getConnection() {
        switch (this.clientType) {
          case "pool":
            return Promise.resolve(this.client);
          case "sequelize":
            return this.client.connectionManager.getConnection();
          case "knex":
            return this.client.client.acquireConnection();
          case "typeorm":
            return Promise.resolve(this.client.driver.master);
          default:
            return Promise.resolve(this.client);
        }
      }
      _releaseConnection(conn) {
        switch (this.clientType) {
          case "pool":
            return true;
          case "sequelize":
            return this.client.connectionManager.releaseConnection(conn);
          case "knex":
            return this.client.client.releaseConnection(conn);
          case "typeorm":
            return true;
          default:
            return true;
        }
      }
      /**
       *
       * @returns {Promise<any>}
       * @private
       */
      _createTable() {
        return new Promise((resolve, reject) => {
          this._query({
            text: this._getCreateTableStmt()
          }).then(() => {
            resolve();
          }).catch((err) => {
            if (err.code === "23505") {
              resolve();
            } else {
              reject(err);
            }
          });
        });
      }
      _getCreateTableStmt() {
        return `CREATE TABLE IF NOT EXISTS ${this._getTableIdentifier()} (
      key varchar(255) PRIMARY KEY,
      points integer NOT NULL DEFAULT 0,
      expire bigint
    );`;
      }
      get clientType() {
        return this._clientType;
      }
      set clientType(value) {
        const constructorName = this.client.constructor.name;
        if (typeof value === "undefined") {
          if (constructorName === "Client") {
            value = "client";
          } else if (constructorName === "Pool" || constructorName === "BoundPool") {
            value = "pool";
          } else if (constructorName === "Sequelize") {
            value = "sequelize";
          } else {
            throw new Error("storeType is not defined");
          }
        }
        this._clientType = value.toLowerCase();
      }
      get tableName() {
        return this._tableName;
      }
      set tableName(value) {
        this._tableName = typeof value === "undefined" ? this.keyPrefix : value;
      }
      get schemaName() {
        return this._schemaName;
      }
      set schemaName(value) {
        this._schemaName = value;
      }
      get tableCreated() {
        return this._tableCreated;
      }
      set tableCreated(value) {
        this._tableCreated = typeof value === "undefined" ? false : !!value;
      }
      get clearExpiredByTimeout() {
        return this._clearExpiredByTimeout;
      }
      set clearExpiredByTimeout(value) {
        this._clearExpiredByTimeout = typeof value === "undefined" ? true : Boolean(value);
      }
      _getRateLimiterRes(rlKey, changedPoints, result) {
        const res = new RateLimiterRes();
        const row = result.rows[0];
        res.isFirstInDuration = changedPoints === row.points;
        res.consumedPoints = res.isFirstInDuration ? changedPoints : row.points;
        res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
        res.msBeforeNext = row.expire ? Math.max(row.expire - Date.now(), 0) : -1;
        return res;
      }
      _query(q) {
        const prefix = this.tableName.toLowerCase();
        const queryObj = { name: `${prefix}:${q.name}`, text: q.text, values: q.values };
        return new Promise((resolve, reject) => {
          this._getConnection().then((conn) => {
            conn.query(queryObj).then((res) => {
              resolve(res);
              this._releaseConnection(conn);
            }).catch((err) => {
              reject(err);
              this._releaseConnection(conn);
            });
          }).catch((err) => {
            reject(err);
          });
        });
      }
      _upsert(key, points, msDuration, forceExpire = false) {
        if (!this.tableCreated) {
          return Promise.reject(Error("Table is not created yet"));
        }
        const newExpire = msDuration > 0 ? Date.now() + msDuration : null;
        const expireQ = forceExpire ? " $3 " : ` CASE
             WHEN ${this._getTableIdentifier()}.expire <= $4 THEN $3
             ELSE ${this._getTableIdentifier()}.expire
            END `;
        return this._query({
          name: forceExpire ? "rlflx-upsert-force" : "rlflx-upsert",
          text: `
            INSERT INTO ${this._getTableIdentifier()} VALUES ($1, $2, $3)
              ON CONFLICT(key) DO UPDATE SET
                points = CASE
                          WHEN (${this._getTableIdentifier()}.expire <= $4 OR 1=${forceExpire ? 1 : 0}) THEN $2
                          ELSE ${this._getTableIdentifier()}.points + ($2)
                         END,
                expire = ${expireQ}
            RETURNING points, expire;`,
          values: [key, points, newExpire, Date.now()]
        });
      }
      _get(rlKey) {
        if (!this.tableCreated) {
          return Promise.reject(Error("Table is not created yet"));
        }
        return new Promise((resolve, reject) => {
          this._query({
            name: "rlflx-get",
            text: `
            SELECT points, expire FROM ${this._getTableIdentifier()} WHERE key = $1 AND (expire > $2 OR expire IS NULL);`,
            values: [rlKey, Date.now()]
          }).then((res) => {
            if (res.rowCount === 0) {
              res = null;
            }
            resolve(res);
          }).catch((err) => {
            reject(err);
          });
        });
      }
      _delete(rlKey) {
        if (!this.tableCreated) {
          return Promise.reject(Error("Table is not created yet"));
        }
        return this._query({
          name: "rlflx-delete",
          text: `DELETE FROM ${this._getTableIdentifier()} WHERE key = $1`,
          values: [rlKey]
        }).then((res) => res.rowCount > 0);
      }
    };
    module.exports = RateLimiterPostgres;
  }
});

// browser-external:cluster
var require_cluster = __commonJS({
  "browser-external:cluster"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "cluster" has been externalized for browser compatibility. Cannot access "cluster.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/rate-limiter-flexible/lib/component/MemoryStorage/Record.js
var require_Record = __commonJS({
  "node_modules/rate-limiter-flexible/lib/component/MemoryStorage/Record.js"(exports, module) {
    module.exports = class Record {
      /**
       *
       * @param value int
       * @param expiresAt Date|int
       * @param timeoutId
       */
      constructor(value, expiresAt, timeoutId = null) {
        this.value = value;
        this.expiresAt = expiresAt;
        this.timeoutId = timeoutId;
      }
      get value() {
        return this._value;
      }
      set value(value) {
        this._value = parseInt(value);
      }
      get expiresAt() {
        return this._expiresAt;
      }
      set expiresAt(value) {
        if (!(value instanceof Date) && Number.isInteger(value)) {
          value = new Date(value);
        }
        this._expiresAt = value;
      }
      get timeoutId() {
        return this._timeoutId;
      }
      set timeoutId(value) {
        this._timeoutId = value;
      }
    };
  }
});

// node_modules/rate-limiter-flexible/lib/component/MemoryStorage/MemoryStorage.js
var require_MemoryStorage = __commonJS({
  "node_modules/rate-limiter-flexible/lib/component/MemoryStorage/MemoryStorage.js"(exports, module) {
    var Record = require_Record();
    var RateLimiterRes = require_RateLimiterRes();
    module.exports = class MemoryStorage {
      constructor() {
        this._storage = {};
      }
      incrby(key, value, durationSec) {
        if (this._storage[key]) {
          const msBeforeExpires = this._storage[key].expiresAt ? this._storage[key].expiresAt.getTime() - (/* @__PURE__ */ new Date()).getTime() : -1;
          if (msBeforeExpires !== 0) {
            this._storage[key].value = this._storage[key].value + value;
            return new RateLimiterRes(0, msBeforeExpires, this._storage[key].value, false);
          }
          return this.set(key, value, durationSec);
        }
        return this.set(key, value, durationSec);
      }
      set(key, value, durationSec) {
        const durationMs = durationSec * 1e3;
        if (this._storage[key] && this._storage[key].timeoutId) {
          clearTimeout(this._storage[key].timeoutId);
        }
        this._storage[key] = new Record(
          value,
          durationMs > 0 ? new Date(Date.now() + durationMs) : null
        );
        if (durationMs > 0) {
          this._storage[key].timeoutId = setTimeout(() => {
            delete this._storage[key];
          }, durationMs);
          if (this._storage[key].timeoutId.unref) {
            this._storage[key].timeoutId.unref();
          }
        }
        return new RateLimiterRes(0, durationMs === 0 ? -1 : durationMs, this._storage[key].value, true);
      }
      /**
       *
       * @param key
       * @returns {*}
       */
      get(key) {
        if (this._storage[key]) {
          const msBeforeExpires = this._storage[key].expiresAt ? this._storage[key].expiresAt.getTime() - (/* @__PURE__ */ new Date()).getTime() : -1;
          return new RateLimiterRes(0, msBeforeExpires, this._storage[key].value, false);
        }
        return null;
      }
      /**
       *
       * @param key
       * @returns {boolean}
       */
      delete(key) {
        if (this._storage[key]) {
          if (this._storage[key].timeoutId) {
            clearTimeout(this._storage[key].timeoutId);
          }
          delete this._storage[key];
          return true;
        }
        return false;
      }
    };
  }
});

// node_modules/rate-limiter-flexible/lib/RateLimiterMemory.js
var require_RateLimiterMemory = __commonJS({
  "node_modules/rate-limiter-flexible/lib/RateLimiterMemory.js"(exports, module) {
    var RateLimiterAbstract = require_RateLimiterAbstract();
    var MemoryStorage = require_MemoryStorage();
    var RateLimiterRes = require_RateLimiterRes();
    var RateLimiterMemory3 = class extends RateLimiterAbstract {
      constructor(opts = {}) {
        super(opts);
        this._memoryStorage = new MemoryStorage();
      }
      /**
       *
       * @param key
       * @param pointsToConsume
       * @param {Object} options
       * @returns {Promise<RateLimiterRes>}
       */
      consume(key, pointsToConsume = 1, options = {}) {
        return new Promise((resolve, reject) => {
          const rlKey = this.getKey(key);
          const secDuration = this._getKeySecDuration(options);
          let res = this._memoryStorage.incrby(rlKey, pointsToConsume, secDuration);
          res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
          if (res.consumedPoints > this.points) {
            if (this.blockDuration > 0 && res.consumedPoints <= this.points + pointsToConsume) {
              res = this._memoryStorage.set(rlKey, res.consumedPoints, this.blockDuration);
            }
            reject(res);
          } else if (this.execEvenly && res.msBeforeNext > 0 && !res.isFirstInDuration) {
            let delay = Math.ceil(res.msBeforeNext / (res.remainingPoints + 2));
            if (delay < this.execEvenlyMinDelayMs) {
              delay = res.consumedPoints * this.execEvenlyMinDelayMs;
            }
            setTimeout(resolve, delay, res);
          } else {
            resolve(res);
          }
        });
      }
      penalty(key, points = 1, options = {}) {
        const rlKey = this.getKey(key);
        return new Promise((resolve) => {
          const secDuration = this._getKeySecDuration(options);
          const res = this._memoryStorage.incrby(rlKey, points, secDuration);
          res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
          resolve(res);
        });
      }
      reward(key, points = 1, options = {}) {
        const rlKey = this.getKey(key);
        return new Promise((resolve) => {
          const secDuration = this._getKeySecDuration(options);
          const res = this._memoryStorage.incrby(rlKey, -points, secDuration);
          res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
          resolve(res);
        });
      }
      /**
       * Block any key for secDuration seconds
       *
       * @param key
       * @param secDuration
       */
      block(key, secDuration) {
        const msDuration = secDuration * 1e3;
        const initPoints = this.points + 1;
        this._memoryStorage.set(this.getKey(key), initPoints, secDuration);
        return Promise.resolve(
          new RateLimiterRes(0, msDuration === 0 ? -1 : msDuration, initPoints)
        );
      }
      set(key, points, secDuration) {
        const msDuration = (secDuration >= 0 ? secDuration : this.duration) * 1e3;
        this._memoryStorage.set(this.getKey(key), points, secDuration);
        return Promise.resolve(
          new RateLimiterRes(0, msDuration === 0 ? -1 : msDuration, points)
        );
      }
      get(key) {
        const res = this._memoryStorage.get(this.getKey(key));
        if (res !== null) {
          res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
        }
        return Promise.resolve(res);
      }
      delete(key) {
        return Promise.resolve(this._memoryStorage.delete(this.getKey(key)));
      }
    };
    module.exports = RateLimiterMemory3;
  }
});

// node_modules/rate-limiter-flexible/lib/RateLimiterCluster.js
var require_RateLimiterCluster = __commonJS({
  "node_modules/rate-limiter-flexible/lib/RateLimiterCluster.js"(exports, module) {
    var cluster = require_cluster();
    var crypto2 = require_crypto();
    var RateLimiterAbstract = require_RateLimiterAbstract();
    var RateLimiterMemory3 = require_RateLimiterMemory();
    var RateLimiterRes = require_RateLimiterRes();
    var channel = "rate_limiter_flexible";
    var masterInstance = null;
    var masterSendToWorker = function(worker, msg, type, res) {
      let data;
      if (res === null || res === true || res === false) {
        data = res;
      } else {
        data = {
          remainingPoints: res.remainingPoints,
          msBeforeNext: res.msBeforeNext,
          consumedPoints: res.consumedPoints,
          isFirstInDuration: res.isFirstInDuration
        };
      }
      worker.send({
        channel,
        keyPrefix: msg.keyPrefix,
        // which rate limiter exactly
        promiseId: msg.promiseId,
        type,
        data
      });
    };
    var workerWaitInit = function(payload) {
      setTimeout(() => {
        if (this._initiated) {
          process.send(payload);
        } else if (typeof this._promises[payload.promiseId] !== "undefined") {
          workerWaitInit.call(this, payload);
        }
      }, 30);
    };
    var workerSendToMaster = function(func2, promiseId, key, arg, opts) {
      const payload = {
        channel,
        keyPrefix: this.keyPrefix,
        func: func2,
        promiseId,
        data: {
          key,
          arg,
          opts
        }
      };
      if (!this._initiated) {
        workerWaitInit.call(this, payload);
      } else {
        process.send(payload);
      }
    };
    var masterProcessMsg = function(worker, msg) {
      if (!msg || msg.channel !== channel || typeof this._rateLimiters[msg.keyPrefix] === "undefined") {
        return false;
      }
      let promise;
      switch (msg.func) {
        case "consume":
          promise = this._rateLimiters[msg.keyPrefix].consume(msg.data.key, msg.data.arg, msg.data.opts);
          break;
        case "penalty":
          promise = this._rateLimiters[msg.keyPrefix].penalty(msg.data.key, msg.data.arg, msg.data.opts);
          break;
        case "reward":
          promise = this._rateLimiters[msg.keyPrefix].reward(msg.data.key, msg.data.arg, msg.data.opts);
          break;
        case "block":
          promise = this._rateLimiters[msg.keyPrefix].block(msg.data.key, msg.data.arg, msg.data.opts);
          break;
        case "get":
          promise = this._rateLimiters[msg.keyPrefix].get(msg.data.key, msg.data.opts);
          break;
        case "delete":
          promise = this._rateLimiters[msg.keyPrefix].delete(msg.data.key, msg.data.opts);
          break;
        default:
          return false;
      }
      if (promise) {
        promise.then((res) => {
          masterSendToWorker(worker, msg, "resolve", res);
        }).catch((rejRes) => {
          masterSendToWorker(worker, msg, "reject", rejRes);
        });
      }
    };
    var workerProcessMsg = function(msg) {
      if (!msg || msg.channel !== channel || msg.keyPrefix !== this.keyPrefix) {
        return false;
      }
      if (this._promises[msg.promiseId]) {
        clearTimeout(this._promises[msg.promiseId].timeoutId);
        let res;
        if (msg.data === null || msg.data === true || msg.data === false) {
          res = msg.data;
        } else {
          res = new RateLimiterRes(
            msg.data.remainingPoints,
            msg.data.msBeforeNext,
            msg.data.consumedPoints,
            msg.data.isFirstInDuration
            // eslint-disable-line comma-dangle
          );
        }
        switch (msg.type) {
          case "resolve":
            this._promises[msg.promiseId].resolve(res);
            break;
          case "reject":
            this._promises[msg.promiseId].reject(res);
            break;
          default:
            throw new Error(`RateLimiterCluster: no such message type '${msg.type}'`);
        }
        delete this._promises[msg.promiseId];
      }
    };
    var getOpts = function() {
      return {
        points: this.points,
        duration: this.duration,
        blockDuration: this.blockDuration,
        execEvenly: this.execEvenly,
        execEvenlyMinDelayMs: this.execEvenlyMinDelayMs,
        keyPrefix: this.keyPrefix
      };
    };
    var savePromise = function(resolve, reject) {
      const hrtime = process.hrtime();
      let promiseId = hrtime[0].toString() + hrtime[1].toString();
      if (typeof this._promises[promiseId] !== "undefined") {
        promiseId += crypto2.randomBytes(12).toString("base64");
      }
      this._promises[promiseId] = {
        resolve,
        reject,
        timeoutId: setTimeout(() => {
          delete this._promises[promiseId];
          reject(new Error("RateLimiterCluster timeout: no answer from master in time"));
        }, this.timeoutMs)
      };
      return promiseId;
    };
    var RateLimiterClusterMaster = class {
      constructor() {
        if (masterInstance) {
          return masterInstance;
        }
        this._rateLimiters = {};
        cluster.setMaxListeners(0);
        cluster.on("message", (worker, msg) => {
          if (msg && msg.channel === channel && msg.type === "init") {
            if (typeof this._rateLimiters[msg.opts.keyPrefix] === "undefined") {
              this._rateLimiters[msg.opts.keyPrefix] = new RateLimiterMemory3(msg.opts);
            }
            worker.send({
              channel,
              type: "init",
              keyPrefix: msg.opts.keyPrefix
            });
          } else {
            masterProcessMsg.call(this, worker, msg);
          }
        });
        masterInstance = this;
      }
    };
    var RateLimiterClusterMasterPM2 = class {
      constructor(pm2) {
        if (masterInstance) {
          return masterInstance;
        }
        this._rateLimiters = {};
        pm2.launchBus((err, pm2Bus) => {
          pm2Bus.on("process:msg", (packet) => {
            const msg = packet.raw;
            if (msg && msg.channel === channel && msg.type === "init") {
              if (typeof this._rateLimiters[msg.opts.keyPrefix] === "undefined") {
                this._rateLimiters[msg.opts.keyPrefix] = new RateLimiterMemory3(msg.opts);
              }
              pm2.sendDataToProcessId(packet.process.pm_id, {
                data: {},
                topic: channel,
                channel,
                type: "init",
                keyPrefix: msg.opts.keyPrefix
              }, (sendErr, res) => {
                if (sendErr) {
                  console.log(sendErr, res);
                }
              });
            } else {
              const worker = {
                send: (msgData) => {
                  const pm2Message = msgData;
                  pm2Message.topic = channel;
                  if (typeof pm2Message.data === "undefined") {
                    pm2Message.data = {};
                  }
                  pm2.sendDataToProcessId(packet.process.pm_id, pm2Message, (sendErr, res) => {
                    if (sendErr) {
                      console.log(sendErr, res);
                    }
                  });
                }
              };
              masterProcessMsg.call(this, worker, msg);
            }
          });
        });
        masterInstance = this;
      }
    };
    var RateLimiterClusterWorker = class extends RateLimiterAbstract {
      get timeoutMs() {
        return this._timeoutMs;
      }
      set timeoutMs(value) {
        this._timeoutMs = typeof value === "undefined" ? 5e3 : Math.abs(parseInt(value));
      }
      constructor(opts = {}) {
        super(opts);
        process.setMaxListeners(0);
        this.timeoutMs = opts.timeoutMs;
        this._initiated = false;
        process.on("message", (msg) => {
          if (msg && msg.channel === channel && msg.type === "init" && msg.keyPrefix === this.keyPrefix) {
            this._initiated = true;
          } else {
            workerProcessMsg.call(this, msg);
          }
        });
        process.send({
          channel,
          type: "init",
          opts: getOpts.call(this)
        });
        this._promises = {};
      }
      consume(key, pointsToConsume = 1, options = {}) {
        return new Promise((resolve, reject) => {
          const promiseId = savePromise.call(this, resolve, reject);
          workerSendToMaster.call(this, "consume", promiseId, key, pointsToConsume, options);
        });
      }
      penalty(key, points = 1, options = {}) {
        return new Promise((resolve, reject) => {
          const promiseId = savePromise.call(this, resolve, reject);
          workerSendToMaster.call(this, "penalty", promiseId, key, points, options);
        });
      }
      reward(key, points = 1, options = {}) {
        return new Promise((resolve, reject) => {
          const promiseId = savePromise.call(this, resolve, reject);
          workerSendToMaster.call(this, "reward", promiseId, key, points, options);
        });
      }
      block(key, secDuration, options = {}) {
        return new Promise((resolve, reject) => {
          const promiseId = savePromise.call(this, resolve, reject);
          workerSendToMaster.call(this, "block", promiseId, key, secDuration, options);
        });
      }
      get(key, options = {}) {
        return new Promise((resolve, reject) => {
          const promiseId = savePromise.call(this, resolve, reject);
          workerSendToMaster.call(this, "get", promiseId, key, options);
        });
      }
      delete(key, options = {}) {
        return new Promise((resolve, reject) => {
          const promiseId = savePromise.call(this, resolve, reject);
          workerSendToMaster.call(this, "delete", promiseId, key, options);
        });
      }
    };
    module.exports = {
      RateLimiterClusterMaster,
      RateLimiterClusterMasterPM2,
      RateLimiterCluster: RateLimiterClusterWorker
    };
  }
});

// node_modules/rate-limiter-flexible/lib/RateLimiterMemcache.js
var require_RateLimiterMemcache = __commonJS({
  "node_modules/rate-limiter-flexible/lib/RateLimiterMemcache.js"(exports, module) {
    var RateLimiterStoreAbstract = require_RateLimiterStoreAbstract();
    var RateLimiterRes = require_RateLimiterRes();
    var RateLimiterMemcache = class extends RateLimiterStoreAbstract {
      /**
       *
       * @param {Object} opts
       * Defaults {
       *   ... see other in RateLimiterStoreAbstract
       *
       *   storeClient: memcacheClient
       * }
       */
      constructor(opts) {
        super(opts);
        this.client = opts.storeClient;
      }
      _getRateLimiterRes(rlKey, changedPoints, result) {
        const res = new RateLimiterRes();
        res.consumedPoints = parseInt(result.consumedPoints);
        res.isFirstInDuration = result.consumedPoints === changedPoints;
        res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
        res.msBeforeNext = result.msBeforeNext;
        return res;
      }
      _upsert(rlKey, points, msDuration, forceExpire = false, options = {}) {
        return new Promise((resolve, reject) => {
          const nowMs = Date.now();
          const secDuration = Math.floor(msDuration / 1e3);
          if (forceExpire) {
            this.client.set(rlKey, points, secDuration, (err) => {
              if (!err) {
                this.client.set(
                  `${rlKey}_expire`,
                  secDuration > 0 ? nowMs + secDuration * 1e3 : -1,
                  secDuration,
                  () => {
                    const res = {
                      consumedPoints: points,
                      msBeforeNext: secDuration > 0 ? secDuration * 1e3 : -1
                    };
                    resolve(res);
                  }
                );
              } else {
                reject(err);
              }
            });
          } else {
            this.client.incr(rlKey, points, (err, consumedPoints) => {
              if (err || consumedPoints === false) {
                this.client.add(rlKey, points, secDuration, (errAddKey, createdNew) => {
                  if (errAddKey || !createdNew) {
                    if (typeof options.attemptNumber === "undefined" || options.attemptNumber < 3) {
                      const nextOptions = Object.assign({}, options);
                      nextOptions.attemptNumber = nextOptions.attemptNumber ? nextOptions.attemptNumber + 1 : 1;
                      this._upsert(rlKey, points, msDuration, forceExpire, nextOptions).then((resUpsert) => resolve(resUpsert)).catch((errUpsert) => reject(errUpsert));
                    } else {
                      reject(new Error("Can not add key"));
                    }
                  } else {
                    this.client.add(
                      `${rlKey}_expire`,
                      secDuration > 0 ? nowMs + secDuration * 1e3 : -1,
                      secDuration,
                      () => {
                        const res = {
                          consumedPoints: points,
                          msBeforeNext: secDuration > 0 ? secDuration * 1e3 : -1
                        };
                        resolve(res);
                      }
                    );
                  }
                });
              } else {
                this.client.get(`${rlKey}_expire`, (errGetExpire, resGetExpireMs) => {
                  if (errGetExpire) {
                    reject(errGetExpire);
                  } else {
                    const expireMs = resGetExpireMs === false ? 0 : resGetExpireMs;
                    const res = {
                      consumedPoints,
                      msBeforeNext: expireMs >= 0 ? Math.max(expireMs - nowMs, 0) : -1
                    };
                    resolve(res);
                  }
                });
              }
            });
          }
        });
      }
      _get(rlKey) {
        return new Promise((resolve, reject) => {
          const nowMs = Date.now();
          this.client.get(rlKey, (err, consumedPoints) => {
            if (!consumedPoints) {
              resolve(null);
            } else {
              this.client.get(`${rlKey}_expire`, (errGetExpire, resGetExpireMs) => {
                if (errGetExpire) {
                  reject(errGetExpire);
                } else {
                  const expireMs = resGetExpireMs === false ? 0 : resGetExpireMs;
                  const res = {
                    consumedPoints,
                    msBeforeNext: expireMs >= 0 ? Math.max(expireMs - nowMs, 0) : -1
                  };
                  resolve(res);
                }
              });
            }
          });
        });
      }
      _delete(rlKey) {
        return new Promise((resolve, reject) => {
          this.client.del(rlKey, (err, res) => {
            if (err) {
              reject(err);
            } else if (res === false) {
              resolve(res);
            } else {
              this.client.del(`${rlKey}_expire`, (errDelExpire) => {
                if (errDelExpire) {
                  reject(errDelExpire);
                } else {
                  resolve(res);
                }
              });
            }
          });
        });
      }
    };
    module.exports = RateLimiterMemcache;
  }
});

// node_modules/rate-limiter-flexible/lib/RLWrapperBlackAndWhite.js
var require_RLWrapperBlackAndWhite = __commonJS({
  "node_modules/rate-limiter-flexible/lib/RLWrapperBlackAndWhite.js"(exports, module) {
    var RateLimiterRes = require_RateLimiterRes();
    module.exports = class RLWrapperBlackAndWhite {
      constructor(opts = {}) {
        this.limiter = opts.limiter;
        this.blackList = opts.blackList;
        this.whiteList = opts.whiteList;
        this.isBlackListed = opts.isBlackListed;
        this.isWhiteListed = opts.isWhiteListed;
        this.runActionAnyway = opts.runActionAnyway;
      }
      get limiter() {
        return this._limiter;
      }
      set limiter(value) {
        if (typeof value === "undefined") {
          throw new Error("limiter is not set");
        }
        this._limiter = value;
      }
      get runActionAnyway() {
        return this._runActionAnyway;
      }
      set runActionAnyway(value) {
        this._runActionAnyway = typeof value === "undefined" ? false : value;
      }
      get blackList() {
        return this._blackList;
      }
      set blackList(value) {
        this._blackList = Array.isArray(value) ? value : [];
      }
      get isBlackListed() {
        return this._isBlackListed;
      }
      set isBlackListed(func2) {
        if (typeof func2 === "undefined") {
          func2 = () => false;
        }
        if (typeof func2 !== "function") {
          throw new Error("isBlackListed must be function");
        }
        this._isBlackListed = func2;
      }
      get whiteList() {
        return this._whiteList;
      }
      set whiteList(value) {
        this._whiteList = Array.isArray(value) ? value : [];
      }
      get isWhiteListed() {
        return this._isWhiteListed;
      }
      set isWhiteListed(func2) {
        if (typeof func2 === "undefined") {
          func2 = () => false;
        }
        if (typeof func2 !== "function") {
          throw new Error("isWhiteListed must be function");
        }
        this._isWhiteListed = func2;
      }
      isBlackListedSomewhere(key) {
        return this.blackList.indexOf(key) >= 0 || this.isBlackListed(key);
      }
      isWhiteListedSomewhere(key) {
        return this.whiteList.indexOf(key) >= 0 || this.isWhiteListed(key);
      }
      getBlackRes() {
        return new RateLimiterRes(0, Number.MAX_SAFE_INTEGER, 0, false);
      }
      getWhiteRes() {
        return new RateLimiterRes(Number.MAX_SAFE_INTEGER, 0, 0, false);
      }
      rejectBlack() {
        return Promise.reject(this.getBlackRes());
      }
      resolveBlack() {
        return Promise.resolve(this.getBlackRes());
      }
      resolveWhite() {
        return Promise.resolve(this.getWhiteRes());
      }
      consume(key, pointsToConsume = 1) {
        let res;
        if (this.isWhiteListedSomewhere(key)) {
          res = this.resolveWhite();
        } else if (this.isBlackListedSomewhere(key)) {
          res = this.rejectBlack();
        }
        if (typeof res === "undefined") {
          return this.limiter.consume(key, pointsToConsume);
        }
        if (this.runActionAnyway) {
          this.limiter.consume(key, pointsToConsume).catch(() => {
          });
        }
        return res;
      }
      block(key, secDuration) {
        let res;
        if (this.isWhiteListedSomewhere(key)) {
          res = this.resolveWhite();
        } else if (this.isBlackListedSomewhere(key)) {
          res = this.resolveBlack();
        }
        if (typeof res === "undefined") {
          return this.limiter.block(key, secDuration);
        }
        if (this.runActionAnyway) {
          this.limiter.block(key, secDuration).catch(() => {
          });
        }
        return res;
      }
      penalty(key, points) {
        let res;
        if (this.isWhiteListedSomewhere(key)) {
          res = this.resolveWhite();
        } else if (this.isBlackListedSomewhere(key)) {
          res = this.resolveBlack();
        }
        if (typeof res === "undefined") {
          return this.limiter.penalty(key, points);
        }
        if (this.runActionAnyway) {
          this.limiter.penalty(key, points).catch(() => {
          });
        }
        return res;
      }
      reward(key, points) {
        let res;
        if (this.isWhiteListedSomewhere(key)) {
          res = this.resolveWhite();
        } else if (this.isBlackListedSomewhere(key)) {
          res = this.resolveBlack();
        }
        if (typeof res === "undefined") {
          return this.limiter.reward(key, points);
        }
        if (this.runActionAnyway) {
          this.limiter.reward(key, points).catch(() => {
          });
        }
        return res;
      }
      get(key) {
        let res;
        if (this.isWhiteListedSomewhere(key)) {
          res = this.resolveWhite();
        } else if (this.isBlackListedSomewhere(key)) {
          res = this.resolveBlack();
        }
        if (typeof res === "undefined" || this.runActionAnyway) {
          return this.limiter.get(key);
        }
        return res;
      }
      delete(key) {
        return this.limiter.delete(key);
      }
    };
  }
});

// node_modules/rate-limiter-flexible/lib/RateLimiterUnion.js
var require_RateLimiterUnion = __commonJS({
  "node_modules/rate-limiter-flexible/lib/RateLimiterUnion.js"(exports, module) {
    var RateLimiterAbstract = require_RateLimiterAbstract();
    module.exports = class RateLimiterUnion {
      constructor(...limiters) {
        if (limiters.length < 1) {
          throw new Error("RateLimiterUnion: at least one limiter have to be passed");
        }
        limiters.forEach((limiter) => {
          if (!(limiter instanceof RateLimiterAbstract)) {
            throw new Error("RateLimiterUnion: all limiters have to be instance of RateLimiterAbstract");
          }
        });
        this._limiters = limiters;
      }
      consume(key, points = 1) {
        return new Promise((resolve, reject) => {
          const promises = [];
          this._limiters.forEach((limiter) => {
            promises.push(limiter.consume(key, points).catch((rej) => ({ rejected: true, rej })));
          });
          Promise.all(promises).then((res) => {
            const resObj = {};
            let rejected = false;
            res.forEach((item) => {
              if (item.rejected === true) {
                rejected = true;
              }
            });
            for (let i = 0; i < res.length; i++) {
              if (rejected && res[i].rejected === true) {
                resObj[this._limiters[i].keyPrefix] = res[i].rej;
              } else if (!rejected) {
                resObj[this._limiters[i].keyPrefix] = res[i];
              }
            }
            if (rejected) {
              reject(resObj);
            } else {
              resolve(resObj);
            }
          });
        });
      }
    };
  }
});

// node_modules/rate-limiter-flexible/lib/component/RateLimiterQueueError.js
var require_RateLimiterQueueError = __commonJS({
  "node_modules/rate-limiter-flexible/lib/component/RateLimiterQueueError.js"(exports, module) {
    module.exports = class RateLimiterQueueError extends Error {
      constructor(message2, extra) {
        super();
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        }
        this.name = "CustomError";
        this.message = message2;
        if (extra) {
          this.extra = extra;
        }
      }
    };
  }
});

// node_modules/rate-limiter-flexible/lib/RateLimiterQueue.js
var require_RateLimiterQueue = __commonJS({
  "node_modules/rate-limiter-flexible/lib/RateLimiterQueue.js"(exports, module) {
    var RateLimiterQueueError = require_RateLimiterQueueError();
    var MAX_QUEUE_SIZE = 4294967295;
    var KEY_DEFAULT = "limiter";
    module.exports = class RateLimiterQueue {
      constructor(limiterFlexible, opts = {
        maxQueueSize: MAX_QUEUE_SIZE
      }) {
        this._queueLimiters = {
          KEY_DEFAULT: new RateLimiterQueueInternal(limiterFlexible, opts)
        };
        this._limiterFlexible = limiterFlexible;
        this._maxQueueSize = opts.maxQueueSize;
      }
      getTokensRemaining(key = KEY_DEFAULT) {
        if (this._queueLimiters[key]) {
          return this._queueLimiters[key].getTokensRemaining();
        } else {
          return Promise.resolve(this._limiterFlexible.points);
        }
      }
      removeTokens(tokens, key = KEY_DEFAULT) {
        if (!this._queueLimiters[key]) {
          this._queueLimiters[key] = new RateLimiterQueueInternal(
            this._limiterFlexible,
            {
              key,
              maxQueueSize: this._maxQueueSize
            }
          );
        }
        return this._queueLimiters[key].removeTokens(tokens);
      }
    };
    var RateLimiterQueueInternal = class {
      constructor(limiterFlexible, opts = {
        maxQueueSize: MAX_QUEUE_SIZE,
        key: KEY_DEFAULT
      }) {
        this._key = opts.key;
        this._waitTimeout = null;
        this._queue = [];
        this._limiterFlexible = limiterFlexible;
        this._maxQueueSize = opts.maxQueueSize;
      }
      getTokensRemaining() {
        return this._limiterFlexible.get(this._key).then((rlRes) => {
          return rlRes !== null ? rlRes.remainingPoints : this._limiterFlexible.points;
        });
      }
      removeTokens(tokens) {
        const _this = this;
        return new Promise((resolve, reject) => {
          if (tokens > _this._limiterFlexible.points) {
            reject(new RateLimiterQueueError(`Requested tokens ${tokens} exceeds maximum ${_this._limiterFlexible.points} tokens per interval`));
            return;
          }
          if (_this._queue.length > 0) {
            _this._queueRequest.call(_this, resolve, reject, tokens);
          } else {
            _this._limiterFlexible.consume(_this._key, tokens).then((res) => {
              resolve(res.remainingPoints);
            }).catch((rej) => {
              if (rej instanceof Error) {
                reject(rej);
              } else {
                _this._queueRequest.call(_this, resolve, reject, tokens);
                if (_this._waitTimeout === null) {
                  _this._waitTimeout = setTimeout(_this._processFIFO.bind(_this), rej.msBeforeNext);
                }
              }
            });
          }
        });
      }
      _queueRequest(resolve, reject, tokens) {
        const _this = this;
        if (_this._queue.length < _this._maxQueueSize) {
          _this._queue.push({ resolve, reject, tokens });
        } else {
          reject(new RateLimiterQueueError(`Number of requests reached it's maximum ${_this._maxQueueSize}`));
        }
      }
      _processFIFO() {
        const _this = this;
        if (_this._waitTimeout !== null) {
          clearTimeout(_this._waitTimeout);
          _this._waitTimeout = null;
        }
        if (_this._queue.length === 0) {
          return;
        }
        const item = _this._queue.shift();
        _this._limiterFlexible.consume(_this._key, item.tokens).then((res) => {
          item.resolve(res.remainingPoints);
          _this._processFIFO.call(_this);
        }).catch((rej) => {
          if (rej instanceof Error) {
            item.reject(rej);
            _this._processFIFO.call(_this);
          } else {
            _this._queue.unshift(item);
            if (_this._waitTimeout === null) {
              _this._waitTimeout = setTimeout(_this._processFIFO.bind(_this), rej.msBeforeNext);
            }
          }
        });
      }
    };
  }
});

// node_modules/rate-limiter-flexible/lib/BurstyRateLimiter.js
var require_BurstyRateLimiter = __commonJS({
  "node_modules/rate-limiter-flexible/lib/BurstyRateLimiter.js"(exports, module) {
    var RateLimiterRes = require_RateLimiterRes();
    module.exports = class BurstyRateLimiter {
      constructor(rateLimiter, burstLimiter) {
        this._rateLimiter = rateLimiter;
        this._burstLimiter = burstLimiter;
      }
      /**
       * Merge rate limiter response objects. Responses can be null
       *
       * @param {RateLimiterRes} [rlRes] Rate limiter response
       * @param {RateLimiterRes} [blRes] Bursty limiter response
       */
      _combineRes(rlRes, blRes) {
        if (!rlRes) {
          return null;
        }
        return new RateLimiterRes(
          rlRes.remainingPoints,
          Math.min(rlRes.msBeforeNext, blRes ? blRes.msBeforeNext : 0),
          rlRes.consumedPoints,
          rlRes.isFirstInDuration
        );
      }
      /**
       * @param key
       * @param pointsToConsume
       * @param options
       * @returns {Promise<any>}
       */
      consume(key, pointsToConsume = 1, options = {}) {
        return this._rateLimiter.consume(key, pointsToConsume, options).catch((rlRej) => {
          if (rlRej instanceof RateLimiterRes) {
            return this._burstLimiter.consume(key, pointsToConsume, options).then((blRes) => {
              return Promise.resolve(this._combineRes(rlRej, blRes));
            }).catch(
              (blRej) => {
                if (blRej instanceof RateLimiterRes) {
                  return Promise.reject(this._combineRes(rlRej, blRej));
                } else {
                  return Promise.reject(blRej);
                }
              }
            );
          } else {
            return Promise.reject(rlRej);
          }
        });
      }
      /**
       * It doesn't expose available points from burstLimiter
       *
       * @param key
       * @returns {Promise<RateLimiterRes>}
       */
      get(key) {
        return Promise.all([
          this._rateLimiter.get(key),
          this._burstLimiter.get(key)
        ]).then(([rlRes, blRes]) => {
          return this._combineRes(rlRes, blRes);
        });
      }
      get points() {
        return this._rateLimiter.points;
      }
    };
  }
});

// node_modules/rate-limiter-flexible/index.js
var require_rate_limiter_flexible = __commonJS({
  "node_modules/rate-limiter-flexible/index.js"(exports, module) {
    var RateLimiterRedis = require_RateLimiterRedis();
    var RateLimiterMongo = require_RateLimiterMongo();
    var RateLimiterMySQL = require_RateLimiterMySQL();
    var RateLimiterPostgres = require_RateLimiterPostgres();
    var { RateLimiterClusterMaster, RateLimiterClusterMasterPM2, RateLimiterCluster } = require_RateLimiterCluster();
    var RateLimiterMemory3 = require_RateLimiterMemory();
    var RateLimiterMemcache = require_RateLimiterMemcache();
    var RLWrapperBlackAndWhite = require_RLWrapperBlackAndWhite();
    var RateLimiterUnion = require_RateLimiterUnion();
    var RateLimiterQueue = require_RateLimiterQueue();
    var BurstyRateLimiter = require_BurstyRateLimiter();
    var RateLimiterRes = require_RateLimiterRes();
    module.exports = {
      RateLimiterRedis,
      RateLimiterMongo,
      RateLimiterMySQL,
      RateLimiterPostgres,
      RateLimiterMemory: RateLimiterMemory3,
      RateLimiterMemcache,
      RateLimiterClusterMaster,
      RateLimiterClusterMasterPM2,
      RateLimiterCluster,
      RLWrapperBlackAndWhite,
      RateLimiterUnion,
      RateLimiterQueue,
      BurstyRateLimiter,
      RateLimiterRes
    };
  }
});

// node_modules/event-iterator/lib/event-iterator.js
var require_event_iterator = __commonJS({
  "node_modules/event-iterator/lib/event-iterator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var EventQueue = class {
      constructor() {
        this.pullQueue = [];
        this.pushQueue = [];
        this.eventHandlers = {};
        this.isPaused = false;
        this.isStopped = false;
      }
      push(value) {
        if (this.isStopped)
          return;
        const resolution = { value, done: false };
        if (this.pullQueue.length) {
          const placeholder = this.pullQueue.shift();
          if (placeholder)
            placeholder.resolve(resolution);
        } else {
          this.pushQueue.push(Promise.resolve(resolution));
          if (this.highWaterMark !== void 0 && this.pushQueue.length >= this.highWaterMark && !this.isPaused) {
            this.isPaused = true;
            if (this.eventHandlers.highWater) {
              this.eventHandlers.highWater();
            } else if (console) {
              console.warn(`EventIterator queue reached ${this.pushQueue.length} items`);
            }
          }
        }
      }
      stop() {
        if (this.isStopped)
          return;
        this.isStopped = true;
        this.remove();
        for (const placeholder of this.pullQueue) {
          placeholder.resolve({ value: void 0, done: true });
        }
        this.pullQueue.length = 0;
      }
      fail(error) {
        if (this.isStopped)
          return;
        this.isStopped = true;
        this.remove();
        if (this.pullQueue.length) {
          for (const placeholder of this.pullQueue) {
            placeholder.reject(error);
          }
          this.pullQueue.length = 0;
        } else {
          const rejection = Promise.reject(error);
          rejection.catch(() => {
          });
          this.pushQueue.push(rejection);
        }
      }
      remove() {
        Promise.resolve().then(() => {
          if (this.removeCallback)
            this.removeCallback();
        });
      }
      [Symbol.asyncIterator]() {
        return {
          next: (value) => {
            const result = this.pushQueue.shift();
            if (result) {
              if (this.lowWaterMark !== void 0 && this.pushQueue.length <= this.lowWaterMark && this.isPaused) {
                this.isPaused = false;
                if (this.eventHandlers.lowWater) {
                  this.eventHandlers.lowWater();
                }
              }
              return result;
            } else if (this.isStopped) {
              return Promise.resolve({ value: void 0, done: true });
            } else {
              return new Promise((resolve, reject) => {
                this.pullQueue.push({ resolve, reject });
              });
            }
          },
          return: () => {
            this.isStopped = true;
            this.pushQueue.length = 0;
            this.remove();
            return Promise.resolve({ value: void 0, done: true });
          }
        };
      }
    };
    var EventIterator2 = class {
      constructor(listen, { highWaterMark = 100, lowWaterMark = 1 } = {}) {
        const queue = new EventQueue();
        queue.highWaterMark = highWaterMark;
        queue.lowWaterMark = lowWaterMark;
        queue.removeCallback = listen({
          push: (value) => queue.push(value),
          stop: () => queue.stop(),
          fail: (error) => queue.fail(error),
          on: (event, fn) => {
            queue.eventHandlers[event] = fn;
          }
        }) || (() => {
        });
        this[Symbol.asyncIterator] = () => queue[Symbol.asyncIterator]();
        Object.freeze(this);
      }
    };
    exports.EventIterator = EventIterator2;
    exports.default = EventIterator2;
  }
});

// node_modules/event-iterator/lib/dom.js
var require_dom = __commonJS({
  "node_modules/event-iterator/lib/dom.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var event_iterator_1 = require_event_iterator();
    exports.EventIterator = event_iterator_1.EventIterator;
    function subscribe(event, options, evOptions) {
      return new event_iterator_1.EventIterator(({ push }) => {
        this.addEventListener(event, push, options);
        return () => this.removeEventListener(event, push, options);
      }, evOptions);
    }
    exports.subscribe = subscribe;
    exports.default = event_iterator_1.EventIterator;
  }
});

// node_modules/iso-url/src/url-browser.js
var require_url_browser = __commonJS({
  "node_modules/iso-url/src/url-browser.js"(exports, module) {
    "use strict";
    var isReactNative2 = typeof navigator !== "undefined" && navigator.product === "ReactNative";
    function getDefaultBase() {
      if (isReactNative2) {
        return "http://localhost";
      }
      if (!self.location) {
        return "";
      }
      return self.location.protocol + "//" + self.location.host;
    }
    var URL3 = self.URL;
    var defaultBase = getDefaultBase();
    var URLWithLegacySupport = class {
      constructor(url = "", base3 = defaultBase) {
        this.super = new URL3(url, base3);
        this.path = this.pathname + this.search;
        this.auth = this.username && this.password ? this.username + ":" + this.password : null;
        this.query = this.search && this.search.startsWith("?") ? this.search.slice(1) : null;
      }
      get hash() {
        return this.super.hash;
      }
      get host() {
        return this.super.host;
      }
      get hostname() {
        return this.super.hostname;
      }
      get href() {
        return this.super.href;
      }
      get origin() {
        return this.super.origin;
      }
      get password() {
        return this.super.password;
      }
      get pathname() {
        return this.super.pathname;
      }
      get port() {
        return this.super.port;
      }
      get protocol() {
        return this.super.protocol;
      }
      get search() {
        return this.super.search;
      }
      get searchParams() {
        return this.super.searchParams;
      }
      get username() {
        return this.super.username;
      }
      set hash(hash2) {
        this.super.hash = hash2;
      }
      set host(host) {
        this.super.host = host;
      }
      set hostname(hostname) {
        this.super.hostname = hostname;
      }
      set href(href) {
        this.super.href = href;
      }
      set password(password) {
        this.super.password = password;
      }
      set pathname(pathname) {
        this.super.pathname = pathname;
      }
      set port(port) {
        this.super.port = port;
      }
      set protocol(protocol) {
        this.super.protocol = protocol;
      }
      set search(search) {
        this.super.search = search;
      }
      set username(username) {
        this.super.username = username;
      }
      /**
       * @param {any} o
       */
      static createObjectURL(o) {
        return URL3.createObjectURL(o);
      }
      /**
       * @param {string} o
       */
      static revokeObjectURL(o) {
        URL3.revokeObjectURL(o);
      }
      toJSON() {
        return this.super.toJSON();
      }
      toString() {
        return this.super.toString();
      }
      format() {
        return this.toString();
      }
    };
    function format(obj) {
      if (typeof obj === "string") {
        const url = new URL3(obj);
        return url.toString();
      }
      if (!(obj instanceof URL3)) {
        const userPass = (
          // @ts-ignore its not supported in node but we normalise
          obj.username && obj.password ? `${obj.username}:${obj.password}@` : ""
        );
        const auth = obj.auth ? obj.auth + "@" : "";
        const port = obj.port ? ":" + obj.port : "";
        const protocol = obj.protocol ? obj.protocol + "//" : "";
        const host = obj.host || "";
        const hostname = obj.hostname || "";
        const search = obj.search || (obj.query ? "?" + obj.query : "");
        const hash2 = obj.hash || "";
        const pathname = obj.pathname || "";
        const path = obj.path || pathname + search;
        return `${protocol}${userPass || auth}${host || hostname + port}${path}${hash2}`;
      }
    }
    module.exports = {
      URLWithLegacySupport,
      URLSearchParams: self.URLSearchParams,
      defaultBase,
      format
    };
  }
});

// node_modules/iso-url/src/relative.js
var require_relative = __commonJS({
  "node_modules/iso-url/src/relative.js"(exports, module) {
    "use strict";
    var { URLWithLegacySupport, format } = require_url_browser();
    module.exports = (url, location = {}, protocolMap = {}, defaultProtocol) => {
      let protocol = location.protocol ? location.protocol.replace(":", "") : "http";
      protocol = (protocolMap[protocol] || defaultProtocol || protocol) + ":";
      let urlParsed;
      try {
        urlParsed = new URLWithLegacySupport(url);
      } catch (err) {
        urlParsed = {};
      }
      const base3 = Object.assign({}, location, {
        protocol: protocol || urlParsed.protocol,
        host: location.host || urlParsed.host
      });
      return new URLWithLegacySupport(url, format(base3)).toString();
    };
  }
});

// node_modules/iso-url/index.js
var require_iso_url = __commonJS({
  "node_modules/iso-url/index.js"(exports, module) {
    "use strict";
    var {
      URLWithLegacySupport,
      format,
      URLSearchParams,
      defaultBase
    } = require_url_browser();
    var relative2 = require_relative();
    module.exports = {
      URL: URLWithLegacySupport,
      URLSearchParams,
      format,
      relative: relative2,
      defaultBase
    };
  }
});

// node_modules/is-electron/index.js
var require_is_electron = __commonJS({
  "node_modules/is-electron/index.js"(exports, module) {
    function isElectron2() {
      if (typeof window !== "undefined" && typeof window.process === "object" && window.process.type === "renderer") {
        return true;
      }
      if (typeof process !== "undefined" && typeof process.versions === "object" && !!process.versions.electron) {
        return true;
      }
      if (typeof navigator === "object" && typeof navigator.userAgent === "string" && navigator.userAgent.indexOf("Electron") >= 0) {
        return true;
      }
      return false;
    }
    module.exports = isElectron2;
  }
});

// node_modules/protobufjs/minimal.js
var require_minimal = __commonJS({
  "node_modules/protobufjs/minimal.js"(exports, module) {
    "use strict";
    module.exports = require_index_minimal();
  }
});

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/message/rpc.cjs
var require_rpc = __commonJS({
  "node_modules/@chainsafe/libp2p-gossipsub/dist/src/message/rpc.cjs"(exports, module) {
    (function(global, factory) {
      if (typeof define === "function" && define.amd)
        define(["protobufjs/minimal"], factory);
      else if (typeof __require === "function" && typeof module === "object" && module && module.exports)
        module.exports = factory(require_minimal());
    })(exports, function($protobuf) {
      "use strict";
      var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
      var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
      $root.RPC = function() {
        function RPC2(p) {
          this.subscriptions = [];
          this.messages = [];
          if (p) {
            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
              if (p[ks[i]] != null)
                this[ks[i]] = p[ks[i]];
          }
        }
        RPC2.prototype.subscriptions = $util.emptyArray;
        RPC2.prototype.messages = $util.emptyArray;
        RPC2.prototype.control = null;
        var $oneOfFields;
        Object.defineProperty(RPC2.prototype, "_control", {
          get: $util.oneOfGetter($oneOfFields = ["control"]),
          set: $util.oneOfSetter($oneOfFields)
        });
        RPC2.encode = function encode12(m, w) {
          if (!w)
            w = $Writer.create();
          if (m.subscriptions != null && m.subscriptions.length) {
            for (var i = 0; i < m.subscriptions.length; ++i)
              $root.RPC.SubOpts.encode(m.subscriptions[i], w.uint32(10).fork()).ldelim();
          }
          if (m.messages != null && m.messages.length) {
            for (var i = 0; i < m.messages.length; ++i)
              $root.RPC.Message.encode(m.messages[i], w.uint32(18).fork()).ldelim();
          }
          if (m.control != null && Object.hasOwnProperty.call(m, "control"))
            $root.RPC.ControlMessage.encode(m.control, w.uint32(26).fork()).ldelim();
          return w;
        };
        RPC2.decode = function decode12(r, l) {
          if (!(r instanceof $Reader))
            r = $Reader.create(r);
          var c = l === void 0 ? r.len : r.pos + l, m = new $root.RPC();
          while (r.pos < c) {
            var t = r.uint32();
            switch (t >>> 3) {
              case 1:
                if (!(m.subscriptions && m.subscriptions.length))
                  m.subscriptions = [];
                m.subscriptions.push($root.RPC.SubOpts.decode(r, r.uint32()));
                break;
              case 2:
                if (!(m.messages && m.messages.length))
                  m.messages = [];
                m.messages.push($root.RPC.Message.decode(r, r.uint32()));
                break;
              case 3:
                m.control = $root.RPC.ControlMessage.decode(r, r.uint32());
                break;
              default:
                r.skipType(t & 7);
                break;
            }
          }
          return m;
        };
        RPC2.fromObject = function fromObject(d) {
          if (d instanceof $root.RPC)
            return d;
          var m = new $root.RPC();
          if (d.subscriptions) {
            if (!Array.isArray(d.subscriptions))
              throw TypeError(".RPC.subscriptions: array expected");
            m.subscriptions = [];
            for (var i = 0; i < d.subscriptions.length; ++i) {
              if (typeof d.subscriptions[i] !== "object")
                throw TypeError(".RPC.subscriptions: object expected");
              m.subscriptions[i] = $root.RPC.SubOpts.fromObject(d.subscriptions[i]);
            }
          }
          if (d.messages) {
            if (!Array.isArray(d.messages))
              throw TypeError(".RPC.messages: array expected");
            m.messages = [];
            for (var i = 0; i < d.messages.length; ++i) {
              if (typeof d.messages[i] !== "object")
                throw TypeError(".RPC.messages: object expected");
              m.messages[i] = $root.RPC.Message.fromObject(d.messages[i]);
            }
          }
          if (d.control != null) {
            if (typeof d.control !== "object")
              throw TypeError(".RPC.control: object expected");
            m.control = $root.RPC.ControlMessage.fromObject(d.control);
          }
          return m;
        };
        RPC2.toObject = function toObject(m, o) {
          if (!o)
            o = {};
          var d = {};
          if (o.arrays || o.defaults) {
            d.subscriptions = [];
            d.messages = [];
          }
          if (m.subscriptions && m.subscriptions.length) {
            d.subscriptions = [];
            for (var j = 0; j < m.subscriptions.length; ++j) {
              d.subscriptions[j] = $root.RPC.SubOpts.toObject(m.subscriptions[j], o);
            }
          }
          if (m.messages && m.messages.length) {
            d.messages = [];
            for (var j = 0; j < m.messages.length; ++j) {
              d.messages[j] = $root.RPC.Message.toObject(m.messages[j], o);
            }
          }
          if (m.control != null && m.hasOwnProperty("control")) {
            d.control = $root.RPC.ControlMessage.toObject(m.control, o);
            if (o.oneofs)
              d._control = "control";
          }
          return d;
        };
        RPC2.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        RPC2.SubOpts = function() {
          function SubOpts(p) {
            if (p) {
              for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          SubOpts.prototype.subscribe = null;
          SubOpts.prototype.topic = null;
          var $oneOfFields2;
          Object.defineProperty(SubOpts.prototype, "_subscribe", {
            get: $util.oneOfGetter($oneOfFields2 = ["subscribe"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(SubOpts.prototype, "_topic", {
            get: $util.oneOfGetter($oneOfFields2 = ["topic"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          SubOpts.encode = function encode12(m, w) {
            if (!w)
              w = $Writer.create();
            if (m.subscribe != null && Object.hasOwnProperty.call(m, "subscribe"))
              w.uint32(8).bool(m.subscribe);
            if (m.topic != null && Object.hasOwnProperty.call(m, "topic"))
              w.uint32(18).string(m.topic);
            return w;
          };
          SubOpts.decode = function decode12(r, l) {
            if (!(r instanceof $Reader))
              r = $Reader.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root.RPC.SubOpts();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m.subscribe = r.bool();
                  break;
                case 2:
                  m.topic = r.string();
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          SubOpts.fromObject = function fromObject(d) {
            if (d instanceof $root.RPC.SubOpts)
              return d;
            var m = new $root.RPC.SubOpts();
            if (d.subscribe != null) {
              m.subscribe = Boolean(d.subscribe);
            }
            if (d.topic != null) {
              m.topic = String(d.topic);
            }
            return m;
          };
          SubOpts.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (m.subscribe != null && m.hasOwnProperty("subscribe")) {
              d.subscribe = m.subscribe;
              if (o.oneofs)
                d._subscribe = "subscribe";
            }
            if (m.topic != null && m.hasOwnProperty("topic")) {
              d.topic = m.topic;
              if (o.oneofs)
                d._topic = "topic";
            }
            return d;
          };
          SubOpts.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return SubOpts;
        }();
        RPC2.Message = function() {
          function Message(p) {
            if (p) {
              for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          Message.prototype.from = null;
          Message.prototype.data = null;
          Message.prototype.seqno = null;
          Message.prototype.topic = "";
          Message.prototype.signature = null;
          Message.prototype.key = null;
          var $oneOfFields2;
          Object.defineProperty(Message.prototype, "_from", {
            get: $util.oneOfGetter($oneOfFields2 = ["from"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(Message.prototype, "_data", {
            get: $util.oneOfGetter($oneOfFields2 = ["data"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(Message.prototype, "_seqno", {
            get: $util.oneOfGetter($oneOfFields2 = ["seqno"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(Message.prototype, "_signature", {
            get: $util.oneOfGetter($oneOfFields2 = ["signature"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(Message.prototype, "_key", {
            get: $util.oneOfGetter($oneOfFields2 = ["key"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          Message.encode = function encode12(m, w) {
            if (!w)
              w = $Writer.create();
            if (m.from != null && Object.hasOwnProperty.call(m, "from"))
              w.uint32(10).bytes(m.from);
            if (m.data != null && Object.hasOwnProperty.call(m, "data"))
              w.uint32(18).bytes(m.data);
            if (m.seqno != null && Object.hasOwnProperty.call(m, "seqno"))
              w.uint32(26).bytes(m.seqno);
            w.uint32(34).string(m.topic);
            if (m.signature != null && Object.hasOwnProperty.call(m, "signature"))
              w.uint32(42).bytes(m.signature);
            if (m.key != null && Object.hasOwnProperty.call(m, "key"))
              w.uint32(50).bytes(m.key);
            return w;
          };
          Message.decode = function decode12(r, l) {
            if (!(r instanceof $Reader))
              r = $Reader.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root.RPC.Message();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m.from = r.bytes();
                  break;
                case 2:
                  m.data = r.bytes();
                  break;
                case 3:
                  m.seqno = r.bytes();
                  break;
                case 4:
                  m.topic = r.string();
                  break;
                case 5:
                  m.signature = r.bytes();
                  break;
                case 6:
                  m.key = r.bytes();
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            if (!m.hasOwnProperty("topic"))
              throw $util.ProtocolError("missing required 'topic'", { instance: m });
            return m;
          };
          Message.fromObject = function fromObject(d) {
            if (d instanceof $root.RPC.Message)
              return d;
            var m = new $root.RPC.Message();
            if (d.from != null) {
              if (typeof d.from === "string")
                $util.base64.decode(d.from, m.from = $util.newBuffer($util.base64.length(d.from)), 0);
              else if (d.from.length)
                m.from = d.from;
            }
            if (d.data != null) {
              if (typeof d.data === "string")
                $util.base64.decode(d.data, m.data = $util.newBuffer($util.base64.length(d.data)), 0);
              else if (d.data.length)
                m.data = d.data;
            }
            if (d.seqno != null) {
              if (typeof d.seqno === "string")
                $util.base64.decode(d.seqno, m.seqno = $util.newBuffer($util.base64.length(d.seqno)), 0);
              else if (d.seqno.length)
                m.seqno = d.seqno;
            }
            if (d.topic != null) {
              m.topic = String(d.topic);
            }
            if (d.signature != null) {
              if (typeof d.signature === "string")
                $util.base64.decode(d.signature, m.signature = $util.newBuffer($util.base64.length(d.signature)), 0);
              else if (d.signature.length)
                m.signature = d.signature;
            }
            if (d.key != null) {
              if (typeof d.key === "string")
                $util.base64.decode(d.key, m.key = $util.newBuffer($util.base64.length(d.key)), 0);
              else if (d.key.length)
                m.key = d.key;
            }
            return m;
          };
          Message.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (o.defaults) {
              d.topic = "";
            }
            if (m.from != null && m.hasOwnProperty("from")) {
              d.from = o.bytes === String ? $util.base64.encode(m.from, 0, m.from.length) : o.bytes === Array ? Array.prototype.slice.call(m.from) : m.from;
              if (o.oneofs)
                d._from = "from";
            }
            if (m.data != null && m.hasOwnProperty("data")) {
              d.data = o.bytes === String ? $util.base64.encode(m.data, 0, m.data.length) : o.bytes === Array ? Array.prototype.slice.call(m.data) : m.data;
              if (o.oneofs)
                d._data = "data";
            }
            if (m.seqno != null && m.hasOwnProperty("seqno")) {
              d.seqno = o.bytes === String ? $util.base64.encode(m.seqno, 0, m.seqno.length) : o.bytes === Array ? Array.prototype.slice.call(m.seqno) : m.seqno;
              if (o.oneofs)
                d._seqno = "seqno";
            }
            if (m.topic != null && m.hasOwnProperty("topic")) {
              d.topic = m.topic;
            }
            if (m.signature != null && m.hasOwnProperty("signature")) {
              d.signature = o.bytes === String ? $util.base64.encode(m.signature, 0, m.signature.length) : o.bytes === Array ? Array.prototype.slice.call(m.signature) : m.signature;
              if (o.oneofs)
                d._signature = "signature";
            }
            if (m.key != null && m.hasOwnProperty("key")) {
              d.key = o.bytes === String ? $util.base64.encode(m.key, 0, m.key.length) : o.bytes === Array ? Array.prototype.slice.call(m.key) : m.key;
              if (o.oneofs)
                d._key = "key";
            }
            return d;
          };
          Message.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return Message;
        }();
        RPC2.ControlMessage = function() {
          function ControlMessage(p) {
            this.ihave = [];
            this.iwant = [];
            this.graft = [];
            this.prune = [];
            if (p) {
              for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          ControlMessage.prototype.ihave = $util.emptyArray;
          ControlMessage.prototype.iwant = $util.emptyArray;
          ControlMessage.prototype.graft = $util.emptyArray;
          ControlMessage.prototype.prune = $util.emptyArray;
          ControlMessage.encode = function encode12(m, w) {
            if (!w)
              w = $Writer.create();
            if (m.ihave != null && m.ihave.length) {
              for (var i = 0; i < m.ihave.length; ++i)
                $root.RPC.ControlIHave.encode(m.ihave[i], w.uint32(10).fork()).ldelim();
            }
            if (m.iwant != null && m.iwant.length) {
              for (var i = 0; i < m.iwant.length; ++i)
                $root.RPC.ControlIWant.encode(m.iwant[i], w.uint32(18).fork()).ldelim();
            }
            if (m.graft != null && m.graft.length) {
              for (var i = 0; i < m.graft.length; ++i)
                $root.RPC.ControlGraft.encode(m.graft[i], w.uint32(26).fork()).ldelim();
            }
            if (m.prune != null && m.prune.length) {
              for (var i = 0; i < m.prune.length; ++i)
                $root.RPC.ControlPrune.encode(m.prune[i], w.uint32(34).fork()).ldelim();
            }
            return w;
          };
          ControlMessage.decode = function decode12(r, l) {
            if (!(r instanceof $Reader))
              r = $Reader.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root.RPC.ControlMessage();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  if (!(m.ihave && m.ihave.length))
                    m.ihave = [];
                  m.ihave.push($root.RPC.ControlIHave.decode(r, r.uint32()));
                  break;
                case 2:
                  if (!(m.iwant && m.iwant.length))
                    m.iwant = [];
                  m.iwant.push($root.RPC.ControlIWant.decode(r, r.uint32()));
                  break;
                case 3:
                  if (!(m.graft && m.graft.length))
                    m.graft = [];
                  m.graft.push($root.RPC.ControlGraft.decode(r, r.uint32()));
                  break;
                case 4:
                  if (!(m.prune && m.prune.length))
                    m.prune = [];
                  m.prune.push($root.RPC.ControlPrune.decode(r, r.uint32()));
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          ControlMessage.fromObject = function fromObject(d) {
            if (d instanceof $root.RPC.ControlMessage)
              return d;
            var m = new $root.RPC.ControlMessage();
            if (d.ihave) {
              if (!Array.isArray(d.ihave))
                throw TypeError(".RPC.ControlMessage.ihave: array expected");
              m.ihave = [];
              for (var i = 0; i < d.ihave.length; ++i) {
                if (typeof d.ihave[i] !== "object")
                  throw TypeError(".RPC.ControlMessage.ihave: object expected");
                m.ihave[i] = $root.RPC.ControlIHave.fromObject(d.ihave[i]);
              }
            }
            if (d.iwant) {
              if (!Array.isArray(d.iwant))
                throw TypeError(".RPC.ControlMessage.iwant: array expected");
              m.iwant = [];
              for (var i = 0; i < d.iwant.length; ++i) {
                if (typeof d.iwant[i] !== "object")
                  throw TypeError(".RPC.ControlMessage.iwant: object expected");
                m.iwant[i] = $root.RPC.ControlIWant.fromObject(d.iwant[i]);
              }
            }
            if (d.graft) {
              if (!Array.isArray(d.graft))
                throw TypeError(".RPC.ControlMessage.graft: array expected");
              m.graft = [];
              for (var i = 0; i < d.graft.length; ++i) {
                if (typeof d.graft[i] !== "object")
                  throw TypeError(".RPC.ControlMessage.graft: object expected");
                m.graft[i] = $root.RPC.ControlGraft.fromObject(d.graft[i]);
              }
            }
            if (d.prune) {
              if (!Array.isArray(d.prune))
                throw TypeError(".RPC.ControlMessage.prune: array expected");
              m.prune = [];
              for (var i = 0; i < d.prune.length; ++i) {
                if (typeof d.prune[i] !== "object")
                  throw TypeError(".RPC.ControlMessage.prune: object expected");
                m.prune[i] = $root.RPC.ControlPrune.fromObject(d.prune[i]);
              }
            }
            return m;
          };
          ControlMessage.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (o.arrays || o.defaults) {
              d.ihave = [];
              d.iwant = [];
              d.graft = [];
              d.prune = [];
            }
            if (m.ihave && m.ihave.length) {
              d.ihave = [];
              for (var j = 0; j < m.ihave.length; ++j) {
                d.ihave[j] = $root.RPC.ControlIHave.toObject(m.ihave[j], o);
              }
            }
            if (m.iwant && m.iwant.length) {
              d.iwant = [];
              for (var j = 0; j < m.iwant.length; ++j) {
                d.iwant[j] = $root.RPC.ControlIWant.toObject(m.iwant[j], o);
              }
            }
            if (m.graft && m.graft.length) {
              d.graft = [];
              for (var j = 0; j < m.graft.length; ++j) {
                d.graft[j] = $root.RPC.ControlGraft.toObject(m.graft[j], o);
              }
            }
            if (m.prune && m.prune.length) {
              d.prune = [];
              for (var j = 0; j < m.prune.length; ++j) {
                d.prune[j] = $root.RPC.ControlPrune.toObject(m.prune[j], o);
              }
            }
            return d;
          };
          ControlMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return ControlMessage;
        }();
        RPC2.ControlIHave = function() {
          function ControlIHave(p) {
            this.messageIDs = [];
            if (p) {
              for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          ControlIHave.prototype.topicID = null;
          ControlIHave.prototype.messageIDs = $util.emptyArray;
          var $oneOfFields2;
          Object.defineProperty(ControlIHave.prototype, "_topicID", {
            get: $util.oneOfGetter($oneOfFields2 = ["topicID"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          ControlIHave.encode = function encode12(m, w) {
            if (!w)
              w = $Writer.create();
            if (m.topicID != null && Object.hasOwnProperty.call(m, "topicID"))
              w.uint32(10).string(m.topicID);
            if (m.messageIDs != null && m.messageIDs.length) {
              for (var i = 0; i < m.messageIDs.length; ++i)
                w.uint32(18).bytes(m.messageIDs[i]);
            }
            return w;
          };
          ControlIHave.decode = function decode12(r, l) {
            if (!(r instanceof $Reader))
              r = $Reader.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root.RPC.ControlIHave();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m.topicID = r.string();
                  break;
                case 2:
                  if (!(m.messageIDs && m.messageIDs.length))
                    m.messageIDs = [];
                  m.messageIDs.push(r.bytes());
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          ControlIHave.fromObject = function fromObject(d) {
            if (d instanceof $root.RPC.ControlIHave)
              return d;
            var m = new $root.RPC.ControlIHave();
            if (d.topicID != null) {
              m.topicID = String(d.topicID);
            }
            if (d.messageIDs) {
              if (!Array.isArray(d.messageIDs))
                throw TypeError(".RPC.ControlIHave.messageIDs: array expected");
              m.messageIDs = [];
              for (var i = 0; i < d.messageIDs.length; ++i) {
                if (typeof d.messageIDs[i] === "string")
                  $util.base64.decode(d.messageIDs[i], m.messageIDs[i] = $util.newBuffer($util.base64.length(d.messageIDs[i])), 0);
                else if (d.messageIDs[i].length)
                  m.messageIDs[i] = d.messageIDs[i];
              }
            }
            return m;
          };
          ControlIHave.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (o.arrays || o.defaults) {
              d.messageIDs = [];
            }
            if (m.topicID != null && m.hasOwnProperty("topicID")) {
              d.topicID = m.topicID;
              if (o.oneofs)
                d._topicID = "topicID";
            }
            if (m.messageIDs && m.messageIDs.length) {
              d.messageIDs = [];
              for (var j = 0; j < m.messageIDs.length; ++j) {
                d.messageIDs[j] = o.bytes === String ? $util.base64.encode(m.messageIDs[j], 0, m.messageIDs[j].length) : o.bytes === Array ? Array.prototype.slice.call(m.messageIDs[j]) : m.messageIDs[j];
              }
            }
            return d;
          };
          ControlIHave.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return ControlIHave;
        }();
        RPC2.ControlIWant = function() {
          function ControlIWant(p) {
            this.messageIDs = [];
            if (p) {
              for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          ControlIWant.prototype.messageIDs = $util.emptyArray;
          ControlIWant.encode = function encode12(m, w) {
            if (!w)
              w = $Writer.create();
            if (m.messageIDs != null && m.messageIDs.length) {
              for (var i = 0; i < m.messageIDs.length; ++i)
                w.uint32(10).bytes(m.messageIDs[i]);
            }
            return w;
          };
          ControlIWant.decode = function decode12(r, l) {
            if (!(r instanceof $Reader))
              r = $Reader.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root.RPC.ControlIWant();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  if (!(m.messageIDs && m.messageIDs.length))
                    m.messageIDs = [];
                  m.messageIDs.push(r.bytes());
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          ControlIWant.fromObject = function fromObject(d) {
            if (d instanceof $root.RPC.ControlIWant)
              return d;
            var m = new $root.RPC.ControlIWant();
            if (d.messageIDs) {
              if (!Array.isArray(d.messageIDs))
                throw TypeError(".RPC.ControlIWant.messageIDs: array expected");
              m.messageIDs = [];
              for (var i = 0; i < d.messageIDs.length; ++i) {
                if (typeof d.messageIDs[i] === "string")
                  $util.base64.decode(d.messageIDs[i], m.messageIDs[i] = $util.newBuffer($util.base64.length(d.messageIDs[i])), 0);
                else if (d.messageIDs[i].length)
                  m.messageIDs[i] = d.messageIDs[i];
              }
            }
            return m;
          };
          ControlIWant.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (o.arrays || o.defaults) {
              d.messageIDs = [];
            }
            if (m.messageIDs && m.messageIDs.length) {
              d.messageIDs = [];
              for (var j = 0; j < m.messageIDs.length; ++j) {
                d.messageIDs[j] = o.bytes === String ? $util.base64.encode(m.messageIDs[j], 0, m.messageIDs[j].length) : o.bytes === Array ? Array.prototype.slice.call(m.messageIDs[j]) : m.messageIDs[j];
              }
            }
            return d;
          };
          ControlIWant.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return ControlIWant;
        }();
        RPC2.ControlGraft = function() {
          function ControlGraft(p) {
            if (p) {
              for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          ControlGraft.prototype.topicID = null;
          var $oneOfFields2;
          Object.defineProperty(ControlGraft.prototype, "_topicID", {
            get: $util.oneOfGetter($oneOfFields2 = ["topicID"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          ControlGraft.encode = function encode12(m, w) {
            if (!w)
              w = $Writer.create();
            if (m.topicID != null && Object.hasOwnProperty.call(m, "topicID"))
              w.uint32(10).string(m.topicID);
            return w;
          };
          ControlGraft.decode = function decode12(r, l) {
            if (!(r instanceof $Reader))
              r = $Reader.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root.RPC.ControlGraft();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m.topicID = r.string();
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          ControlGraft.fromObject = function fromObject(d) {
            if (d instanceof $root.RPC.ControlGraft)
              return d;
            var m = new $root.RPC.ControlGraft();
            if (d.topicID != null) {
              m.topicID = String(d.topicID);
            }
            return m;
          };
          ControlGraft.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (m.topicID != null && m.hasOwnProperty("topicID")) {
              d.topicID = m.topicID;
              if (o.oneofs)
                d._topicID = "topicID";
            }
            return d;
          };
          ControlGraft.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return ControlGraft;
        }();
        RPC2.ControlPrune = function() {
          function ControlPrune(p) {
            this.peers = [];
            if (p) {
              for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          ControlPrune.prototype.topicID = null;
          ControlPrune.prototype.peers = $util.emptyArray;
          ControlPrune.prototype.backoff = null;
          var $oneOfFields2;
          Object.defineProperty(ControlPrune.prototype, "_topicID", {
            get: $util.oneOfGetter($oneOfFields2 = ["topicID"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(ControlPrune.prototype, "_backoff", {
            get: $util.oneOfGetter($oneOfFields2 = ["backoff"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          ControlPrune.encode = function encode12(m, w) {
            if (!w)
              w = $Writer.create();
            if (m.topicID != null && Object.hasOwnProperty.call(m, "topicID"))
              w.uint32(10).string(m.topicID);
            if (m.peers != null && m.peers.length) {
              for (var i = 0; i < m.peers.length; ++i)
                $root.RPC.PeerInfo.encode(m.peers[i], w.uint32(18).fork()).ldelim();
            }
            if (m.backoff != null && Object.hasOwnProperty.call(m, "backoff"))
              w.uint32(24).uint64(m.backoff);
            return w;
          };
          ControlPrune.decode = function decode12(r, l) {
            if (!(r instanceof $Reader))
              r = $Reader.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root.RPC.ControlPrune();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m.topicID = r.string();
                  break;
                case 2:
                  if (!(m.peers && m.peers.length))
                    m.peers = [];
                  m.peers.push($root.RPC.PeerInfo.decode(r, r.uint32()));
                  break;
                case 3:
                  m.backoff = r.uint64();
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          ControlPrune.fromObject = function fromObject(d) {
            if (d instanceof $root.RPC.ControlPrune)
              return d;
            var m = new $root.RPC.ControlPrune();
            if (d.topicID != null) {
              m.topicID = String(d.topicID);
            }
            if (d.peers) {
              if (!Array.isArray(d.peers))
                throw TypeError(".RPC.ControlPrune.peers: array expected");
              m.peers = [];
              for (var i = 0; i < d.peers.length; ++i) {
                if (typeof d.peers[i] !== "object")
                  throw TypeError(".RPC.ControlPrune.peers: object expected");
                m.peers[i] = $root.RPC.PeerInfo.fromObject(d.peers[i]);
              }
            }
            if (d.backoff != null) {
              if ($util.Long)
                (m.backoff = $util.Long.fromValue(d.backoff)).unsigned = true;
              else if (typeof d.backoff === "string")
                m.backoff = parseInt(d.backoff, 10);
              else if (typeof d.backoff === "number")
                m.backoff = d.backoff;
              else if (typeof d.backoff === "object")
                m.backoff = new $util.LongBits(d.backoff.low >>> 0, d.backoff.high >>> 0).toNumber(true);
            }
            return m;
          };
          ControlPrune.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (o.arrays || o.defaults) {
              d.peers = [];
            }
            if (m.topicID != null && m.hasOwnProperty("topicID")) {
              d.topicID = m.topicID;
              if (o.oneofs)
                d._topicID = "topicID";
            }
            if (m.peers && m.peers.length) {
              d.peers = [];
              for (var j = 0; j < m.peers.length; ++j) {
                d.peers[j] = $root.RPC.PeerInfo.toObject(m.peers[j], o);
              }
            }
            if (m.backoff != null && m.hasOwnProperty("backoff")) {
              if (typeof m.backoff === "number")
                d.backoff = o.longs === String ? String(m.backoff) : m.backoff;
              else
                d.backoff = o.longs === String ? $util.Long.prototype.toString.call(m.backoff) : o.longs === Number ? new $util.LongBits(m.backoff.low >>> 0, m.backoff.high >>> 0).toNumber(true) : m.backoff;
              if (o.oneofs)
                d._backoff = "backoff";
            }
            return d;
          };
          ControlPrune.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return ControlPrune;
        }();
        RPC2.PeerInfo = function() {
          function PeerInfo2(p) {
            if (p) {
              for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          PeerInfo2.prototype.peerID = null;
          PeerInfo2.prototype.signedPeerRecord = null;
          var $oneOfFields2;
          Object.defineProperty(PeerInfo2.prototype, "_peerID", {
            get: $util.oneOfGetter($oneOfFields2 = ["peerID"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(PeerInfo2.prototype, "_signedPeerRecord", {
            get: $util.oneOfGetter($oneOfFields2 = ["signedPeerRecord"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          PeerInfo2.encode = function encode12(m, w) {
            if (!w)
              w = $Writer.create();
            if (m.peerID != null && Object.hasOwnProperty.call(m, "peerID"))
              w.uint32(10).bytes(m.peerID);
            if (m.signedPeerRecord != null && Object.hasOwnProperty.call(m, "signedPeerRecord"))
              w.uint32(18).bytes(m.signedPeerRecord);
            return w;
          };
          PeerInfo2.decode = function decode12(r, l) {
            if (!(r instanceof $Reader))
              r = $Reader.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root.RPC.PeerInfo();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m.peerID = r.bytes();
                  break;
                case 2:
                  m.signedPeerRecord = r.bytes();
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          PeerInfo2.fromObject = function fromObject(d) {
            if (d instanceof $root.RPC.PeerInfo)
              return d;
            var m = new $root.RPC.PeerInfo();
            if (d.peerID != null) {
              if (typeof d.peerID === "string")
                $util.base64.decode(d.peerID, m.peerID = $util.newBuffer($util.base64.length(d.peerID)), 0);
              else if (d.peerID.length)
                m.peerID = d.peerID;
            }
            if (d.signedPeerRecord != null) {
              if (typeof d.signedPeerRecord === "string")
                $util.base64.decode(d.signedPeerRecord, m.signedPeerRecord = $util.newBuffer($util.base64.length(d.signedPeerRecord)), 0);
              else if (d.signedPeerRecord.length)
                m.signedPeerRecord = d.signedPeerRecord;
            }
            return m;
          };
          PeerInfo2.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (m.peerID != null && m.hasOwnProperty("peerID")) {
              d.peerID = o.bytes === String ? $util.base64.encode(m.peerID, 0, m.peerID.length) : o.bytes === Array ? Array.prototype.slice.call(m.peerID) : m.peerID;
              if (o.oneofs)
                d._peerID = "peerID";
            }
            if (m.signedPeerRecord != null && m.hasOwnProperty("signedPeerRecord")) {
              d.signedPeerRecord = o.bytes === String ? $util.base64.encode(m.signedPeerRecord, 0, m.signedPeerRecord.length) : o.bytes === Array ? Array.prototype.slice.call(m.signedPeerRecord) : m.signedPeerRecord;
              if (o.oneofs)
                d._signedPeerRecord = "signedPeerRecord";
            }
            return d;
          };
          PeerInfo2.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return PeerInfo2;
        }();
        return RPC2;
      }();
      return $root;
    });
  }
});

// node_modules/denque/index.js
var require_denque = __commonJS({
  "node_modules/denque/index.js"(exports, module) {
    "use strict";
    function Denque2(array, options) {
      var options = options || {};
      this._capacity = options.capacity;
      this._head = 0;
      this._tail = 0;
      if (Array.isArray(array)) {
        this._fromArray(array);
      } else {
        this._capacityMask = 3;
        this._list = new Array(4);
      }
    }
    Denque2.prototype.peekAt = function peekAt(index) {
      var i = index;
      if (i !== (i | 0)) {
        return void 0;
      }
      var len = this.size();
      if (i >= len || i < -len)
        return void 0;
      if (i < 0)
        i += len;
      i = this._head + i & this._capacityMask;
      return this._list[i];
    };
    Denque2.prototype.get = function get(i) {
      return this.peekAt(i);
    };
    Denque2.prototype.peek = function peek() {
      if (this._head === this._tail)
        return void 0;
      return this._list[this._head];
    };
    Denque2.prototype.peekFront = function peekFront() {
      return this.peek();
    };
    Denque2.prototype.peekBack = function peekBack() {
      return this.peekAt(-1);
    };
    Object.defineProperty(Denque2.prototype, "length", {
      get: function length4() {
        return this.size();
      }
    });
    Denque2.prototype.size = function size() {
      if (this._head === this._tail)
        return 0;
      if (this._head < this._tail)
        return this._tail - this._head;
      else
        return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque2.prototype.unshift = function unshift(item) {
      if (arguments.length === 0)
        return this.size();
      var len = this._list.length;
      this._head = this._head - 1 + len & this._capacityMask;
      this._list[this._head] = item;
      if (this._tail === this._head)
        this._growArray();
      if (this._capacity && this.size() > this._capacity)
        this.pop();
      if (this._head < this._tail)
        return this._tail - this._head;
      else
        return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque2.prototype.shift = function shift() {
      var head = this._head;
      if (head === this._tail)
        return void 0;
      var item = this._list[head];
      this._list[head] = void 0;
      this._head = head + 1 & this._capacityMask;
      if (head < 2 && this._tail > 1e4 && this._tail <= this._list.length >>> 2)
        this._shrinkArray();
      return item;
    };
    Denque2.prototype.push = function push(item) {
      if (arguments.length === 0)
        return this.size();
      var tail = this._tail;
      this._list[tail] = item;
      this._tail = tail + 1 & this._capacityMask;
      if (this._tail === this._head) {
        this._growArray();
      }
      if (this._capacity && this.size() > this._capacity) {
        this.shift();
      }
      if (this._head < this._tail)
        return this._tail - this._head;
      else
        return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque2.prototype.pop = function pop() {
      var tail = this._tail;
      if (tail === this._head)
        return void 0;
      var len = this._list.length;
      this._tail = tail - 1 + len & this._capacityMask;
      var item = this._list[this._tail];
      this._list[this._tail] = void 0;
      if (this._head < 2 && tail > 1e4 && tail <= len >>> 2)
        this._shrinkArray();
      return item;
    };
    Denque2.prototype.removeOne = function removeOne(index) {
      var i = index;
      if (i !== (i | 0)) {
        return void 0;
      }
      if (this._head === this._tail)
        return void 0;
      var size = this.size();
      var len = this._list.length;
      if (i >= size || i < -size)
        return void 0;
      if (i < 0)
        i += size;
      i = this._head + i & this._capacityMask;
      var item = this._list[i];
      var k;
      if (index < size / 2) {
        for (k = index; k > 0; k--) {
          this._list[i] = this._list[i = i - 1 + len & this._capacityMask];
        }
        this._list[i] = void 0;
        this._head = this._head + 1 + len & this._capacityMask;
      } else {
        for (k = size - 1 - index; k > 0; k--) {
          this._list[i] = this._list[i = i + 1 + len & this._capacityMask];
        }
        this._list[i] = void 0;
        this._tail = this._tail - 1 + len & this._capacityMask;
      }
      return item;
    };
    Denque2.prototype.remove = function remove(index, count) {
      var i = index;
      var removed;
      var del_count = count;
      if (i !== (i | 0)) {
        return void 0;
      }
      if (this._head === this._tail)
        return void 0;
      var size = this.size();
      var len = this._list.length;
      if (i >= size || i < -size || count < 1)
        return void 0;
      if (i < 0)
        i += size;
      if (count === 1 || !count) {
        removed = new Array(1);
        removed[0] = this.removeOne(i);
        return removed;
      }
      if (i === 0 && i + count >= size) {
        removed = this.toArray();
        this.clear();
        return removed;
      }
      if (i + count > size)
        count = size - i;
      var k;
      removed = new Array(count);
      for (k = 0; k < count; k++) {
        removed[k] = this._list[this._head + i + k & this._capacityMask];
      }
      i = this._head + i & this._capacityMask;
      if (index + count === size) {
        this._tail = this._tail - count + len & this._capacityMask;
        for (k = count; k > 0; k--) {
          this._list[i = i + 1 + len & this._capacityMask] = void 0;
        }
        return removed;
      }
      if (index === 0) {
        this._head = this._head + count + len & this._capacityMask;
        for (k = count - 1; k > 0; k--) {
          this._list[i = i + 1 + len & this._capacityMask] = void 0;
        }
        return removed;
      }
      if (i < size / 2) {
        this._head = this._head + index + count + len & this._capacityMask;
        for (k = index; k > 0; k--) {
          this.unshift(this._list[i = i - 1 + len & this._capacityMask]);
        }
        i = this._head - 1 + len & this._capacityMask;
        while (del_count > 0) {
          this._list[i = i - 1 + len & this._capacityMask] = void 0;
          del_count--;
        }
        if (index < 0)
          this._tail = i;
      } else {
        this._tail = i;
        i = i + count + len & this._capacityMask;
        for (k = size - (count + index); k > 0; k--) {
          this.push(this._list[i++]);
        }
        i = this._tail;
        while (del_count > 0) {
          this._list[i = i + 1 + len & this._capacityMask] = void 0;
          del_count--;
        }
      }
      if (this._head < 2 && this._tail > 1e4 && this._tail <= len >>> 2)
        this._shrinkArray();
      return removed;
    };
    Denque2.prototype.splice = function splice(index, count) {
      var i = index;
      if (i !== (i | 0)) {
        return void 0;
      }
      var size = this.size();
      if (i < 0)
        i += size;
      if (i > size)
        return void 0;
      if (arguments.length > 2) {
        var k;
        var temp;
        var removed;
        var arg_len = arguments.length;
        var len = this._list.length;
        var arguments_index = 2;
        if (!size || i < size / 2) {
          temp = new Array(i);
          for (k = 0; k < i; k++) {
            temp[k] = this._list[this._head + k & this._capacityMask];
          }
          if (count === 0) {
            removed = [];
            if (i > 0) {
              this._head = this._head + i + len & this._capacityMask;
            }
          } else {
            removed = this.remove(i, count);
            this._head = this._head + i + len & this._capacityMask;
          }
          while (arg_len > arguments_index) {
            this.unshift(arguments[--arg_len]);
          }
          for (k = i; k > 0; k--) {
            this.unshift(temp[k - 1]);
          }
        } else {
          temp = new Array(size - (i + count));
          var leng = temp.length;
          for (k = 0; k < leng; k++) {
            temp[k] = this._list[this._head + i + count + k & this._capacityMask];
          }
          if (count === 0) {
            removed = [];
            if (i != size) {
              this._tail = this._head + i + len & this._capacityMask;
            }
          } else {
            removed = this.remove(i, count);
            this._tail = this._tail - leng + len & this._capacityMask;
          }
          while (arguments_index < arg_len) {
            this.push(arguments[arguments_index++]);
          }
          for (k = 0; k < leng; k++) {
            this.push(temp[k]);
          }
        }
        return removed;
      } else {
        return this.remove(i, count);
      }
    };
    Denque2.prototype.clear = function clear() {
      this._list = new Array(this._list.length);
      this._head = 0;
      this._tail = 0;
    };
    Denque2.prototype.isEmpty = function isEmpty() {
      return this._head === this._tail;
    };
    Denque2.prototype.toArray = function toArray() {
      return this._copyArray(false);
    };
    Denque2.prototype._fromArray = function _fromArray(array) {
      var length4 = array.length;
      var capacity = this._nextPowerOf2(length4);
      this._list = new Array(capacity);
      this._capacityMask = capacity - 1;
      this._tail = length4;
      for (var i = 0; i < length4; i++)
        this._list[i] = array[i];
    };
    Denque2.prototype._copyArray = function _copyArray(fullCopy, size) {
      var src3 = this._list;
      var capacity = src3.length;
      var length4 = this.length;
      size = size | length4;
      if (size == length4 && this._head < this._tail) {
        return this._list.slice(this._head, this._tail);
      }
      var dest = new Array(size);
      var k = 0;
      var i;
      if (fullCopy || this._head > this._tail) {
        for (i = this._head; i < capacity; i++)
          dest[k++] = src3[i];
        for (i = 0; i < this._tail; i++)
          dest[k++] = src3[i];
      } else {
        for (i = this._head; i < this._tail; i++)
          dest[k++] = src3[i];
      }
      return dest;
    };
    Denque2.prototype._growArray = function _growArray() {
      if (this._head != 0) {
        var newList = this._copyArray(true, this._list.length << 1);
        this._tail = this._list.length;
        this._head = 0;
        this._list = newList;
      } else {
        this._tail = this._list.length;
        this._list.length <<= 1;
      }
      this._capacityMask = this._capacityMask << 1 | 1;
    };
    Denque2.prototype._shrinkArray = function _shrinkArray() {
      this._list.length >>>= 1;
      this._capacityMask >>>= 1;
    };
    Denque2.prototype._nextPowerOf2 = function _nextPowerOf2(num) {
      var log210 = Math.log(num) / Math.log(2);
      var nextPow2 = 1 << log210 + 1;
      return Math.max(nextPow2, 4);
    };
    module.exports = Denque2;
  }
});

// node_modules/truncate-utf8-bytes/lib/truncate.js
var require_truncate = __commonJS({
  "node_modules/truncate-utf8-bytes/lib/truncate.js"(exports, module) {
    "use strict";
    function isHighSurrogate(codePoint) {
      return codePoint >= 55296 && codePoint <= 56319;
    }
    function isLowSurrogate(codePoint) {
      return codePoint >= 56320 && codePoint <= 57343;
    }
    module.exports = function truncate(getLength, string2, byteLength) {
      if (typeof string2 !== "string") {
        throw new Error("Input must be string");
      }
      var charLength = string2.length;
      var curByteLength = 0;
      var codePoint;
      var segment;
      for (var i = 0; i < charLength; i += 1) {
        codePoint = string2.charCodeAt(i);
        segment = string2[i];
        if (isHighSurrogate(codePoint) && isLowSurrogate(string2.charCodeAt(i + 1))) {
          i += 1;
          segment += string2[i];
        }
        curByteLength += getLength(segment);
        if (curByteLength === byteLength) {
          return string2.slice(0, i + 1);
        } else if (curByteLength > byteLength) {
          return string2.slice(0, i - segment.length + 1);
        }
      }
      return string2;
    };
  }
});

// node_modules/utf8-byte-length/browser.js
var require_browser2 = __commonJS({
  "node_modules/utf8-byte-length/browser.js"(exports, module) {
    "use strict";
    function isHighSurrogate(codePoint) {
      return codePoint >= 55296 && codePoint <= 56319;
    }
    function isLowSurrogate(codePoint) {
      return codePoint >= 56320 && codePoint <= 57343;
    }
    module.exports = function getByteLength(string2) {
      if (typeof string2 !== "string") {
        throw new Error("Input must be string");
      }
      var charLength = string2.length;
      var byteLength = 0;
      var codePoint = null;
      var prevCodePoint = null;
      for (var i = 0; i < charLength; i++) {
        codePoint = string2.charCodeAt(i);
        if (isLowSurrogate(codePoint)) {
          if (prevCodePoint != null && isHighSurrogate(prevCodePoint)) {
            byteLength += 1;
          } else {
            byteLength += 3;
          }
        } else if (codePoint <= 127) {
          byteLength += 1;
        } else if (codePoint >= 128 && codePoint <= 2047) {
          byteLength += 2;
        } else if (codePoint >= 2048 && codePoint <= 65535) {
          byteLength += 3;
        }
        prevCodePoint = codePoint;
      }
      return byteLength;
    };
  }
});

// node_modules/truncate-utf8-bytes/browser.js
var require_browser3 = __commonJS({
  "node_modules/truncate-utf8-bytes/browser.js"(exports, module) {
    "use strict";
    var truncate = require_truncate();
    var getLength = require_browser2();
    module.exports = truncate.bind(null, getLength);
  }
});

// node_modules/sanitize-filename/index.js
var require_sanitize_filename = __commonJS({
  "node_modules/sanitize-filename/index.js"(exports, module) {
    "use strict";
    var truncate = require_browser3();
    var illegalRe = /[\/\?<>\\:\*\|"]/g;
    var controlRe = /[\x00-\x1f\x80-\x9f]/g;
    var reservedRe = /^\.+$/;
    var windowsReservedRe = /^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\..*)?$/i;
    var windowsTrailingRe = /[\. ]+$/;
    function sanitize2(input, replacement) {
      if (typeof input !== "string") {
        throw new Error("Input must be string");
      }
      var sanitized = input.replace(illegalRe, replacement).replace(controlRe, replacement).replace(reservedRe, replacement).replace(windowsReservedRe, replacement).replace(windowsTrailingRe, replacement);
      return truncate(sanitized, 255);
    }
    module.exports = function(input, options) {
      var replacement = options && options.replacement || "";
      var output2 = sanitize2(input, replacement);
      if (replacement === "") {
        return output2;
      }
      return sanitize2(output2, "");
    };
  }
});

// node_modules/p-queue/node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/p-queue/node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter3() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter3.prototype.eventNames = function eventNames() {
      var names2 = [], events2, name2;
      if (this._eventsCount === 0)
        return names2;
      for (name2 in events2 = this._events) {
        if (has.call(events2, name2))
          names2.push(prefix ? name2.slice(1) : name2);
      }
      if (Object.getOwnPropertySymbols) {
        return names2.concat(Object.getOwnPropertySymbols(events2));
      }
      return names2;
    };
    EventEmitter3.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter3.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter3.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length4 = listeners.length, j;
        for (i = 0; i < length4; i++) {
          if (listeners[i].once)
            this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter3.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter3.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter3.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events2 = [], length4 = listeners.length; i < length4; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events2.push(listeners[i]);
          }
        }
        if (events2.length)
          this._events[evt] = events2.length === 1 ? events2[0] : events2;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter3.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter3.prototype.off = EventEmitter3.prototype.removeListener;
    EventEmitter3.prototype.addListener = EventEmitter3.prototype.on;
    EventEmitter3.prefixed = prefix;
    EventEmitter3.EventEmitter = EventEmitter3;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter3;
    }
  }
});

// node_modules/netmask/lib/netmask.js
var require_netmask = __commonJS({
  "node_modules/netmask/lib/netmask.js"(exports) {
    (function() {
      var Netmask2, atob, chr, chr0, chrA, chra, ip2long, long2ip;
      long2ip = function(long) {
        var a, b, c, d;
        a = (long & 255 << 24) >>> 24;
        b = (long & 255 << 16) >>> 16;
        c = (long & 255 << 8) >>> 8;
        d = long & 255;
        return [a, b, c, d].join(".");
      };
      ip2long = function(ip) {
        var b, c, i, j, n, ref;
        b = [];
        for (i = j = 0; j <= 3; i = ++j) {
          if (ip.length === 0) {
            break;
          }
          if (i > 0) {
            if (ip[0] !== ".") {
              throw new Error("Invalid IP");
            }
            ip = ip.substring(1);
          }
          ref = atob(ip), n = ref[0], c = ref[1];
          ip = ip.substring(c);
          b.push(n);
        }
        if (ip.length !== 0) {
          throw new Error("Invalid IP");
        }
        switch (b.length) {
          case 1:
            if (b[0] > 4294967295) {
              throw new Error("Invalid IP");
            }
            return b[0] >>> 0;
          case 2:
            if (b[0] > 255 || b[1] > 16777215) {
              throw new Error("Invalid IP");
            }
            return (b[0] << 24 | b[1]) >>> 0;
          case 3:
            if (b[0] > 255 || b[1] > 255 || b[2] > 65535) {
              throw new Error("Invalid IP");
            }
            return (b[0] << 24 | b[1] << 16 | b[2]) >>> 0;
          case 4:
            if (b[0] > 255 || b[1] > 255 || b[2] > 255 || b[3] > 255) {
              throw new Error("Invalid IP");
            }
            return (b[0] << 24 | b[1] << 16 | b[2] << 8 | b[3]) >>> 0;
          default:
            throw new Error("Invalid IP");
        }
      };
      chr = function(b) {
        return b.charCodeAt(0);
      };
      chr0 = chr("0");
      chra = chr("a");
      chrA = chr("A");
      atob = function(s) {
        var base3, dmax, i, n, start;
        n = 0;
        base3 = 10;
        dmax = "9";
        i = 0;
        if (s.length > 1 && s[i] === "0") {
          if (s[i + 1] === "x" || s[i + 1] === "X") {
            i += 2;
            base3 = 16;
          } else if ("0" <= s[i + 1] && s[i + 1] <= "9") {
            i++;
            base3 = 8;
            dmax = "7";
          }
        }
        start = i;
        while (i < s.length) {
          if ("0" <= s[i] && s[i] <= dmax) {
            n = n * base3 + (chr(s[i]) - chr0) >>> 0;
          } else if (base3 === 16) {
            if ("a" <= s[i] && s[i] <= "f") {
              n = n * base3 + (10 + chr(s[i]) - chra) >>> 0;
            } else if ("A" <= s[i] && s[i] <= "F") {
              n = n * base3 + (10 + chr(s[i]) - chrA) >>> 0;
            } else {
              break;
            }
          } else {
            break;
          }
          if (n > 4294967295) {
            throw new Error("too large");
          }
          i++;
        }
        if (i === start) {
          throw new Error("empty octet");
        }
        return [n, i];
      };
      Netmask2 = function() {
        function Netmask3(net, mask) {
          var error, i, j, ref;
          if (typeof net !== "string") {
            throw new Error("Missing `net' parameter");
          }
          if (!mask) {
            ref = net.split("/", 2), net = ref[0], mask = ref[1];
          }
          if (!mask) {
            mask = 32;
          }
          if (typeof mask === "string" && mask.indexOf(".") > -1) {
            try {
              this.maskLong = ip2long(mask);
            } catch (error1) {
              error = error1;
              throw new Error("Invalid mask: " + mask);
            }
            for (i = j = 32; j >= 0; i = --j) {
              if (this.maskLong === 4294967295 << 32 - i >>> 0) {
                this.bitmask = i;
                break;
              }
            }
          } else if (mask || mask === 0) {
            this.bitmask = parseInt(mask, 10);
            this.maskLong = 0;
            if (this.bitmask > 0) {
              this.maskLong = 4294967295 << 32 - this.bitmask >>> 0;
            }
          } else {
            throw new Error("Invalid mask: empty");
          }
          try {
            this.netLong = (ip2long(net) & this.maskLong) >>> 0;
          } catch (error1) {
            error = error1;
            throw new Error("Invalid net address: " + net);
          }
          if (!(this.bitmask <= 32)) {
            throw new Error("Invalid mask for ip4: " + mask);
          }
          this.size = Math.pow(2, 32 - this.bitmask);
          this.base = long2ip(this.netLong);
          this.mask = long2ip(this.maskLong);
          this.hostmask = long2ip(~this.maskLong);
          this.first = this.bitmask <= 30 ? long2ip(this.netLong + 1) : this.base;
          this.last = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 2) : long2ip(this.netLong + this.size - 1);
          this.broadcast = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 1) : void 0;
        }
        Netmask3.prototype.contains = function(ip) {
          if (typeof ip === "string" && (ip.indexOf("/") > 0 || ip.split(".").length !== 4)) {
            ip = new Netmask3(ip);
          }
          if (ip instanceof Netmask3) {
            return this.contains(ip.base) && this.contains(ip.broadcast || ip.last);
          } else {
            return (ip2long(ip) & this.maskLong) >>> 0 === (this.netLong & this.maskLong) >>> 0;
          }
        };
        Netmask3.prototype.next = function(count) {
          if (count == null) {
            count = 1;
          }
          return new Netmask3(long2ip(this.netLong + this.size * count), this.mask);
        };
        Netmask3.prototype.forEach = function(fn) {
          var index, lastLong, long;
          long = ip2long(this.first);
          lastLong = ip2long(this.last);
          index = 0;
          while (long <= lastLong) {
            fn(long2ip(long), long, index);
            index++;
            long++;
          }
        };
        Netmask3.prototype.toString = function() {
          return this.base + "/" + this.bitmask;
        };
        return Netmask3;
      }();
      exports.ip2long = ip2long;
      exports.long2ip = long2ip;
      exports.Netmask = Netmask2;
    }).call(exports);
  }
});

// node_modules/ipaddr.js/lib/ipaddr.js
var require_ipaddr = __commonJS({
  "node_modules/ipaddr.js/lib/ipaddr.js"(exports, module) {
    (function(root) {
      "use strict";
      const ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
      const ipv4Regexes = {
        fourOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}$`, "i"),
        threeOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}$`, "i"),
        twoOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}$`, "i"),
        longValue: new RegExp(`^${ipv4Part}$`, "i")
      };
      const octalRegex = new RegExp(`^0[0-7]+$`, "i");
      const hexRegex = new RegExp(`^0x[a-f0-9]+$`, "i");
      const zoneIndex = "%[0-9a-z]{1,}";
      const ipv6Part = "(?:[0-9a-f]+::?)+";
      const ipv6Regexes = {
        zoneIndex: new RegExp(zoneIndex, "i"),
        "native": new RegExp(`^(::)?(${ipv6Part})?([0-9a-f]+)?(::)?(${zoneIndex})?$`, "i"),
        deprecatedTransitional: new RegExp(`^(?:::)(${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?)$`, "i"),
        transitional: new RegExp(`^((?:${ipv6Part})|(?:::)(?:${ipv6Part})?)${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?$`, "i")
      };
      function expandIPv6(string2, parts) {
        if (string2.indexOf("::") !== string2.lastIndexOf("::")) {
          return null;
        }
        let colonCount = 0;
        let lastColon = -1;
        let zoneId = (string2.match(ipv6Regexes.zoneIndex) || [])[0];
        let replacement, replacementCount;
        if (zoneId) {
          zoneId = zoneId.substring(1);
          string2 = string2.replace(/%.+$/, "");
        }
        while ((lastColon = string2.indexOf(":", lastColon + 1)) >= 0) {
          colonCount++;
        }
        if (string2.substr(0, 2) === "::") {
          colonCount--;
        }
        if (string2.substr(-2, 2) === "::") {
          colonCount--;
        }
        if (colonCount > parts) {
          return null;
        }
        replacementCount = parts - colonCount;
        replacement = ":";
        while (replacementCount--) {
          replacement += "0:";
        }
        string2 = string2.replace("::", replacement);
        if (string2[0] === ":") {
          string2 = string2.slice(1);
        }
        if (string2[string2.length - 1] === ":") {
          string2 = string2.slice(0, -1);
        }
        parts = function() {
          const ref = string2.split(":");
          const results = [];
          for (let i = 0; i < ref.length; i++) {
            results.push(parseInt(ref[i], 16));
          }
          return results;
        }();
        return {
          parts,
          zoneId
        };
      }
      function matchCIDR(first2, second3, partSize, cidrBits) {
        if (first2.length !== second3.length) {
          throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
        }
        let part = 0;
        let shift;
        while (cidrBits > 0) {
          shift = partSize - cidrBits;
          if (shift < 0) {
            shift = 0;
          }
          if (first2[part] >> shift !== second3[part] >> shift) {
            return false;
          }
          cidrBits -= partSize;
          part += 1;
        }
        return true;
      }
      function parseIntAuto(string2) {
        if (hexRegex.test(string2)) {
          return parseInt(string2, 16);
        }
        if (string2[0] === "0" && !isNaN(parseInt(string2[1], 10))) {
          if (octalRegex.test(string2)) {
            return parseInt(string2, 8);
          }
          throw new Error(`ipaddr: cannot parse ${string2} as octal`);
        }
        return parseInt(string2, 10);
      }
      function padPart(part, length4) {
        while (part.length < length4) {
          part = `0${part}`;
        }
        return part;
      }
      const ipaddr2 = {};
      ipaddr2.IPv4 = function() {
        function IPv4(octets) {
          if (octets.length !== 4) {
            throw new Error("ipaddr: ipv4 octet count should be 4");
          }
          let i, octet;
          for (i = 0; i < octets.length; i++) {
            octet = octets[i];
            if (!(0 <= octet && octet <= 255)) {
              throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
            }
          }
          this.octets = octets;
        }
        IPv4.prototype.SpecialRanges = {
          unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
          broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
          // RFC3171
          multicast: [[new IPv4([224, 0, 0, 0]), 4]],
          // RFC3927
          linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
          // RFC5735
          loopback: [[new IPv4([127, 0, 0, 0]), 8]],
          // RFC6598
          carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
          // RFC1918
          "private": [
            [new IPv4([10, 0, 0, 0]), 8],
            [new IPv4([172, 16, 0, 0]), 12],
            [new IPv4([192, 168, 0, 0]), 16]
          ],
          // Reserved and testing-only ranges; RFCs 5735, 5737, 2544, 1700
          reserved: [
            [new IPv4([192, 0, 0, 0]), 24],
            [new IPv4([192, 0, 2, 0]), 24],
            [new IPv4([192, 88, 99, 0]), 24],
            [new IPv4([198, 18, 0, 0]), 15],
            [new IPv4([198, 51, 100, 0]), 24],
            [new IPv4([203, 0, 113, 0]), 24],
            [new IPv4([240, 0, 0, 0]), 4]
          ]
        };
        IPv4.prototype.kind = function() {
          return "ipv4";
        };
        IPv4.prototype.match = function(other, cidrRange) {
          let ref;
          if (cidrRange === void 0) {
            ref = other;
            other = ref[0];
            cidrRange = ref[1];
          }
          if (other.kind() !== "ipv4") {
            throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
          }
          return matchCIDR(this.octets, other.octets, 8, cidrRange);
        };
        IPv4.prototype.prefixLengthFromSubnetMask = function() {
          let cidr = 0;
          let stop = false;
          const zerotable = {
            0: 8,
            128: 7,
            192: 6,
            224: 5,
            240: 4,
            248: 3,
            252: 2,
            254: 1,
            255: 0
          };
          let i, octet, zeros;
          for (i = 3; i >= 0; i -= 1) {
            octet = this.octets[i];
            if (octet in zerotable) {
              zeros = zerotable[octet];
              if (stop && zeros !== 0) {
                return null;
              }
              if (zeros !== 8) {
                stop = true;
              }
              cidr += zeros;
            } else {
              return null;
            }
          }
          return 32 - cidr;
        };
        IPv4.prototype.range = function() {
          return ipaddr2.subnetMatch(this, this.SpecialRanges);
        };
        IPv4.prototype.toByteArray = function() {
          return this.octets.slice(0);
        };
        IPv4.prototype.toIPv4MappedAddress = function() {
          return ipaddr2.IPv6.parse(`::ffff:${this.toString()}`);
        };
        IPv4.prototype.toNormalizedString = function() {
          return this.toString();
        };
        IPv4.prototype.toString = function() {
          return this.octets.join(".");
        };
        return IPv4;
      }();
      ipaddr2.IPv4.broadcastAddressFromCIDR = function(string2) {
        try {
          const cidr = this.parseCIDR(string2);
          const ipInterfaceOctets = cidr[0].toByteArray();
          const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          const octets = [];
          let i = 0;
          while (i < 4) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
            i++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error("ipaddr: the address does not have IPv4 CIDR format");
        }
      };
      ipaddr2.IPv4.isIPv4 = function(string2) {
        return this.parser(string2) !== null;
      };
      ipaddr2.IPv4.isValid = function(string2) {
        try {
          new this(this.parser(string2));
          return true;
        } catch (e) {
          return false;
        }
      };
      ipaddr2.IPv4.isValidFourPartDecimal = function(string2) {
        if (ipaddr2.IPv4.isValid(string2) && string2.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
          return true;
        } else {
          return false;
        }
      };
      ipaddr2.IPv4.networkAddressFromCIDR = function(string2) {
        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
          cidr = this.parseCIDR(string2);
          ipInterfaceOctets = cidr[0].toByteArray();
          subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          octets = [];
          i = 0;
          while (i < 4) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
            i++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error("ipaddr: the address does not have IPv4 CIDR format");
        }
      };
      ipaddr2.IPv4.parse = function(string2) {
        const parts = this.parser(string2);
        if (parts === null) {
          throw new Error("ipaddr: string is not formatted like an IPv4 Address");
        }
        return new this(parts);
      };
      ipaddr2.IPv4.parseCIDR = function(string2) {
        let match;
        if (match = string2.match(/^(.+)\/(\d+)$/)) {
          const maskLength = parseInt(match[2]);
          if (maskLength >= 0 && maskLength <= 32) {
            const parsed = [this.parse(match[1]), maskLength];
            Object.defineProperty(parsed, "toString", {
              value: function() {
                return this.join("/");
              }
            });
            return parsed;
          }
        }
        throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
      };
      ipaddr2.IPv4.parser = function(string2) {
        let match, part, value;
        if (match = string2.match(ipv4Regexes.fourOctet)) {
          return function() {
            const ref = match.slice(1, 6);
            const results = [];
            for (let i = 0; i < ref.length; i++) {
              part = ref[i];
              results.push(parseIntAuto(part));
            }
            return results;
          }();
        } else if (match = string2.match(ipv4Regexes.longValue)) {
          value = parseIntAuto(match[1]);
          if (value > 4294967295 || value < 0) {
            throw new Error("ipaddr: address outside defined range");
          }
          return function() {
            const results = [];
            let shift;
            for (shift = 0; shift <= 24; shift += 8) {
              results.push(value >> shift & 255);
            }
            return results;
          }().reverse();
        } else if (match = string2.match(ipv4Regexes.twoOctet)) {
          return function() {
            const ref = match.slice(1, 4);
            const results = [];
            value = parseIntAuto(ref[1]);
            if (value > 16777215 || value < 0) {
              throw new Error("ipaddr: address outside defined range");
            }
            results.push(parseIntAuto(ref[0]));
            results.push(value >> 16 & 255);
            results.push(value >> 8 & 255);
            results.push(value & 255);
            return results;
          }();
        } else if (match = string2.match(ipv4Regexes.threeOctet)) {
          return function() {
            const ref = match.slice(1, 5);
            const results = [];
            value = parseIntAuto(ref[2]);
            if (value > 65535 || value < 0) {
              throw new Error("ipaddr: address outside defined range");
            }
            results.push(parseIntAuto(ref[0]));
            results.push(parseIntAuto(ref[1]));
            results.push(value >> 8 & 255);
            results.push(value & 255);
            return results;
          }();
        } else {
          return null;
        }
      };
      ipaddr2.IPv4.subnetMaskFromPrefixLength = function(prefix) {
        prefix = parseInt(prefix);
        if (prefix < 0 || prefix > 32) {
          throw new Error("ipaddr: invalid IPv4 prefix length");
        }
        const octets = [0, 0, 0, 0];
        let j = 0;
        const filledOctetCount = Math.floor(prefix / 8);
        while (j < filledOctetCount) {
          octets[j] = 255;
          j++;
        }
        if (filledOctetCount < 4) {
          octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
        }
        return new this(octets);
      };
      ipaddr2.IPv6 = function() {
        function IPv6(parts, zoneId) {
          let i, part;
          if (parts.length === 16) {
            this.parts = [];
            for (i = 0; i <= 14; i += 2) {
              this.parts.push(parts[i] << 8 | parts[i + 1]);
            }
          } else if (parts.length === 8) {
            this.parts = parts;
          } else {
            throw new Error("ipaddr: ipv6 part count should be 8 or 16");
          }
          for (i = 0; i < this.parts.length; i++) {
            part = this.parts[i];
            if (!(0 <= part && part <= 65535)) {
              throw new Error("ipaddr: ipv6 part should fit in 16 bits");
            }
          }
          if (zoneId) {
            this.zoneId = zoneId;
          }
        }
        IPv6.prototype.SpecialRanges = {
          // RFC4291, here and after
          unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
          linkLocal: [new IPv6([65152, 0, 0, 0, 0, 0, 0, 0]), 10],
          multicast: [new IPv6([65280, 0, 0, 0, 0, 0, 0, 0]), 8],
          loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
          uniqueLocal: [new IPv6([64512, 0, 0, 0, 0, 0, 0, 0]), 7],
          ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 65535, 0, 0]), 96],
          // RFC6145
          rfc6145: [new IPv6([0, 0, 0, 0, 65535, 0, 0, 0]), 96],
          // RFC6052
          rfc6052: [new IPv6([100, 65435, 0, 0, 0, 0, 0, 0]), 96],
          // RFC3056
          "6to4": [new IPv6([8194, 0, 0, 0, 0, 0, 0, 0]), 16],
          // RFC6052, RFC6146
          teredo: [new IPv6([8193, 0, 0, 0, 0, 0, 0, 0]), 32],
          // RFC4291
          reserved: [[new IPv6([8193, 3512, 0, 0, 0, 0, 0, 0]), 32]],
          benchmarking: [new IPv6([8193, 2, 0, 0, 0, 0, 0, 0]), 48],
          amt: [new IPv6([8193, 3, 0, 0, 0, 0, 0, 0]), 32],
          as112v6: [new IPv6([8193, 4, 274, 0, 0, 0, 0, 0]), 48],
          deprecated: [new IPv6([8193, 16, 0, 0, 0, 0, 0, 0]), 28],
          orchid2: [new IPv6([8193, 32, 0, 0, 0, 0, 0, 0]), 28]
        };
        IPv6.prototype.isIPv4MappedAddress = function() {
          return this.range() === "ipv4Mapped";
        };
        IPv6.prototype.kind = function() {
          return "ipv6";
        };
        IPv6.prototype.match = function(other, cidrRange) {
          let ref;
          if (cidrRange === void 0) {
            ref = other;
            other = ref[0];
            cidrRange = ref[1];
          }
          if (other.kind() !== "ipv6") {
            throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
          }
          return matchCIDR(this.parts, other.parts, 16, cidrRange);
        };
        IPv6.prototype.prefixLengthFromSubnetMask = function() {
          let cidr = 0;
          let stop = false;
          const zerotable = {
            0: 16,
            32768: 15,
            49152: 14,
            57344: 13,
            61440: 12,
            63488: 11,
            64512: 10,
            65024: 9,
            65280: 8,
            65408: 7,
            65472: 6,
            65504: 5,
            65520: 4,
            65528: 3,
            65532: 2,
            65534: 1,
            65535: 0
          };
          let part, zeros;
          for (let i = 7; i >= 0; i -= 1) {
            part = this.parts[i];
            if (part in zerotable) {
              zeros = zerotable[part];
              if (stop && zeros !== 0) {
                return null;
              }
              if (zeros !== 16) {
                stop = true;
              }
              cidr += zeros;
            } else {
              return null;
            }
          }
          return 128 - cidr;
        };
        IPv6.prototype.range = function() {
          return ipaddr2.subnetMatch(this, this.SpecialRanges);
        };
        IPv6.prototype.toByteArray = function() {
          let part;
          const bytes2 = [];
          const ref = this.parts;
          for (let i = 0; i < ref.length; i++) {
            part = ref[i];
            bytes2.push(part >> 8);
            bytes2.push(part & 255);
          }
          return bytes2;
        };
        IPv6.prototype.toFixedLengthString = function() {
          const addr = (function() {
            const results = [];
            for (let i = 0; i < this.parts.length; i++) {
              results.push(padPart(this.parts[i].toString(16), 4));
            }
            return results;
          }).call(this).join(":");
          let suffix = "";
          if (this.zoneId) {
            suffix = `%${this.zoneId}`;
          }
          return addr + suffix;
        };
        IPv6.prototype.toIPv4Address = function() {
          if (!this.isIPv4MappedAddress()) {
            throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
          }
          const ref = this.parts.slice(-2);
          const high = ref[0];
          const low = ref[1];
          return new ipaddr2.IPv4([high >> 8, high & 255, low >> 8, low & 255]);
        };
        IPv6.prototype.toNormalizedString = function() {
          const addr = (function() {
            const results = [];
            for (let i = 0; i < this.parts.length; i++) {
              results.push(this.parts[i].toString(16));
            }
            return results;
          }).call(this).join(":");
          let suffix = "";
          if (this.zoneId) {
            suffix = `%${this.zoneId}`;
          }
          return addr + suffix;
        };
        IPv6.prototype.toRFC5952String = function() {
          const regex = /((^|:)(0(:|$)){2,})/g;
          const string2 = this.toNormalizedString();
          let bestMatchIndex = 0;
          let bestMatchLength = -1;
          let match;
          while (match = regex.exec(string2)) {
            if (match[0].length > bestMatchLength) {
              bestMatchIndex = match.index;
              bestMatchLength = match[0].length;
            }
          }
          if (bestMatchLength < 0) {
            return string2;
          }
          return `${string2.substring(0, bestMatchIndex)}::${string2.substring(bestMatchIndex + bestMatchLength)}`;
        };
        IPv6.prototype.toString = function() {
          return this.toRFC5952String();
        };
        return IPv6;
      }();
      ipaddr2.IPv6.broadcastAddressFromCIDR = function(string2) {
        try {
          const cidr = this.parseCIDR(string2);
          const ipInterfaceOctets = cidr[0].toByteArray();
          const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          const octets = [];
          let i = 0;
          while (i < 16) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
            i++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);
        }
      };
      ipaddr2.IPv6.isIPv6 = function(string2) {
        return this.parser(string2) !== null;
      };
      ipaddr2.IPv6.isValid = function(string2) {
        if (typeof string2 === "string" && string2.indexOf(":") === -1) {
          return false;
        }
        try {
          const addr = this.parser(string2);
          new this(addr.parts, addr.zoneId);
          return true;
        } catch (e) {
          return false;
        }
      };
      ipaddr2.IPv6.networkAddressFromCIDR = function(string2) {
        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
          cidr = this.parseCIDR(string2);
          ipInterfaceOctets = cidr[0].toByteArray();
          subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          octets = [];
          i = 0;
          while (i < 16) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
            i++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);
        }
      };
      ipaddr2.IPv6.parse = function(string2) {
        const addr = this.parser(string2);
        if (addr.parts === null) {
          throw new Error("ipaddr: string is not formatted like an IPv6 Address");
        }
        return new this(addr.parts, addr.zoneId);
      };
      ipaddr2.IPv6.parseCIDR = function(string2) {
        let maskLength, match, parsed;
        if (match = string2.match(/^(.+)\/(\d+)$/)) {
          maskLength = parseInt(match[2]);
          if (maskLength >= 0 && maskLength <= 128) {
            parsed = [this.parse(match[1]), maskLength];
            Object.defineProperty(parsed, "toString", {
              value: function() {
                return this.join("/");
              }
            });
            return parsed;
          }
        }
        throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
      };
      ipaddr2.IPv6.parser = function(string2) {
        let addr, i, match, octet, octets, zoneId;
        if (match = string2.match(ipv6Regexes.deprecatedTransitional)) {
          return this.parser(`::ffff:${match[1]}`);
        }
        if (ipv6Regexes.native.test(string2)) {
          return expandIPv6(string2, 8);
        }
        if (match = string2.match(ipv6Regexes.transitional)) {
          zoneId = match[6] || "";
          addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);
          if (addr.parts) {
            octets = [
              parseInt(match[2]),
              parseInt(match[3]),
              parseInt(match[4]),
              parseInt(match[5])
            ];
            for (i = 0; i < octets.length; i++) {
              octet = octets[i];
              if (!(0 <= octet && octet <= 255)) {
                return null;
              }
            }
            addr.parts.push(octets[0] << 8 | octets[1]);
            addr.parts.push(octets[2] << 8 | octets[3]);
            return {
              parts: addr.parts,
              zoneId: addr.zoneId
            };
          }
        }
        return null;
      };
      ipaddr2.IPv6.subnetMaskFromPrefixLength = function(prefix) {
        prefix = parseInt(prefix);
        if (prefix < 0 || prefix > 128) {
          throw new Error("ipaddr: invalid IPv6 prefix length");
        }
        const octets = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        let j = 0;
        const filledOctetCount = Math.floor(prefix / 8);
        while (j < filledOctetCount) {
          octets[j] = 255;
          j++;
        }
        if (filledOctetCount < 16) {
          octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
        }
        return new this(octets);
      };
      ipaddr2.fromByteArray = function(bytes2) {
        const length4 = bytes2.length;
        if (length4 === 4) {
          return new ipaddr2.IPv4(bytes2);
        } else if (length4 === 16) {
          return new ipaddr2.IPv6(bytes2);
        } else {
          throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
        }
      };
      ipaddr2.isValid = function(string2) {
        return ipaddr2.IPv6.isValid(string2) || ipaddr2.IPv4.isValid(string2);
      };
      ipaddr2.parse = function(string2) {
        if (ipaddr2.IPv6.isValid(string2)) {
          return ipaddr2.IPv6.parse(string2);
        } else if (ipaddr2.IPv4.isValid(string2)) {
          return ipaddr2.IPv4.parse(string2);
        } else {
          throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
        }
      };
      ipaddr2.parseCIDR = function(string2) {
        try {
          return ipaddr2.IPv6.parseCIDR(string2);
        } catch (e) {
          try {
            return ipaddr2.IPv4.parseCIDR(string2);
          } catch (e2) {
            throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
          }
        }
      };
      ipaddr2.process = function(string2) {
        const addr = this.parse(string2);
        if (addr.kind() === "ipv6" && addr.isIPv4MappedAddress()) {
          return addr.toIPv4Address();
        } else {
          return addr;
        }
      };
      ipaddr2.subnetMatch = function(address, rangeList, defaultName) {
        let i, rangeName, rangeSubnets, subnet;
        if (defaultName === void 0 || defaultName === null) {
          defaultName = "unicast";
        }
        for (rangeName in rangeList) {
          if (Object.prototype.hasOwnProperty.call(rangeList, rangeName)) {
            rangeSubnets = rangeList[rangeName];
            if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
              rangeSubnets = [rangeSubnets];
            }
            for (i = 0; i < rangeSubnets.length; i++) {
              subnet = rangeSubnets[i];
              if (address.kind() === subnet[0].kind() && address.match.apply(address, subnet)) {
                return rangeName;
              }
            }
          }
        }
        return defaultName;
      };
      if (typeof module !== "undefined" && module.exports) {
        module.exports = ipaddr2;
      } else {
        root.ipaddr = ipaddr2;
      }
    })(exports);
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse3(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse3(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name2) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name2 + (isPlural ? "s" : "");
    }
  }
});

// node_modules/receptacle/index.js
var require_receptacle = __commonJS({
  "node_modules/receptacle/index.js"(exports, module) {
    "use strict";
    module.exports = Receptacle2;
    var toMS = require_ms();
    var cache = Receptacle2.prototype;
    var counter = /* @__PURE__ */ new Date() % 1e9;
    function getUID() {
      return (Math.random() * 1e9 >>> 0) + counter++;
    }
    function Receptacle2(options) {
      options = options || {};
      this.id = options.id || getUID();
      this.max = options.max || Infinity;
      this.items = options.items || [];
      this._lookup = {};
      this.size = this.items.length;
      this.lastModified = new Date(options.lastModified || /* @__PURE__ */ new Date());
      for (var item, ttl, i = this.items.length; i--; ) {
        item = this.items[i];
        ttl = new Date(item.expires) - /* @__PURE__ */ new Date();
        this._lookup[item.key] = item;
        if (ttl > 0)
          this.expire(item.key, ttl);
        else if (ttl <= 0)
          this.delete(item.key);
      }
    }
    cache.has = function(key) {
      return key in this._lookup;
    };
    cache.get = function(key) {
      if (!this.has(key))
        return null;
      var record = this._lookup[key];
      if (record.refresh)
        this.expire(key, record.refresh);
      this.items.splice(this.items.indexOf(record), 1);
      this.items.push(record);
      return record.value;
    };
    cache.meta = function(key) {
      if (!this.has(key))
        return null;
      var record = this._lookup[key];
      if (!("meta" in record))
        return null;
      return record.meta;
    };
    cache.set = function(key, value, options) {
      var oldRecord = this._lookup[key];
      var record = this._lookup[key] = { key, value };
      this.lastModified = /* @__PURE__ */ new Date();
      if (oldRecord) {
        clearTimeout(oldRecord.timeout);
        this.items.splice(this.items.indexOf(oldRecord), 1, record);
      } else {
        if (this.size >= this.max)
          this.delete(this.items[0].key);
        this.items.push(record);
        this.size++;
      }
      if (options) {
        if ("ttl" in options)
          this.expire(key, options.ttl);
        if ("meta" in options)
          record.meta = options.meta;
        if (options.refresh)
          record.refresh = options.ttl;
      }
      return this;
    };
    cache.delete = function(key) {
      var record = this._lookup[key];
      if (!record)
        return false;
      this.lastModified = /* @__PURE__ */ new Date();
      this.items.splice(this.items.indexOf(record), 1);
      clearTimeout(record.timeout);
      delete this._lookup[key];
      this.size--;
      return this;
    };
    cache.expire = function(key, ttl) {
      var ms = ttl || 0;
      var record = this._lookup[key];
      if (!record)
        return this;
      if (typeof ms === "string")
        ms = toMS(ttl);
      if (typeof ms !== "number")
        throw new TypeError("Expiration time must be a string or number.");
      clearTimeout(record.timeout);
      record.timeout = setTimeout(this.delete.bind(this, record.key), ms);
      record.expires = Number(/* @__PURE__ */ new Date()) + ms;
      return this;
    };
    cache.clear = function() {
      for (var i = this.items.length; i--; )
        this.delete(this.items[i].key);
      return this;
    };
    cache.toJSON = function() {
      var items = new Array(this.items.length);
      var item;
      for (var i = items.length; i--; ) {
        item = this.items[i];
        items[i] = {
          key: item.key,
          meta: item.meta,
          value: item.value,
          expires: item.expires,
          refresh: item.refresh
        };
      }
      return {
        id: this.id,
        max: isFinite(this.max) ? this.max : void 0,
        lastModified: this.lastModified,
        items
      };
    };
  }
});

// node_modules/@waku/core/dist/index.js
var dist_exports2 = {};
__export(dist_exports2, {
  ConnectionManager: () => ConnectionManager,
  DefaultPubSubTopic: () => DefaultPubSubTopic,
  DefaultUserAgent: () => DefaultUserAgent,
  FilterCodecs: () => FilterCodecs,
  KeepAliveManager: () => KeepAliveManager,
  PageDirection: () => PageDirection2,
  StreamManager: () => StreamManager,
  WakuNode: () => WakuNode,
  createCursor: () => createCursor,
  createDecoder: () => createDecoder,
  createEncoder: () => createEncoder,
  message: () => message_exports2,
  waitForRemotePeer: () => waitForRemotePeer,
  waku: () => waku_exports,
  wakuFilter: () => wakuFilter,
  wakuLightPush: () => wakuLightPush,
  wakuStore: () => wakuStore,
  waku_filter: () => filter_exports2,
  waku_light_push: () => light_push_exports2,
  waku_store: () => store_exports2
});

// node_modules/@waku/core/dist/lib/waku.js
var waku_exports = {};
__export(waku_exports, {
  DefaultPingKeepAliveValueSecs: () => DefaultPingKeepAliveValueSecs,
  DefaultRelayKeepAliveValueSecs: () => DefaultRelayKeepAliveValueSecs,
  DefaultUserAgent: () => DefaultUserAgent,
  WakuNode: () => WakuNode
});

// node_modules/@waku/interfaces/dist/protocols.js
var Protocols;
(function(Protocols2) {
  Protocols2["Relay"] = "relay";
  Protocols2["Store"] = "store";
  Protocols2["LightPush"] = "lightpush";
  Protocols2["Filter"] = "filter";
})(Protocols || (Protocols = {}));
var SendError;
(function(SendError2) {
  SendError2["GENERIC_FAIL"] = "Generic error";
  SendError2["ENCODE_FAILED"] = "Failed to encode";
  SendError2["DECODE_FAILED"] = "Failed to decode";
  SendError2["EMPTY_PAYLOAD"] = "Payload is empty";
  SendError2["SIZE_TOO_BIG"] = "Size is too big";
  SendError2["TOPIC_NOT_CONFIGURED"] = "Topic not configured";
  SendError2["NO_PEER_AVAILABLE"] = "No peer available";
  SendError2["REMOTE_PEER_FAULT"] = "Remote peer fault";
  SendError2["REMOTE_PEER_REJECTED"] = "Remote peer rejected";
})(SendError || (SendError = {}));

// node_modules/@waku/interfaces/dist/store.js
var PageDirection;
(function(PageDirection3) {
  PageDirection3["BACKWARD"] = "backward";
  PageDirection3["FORWARD"] = "forward";
})(PageDirection || (PageDirection = {}));

// node_modules/@waku/interfaces/dist/connection_manager.js
var Tags;
(function(Tags2) {
  Tags2["BOOTSTRAP"] = "bootstrap";
  Tags2["PEER_EXCHANGE"] = "peer-exchange";
})(Tags || (Tags = {}));
var EPeersByDiscoveryEvents;
(function(EPeersByDiscoveryEvents2) {
  EPeersByDiscoveryEvents2["PEER_DISCOVERY_BOOTSTRAP"] = "peer:discovery:bootstrap";
  EPeersByDiscoveryEvents2["PEER_DISCOVERY_PEER_EXCHANGE"] = "peer:discovery:peer-exchange";
  EPeersByDiscoveryEvents2["PEER_CONNECT_BOOTSTRAP"] = "peer:connected:bootstrap";
  EPeersByDiscoveryEvents2["PEER_CONNECT_PEER_EXCHANGE"] = "peer:connected:peer-exchange";
})(EPeersByDiscoveryEvents || (EPeersByDiscoveryEvents = {}));

// node_modules/@libp2p/interfaces/dist/src/events.js
var _listeners;
var EventEmitter = class extends EventTarget {
  constructor() {
    super(...arguments);
    __privateAdd(this, _listeners, /* @__PURE__ */ new Map());
  }
  listenerCount(type) {
    const listeners = __privateGet(this, _listeners).get(type);
    if (listeners == null) {
      return 0;
    }
    return listeners.length;
  }
  addEventListener(type, listener, options) {
    super.addEventListener(type, listener, options);
    let list = __privateGet(this, _listeners).get(type);
    if (list == null) {
      list = [];
      __privateGet(this, _listeners).set(type, list);
    }
    list.push({
      callback: listener,
      once: (options !== true && options !== false && (options == null ? void 0 : options.once)) ?? false
    });
  }
  removeEventListener(type, listener, options) {
    super.removeEventListener(type.toString(), listener ?? null, options);
    let list = __privateGet(this, _listeners).get(type);
    if (list == null) {
      return;
    }
    list = list.filter(({ callback }) => callback !== listener);
    __privateGet(this, _listeners).set(type, list);
  }
  dispatchEvent(event) {
    const result = super.dispatchEvent(event);
    let list = __privateGet(this, _listeners).get(event.type);
    if (list == null) {
      return result;
    }
    list = list.filter(({ once }) => !once);
    __privateGet(this, _listeners).set(event.type, list);
    return result;
  }
  safeDispatchEvent(type, detail) {
    return this.dispatchEvent(new CustomEvent2(type, detail));
  }
};
_listeners = new WeakMap();
var CustomEventPolyfill = class extends Event {
  constructor(message2, data) {
    super(message2, data);
    /** Returns any custom data event was created with. Typically used for synthetic events. */
    __publicField(this, "detail");
    this.detail = data == null ? void 0 : data.detail;
  }
};
var CustomEvent2 = globalThis.CustomEvent ?? CustomEventPolyfill;

// node_modules/@waku/core/dist/lib/message/version_0.js
var version_0_exports = {};
__export(version_0_exports, {
  DecodedMessage: () => DecodedMessage,
  Decoder: () => Decoder,
  Encoder: () => Encoder,
  Version: () => Version,
  createDecoder: () => createDecoder,
  createEncoder: () => createEncoder,
  proto: () => message_exports
});

// node_modules/@waku/proto/dist/lib/message.js
var message_exports = {};
__export(message_exports, {
  RateLimitProof: () => RateLimitProof,
  WakuMessage: () => WakuMessage
});
var RateLimitProof;
(function(RateLimitProof6) {
  let _codec;
  RateLimitProof6.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.proof != null && obj.proof.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.proof);
        }
        if (obj.merkleRoot != null && obj.merkleRoot.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.merkleRoot);
        }
        if (obj.epoch != null && obj.epoch.byteLength > 0) {
          w.uint32(26);
          w.bytes(obj.epoch);
        }
        if (obj.shareX != null && obj.shareX.byteLength > 0) {
          w.uint32(34);
          w.bytes(obj.shareX);
        }
        if (obj.shareY != null && obj.shareY.byteLength > 0) {
          w.uint32(42);
          w.bytes(obj.shareY);
        }
        if (obj.nullifier != null && obj.nullifier.byteLength > 0) {
          w.uint32(50);
          w.bytes(obj.nullifier);
        }
        if (obj.rlnIdentifier != null && obj.rlnIdentifier.byteLength > 0) {
          w.uint32(58);
          w.bytes(obj.rlnIdentifier);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length4) => {
        const obj = {
          proof: new Uint8Array(0),
          merkleRoot: new Uint8Array(0),
          epoch: new Uint8Array(0),
          shareX: new Uint8Array(0),
          shareY: new Uint8Array(0),
          nullifier: new Uint8Array(0),
          rlnIdentifier: new Uint8Array(0)
        };
        const end = length4 == null ? reader2.len : reader2.pos + length4;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.proof = reader2.bytes();
              break;
            case 2:
              obj.merkleRoot = reader2.bytes();
              break;
            case 3:
              obj.epoch = reader2.bytes();
              break;
            case 4:
              obj.shareX = reader2.bytes();
              break;
            case 5:
              obj.shareY = reader2.bytes();
              break;
            case 6:
              obj.nullifier = reader2.bytes();
              break;
            case 7:
              obj.rlnIdentifier = reader2.bytes();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  RateLimitProof6.encode = (obj) => {
    return encodeMessage(obj, RateLimitProof6.codec());
  };
  RateLimitProof6.decode = (buf) => {
    return decodeMessage(buf, RateLimitProof6.codec());
  };
})(RateLimitProof || (RateLimitProof = {}));
var WakuMessage;
(function(WakuMessage6) {
  let _codec;
  WakuMessage6.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.payload != null && obj.payload.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.payload);
        }
        if (obj.contentTopic != null && obj.contentTopic !== "") {
          w.uint32(18);
          w.string(obj.contentTopic);
        }
        if (obj.version != null) {
          w.uint32(24);
          w.uint32(obj.version);
        }
        if (obj.timestamp != null) {
          w.uint32(80);
          w.sint64(obj.timestamp);
        }
        if (obj.meta != null) {
          w.uint32(90);
          w.bytes(obj.meta);
        }
        if (obj.rateLimitProof != null) {
          w.uint32(170);
          RateLimitProof.codec().encode(obj.rateLimitProof, w);
        }
        if (obj.ephemeral != null) {
          w.uint32(248);
          w.bool(obj.ephemeral);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length4) => {
        const obj = {
          payload: new Uint8Array(0),
          contentTopic: ""
        };
        const end = length4 == null ? reader2.len : reader2.pos + length4;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.payload = reader2.bytes();
              break;
            case 2:
              obj.contentTopic = reader2.string();
              break;
            case 3:
              obj.version = reader2.uint32();
              break;
            case 10:
              obj.timestamp = reader2.sint64();
              break;
            case 11:
              obj.meta = reader2.bytes();
              break;
            case 21:
              obj.rateLimitProof = RateLimitProof.codec().decode(reader2, reader2.uint32());
              break;
            case 31:
              obj.ephemeral = reader2.bool();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  WakuMessage6.encode = (obj) => {
    return encodeMessage(obj, WakuMessage6.codec());
  };
  WakuMessage6.decode = (buf) => {
    return decodeMessage(buf, WakuMessage6.codec());
  };
})(WakuMessage || (WakuMessage = {}));

// node_modules/@waku/proto/dist/lib/filter.js
var filter_exports = {};
__export(filter_exports, {
  FilterRequest: () => FilterRequest,
  FilterRpc: () => FilterRpc,
  MessagePush: () => MessagePush,
  RateLimitProof: () => RateLimitProof2,
  WakuMessage: () => WakuMessage2
});
var FilterRequest;
(function(FilterRequest2) {
  let ContentFilter2;
  (function(ContentFilter3) {
    let _codec2;
    ContentFilter3.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.contentTopic != null && obj.contentTopic !== "") {
            w.uint32(10);
            w.string(obj.contentTopic);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length4) => {
          const obj = {
            contentTopic: ""
          };
          const end = length4 == null ? reader2.len : reader2.pos + length4;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.contentTopic = reader2.string();
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    ContentFilter3.encode = (obj) => {
      return encodeMessage(obj, ContentFilter3.codec());
    };
    ContentFilter3.decode = (buf) => {
      return decodeMessage(buf, ContentFilter3.codec());
    };
  })(ContentFilter2 = FilterRequest2.ContentFilter || (FilterRequest2.ContentFilter = {}));
  let _codec;
  FilterRequest2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.subscribe != null && obj.subscribe !== false) {
          w.uint32(8);
          w.bool(obj.subscribe);
        }
        if (obj.topic != null && obj.topic !== "") {
          w.uint32(18);
          w.string(obj.topic);
        }
        if (obj.contentFilters != null) {
          for (const value of obj.contentFilters) {
            w.uint32(26);
            FilterRequest2.ContentFilter.codec().encode(value, w);
          }
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length4) => {
        const obj = {
          subscribe: false,
          topic: "",
          contentFilters: []
        };
        const end = length4 == null ? reader2.len : reader2.pos + length4;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.subscribe = reader2.bool();
              break;
            case 2:
              obj.topic = reader2.string();
              break;
            case 3:
              obj.contentFilters.push(FilterRequest2.ContentFilter.codec().decode(reader2, reader2.uint32()));
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  FilterRequest2.encode = (obj) => {
    return encodeMessage(obj, FilterRequest2.codec());
  };
  FilterRequest2.decode = (buf) => {
    return decodeMessage(buf, FilterRequest2.codec());
  };
})(FilterRequest || (FilterRequest = {}));
var MessagePush;
(function(MessagePush3) {
  let _codec;
  MessagePush3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.messages != null) {
          for (const value of obj.messages) {
            w.uint32(10);
            WakuMessage2.codec().encode(value, w);
          }
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length4) => {
        const obj = {
          messages: []
        };
        const end = length4 == null ? reader2.len : reader2.pos + length4;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.messages.push(WakuMessage2.codec().decode(reader2, reader2.uint32()));
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  MessagePush3.encode = (obj) => {
    return encodeMessage(obj, MessagePush3.codec());
  };
  MessagePush3.decode = (buf) => {
    return decodeMessage(buf, MessagePush3.codec());
  };
})(MessagePush || (MessagePush = {}));
var FilterRpc;
(function(FilterRpc2) {
  let _codec;
  FilterRpc2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.requestId != null && obj.requestId !== "") {
          w.uint32(10);
          w.string(obj.requestId);
        }
        if (obj.request != null) {
          w.uint32(18);
          FilterRequest.codec().encode(obj.request, w);
        }
        if (obj.push != null) {
          w.uint32(26);
          MessagePush.codec().encode(obj.push, w);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length4) => {
        const obj = {
          requestId: ""
        };
        const end = length4 == null ? reader2.len : reader2.pos + length4;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.requestId = reader2.string();
              break;
            case 2:
              obj.request = FilterRequest.codec().decode(reader2, reader2.uint32());
              break;
            case 3:
              obj.push = MessagePush.codec().decode(reader2, reader2.uint32());
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  FilterRpc2.encode = (obj) => {
    return encodeMessage(obj, FilterRpc2.codec());
  };
  FilterRpc2.decode = (buf) => {
    return decodeMessage(buf, FilterRpc2.codec());
  };
})(FilterRpc || (FilterRpc = {}));
var RateLimitProof2;
(function(RateLimitProof6) {
  let _codec;
  RateLimitProof6.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.proof != null && obj.proof.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.proof);
        }
        if (obj.merkleRoot != null && obj.merkleRoot.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.merkleRoot);
        }
        if (obj.epoch != null && obj.epoch.byteLength > 0) {
          w.uint32(26);
          w.bytes(obj.epoch);
        }
        if (obj.shareX != null && obj.shareX.byteLength > 0) {
          w.uint32(34);
          w.bytes(obj.shareX);
        }
        if (obj.shareY != null && obj.shareY.byteLength > 0) {
          w.uint32(42);
          w.bytes(obj.shareY);
        }
        if (obj.nullifier != null && obj.nullifier.byteLength > 0) {
          w.uint32(50);
          w.bytes(obj.nullifier);
        }
        if (obj.rlnIdentifier != null && obj.rlnIdentifier.byteLength > 0) {
          w.uint32(58);
          w.bytes(obj.rlnIdentifier);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length4) => {
        const obj = {
          proof: new Uint8Array(0),
          merkleRoot: new Uint8Array(0),
          epoch: new Uint8Array(0),
          shareX: new Uint8Array(0),
          shareY: new Uint8Array(0),
          nullifier: new Uint8Array(0),
          rlnIdentifier: new Uint8Array(0)
        };
        const end = length4 == null ? reader2.len : reader2.pos + length4;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.proof = reader2.bytes();
              break;
            case 2:
              obj.merkleRoot = reader2.bytes();
              break;
            case 3:
              obj.epoch = reader2.bytes();
              break;
            case 4:
              obj.shareX = reader2.bytes();
              break;
            case 5:
              obj.shareY = reader2.bytes();
              break;
            case 6:
              obj.nullifier = reader2.bytes();
              break;
            case 7:
              obj.rlnIdentifier = reader2.bytes();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  RateLimitProof6.encode = (obj) => {
    return encodeMessage(obj, RateLimitProof6.codec());
  };
  RateLimitProof6.decode = (buf) => {
    return decodeMessage(buf, RateLimitProof6.codec());
  };
})(RateLimitProof2 || (RateLimitProof2 = {}));
var WakuMessage2;
(function(WakuMessage6) {
  let _codec;
  WakuMessage6.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.payload != null && obj.payload.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.payload);
        }
        if (obj.contentTopic != null && obj.contentTopic !== "") {
          w.uint32(18);
          w.string(obj.contentTopic);
        }
        if (obj.version != null) {
          w.uint32(24);
          w.uint32(obj.version);
        }
        if (obj.timestamp != null) {
          w.uint32(80);
          w.sint64(obj.timestamp);
        }
        if (obj.meta != null) {
          w.uint32(90);
          w.bytes(obj.meta);
        }
        if (obj.rateLimitProof != null) {
          w.uint32(170);
          RateLimitProof2.codec().encode(obj.rateLimitProof, w);
        }
        if (obj.ephemeral != null) {
          w.uint32(248);
          w.bool(obj.ephemeral);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length4) => {
        const obj = {
          payload: new Uint8Array(0),
          contentTopic: ""
        };
        const end = length4 == null ? reader2.len : reader2.pos + length4;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.payload = reader2.bytes();
              break;
            case 2:
              obj.contentTopic = reader2.string();
              break;
            case 3:
              obj.version = reader2.uint32();
              break;
            case 10:
              obj.timestamp = reader2.sint64();
              break;
            case 11:
              obj.meta = reader2.bytes();
              break;
            case 21:
              obj.rateLimitProof = RateLimitProof2.codec().decode(reader2, reader2.uint32());
              break;
            case 31:
              obj.ephemeral = reader2.bool();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  WakuMessage6.encode = (obj) => {
    return encodeMessage(obj, WakuMessage6.codec());
  };
  WakuMessage6.decode = (buf) => {
    return decodeMessage(buf, WakuMessage6.codec());
  };
})(WakuMessage2 || (WakuMessage2 = {}));

// node_modules/@waku/proto/dist/lib/topic_only_message.js
var topic_only_message_exports = {};
__export(topic_only_message_exports, {
  TopicOnlyMessage: () => TopicOnlyMessage
});
var TopicOnlyMessage;
(function(TopicOnlyMessage3) {
  let _codec;
  TopicOnlyMessage3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.contentTopic != null && obj.contentTopic !== "") {
          w.uint32(18);
          w.string(obj.contentTopic);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length4) => {
        const obj = {
          contentTopic: ""
        };
        const end = length4 == null ? reader2.len : reader2.pos + length4;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 2:
              obj.contentTopic = reader2.string();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  TopicOnlyMessage3.encode = (obj) => {
    return encodeMessage(obj, TopicOnlyMessage3.codec());
  };
  TopicOnlyMessage3.decode = (buf) => {
    return decodeMessage(buf, TopicOnlyMessage3.codec());
  };
})(TopicOnlyMessage || (TopicOnlyMessage = {}));

// node_modules/@waku/proto/dist/lib/filter_v2.js
var filter_v2_exports = {};
__export(filter_v2_exports, {
  FilterSubscribeRequest: () => FilterSubscribeRequest,
  FilterSubscribeResponse: () => FilterSubscribeResponse,
  MessagePush: () => MessagePush2,
  RateLimitProof: () => RateLimitProof3,
  WakuMessage: () => WakuMessage3
});
var FilterSubscribeRequest;
(function(FilterSubscribeRequest2) {
  let FilterSubscribeType;
  (function(FilterSubscribeType2) {
    FilterSubscribeType2["SUBSCRIBER_PING"] = "SUBSCRIBER_PING";
    FilterSubscribeType2["SUBSCRIBE"] = "SUBSCRIBE";
    FilterSubscribeType2["UNSUBSCRIBE"] = "UNSUBSCRIBE";
    FilterSubscribeType2["UNSUBSCRIBE_ALL"] = "UNSUBSCRIBE_ALL";
  })(FilterSubscribeType = FilterSubscribeRequest2.FilterSubscribeType || (FilterSubscribeRequest2.FilterSubscribeType = {}));
  let __FilterSubscribeTypeValues;
  (function(__FilterSubscribeTypeValues2) {
    __FilterSubscribeTypeValues2[__FilterSubscribeTypeValues2["SUBSCRIBER_PING"] = 0] = "SUBSCRIBER_PING";
    __FilterSubscribeTypeValues2[__FilterSubscribeTypeValues2["SUBSCRIBE"] = 1] = "SUBSCRIBE";
    __FilterSubscribeTypeValues2[__FilterSubscribeTypeValues2["UNSUBSCRIBE"] = 2] = "UNSUBSCRIBE";
    __FilterSubscribeTypeValues2[__FilterSubscribeTypeValues2["UNSUBSCRIBE_ALL"] = 3] = "UNSUBSCRIBE_ALL";
  })(__FilterSubscribeTypeValues || (__FilterSubscribeTypeValues = {}));
  (function(FilterSubscribeType2) {
    FilterSubscribeType2.codec = () => {
      return enumeration(__FilterSubscribeTypeValues);
    };
  })(FilterSubscribeType = FilterSubscribeRequest2.FilterSubscribeType || (FilterSubscribeRequest2.FilterSubscribeType = {}));
  let _codec;
  FilterSubscribeRequest2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.requestId != null && obj.requestId !== "") {
          w.uint32(10);
          w.string(obj.requestId);
        }
        if (obj.filterSubscribeType != null && __FilterSubscribeTypeValues[obj.filterSubscribeType] !== 0) {
          w.uint32(16);
          FilterSubscribeRequest2.FilterSubscribeType.codec().encode(obj.filterSubscribeType, w);
        }
        if (obj.pubsubTopic != null) {
          w.uint32(82);
          w.string(obj.pubsubTopic);
        }
        if (obj.contentTopics != null) {
          for (const value of obj.contentTopics) {
            w.uint32(90);
            w.string(value);
          }
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length4) => {
        const obj = {
          requestId: "",
          filterSubscribeType: FilterSubscribeType.SUBSCRIBER_PING,
          contentTopics: []
        };
        const end = length4 == null ? reader2.len : reader2.pos + length4;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.requestId = reader2.string();
              break;
            case 2:
              obj.filterSubscribeType = FilterSubscribeRequest2.FilterSubscribeType.codec().decode(reader2);
              break;
            case 10:
              obj.pubsubTopic = reader2.string();
              break;
            case 11:
              obj.contentTopics.push(reader2.string());
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  FilterSubscribeRequest2.encode = (obj) => {
    return encodeMessage(obj, FilterSubscribeRequest2.codec());
  };
  FilterSubscribeRequest2.decode = (buf) => {
    return decodeMessage(buf, FilterSubscribeRequest2.codec());
  };
})(FilterSubscribeRequest || (FilterSubscribeRequest = {}));
var FilterSubscribeResponse;
(function(FilterSubscribeResponse3) {
  let _codec;
  FilterSubscribeResponse3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.requestId != null && obj.requestId !== "") {
          w.uint32(10);
          w.string(obj.requestId);
        }
        if (obj.statusCode != null && obj.statusCode !== 0) {
          w.uint32(80);
          w.uint32(obj.statusCode);
        }
        if (obj.statusDesc != null) {
          w.uint32(90);
          w.string(obj.statusDesc);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length4) => {
        const obj = {
          requestId: "",
          statusCode: 0
        };
        const end = length4 == null ? reader2.len : reader2.pos + length4;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.requestId = reader2.string();
              break;
            case 10:
              obj.statusCode = reader2.uint32();
              break;
            case 11:
              obj.statusDesc = reader2.string();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  FilterSubscribeResponse3.encode = (obj) => {
    return encodeMessage(obj, FilterSubscribeResponse3.codec());
  };
  FilterSubscribeResponse3.decode = (buf) => {
    return decodeMessage(buf, FilterSubscribeResponse3.codec());
  };
})(FilterSubscribeResponse || (FilterSubscribeResponse = {}));
var MessagePush2;
(function(MessagePush3) {
  let _codec;
  MessagePush3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.wakuMessage != null) {
          w.uint32(10);
          WakuMessage3.codec().encode(obj.wakuMessage, w);
        }
        if (obj.pubsubTopic != null) {
          w.uint32(18);
          w.string(obj.pubsubTopic);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length4) => {
        const obj = {};
        const end = length4 == null ? reader2.len : reader2.pos + length4;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.wakuMessage = WakuMessage3.codec().decode(reader2, reader2.uint32());
              break;
            case 2:
              obj.pubsubTopic = reader2.string();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  MessagePush3.encode = (obj) => {
    return encodeMessage(obj, MessagePush3.codec());
  };
  MessagePush3.decode = (buf) => {
    return decodeMessage(buf, MessagePush3.codec());
  };
})(MessagePush2 || (MessagePush2 = {}));
var RateLimitProof3;
(function(RateLimitProof6) {
  let _codec;
  RateLimitProof6.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.proof != null && obj.proof.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.proof);
        }
        if (obj.merkleRoot != null && obj.merkleRoot.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.merkleRoot);
        }
        if (obj.epoch != null && obj.epoch.byteLength > 0) {
          w.uint32(26);
          w.bytes(obj.epoch);
        }
        if (obj.shareX != null && obj.shareX.byteLength > 0) {
          w.uint32(34);
          w.bytes(obj.shareX);
        }
        if (obj.shareY != null && obj.shareY.byteLength > 0) {
          w.uint32(42);
          w.bytes(obj.shareY);
        }
        if (obj.nullifier != null && obj.nullifier.byteLength > 0) {
          w.uint32(50);
          w.bytes(obj.nullifier);
        }
        if (obj.rlnIdentifier != null && obj.rlnIdentifier.byteLength > 0) {
          w.uint32(58);
          w.bytes(obj.rlnIdentifier);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length4) => {
        const obj = {
          proof: new Uint8Array(0),
          merkleRoot: new Uint8Array(0),
          epoch: new Uint8Array(0),
          shareX: new Uint8Array(0),
          shareY: new Uint8Array(0),
          nullifier: new Uint8Array(0),
          rlnIdentifier: new Uint8Array(0)
        };
        const end = length4 == null ? reader2.len : reader2.pos + length4;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.proof = reader2.bytes();
              break;
            case 2:
              obj.merkleRoot = reader2.bytes();
              break;
            case 3:
              obj.epoch = reader2.bytes();
              break;
            case 4:
              obj.shareX = reader2.bytes();
              break;
            case 5:
              obj.shareY = reader2.bytes();
              break;
            case 6:
              obj.nullifier = reader2.bytes();
              break;
            case 7:
              obj.rlnIdentifier = reader2.bytes();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  RateLimitProof6.encode = (obj) => {
    return encodeMessage(obj, RateLimitProof6.codec());
  };
  RateLimitProof6.decode = (buf) => {
    return decodeMessage(buf, RateLimitProof6.codec());
  };
})(RateLimitProof3 || (RateLimitProof3 = {}));
var WakuMessage3;
(function(WakuMessage6) {
  let _codec;
  WakuMessage6.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.payload != null && obj.payload.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.payload);
        }
        if (obj.contentTopic != null && obj.contentTopic !== "") {
          w.uint32(18);
          w.string(obj.contentTopic);
        }
        if (obj.version != null) {
          w.uint32(24);
          w.uint32(obj.version);
        }
        if (obj.timestamp != null) {
          w.uint32(80);
          w.sint64(obj.timestamp);
        }
        if (obj.meta != null) {
          w.uint32(90);
          w.bytes(obj.meta);
        }
        if (obj.rateLimitProof != null) {
          w.uint32(170);
          RateLimitProof3.codec().encode(obj.rateLimitProof, w);
        }
        if (obj.ephemeral != null) {
          w.uint32(248);
          w.bool(obj.ephemeral);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length4) => {
        const obj = {
          payload: new Uint8Array(0),
          contentTopic: ""
        };
        const end = length4 == null ? reader2.len : reader2.pos + length4;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.payload = reader2.bytes();
              break;
            case 2:
              obj.contentTopic = reader2.string();
              break;
            case 3:
              obj.version = reader2.uint32();
              break;
            case 10:
              obj.timestamp = reader2.sint64();
              break;
            case 11:
              obj.meta = reader2.bytes();
              break;
            case 21:
              obj.rateLimitProof = RateLimitProof3.codec().decode(reader2, reader2.uint32());
              break;
            case 31:
              obj.ephemeral = reader2.bool();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  WakuMessage6.encode = (obj) => {
    return encodeMessage(obj, WakuMessage6.codec());
  };
  WakuMessage6.decode = (buf) => {
    return decodeMessage(buf, WakuMessage6.codec());
  };
})(WakuMessage3 || (WakuMessage3 = {}));

// node_modules/@waku/proto/dist/lib/light_push.js
var light_push_exports = {};
__export(light_push_exports, {
  PushRequest: () => PushRequest,
  PushResponse: () => PushResponse,
  PushRpc: () => PushRpc,
  RateLimitProof: () => RateLimitProof4,
  WakuMessage: () => WakuMessage4
});
var PushRequest;
(function(PushRequest2) {
  let _codec;
  PushRequest2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.pubsubTopic != null && obj.pubsubTopic !== "") {
          w.uint32(10);
          w.string(obj.pubsubTopic);
        }
        if (obj.message != null) {
          w.uint32(18);
          WakuMessage4.codec().encode(obj.message, w);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length4) => {
        const obj = {
          pubsubTopic: ""
        };
        const end = length4 == null ? reader2.len : reader2.pos + length4;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.pubsubTopic = reader2.string();
              break;
            case 2:
              obj.message = WakuMessage4.codec().decode(reader2, reader2.uint32());
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PushRequest2.encode = (obj) => {
    return encodeMessage(obj, PushRequest2.codec());
  };
  PushRequest2.decode = (buf) => {
    return decodeMessage(buf, PushRequest2.codec());
  };
})(PushRequest || (PushRequest = {}));
var PushResponse;
(function(PushResponse2) {
  let _codec;
  PushResponse2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.isSuccess != null && obj.isSuccess !== false) {
          w.uint32(8);
          w.bool(obj.isSuccess);
        }
        if (obj.info != null) {
          w.uint32(18);
          w.string(obj.info);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length4) => {
        const obj = {
          isSuccess: false
        };
        const end = length4 == null ? reader2.len : reader2.pos + length4;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.isSuccess = reader2.bool();
              break;
            case 2:
              obj.info = reader2.string();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PushResponse2.encode = (obj) => {
    return encodeMessage(obj, PushResponse2.codec());
  };
  PushResponse2.decode = (buf) => {
    return decodeMessage(buf, PushResponse2.codec());
  };
})(PushResponse || (PushResponse = {}));
var PushRpc;
(function(PushRpc3) {
  let _codec;
  PushRpc3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.requestId != null && obj.requestId !== "") {
          w.uint32(10);
          w.string(obj.requestId);
        }
        if (obj.request != null) {
          w.uint32(18);
          PushRequest.codec().encode(obj.request, w);
        }
        if (obj.response != null) {
          w.uint32(26);
          PushResponse.codec().encode(obj.response, w);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length4) => {
        const obj = {
          requestId: ""
        };
        const end = length4 == null ? reader2.len : reader2.pos + length4;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.requestId = reader2.string();
              break;
            case 2:
              obj.request = PushRequest.codec().decode(reader2, reader2.uint32());
              break;
            case 3:
              obj.response = PushResponse.codec().decode(reader2, reader2.uint32());
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PushRpc3.encode = (obj) => {
    return encodeMessage(obj, PushRpc3.codec());
  };
  PushRpc3.decode = (buf) => {
    return decodeMessage(buf, PushRpc3.codec());
  };
})(PushRpc || (PushRpc = {}));
var RateLimitProof4;
(function(RateLimitProof6) {
  let _codec;
  RateLimitProof6.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.proof != null && obj.proof.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.proof);
        }
        if (obj.merkleRoot != null && obj.merkleRoot.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.merkleRoot);
        }
        if (obj.epoch != null && obj.epoch.byteLength > 0) {
          w.uint32(26);
          w.bytes(obj.epoch);
        }
        if (obj.shareX != null && obj.shareX.byteLength > 0) {
          w.uint32(34);
          w.bytes(obj.shareX);
        }
        if (obj.shareY != null && obj.shareY.byteLength > 0) {
          w.uint32(42);
          w.bytes(obj.shareY);
        }
        if (obj.nullifier != null && obj.nullifier.byteLength > 0) {
          w.uint32(50);
          w.bytes(obj.nullifier);
        }
        if (obj.rlnIdentifier != null && obj.rlnIdentifier.byteLength > 0) {
          w.uint32(58);
          w.bytes(obj.rlnIdentifier);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length4) => {
        const obj = {
          proof: new Uint8Array(0),
          merkleRoot: new Uint8Array(0),
          epoch: new Uint8Array(0),
          shareX: new Uint8Array(0),
          shareY: new Uint8Array(0),
          nullifier: new Uint8Array(0),
          rlnIdentifier: new Uint8Array(0)
        };
        const end = length4 == null ? reader2.len : reader2.pos + length4;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.proof = reader2.bytes();
              break;
            case 2:
              obj.merkleRoot = reader2.bytes();
              break;
            case 3:
              obj.epoch = reader2.bytes();
              break;
            case 4:
              obj.shareX = reader2.bytes();
              break;
            case 5:
              obj.shareY = reader2.bytes();
              break;
            case 6:
              obj.nullifier = reader2.bytes();
              break;
            case 7:
              obj.rlnIdentifier = reader2.bytes();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  RateLimitProof6.encode = (obj) => {
    return encodeMessage(obj, RateLimitProof6.codec());
  };
  RateLimitProof6.decode = (buf) => {
    return decodeMessage(buf, RateLimitProof6.codec());
  };
})(RateLimitProof4 || (RateLimitProof4 = {}));
var WakuMessage4;
(function(WakuMessage6) {
  let _codec;
  WakuMessage6.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.payload != null && obj.payload.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.payload);
        }
        if (obj.contentTopic != null && obj.contentTopic !== "") {
          w.uint32(18);
          w.string(obj.contentTopic);
        }
        if (obj.version != null) {
          w.uint32(24);
          w.uint32(obj.version);
        }
        if (obj.timestamp != null) {
          w.uint32(80);
          w.sint64(obj.timestamp);
        }
        if (obj.meta != null) {
          w.uint32(90);
          w.bytes(obj.meta);
        }
        if (obj.rateLimitProof != null) {
          w.uint32(170);
          RateLimitProof4.codec().encode(obj.rateLimitProof, w);
        }
        if (obj.ephemeral != null) {
          w.uint32(248);
          w.bool(obj.ephemeral);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length4) => {
        const obj = {
          payload: new Uint8Array(0),
          contentTopic: ""
        };
        const end = length4 == null ? reader2.len : reader2.pos + length4;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.payload = reader2.bytes();
              break;
            case 2:
              obj.contentTopic = reader2.string();
              break;
            case 3:
              obj.version = reader2.uint32();
              break;
            case 10:
              obj.timestamp = reader2.sint64();
              break;
            case 11:
              obj.meta = reader2.bytes();
              break;
            case 21:
              obj.rateLimitProof = RateLimitProof4.codec().decode(reader2, reader2.uint32());
              break;
            case 31:
              obj.ephemeral = reader2.bool();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  WakuMessage6.encode = (obj) => {
    return encodeMessage(obj, WakuMessage6.codec());
  };
  WakuMessage6.decode = (buf) => {
    return decodeMessage(buf, WakuMessage6.codec());
  };
})(WakuMessage4 || (WakuMessage4 = {}));

// node_modules/@waku/proto/dist/lib/store.js
var store_exports = {};
__export(store_exports, {
  ContentFilter: () => ContentFilter,
  HistoryQuery: () => HistoryQuery,
  HistoryResponse: () => HistoryResponse,
  HistoryRpc: () => HistoryRpc,
  Index: () => Index,
  PagingInfo: () => PagingInfo,
  RateLimitProof: () => RateLimitProof5,
  WakuMessage: () => WakuMessage5
});
var Index;
(function(Index2) {
  let _codec;
  Index2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.digest != null && obj.digest.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.digest);
        }
        if (obj.receiverTime != null && obj.receiverTime !== 0n) {
          w.uint32(16);
          w.sint64(obj.receiverTime);
        }
        if (obj.senderTime != null && obj.senderTime !== 0n) {
          w.uint32(24);
          w.sint64(obj.senderTime);
        }
        if (obj.pubsubTopic != null && obj.pubsubTopic !== "") {
          w.uint32(34);
          w.string(obj.pubsubTopic);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length4) => {
        const obj = {
          digest: new Uint8Array(0),
          receiverTime: 0n,
          senderTime: 0n,
          pubsubTopic: ""
        };
        const end = length4 == null ? reader2.len : reader2.pos + length4;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.digest = reader2.bytes();
              break;
            case 2:
              obj.receiverTime = reader2.sint64();
              break;
            case 3:
              obj.senderTime = reader2.sint64();
              break;
            case 4:
              obj.pubsubTopic = reader2.string();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Index2.encode = (obj) => {
    return encodeMessage(obj, Index2.codec());
  };
  Index2.decode = (buf) => {
    return decodeMessage(buf, Index2.codec());
  };
})(Index || (Index = {}));
var PagingInfo;
(function(PagingInfo2) {
  let Direction;
  (function(Direction2) {
    Direction2["BACKWARD"] = "BACKWARD";
    Direction2["FORWARD"] = "FORWARD";
  })(Direction = PagingInfo2.Direction || (PagingInfo2.Direction = {}));
  let __DirectionValues;
  (function(__DirectionValues2) {
    __DirectionValues2[__DirectionValues2["BACKWARD"] = 0] = "BACKWARD";
    __DirectionValues2[__DirectionValues2["FORWARD"] = 1] = "FORWARD";
  })(__DirectionValues || (__DirectionValues = {}));
  (function(Direction2) {
    Direction2.codec = () => {
      return enumeration(__DirectionValues);
    };
  })(Direction = PagingInfo2.Direction || (PagingInfo2.Direction = {}));
  let _codec;
  PagingInfo2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.pageSize != null) {
          w.uint32(8);
          w.uint64(obj.pageSize);
        }
        if (obj.cursor != null) {
          w.uint32(18);
          Index.codec().encode(obj.cursor, w);
        }
        if (obj.direction != null) {
          w.uint32(24);
          PagingInfo2.Direction.codec().encode(obj.direction, w);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length4) => {
        const obj = {};
        const end = length4 == null ? reader2.len : reader2.pos + length4;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.pageSize = reader2.uint64();
              break;
            case 2:
              obj.cursor = Index.codec().decode(reader2, reader2.uint32());
              break;
            case 3:
              obj.direction = PagingInfo2.Direction.codec().decode(reader2);
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PagingInfo2.encode = (obj) => {
    return encodeMessage(obj, PagingInfo2.codec());
  };
  PagingInfo2.decode = (buf) => {
    return decodeMessage(buf, PagingInfo2.codec());
  };
})(PagingInfo || (PagingInfo = {}));
var ContentFilter;
(function(ContentFilter2) {
  let _codec;
  ContentFilter2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.contentTopic != null && obj.contentTopic !== "") {
          w.uint32(10);
          w.string(obj.contentTopic);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length4) => {
        const obj = {
          contentTopic: ""
        };
        const end = length4 == null ? reader2.len : reader2.pos + length4;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.contentTopic = reader2.string();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  ContentFilter2.encode = (obj) => {
    return encodeMessage(obj, ContentFilter2.codec());
  };
  ContentFilter2.decode = (buf) => {
    return decodeMessage(buf, ContentFilter2.codec());
  };
})(ContentFilter || (ContentFilter = {}));
var HistoryQuery;
(function(HistoryQuery2) {
  let _codec;
  HistoryQuery2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.pubsubTopic != null) {
          w.uint32(18);
          w.string(obj.pubsubTopic);
        }
        if (obj.contentFilters != null) {
          for (const value of obj.contentFilters) {
            w.uint32(26);
            ContentFilter.codec().encode(value, w);
          }
        }
        if (obj.pagingInfo != null) {
          w.uint32(34);
          PagingInfo.codec().encode(obj.pagingInfo, w);
        }
        if (obj.startTime != null) {
          w.uint32(40);
          w.sint64(obj.startTime);
        }
        if (obj.endTime != null) {
          w.uint32(48);
          w.sint64(obj.endTime);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length4) => {
        const obj = {
          contentFilters: []
        };
        const end = length4 == null ? reader2.len : reader2.pos + length4;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 2:
              obj.pubsubTopic = reader2.string();
              break;
            case 3:
              obj.contentFilters.push(ContentFilter.codec().decode(reader2, reader2.uint32()));
              break;
            case 4:
              obj.pagingInfo = PagingInfo.codec().decode(reader2, reader2.uint32());
              break;
            case 5:
              obj.startTime = reader2.sint64();
              break;
            case 6:
              obj.endTime = reader2.sint64();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  HistoryQuery2.encode = (obj) => {
    return encodeMessage(obj, HistoryQuery2.codec());
  };
  HistoryQuery2.decode = (buf) => {
    return decodeMessage(buf, HistoryQuery2.codec());
  };
})(HistoryQuery || (HistoryQuery = {}));
var HistoryResponse;
(function(HistoryResponse2) {
  let HistoryError2;
  (function(HistoryError3) {
    HistoryError3["NONE"] = "NONE";
    HistoryError3["INVALID_CURSOR"] = "INVALID_CURSOR";
  })(HistoryError2 = HistoryResponse2.HistoryError || (HistoryResponse2.HistoryError = {}));
  let __HistoryErrorValues;
  (function(__HistoryErrorValues2) {
    __HistoryErrorValues2[__HistoryErrorValues2["NONE"] = 0] = "NONE";
    __HistoryErrorValues2[__HistoryErrorValues2["INVALID_CURSOR"] = 1] = "INVALID_CURSOR";
  })(__HistoryErrorValues || (__HistoryErrorValues = {}));
  (function(HistoryError3) {
    HistoryError3.codec = () => {
      return enumeration(__HistoryErrorValues);
    };
  })(HistoryError2 = HistoryResponse2.HistoryError || (HistoryResponse2.HistoryError = {}));
  let _codec;
  HistoryResponse2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.messages != null) {
          for (const value of obj.messages) {
            w.uint32(18);
            WakuMessage5.codec().encode(value, w);
          }
        }
        if (obj.pagingInfo != null) {
          w.uint32(26);
          PagingInfo.codec().encode(obj.pagingInfo, w);
        }
        if (obj.error != null && __HistoryErrorValues[obj.error] !== 0) {
          w.uint32(32);
          HistoryResponse2.HistoryError.codec().encode(obj.error, w);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length4) => {
        const obj = {
          messages: [],
          error: HistoryError2.NONE
        };
        const end = length4 == null ? reader2.len : reader2.pos + length4;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 2:
              obj.messages.push(WakuMessage5.codec().decode(reader2, reader2.uint32()));
              break;
            case 3:
              obj.pagingInfo = PagingInfo.codec().decode(reader2, reader2.uint32());
              break;
            case 4:
              obj.error = HistoryResponse2.HistoryError.codec().decode(reader2);
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  HistoryResponse2.encode = (obj) => {
    return encodeMessage(obj, HistoryResponse2.codec());
  };
  HistoryResponse2.decode = (buf) => {
    return decodeMessage(buf, HistoryResponse2.codec());
  };
})(HistoryResponse || (HistoryResponse = {}));
var HistoryRpc;
(function(HistoryRpc3) {
  let _codec;
  HistoryRpc3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.requestId != null && obj.requestId !== "") {
          w.uint32(10);
          w.string(obj.requestId);
        }
        if (obj.query != null) {
          w.uint32(18);
          HistoryQuery.codec().encode(obj.query, w);
        }
        if (obj.response != null) {
          w.uint32(26);
          HistoryResponse.codec().encode(obj.response, w);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length4) => {
        const obj = {
          requestId: ""
        };
        const end = length4 == null ? reader2.len : reader2.pos + length4;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.requestId = reader2.string();
              break;
            case 2:
              obj.query = HistoryQuery.codec().decode(reader2, reader2.uint32());
              break;
            case 3:
              obj.response = HistoryResponse.codec().decode(reader2, reader2.uint32());
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  HistoryRpc3.encode = (obj) => {
    return encodeMessage(obj, HistoryRpc3.codec());
  };
  HistoryRpc3.decode = (buf) => {
    return decodeMessage(buf, HistoryRpc3.codec());
  };
})(HistoryRpc || (HistoryRpc = {}));
var RateLimitProof5;
(function(RateLimitProof6) {
  let _codec;
  RateLimitProof6.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.proof != null && obj.proof.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.proof);
        }
        if (obj.merkleRoot != null && obj.merkleRoot.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.merkleRoot);
        }
        if (obj.epoch != null && obj.epoch.byteLength > 0) {
          w.uint32(26);
          w.bytes(obj.epoch);
        }
        if (obj.shareX != null && obj.shareX.byteLength > 0) {
          w.uint32(34);
          w.bytes(obj.shareX);
        }
        if (obj.shareY != null && obj.shareY.byteLength > 0) {
          w.uint32(42);
          w.bytes(obj.shareY);
        }
        if (obj.nullifier != null && obj.nullifier.byteLength > 0) {
          w.uint32(50);
          w.bytes(obj.nullifier);
        }
        if (obj.rlnIdentifier != null && obj.rlnIdentifier.byteLength > 0) {
          w.uint32(58);
          w.bytes(obj.rlnIdentifier);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length4) => {
        const obj = {
          proof: new Uint8Array(0),
          merkleRoot: new Uint8Array(0),
          epoch: new Uint8Array(0),
          shareX: new Uint8Array(0),
          shareY: new Uint8Array(0),
          nullifier: new Uint8Array(0),
          rlnIdentifier: new Uint8Array(0)
        };
        const end = length4 == null ? reader2.len : reader2.pos + length4;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.proof = reader2.bytes();
              break;
            case 2:
              obj.merkleRoot = reader2.bytes();
              break;
            case 3:
              obj.epoch = reader2.bytes();
              break;
            case 4:
              obj.shareX = reader2.bytes();
              break;
            case 5:
              obj.shareY = reader2.bytes();
              break;
            case 6:
              obj.nullifier = reader2.bytes();
              break;
            case 7:
              obj.rlnIdentifier = reader2.bytes();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  RateLimitProof6.encode = (obj) => {
    return encodeMessage(obj, RateLimitProof6.codec());
  };
  RateLimitProof6.decode = (buf) => {
    return decodeMessage(buf, RateLimitProof6.codec());
  };
})(RateLimitProof5 || (RateLimitProof5 = {}));
var WakuMessage5;
(function(WakuMessage6) {
  let _codec;
  WakuMessage6.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.payload != null && obj.payload.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.payload);
        }
        if (obj.contentTopic != null && obj.contentTopic !== "") {
          w.uint32(18);
          w.string(obj.contentTopic);
        }
        if (obj.version != null) {
          w.uint32(24);
          w.uint32(obj.version);
        }
        if (obj.timestamp != null) {
          w.uint32(80);
          w.sint64(obj.timestamp);
        }
        if (obj.meta != null) {
          w.uint32(90);
          w.bytes(obj.meta);
        }
        if (obj.rateLimitProof != null) {
          w.uint32(170);
          RateLimitProof5.codec().encode(obj.rateLimitProof, w);
        }
        if (obj.ephemeral != null) {
          w.uint32(248);
          w.bool(obj.ephemeral);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length4) => {
        const obj = {
          payload: new Uint8Array(0),
          contentTopic: ""
        };
        const end = length4 == null ? reader2.len : reader2.pos + length4;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.payload = reader2.bytes();
              break;
            case 2:
              obj.contentTopic = reader2.string();
              break;
            case 3:
              obj.version = reader2.uint32();
              break;
            case 10:
              obj.timestamp = reader2.sint64();
              break;
            case 11:
              obj.meta = reader2.bytes();
              break;
            case 21:
              obj.rateLimitProof = RateLimitProof5.codec().decode(reader2, reader2.uint32());
              break;
            case 31:
              obj.ephemeral = reader2.bool();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  WakuMessage6.encode = (obj) => {
    return encodeMessage(obj, WakuMessage6.codec());
  };
  WakuMessage6.decode = (buf) => {
    return decodeMessage(buf, WakuMessage6.codec());
  };
})(WakuMessage5 || (WakuMessage5 = {}));

// node_modules/@waku/proto/dist/lib/peer_exchange.js
var peer_exchange_exports = {};
__export(peer_exchange_exports, {
  PeerExchangeQuery: () => PeerExchangeQuery,
  PeerExchangeRPC: () => PeerExchangeRPC,
  PeerExchangeResponse: () => PeerExchangeResponse,
  PeerInfo: () => PeerInfo
});
var PeerInfo;
(function(PeerInfo2) {
  let _codec;
  PeerInfo2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.enr != null) {
          w.uint32(10);
          w.bytes(obj.enr);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length4) => {
        const obj = {};
        const end = length4 == null ? reader2.len : reader2.pos + length4;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.enr = reader2.bytes();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PeerInfo2.encode = (obj) => {
    return encodeMessage(obj, PeerInfo2.codec());
  };
  PeerInfo2.decode = (buf) => {
    return decodeMessage(buf, PeerInfo2.codec());
  };
})(PeerInfo || (PeerInfo = {}));
var PeerExchangeQuery;
(function(PeerExchangeQuery2) {
  let _codec;
  PeerExchangeQuery2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.numPeers != null) {
          w.uint32(8);
          w.uint64(obj.numPeers);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length4) => {
        const obj = {};
        const end = length4 == null ? reader2.len : reader2.pos + length4;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.numPeers = reader2.uint64();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PeerExchangeQuery2.encode = (obj) => {
    return encodeMessage(obj, PeerExchangeQuery2.codec());
  };
  PeerExchangeQuery2.decode = (buf) => {
    return decodeMessage(buf, PeerExchangeQuery2.codec());
  };
})(PeerExchangeQuery || (PeerExchangeQuery = {}));
var PeerExchangeResponse;
(function(PeerExchangeResponse2) {
  let _codec;
  PeerExchangeResponse2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.peerInfos != null) {
          for (const value of obj.peerInfos) {
            w.uint32(10);
            PeerInfo.codec().encode(value, w);
          }
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length4) => {
        const obj = {
          peerInfos: []
        };
        const end = length4 == null ? reader2.len : reader2.pos + length4;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.peerInfos.push(PeerInfo.codec().decode(reader2, reader2.uint32()));
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PeerExchangeResponse2.encode = (obj) => {
    return encodeMessage(obj, PeerExchangeResponse2.codec());
  };
  PeerExchangeResponse2.decode = (buf) => {
    return decodeMessage(buf, PeerExchangeResponse2.codec());
  };
})(PeerExchangeResponse || (PeerExchangeResponse = {}));
var PeerExchangeRPC;
(function(PeerExchangeRPC3) {
  let _codec;
  PeerExchangeRPC3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.query != null) {
          w.uint32(10);
          PeerExchangeQuery.codec().encode(obj.query, w);
        }
        if (obj.response != null) {
          w.uint32(18);
          PeerExchangeResponse.codec().encode(obj.response, w);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length4) => {
        const obj = {};
        const end = length4 == null ? reader2.len : reader2.pos + length4;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.query = PeerExchangeQuery.codec().decode(reader2, reader2.uint32());
              break;
            case 2:
              obj.response = PeerExchangeResponse.codec().decode(reader2, reader2.uint32());
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PeerExchangeRPC3.encode = (obj) => {
    return encodeMessage(obj, PeerExchangeRPC3.codec());
  };
  PeerExchangeRPC3.decode = (buf) => {
    return decodeMessage(buf, PeerExchangeRPC3.codec());
  };
})(PeerExchangeRPC || (PeerExchangeRPC = {}));

// node_modules/@waku/core/dist/lib/constants.js
var DefaultPubSubTopic = "/waku/2/default-waku/proto";

// node_modules/@waku/core/dist/lib/message/version_0.js
var log = new Logger("message:version-0");
var OneMillion = BigInt(1e6);
var Version = 0;
var DecodedMessage = class {
  constructor(pubsubTopic, proto) {
    __publicField(this, "pubsubTopic");
    __publicField(this, "proto");
    this.pubsubTopic = pubsubTopic;
    this.proto = proto;
  }
  get ephemeral() {
    return Boolean(this.proto.ephemeral);
  }
  get payload() {
    return this.proto.payload;
  }
  get contentTopic() {
    return this.proto.contentTopic;
  }
  get _rawTimestamp() {
    return this.proto.timestamp;
  }
  get timestamp() {
    try {
      if (this.proto.timestamp) {
        const timestamp = this.proto.timestamp / OneMillion;
        return new Date(Number(timestamp));
      }
      return;
    } catch (e) {
      return;
    }
  }
  get meta() {
    return this.proto.meta;
  }
  get version() {
    return this.proto.version ?? 0;
  }
  get rateLimitProof() {
    return this.proto.rateLimitProof;
  }
};
var Encoder = class {
  constructor(contentTopic, ephemeral = false, pubsubTopic, metaSetter) {
    __publicField(this, "contentTopic");
    __publicField(this, "ephemeral");
    __publicField(this, "pubsubTopic");
    __publicField(this, "metaSetter");
    this.contentTopic = contentTopic;
    this.ephemeral = ephemeral;
    this.pubsubTopic = pubsubTopic;
    this.metaSetter = metaSetter;
    if (!contentTopic || contentTopic === "") {
      throw new Error("Content topic must be specified");
    }
  }
  async toWire(message2) {
    return message_exports.WakuMessage.encode(await this.toProtoObj(message2));
  }
  async toProtoObj(message2) {
    const timestamp = message2.timestamp ?? /* @__PURE__ */ new Date();
    const protoMessage = {
      payload: message2.payload,
      version: Version,
      contentTopic: this.contentTopic,
      timestamp: BigInt(timestamp.valueOf()) * OneMillion,
      meta: void 0,
      rateLimitProof: message2.rateLimitProof,
      ephemeral: this.ephemeral
    };
    if (this.metaSetter) {
      const meta = this.metaSetter(protoMessage);
      return { ...protoMessage, meta };
    }
    return protoMessage;
  }
};
function createEncoder({ pubsubTopic = DefaultPubSubTopic, contentTopic, ephemeral, metaSetter }) {
  return new Encoder(contentTopic, ephemeral, pubsubTopic, metaSetter);
}
var Decoder = class {
  constructor(pubsubTopic, contentTopic) {
    __publicField(this, "pubsubTopic");
    __publicField(this, "contentTopic");
    this.pubsubTopic = pubsubTopic;
    this.contentTopic = contentTopic;
    if (!contentTopic || contentTopic === "") {
      throw new Error("Content topic must be specified");
    }
  }
  fromWireToProtoObj(bytes2) {
    const protoMessage = message_exports.WakuMessage.decode(bytes2);
    return Promise.resolve({
      payload: protoMessage.payload,
      contentTopic: protoMessage.contentTopic,
      version: protoMessage.version ?? void 0,
      timestamp: protoMessage.timestamp ?? void 0,
      meta: protoMessage.meta ?? void 0,
      rateLimitProof: protoMessage.rateLimitProof ?? void 0,
      ephemeral: protoMessage.ephemeral ?? false
    });
  }
  async fromProtoObj(pubsubTopic, proto) {
    if (proto.version ?? 0 !== Version) {
      log.error("Failed to decode due to incorrect version, expected:", Version, ", actual:", proto.version);
      return Promise.resolve(void 0);
    }
    return new DecodedMessage(pubsubTopic, proto);
  }
};
function createDecoder(contentTopic, pubsubTopic = DefaultPubSubTopic) {
  return new Decoder(pubsubTopic, contentTopic);
}

// node_modules/@waku/core/dist/lib/keep_alive_manager.js
var RelayPingContentTopic = "/relay-ping/1/ping/null";
var log2 = new Logger("keep-alive");
var KeepAliveManager = class {
  constructor(options, relay) {
    __publicField(this, "pingKeepAliveTimers");
    __publicField(this, "relayKeepAliveTimers");
    __publicField(this, "options");
    __publicField(this, "relay");
    this.pingKeepAliveTimers = /* @__PURE__ */ new Map();
    this.relayKeepAliveTimers = /* @__PURE__ */ new Map();
    this.options = options;
    this.relay = relay;
  }
  start(peerId2, libp2pPing, peerStore) {
    this.stop(peerId2);
    const { pingKeepAlive: pingPeriodSecs, relayKeepAlive: relayPeriodSecs } = this.options;
    const peerIdStr = peerId2.toString();
    if (pingPeriodSecs !== 0) {
      const interval = setInterval(() => {
        void (async () => {
          let ping;
          try {
            try {
              ping = await libp2pPing.ping(peerId2);
              log2.info(`Ping succeeded (${peerIdStr})`, ping);
            } catch (error) {
              log2.error(`Ping failed for peer (${peerIdStr}).
                Next ping will be attempted in ${pingPeriodSecs} seconds.
              `);
              return;
            }
            try {
              await peerStore.patch(peerId2, {
                metadata: {
                  ping: utf8ToBytes(ping.toString())
                }
              });
            } catch (e) {
              log2.error("Failed to update ping", e);
            }
          } catch (e) {
            log2.error(`Ping failed (${peerIdStr})`, e);
          }
        })();
      }, pingPeriodSecs * 1e3);
      this.pingKeepAliveTimers.set(peerIdStr, interval);
    }
    const relay = this.relay;
    if (relay && relayPeriodSecs !== 0) {
      const intervals = this.scheduleRelayPings(relay, relayPeriodSecs, peerId2.toString());
      this.relayKeepAliveTimers.set(peerId2, intervals);
    }
  }
  stop(peerId2) {
    var _a4;
    const peerIdStr = peerId2.toString();
    if (this.pingKeepAliveTimers.has(peerIdStr)) {
      clearInterval(this.pingKeepAliveTimers.get(peerIdStr));
      this.pingKeepAliveTimers.delete(peerIdStr);
    }
    if (this.relayKeepAliveTimers.has(peerId2)) {
      (_a4 = this.relayKeepAliveTimers.get(peerId2)) == null ? void 0 : _a4.map(clearInterval);
      this.relayKeepAliveTimers.delete(peerId2);
    }
  }
  stopAll() {
    for (const timer of [
      ...Object.values(this.pingKeepAliveTimers),
      ...Object.values(this.relayKeepAliveTimers)
    ]) {
      clearInterval(timer);
    }
    this.pingKeepAliveTimers.clear();
    this.relayKeepAliveTimers.clear();
  }
  scheduleRelayPings(relay, relayPeriodSecs, peerIdStr) {
    const intervals = [];
    for (const topic of relay.pubsubTopics) {
      const meshPeers = relay.getMeshPeers(topic);
      if (!meshPeers.includes(peerIdStr))
        continue;
      const encoder2 = createEncoder({
        pubsubTopic: topic,
        contentTopic: RelayPingContentTopic,
        ephemeral: true
      });
      const interval = setInterval(() => {
        log2.info("Sending Waku Relay ping message");
        relay.send(encoder2, { payload: new Uint8Array([1]) }).catch((e) => log2.error("Failed to send relay ping", e));
      }, relayPeriodSecs * 1e3);
      intervals.push(interval);
    }
    return intervals;
  }
};

// node_modules/@waku/core/dist/lib/connection_manager.js
var log3 = new Logger("connection-manager");
var DEFAULT_MAX_BOOTSTRAP_PEERS_ALLOWED = 1;
var DEFAULT_MAX_DIAL_ATTEMPTS_FOR_PEER = 3;
var DEFAULT_MAX_PARALLEL_DIALS = 3;
var _ConnectionManager = class _ConnectionManager extends EventEmitter {
  constructor(libp2p, keepAliveOptions, configuredPubSubTopics, relay, options) {
    super();
    __publicField(this, "configuredPubSubTopics");
    __publicField(this, "keepAliveManager");
    __publicField(this, "options");
    __publicField(this, "libp2p");
    __publicField(this, "dialAttemptsForPeer", /* @__PURE__ */ new Map());
    __publicField(this, "dialErrorsForPeer", /* @__PURE__ */ new Map());
    __publicField(this, "currentActiveParallelDialCount", 0);
    __publicField(this, "pendingPeerDialQueue", []);
    __publicField(this, "onEventHandlers", {
      "peer:discovery": (evt) => {
        void (async () => {
          const { id: peerId2 } = evt.detail;
          await this.dispatchDiscoveryEvent(peerId2);
          try {
            await this.attemptDial(peerId2);
          } catch (error) {
            log3.error(`Error dialing peer ${peerId2.toString()} : ${error}`);
          }
        })();
      },
      "peer:connect": (evt) => {
        void (async () => {
          const peerId2 = evt.detail;
          this.keepAliveManager.start(peerId2, this.libp2p.services.ping, this.libp2p.peerStore);
          const isBootstrap = (await this.getTagNamesForPeer(peerId2)).includes(Tags.BOOTSTRAP);
          if (isBootstrap) {
            const bootstrapConnections = this.libp2p.getConnections().filter((conn) => conn.tags.includes(Tags.BOOTSTRAP));
            if (bootstrapConnections.length > this.options.maxBootstrapPeersAllowed) {
              await this.dropConnection(peerId2);
            } else {
              this.dispatchEvent(new CustomEvent2(EPeersByDiscoveryEvents.PEER_CONNECT_BOOTSTRAP, {
                detail: peerId2
              }));
            }
          } else {
            this.dispatchEvent(new CustomEvent2(EPeersByDiscoveryEvents.PEER_CONNECT_PEER_EXCHANGE, {
              detail: peerId2
            }));
          }
        })();
      },
      "peer:disconnect": () => {
        return (evt) => {
          this.keepAliveManager.stop(evt.detail);
        };
      }
    });
    this.configuredPubSubTopics = configuredPubSubTopics;
    this.libp2p = libp2p;
    this.configuredPubSubTopics = configuredPubSubTopics;
    this.options = {
      maxDialAttemptsForPeer: DEFAULT_MAX_DIAL_ATTEMPTS_FOR_PEER,
      maxBootstrapPeersAllowed: DEFAULT_MAX_BOOTSTRAP_PEERS_ALLOWED,
      maxParallelDials: DEFAULT_MAX_PARALLEL_DIALS,
      ...options
    };
    this.keepAliveManager = new KeepAliveManager(keepAliveOptions, relay);
    this.run().then(() => log3.info(`Connection Manager is now running`)).catch((error) => log3.error(`Unexpected error while running service`, error));
    this.dialPeerStorePeers().catch((error) => log3.error(`Unexpected error while dialing peer store peers`, error));
  }
  static create(peerId2, libp2p, keepAliveOptions, pubsubTopics, relay, options) {
    let instance = _ConnectionManager.instances.get(peerId2);
    if (!instance) {
      instance = new _ConnectionManager(libp2p, keepAliveOptions, pubsubTopics, relay, options);
      _ConnectionManager.instances.set(peerId2, instance);
    }
    return instance;
  }
  async getPeersByDiscovery() {
    const peersDiscovered = await this.libp2p.peerStore.all();
    const peersConnected = this.libp2p.getConnections().map((conn) => conn.remotePeer);
    const peersDiscoveredByBootstrap = [];
    const peersDiscoveredByPeerExchange = [];
    const peersConnectedByBootstrap = [];
    const peersConnectedByPeerExchange = [];
    for (const peer of peersDiscovered) {
      const tags = await this.getTagNamesForPeer(peer.id);
      if (tags.includes(Tags.BOOTSTRAP)) {
        peersDiscoveredByBootstrap.push(peer);
      } else if (tags.includes(Tags.PEER_EXCHANGE)) {
        peersDiscoveredByPeerExchange.push(peer);
      }
    }
    for (const peerId2 of peersConnected) {
      const peer = await this.libp2p.peerStore.get(peerId2);
      const tags = await this.getTagNamesForPeer(peerId2);
      if (tags.includes(Tags.BOOTSTRAP)) {
        peersConnectedByBootstrap.push(peer);
      } else if (tags.includes(Tags.PEER_EXCHANGE)) {
        peersConnectedByPeerExchange.push(peer);
      }
    }
    return {
      DISCOVERED: {
        [Tags.BOOTSTRAP]: peersDiscoveredByBootstrap,
        [Tags.PEER_EXCHANGE]: peersDiscoveredByPeerExchange
      },
      CONNECTED: {
        [Tags.BOOTSTRAP]: peersConnectedByBootstrap,
        [Tags.PEER_EXCHANGE]: peersConnectedByPeerExchange
      }
    };
  }
  async dialPeerStorePeers() {
    const peerInfos = await this.libp2p.peerStore.all();
    const dialPromises = [];
    for (const peerInfo of peerInfos) {
      if (this.libp2p.getConnections().find((c) => c.remotePeer === peerInfo.id))
        continue;
      dialPromises.push(this.attemptDial(peerInfo.id));
    }
    try {
      await Promise.all(dialPromises);
    } catch (error) {
      log3.error(`Unexpected error while dialing peer store peers`, error);
    }
  }
  async run() {
    this.startPeerDiscoveryListener();
    this.startPeerConnectionListener();
    this.startPeerDisconnectionListener();
  }
  stop() {
    this.keepAliveManager.stopAll();
    this.libp2p.removeEventListener("peer:connect", this.onEventHandlers["peer:connect"]);
    this.libp2p.removeEventListener("peer:disconnect", this.onEventHandlers["peer:disconnect"]);
    this.libp2p.removeEventListener("peer:discovery", this.onEventHandlers["peer:discovery"]);
  }
  async dialPeer(peerId2) {
    this.currentActiveParallelDialCount += 1;
    let dialAttempt = 0;
    while (dialAttempt < this.options.maxDialAttemptsForPeer) {
      try {
        log3.info(`Dialing peer ${peerId2.toString()} on attempt ${dialAttempt + 1}`);
        await this.libp2p.dial(peerId2);
        const tags = await this.getTagNamesForPeer(peerId2);
        this.libp2p.getConnections(peerId2).forEach((conn) => {
          conn.tags = Array.from(/* @__PURE__ */ new Set([...conn.tags, ...tags]));
        });
        this.dialAttemptsForPeer.set(peerId2.toString(), -1);
        break;
      } catch (error) {
        if (error instanceof AggregateError) {
          log3.error(`Error dialing peer ${peerId2.toString()} - ${error.errors}`);
        } else {
          log3.error(`Error dialing peer ${peerId2.toString()} - ${error.message}`);
        }
        this.dialErrorsForPeer.set(peerId2.toString(), error);
        dialAttempt++;
        this.dialAttemptsForPeer.set(peerId2.toString(), dialAttempt);
      }
    }
    this.currentActiveParallelDialCount--;
    this.processDialQueue();
    if (dialAttempt === this.options.maxDialAttemptsForPeer) {
      try {
        const error = this.dialErrorsForPeer.get(peerId2.toString());
        if (error) {
          let errorMessage;
          if (error instanceof AggregateError) {
            if (!error.errors) {
              log3.warn(`No errors array found for AggregateError`);
            } else if (error.errors.length === 0) {
              log3.warn(`Errors array is empty for AggregateError`);
            } else {
              errorMessage = JSON.stringify(error.errors[0]);
            }
          } else {
            errorMessage = error.message;
          }
          log3.info(`Deleting undialable peer ${peerId2.toString()} from peer store. Reason: ${errorMessage}`);
        }
        this.dialErrorsForPeer.delete(peerId2.toString());
        await this.libp2p.peerStore.delete(peerId2);
      } catch (error) {
        throw new Error(`Error deleting undialable peer ${peerId2.toString()} from peer store - ${error}`);
      }
    }
  }
  async dropConnection(peerId2) {
    try {
      this.keepAliveManager.stop(peerId2);
      await this.libp2p.hangUp(peerId2);
      log3.info(`Dropped connection with peer ${peerId2.toString()}`);
    } catch (error) {
      log3.error(`Error dropping connection with peer ${peerId2.toString()} - ${error}`);
    }
  }
  processDialQueue() {
    if (this.pendingPeerDialQueue.length > 0 && this.currentActiveParallelDialCount < this.options.maxParallelDials) {
      const peerId2 = this.pendingPeerDialQueue.shift();
      if (!peerId2)
        return;
      this.attemptDial(peerId2).catch((error) => {
        log3.error(error);
      });
    }
  }
  startPeerDiscoveryListener() {
    this.libp2p.addEventListener("peer:discovery", this.onEventHandlers["peer:discovery"]);
  }
  startPeerConnectionListener() {
    this.libp2p.addEventListener("peer:connect", this.onEventHandlers["peer:connect"]);
  }
  startPeerDisconnectionListener() {
    this.libp2p.addEventListener("peer:disconnect", this.onEventHandlers["peer:disconnect"]);
  }
  async attemptDial(peerId2) {
    if (!await this.shouldDialPeer(peerId2))
      return;
    if (this.currentActiveParallelDialCount >= this.options.maxParallelDials) {
      this.pendingPeerDialQueue.push(peerId2);
      return;
    }
    this.dialPeer(peerId2).catch((err) => {
      log3.error(`Error dialing peer ${peerId2.toString()} : ${err}`);
    });
  }
  /**
   * Checks if the peer should be dialed based on the following conditions:
   * 1. If the peer is already connected, don't dial
   * 2. If the peer is not part of any of the configured pubsub topics, don't dial
   * 3. If the peer is not dialable based on bootstrap status, don't dial
   * 4. If the peer is already has an active dial attempt, or has been dialed before, don't dial it
   * @returns true if the peer should be dialed, false otherwise
   */
  async shouldDialPeer(peerId2) {
    const isConnected = this.libp2p.getConnections(peerId2).length > 0;
    if (isConnected) {
      log3.warn(`Already connected to peer ${peerId2.toString()}. Not dialing.`);
      return false;
    }
    if (!await this.isPeerTopicConfigured(peerId2)) {
      const shardInfo = await this.getPeerShardInfo(peerId2, this.libp2p.peerStore);
      log3.warn(`Discovered peer ${peerId2.toString()} with ShardInfo ${shardInfo} is not part of any of the configured pubsub topics (${this.configuredPubSubTopics}). 
            Not dialing.`);
      return false;
    }
    if (!await this.isPeerDialableBasedOnBootstrapStatus(peerId2)) {
      log3.warn(`Peer ${peerId2.toString()} is not dialable based on bootstrap status. Not dialing.`);
      return false;
    }
    if (this.dialAttemptsForPeer.has(peerId2.toString())) {
      log3.warn(`Peer ${peerId2.toString()} has already been attempted dial before, or already has a dial attempt in progress, skipping dial`);
      return false;
    }
    return true;
  }
  /**
   * Checks if the peer is dialable based on the following conditions:
   * 1. If the peer is a bootstrap peer, it is only dialable if the number of current bootstrap connections is less than the max allowed.
   * 2. If the peer is not a bootstrap peer
   */
  async isPeerDialableBasedOnBootstrapStatus(peerId2) {
    const tagNames = await this.getTagNamesForPeer(peerId2);
    const isBootstrap = tagNames.some((tagName) => tagName === Tags.BOOTSTRAP);
    if (isBootstrap) {
      const currentBootstrapConnections = this.libp2p.getConnections().filter((conn) => {
        return conn.tags.find((name2) => name2 === Tags.BOOTSTRAP);
      }).length;
      if (currentBootstrapConnections < this.options.maxBootstrapPeersAllowed)
        return true;
    } else {
      return true;
    }
    return false;
  }
  async dispatchDiscoveryEvent(peerId2) {
    const isBootstrap = (await this.getTagNamesForPeer(peerId2)).includes(Tags.BOOTSTRAP);
    this.dispatchEvent(new CustomEvent2(isBootstrap ? EPeersByDiscoveryEvents.PEER_DISCOVERY_BOOTSTRAP : EPeersByDiscoveryEvents.PEER_DISCOVERY_PEER_EXCHANGE, {
      detail: peerId2
    }));
  }
  /**
   * Fetches the tag names for a given peer
   */
  async getTagNamesForPeer(peerId2) {
    try {
      const peer = await this.libp2p.peerStore.get(peerId2);
      return Array.from(peer.tags.keys());
    } catch (error) {
      log3.error(`Failed to get peer ${peerId2}, error: ${error}`);
      return [];
    }
  }
  async isPeerTopicConfigured(peerId2) {
    const shardInfo = await this.getPeerShardInfo(peerId2, this.libp2p.peerStore);
    if (!shardInfo)
      return true;
    const pubsubTopics = shardInfoToPubSubTopics(shardInfo);
    const isTopicConfigured = pubsubTopics.some((topic) => this.configuredPubSubTopics.includes(topic));
    return isTopicConfigured;
  }
  async getPeerShardInfo(peerId2, peerStore) {
    const peer = await peerStore.get(peerId2);
    const shardInfoBytes = peer.metadata.get("shardInfo");
    if (!shardInfoBytes)
      return void 0;
    return decodeRelayShard(shardInfoBytes);
  }
};
__publicField(_ConnectionManager, "instances", /* @__PURE__ */ new Map());
var ConnectionManager = _ConnectionManager;

// node_modules/@waku/core/dist/lib/waku.js
var DefaultPingKeepAliveValueSecs = 5 * 60;
var DefaultRelayKeepAliveValueSecs = 5 * 60;
var DefaultUserAgent = "js-waku";
var log4 = new Logger("waku");
var WakuNode = class {
  constructor(options, pubsubTopics, libp2p, store, lightPush, filter2, relay) {
    __publicField(this, "pubsubTopics");
    __publicField(this, "libp2p");
    __publicField(this, "relay");
    __publicField(this, "store");
    __publicField(this, "filter");
    __publicField(this, "lightPush");
    __publicField(this, "connectionManager");
    this.pubsubTopics = pubsubTopics;
    this.libp2p = libp2p;
    if (store) {
      this.store = store(libp2p);
    }
    if (filter2) {
      this.filter = filter2(libp2p);
    }
    if (lightPush) {
      this.lightPush = lightPush(libp2p);
    }
    if (relay) {
      this.relay = relay(libp2p);
    }
    const pingKeepAlive = options.pingKeepAlive || DefaultPingKeepAliveValueSecs;
    const relayKeepAlive = this.relay ? options.relayKeepAlive || DefaultRelayKeepAliveValueSecs : 0;
    const peerId2 = this.libp2p.peerId.toString();
    this.connectionManager = ConnectionManager.create(peerId2, libp2p, { pingKeepAlive, relayKeepAlive }, pubsubTopics, this.relay);
    log4.info("Waku node created", peerId2, `relay: ${!!this.relay}, store: ${!!this.store}, light push: ${!!this.lightPush}, filter: ${!!this.filter}`);
  }
  /**
   * Dials to the provided peer.
   *
   * @param peer The peer to dial
   * @param protocols Waku protocols we expect from the peer; Defaults to mounted protocols
   */
  async dial(peer, protocols) {
    const _protocols = protocols ?? [];
    const peerId2 = mapToPeerIdOrMultiaddr(peer);
    if (typeof protocols === "undefined") {
      this.relay && _protocols.push(Protocols.Relay);
      this.store && _protocols.push(Protocols.Store);
      this.filter && _protocols.push(Protocols.Filter);
      this.lightPush && _protocols.push(Protocols.LightPush);
    }
    const codecs = [];
    if (_protocols.includes(Protocols.Relay)) {
      if (this.relay) {
        this.relay.gossipSub.multicodecs.forEach((codec) => codecs.push(codec));
      } else {
        log4.error("Relay codec not included in dial codec: protocol not mounted locally");
      }
    }
    if (_protocols.includes(Protocols.Store)) {
      if (this.store) {
        codecs.push(this.store.multicodec);
      } else {
        log4.error("Store codec not included in dial codec: protocol not mounted locally");
      }
    }
    if (_protocols.includes(Protocols.LightPush)) {
      if (this.lightPush) {
        codecs.push(this.lightPush.multicodec);
      } else {
        log4.error("Light Push codec not included in dial codec: protocol not mounted locally");
      }
    }
    if (_protocols.includes(Protocols.Filter)) {
      if (this.filter) {
        codecs.push(this.filter.multicodec);
      } else {
        log4.error("Filter codec not included in dial codec: protocol not mounted locally");
      }
    }
    log4.info(`Dialing to ${peerId2.toString()} with protocols ${_protocols}`);
    return this.libp2p.dialProtocol(peerId2, codecs);
  }
  async start() {
    await this.libp2p.start();
  }
  async stop() {
    this.connectionManager.stop();
    await this.libp2p.stop();
  }
  isStarted() {
    return this.libp2p.isStarted();
  }
  /**
   * Return the local multiaddr with peer id on which libp2p is listening.
   *
   * @throws if libp2p is not listening on localhost.
   */
  getLocalMultiaddrWithID() {
    const localMultiaddr = this.libp2p.getMultiaddrs().find((addr) => addr.toString().match(/127\.0\.0\.1/));
    if (!localMultiaddr || localMultiaddr.toString() === "") {
      throw "Not listening on localhost";
    }
    return localMultiaddr + "/p2p/" + this.libp2p.peerId.toString();
  }
};
function mapToPeerIdOrMultiaddr(peerId2) {
  return isPeerId(peerId2) ? peerId2 : multiaddr(peerId2);
}

// node_modules/@waku/core/dist/lib/message/index.js
var message_exports2 = {};
__export(message_exports2, {
  version_0: () => version_0_exports
});

// node_modules/@waku/core/dist/lib/filter/index.js
var filter_exports2 = {};
__export(filter_exports2, {
  FilterCodecs: () => FilterCodecs,
  wakuFilter: () => wakuFilter
});

// node_modules/it-all/dist/src/index.js
function isAsyncIterable(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function all(source) {
  if (isAsyncIterable(source)) {
    return (async () => {
      const arr2 = [];
      for await (const entry of source) {
        arr2.push(entry);
      }
      return arr2;
    })();
  }
  const arr = [];
  for (const entry of source) {
    arr.push(entry);
  }
  return arr;
}
var src_default = all;

// node_modules/uint8arraylist/dist/src/index.js
var symbol = Symbol.for("@achingbrain/uint8arraylist");
function findBufAndOffset(bufs, index) {
  if (index == null || index < 0) {
    throw new RangeError("index is out of bounds");
  }
  let offset = 0;
  for (const buf of bufs) {
    const bufEnd = offset + buf.byteLength;
    if (index < bufEnd) {
      return {
        buf,
        index: index - offset
      };
    }
    offset = bufEnd;
  }
  throw new RangeError("index is out of bounds");
}
function isUint8ArrayList(value) {
  return Boolean(value == null ? void 0 : value[symbol]);
}
var Uint8ArrayList = class _Uint8ArrayList {
  constructor(...data) {
    Object.defineProperty(this, symbol, { value: true });
    this.bufs = [];
    this.length = 0;
    if (data.length > 0) {
      this.appendAll(data);
    }
  }
  *[Symbol.iterator]() {
    yield* this.bufs;
  }
  get byteLength() {
    return this.length;
  }
  /**
   * Add one or more `bufs` to the end of this Uint8ArrayList
   */
  append(...bufs) {
    this.appendAll(bufs);
  }
  /**
   * Add all `bufs` to the end of this Uint8ArrayList
   */
  appendAll(bufs) {
    let length4 = 0;
    for (const buf of bufs) {
      if (buf instanceof Uint8Array) {
        length4 += buf.byteLength;
        this.bufs.push(buf);
      } else if (isUint8ArrayList(buf)) {
        length4 += buf.byteLength;
        this.bufs.push(...buf.bufs);
      } else {
        throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");
      }
    }
    this.length += length4;
  }
  /**
   * Add one or more `bufs` to the start of this Uint8ArrayList
   */
  prepend(...bufs) {
    this.prependAll(bufs);
  }
  /**
   * Add all `bufs` to the start of this Uint8ArrayList
   */
  prependAll(bufs) {
    let length4 = 0;
    for (const buf of bufs.reverse()) {
      if (buf instanceof Uint8Array) {
        length4 += buf.byteLength;
        this.bufs.unshift(buf);
      } else if (isUint8ArrayList(buf)) {
        length4 += buf.byteLength;
        this.bufs.unshift(...buf.bufs);
      } else {
        throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");
      }
    }
    this.length += length4;
  }
  /**
   * Read the value at `index`
   */
  get(index) {
    const res = findBufAndOffset(this.bufs, index);
    return res.buf[res.index];
  }
  /**
   * Set the value at `index` to `value`
   */
  set(index, value) {
    const res = findBufAndOffset(this.bufs, index);
    res.buf[res.index] = value;
  }
  /**
   * Copy bytes from `buf` to the index specified by `offset`
   */
  write(buf, offset = 0) {
    if (buf instanceof Uint8Array) {
      for (let i = 0; i < buf.length; i++) {
        this.set(offset + i, buf[i]);
      }
    } else if (isUint8ArrayList(buf)) {
      for (let i = 0; i < buf.length; i++) {
        this.set(offset + i, buf.get(i));
      }
    } else {
      throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList");
    }
  }
  /**
   * Remove bytes from the front of the pool
   */
  consume(bytes2) {
    bytes2 = Math.trunc(bytes2);
    if (Number.isNaN(bytes2) || bytes2 <= 0) {
      return;
    }
    if (bytes2 === this.byteLength) {
      this.bufs = [];
      this.length = 0;
      return;
    }
    while (this.bufs.length > 0) {
      if (bytes2 >= this.bufs[0].byteLength) {
        bytes2 -= this.bufs[0].byteLength;
        this.length -= this.bufs[0].byteLength;
        this.bufs.shift();
      } else {
        this.bufs[0] = this.bufs[0].subarray(bytes2);
        this.length -= bytes2;
        break;
      }
    }
  }
  /**
   * Extracts a section of an array and returns a new array.
   *
   * This is a copy operation as it is with Uint8Arrays and Arrays
   * - note this is different to the behaviour of Node Buffers.
   */
  slice(beginInclusive, endExclusive) {
    const { bufs, length: length4 } = this._subList(beginInclusive, endExclusive);
    return concat(bufs, length4);
  }
  /**
   * Returns a alloc from the given start and end element index.
   *
   * In the best case where the data extracted comes from a single Uint8Array
   * internally this is a no-copy operation otherwise it is a copy operation.
   */
  subarray(beginInclusive, endExclusive) {
    const { bufs, length: length4 } = this._subList(beginInclusive, endExclusive);
    if (bufs.length === 1) {
      return bufs[0];
    }
    return concat(bufs, length4);
  }
  /**
   * Returns a allocList from the given start and end element index.
   *
   * This is a no-copy operation.
   */
  sublist(beginInclusive, endExclusive) {
    const { bufs, length: length4 } = this._subList(beginInclusive, endExclusive);
    const list = new _Uint8ArrayList();
    list.length = length4;
    list.bufs = bufs;
    return list;
  }
  _subList(beginInclusive, endExclusive) {
    beginInclusive = beginInclusive ?? 0;
    endExclusive = endExclusive ?? this.length;
    if (beginInclusive < 0) {
      beginInclusive = this.length + beginInclusive;
    }
    if (endExclusive < 0) {
      endExclusive = this.length + endExclusive;
    }
    if (beginInclusive < 0 || endExclusive > this.length) {
      throw new RangeError("index is out of bounds");
    }
    if (beginInclusive === endExclusive) {
      return { bufs: [], length: 0 };
    }
    if (beginInclusive === 0 && endExclusive === this.length) {
      return { bufs: [...this.bufs], length: this.length };
    }
    const bufs = [];
    let offset = 0;
    for (let i = 0; i < this.bufs.length; i++) {
      const buf = this.bufs[i];
      const bufStart = offset;
      const bufEnd = bufStart + buf.byteLength;
      offset = bufEnd;
      if (beginInclusive >= bufEnd) {
        continue;
      }
      const sliceStartInBuf = beginInclusive >= bufStart && beginInclusive < bufEnd;
      const sliceEndsInBuf = endExclusive > bufStart && endExclusive <= bufEnd;
      if (sliceStartInBuf && sliceEndsInBuf) {
        if (beginInclusive === bufStart && endExclusive === bufEnd) {
          bufs.push(buf);
          break;
        }
        const start = beginInclusive - bufStart;
        bufs.push(buf.subarray(start, start + (endExclusive - beginInclusive)));
        break;
      }
      if (sliceStartInBuf) {
        if (beginInclusive === 0) {
          bufs.push(buf);
          continue;
        }
        bufs.push(buf.subarray(beginInclusive - bufStart));
        continue;
      }
      if (sliceEndsInBuf) {
        if (endExclusive === bufEnd) {
          bufs.push(buf);
          break;
        }
        bufs.push(buf.subarray(0, endExclusive - bufStart));
        break;
      }
      bufs.push(buf);
    }
    return { bufs, length: endExclusive - beginInclusive };
  }
  indexOf(search, offset = 0) {
    if (!isUint8ArrayList(search) && !(search instanceof Uint8Array)) {
      throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');
    }
    const needle = search instanceof Uint8Array ? search : search.subarray();
    offset = Number(offset ?? 0);
    if (isNaN(offset)) {
      offset = 0;
    }
    if (offset < 0) {
      offset = this.length + offset;
    }
    if (offset < 0) {
      offset = 0;
    }
    if (search.length === 0) {
      return offset > this.length ? this.length : offset;
    }
    const M = needle.byteLength;
    if (M === 0) {
      throw new TypeError("search must be at least 1 byte long");
    }
    const radix = 256;
    const rightmostPositions = new Int32Array(radix);
    for (let c = 0; c < radix; c++) {
      rightmostPositions[c] = -1;
    }
    for (let j = 0; j < M; j++) {
      rightmostPositions[needle[j]] = j;
    }
    const right = rightmostPositions;
    const lastIndex = this.byteLength - needle.byteLength;
    const lastPatIndex = needle.byteLength - 1;
    let skip;
    for (let i = offset; i <= lastIndex; i += skip) {
      skip = 0;
      for (let j = lastPatIndex; j >= 0; j--) {
        const char = this.get(i + j);
        if (needle[j] !== char) {
          skip = Math.max(1, j - right[char]);
          break;
        }
      }
      if (skip === 0) {
        return i;
      }
    }
    return -1;
  }
  getInt8(byteOffset) {
    const buf = this.subarray(byteOffset, byteOffset + 1);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    return view.getInt8(0);
  }
  setInt8(byteOffset, value) {
    const buf = allocUnsafe(1);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    view.setInt8(0, value);
    this.write(buf, byteOffset);
  }
  getInt16(byteOffset, littleEndian) {
    const buf = this.subarray(byteOffset, byteOffset + 2);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    return view.getInt16(0, littleEndian);
  }
  setInt16(byteOffset, value, littleEndian) {
    const buf = alloc(2);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    view.setInt16(0, value, littleEndian);
    this.write(buf, byteOffset);
  }
  getInt32(byteOffset, littleEndian) {
    const buf = this.subarray(byteOffset, byteOffset + 4);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    return view.getInt32(0, littleEndian);
  }
  setInt32(byteOffset, value, littleEndian) {
    const buf = alloc(4);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    view.setInt32(0, value, littleEndian);
    this.write(buf, byteOffset);
  }
  getBigInt64(byteOffset, littleEndian) {
    const buf = this.subarray(byteOffset, byteOffset + 8);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    return view.getBigInt64(0, littleEndian);
  }
  setBigInt64(byteOffset, value, littleEndian) {
    const buf = alloc(8);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    view.setBigInt64(0, value, littleEndian);
    this.write(buf, byteOffset);
  }
  getUint8(byteOffset) {
    const buf = this.subarray(byteOffset, byteOffset + 1);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    return view.getUint8(0);
  }
  setUint8(byteOffset, value) {
    const buf = allocUnsafe(1);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    view.setUint8(0, value);
    this.write(buf, byteOffset);
  }
  getUint16(byteOffset, littleEndian) {
    const buf = this.subarray(byteOffset, byteOffset + 2);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    return view.getUint16(0, littleEndian);
  }
  setUint16(byteOffset, value, littleEndian) {
    const buf = alloc(2);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    view.setUint16(0, value, littleEndian);
    this.write(buf, byteOffset);
  }
  getUint32(byteOffset, littleEndian) {
    const buf = this.subarray(byteOffset, byteOffset + 4);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    return view.getUint32(0, littleEndian);
  }
  setUint32(byteOffset, value, littleEndian) {
    const buf = alloc(4);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    view.setUint32(0, value, littleEndian);
    this.write(buf, byteOffset);
  }
  getBigUint64(byteOffset, littleEndian) {
    const buf = this.subarray(byteOffset, byteOffset + 8);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    return view.getBigUint64(0, littleEndian);
  }
  setBigUint64(byteOffset, value, littleEndian) {
    const buf = alloc(8);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    view.setBigUint64(0, value, littleEndian);
    this.write(buf, byteOffset);
  }
  getFloat32(byteOffset, littleEndian) {
    const buf = this.subarray(byteOffset, byteOffset + 4);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    return view.getFloat32(0, littleEndian);
  }
  setFloat32(byteOffset, value, littleEndian) {
    const buf = alloc(4);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    view.setFloat32(0, value, littleEndian);
    this.write(buf, byteOffset);
  }
  getFloat64(byteOffset, littleEndian) {
    const buf = this.subarray(byteOffset, byteOffset + 8);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    return view.getFloat64(0, littleEndian);
  }
  setFloat64(byteOffset, value, littleEndian) {
    const buf = alloc(8);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    view.setFloat64(0, value, littleEndian);
    this.write(buf, byteOffset);
  }
  equals(other) {
    if (other == null) {
      return false;
    }
    if (!(other instanceof _Uint8ArrayList)) {
      return false;
    }
    if (other.bufs.length !== this.bufs.length) {
      return false;
    }
    for (let i = 0; i < this.bufs.length; i++) {
      if (!equals(this.bufs[i], other.bufs[i])) {
        return false;
      }
    }
    return true;
  }
  /**
   * Create a Uint8ArrayList from a pre-existing list of Uint8Arrays.  Use this
   * method if you know the total size of all the Uint8Arrays ahead of time.
   */
  static fromUint8Arrays(bufs, length4) {
    const list = new _Uint8ArrayList();
    list.bufs = bufs;
    if (length4 == null) {
      length4 = bufs.reduce((acc, curr) => acc + curr.byteLength, 0);
    }
    list.length = length4;
    return list;
  }
};

// node_modules/it-length-prefixed/dist/src/utils.js
function isAsyncIterable2(thing) {
  return thing[Symbol.asyncIterator] != null;
}

// node_modules/it-length-prefixed/dist/src/encode.js
var defaultEncoder = (length4) => {
  const lengthLength = encodingLength(length4);
  const lengthBuf = allocUnsafe(lengthLength);
  encode(length4, lengthBuf);
  defaultEncoder.bytes = lengthLength;
  return lengthBuf;
};
defaultEncoder.bytes = 0;
function encode2(source, options) {
  options = options ?? {};
  const encodeLength = options.lengthEncoder ?? defaultEncoder;
  function* maybeYield(chunk) {
    const length4 = encodeLength(chunk.byteLength);
    if (length4 instanceof Uint8Array) {
      yield length4;
    } else {
      yield* length4;
    }
    if (chunk instanceof Uint8Array) {
      yield chunk;
    } else {
      yield* chunk;
    }
  }
  if (isAsyncIterable2(source)) {
    return async function* () {
      for await (const chunk of source) {
        yield* maybeYield(chunk);
      }
    }();
  }
  return function* () {
    for (const chunk of source) {
      yield* maybeYield(chunk);
    }
  }();
}
encode2.single = (chunk, options) => {
  options = options ?? {};
  const encodeLength = options.lengthEncoder ?? defaultEncoder;
  return new Uint8ArrayList(encodeLength(chunk.byteLength), chunk);
};

// node_modules/it-length-prefixed/dist/src/decode.js
var import_err_code = __toESM(require_err_code(), 1);
var MAX_LENGTH_LENGTH = 8;
var MAX_DATA_LENGTH = 1024 * 1024 * 4;
var ReadMode;
(function(ReadMode2) {
  ReadMode2[ReadMode2["LENGTH"] = 0] = "LENGTH";
  ReadMode2[ReadMode2["DATA"] = 1] = "DATA";
})(ReadMode || (ReadMode = {}));
var defaultDecoder = (buf) => {
  const length4 = decode(buf);
  defaultDecoder.bytes = encodingLength(length4);
  return length4;
};
defaultDecoder.bytes = 0;
function decode2(source, options) {
  const buffer = new Uint8ArrayList();
  let mode = ReadMode.LENGTH;
  let dataLength = -1;
  const lengthDecoder = (options == null ? void 0 : options.lengthDecoder) ?? defaultDecoder;
  const maxLengthLength = (options == null ? void 0 : options.maxLengthLength) ?? MAX_LENGTH_LENGTH;
  const maxDataLength = (options == null ? void 0 : options.maxDataLength) ?? MAX_DATA_LENGTH;
  function* maybeYield() {
    while (buffer.byteLength > 0) {
      if (mode === ReadMode.LENGTH) {
        try {
          dataLength = lengthDecoder(buffer);
          if (dataLength < 0) {
            throw (0, import_err_code.default)(new Error("invalid message length"), "ERR_INVALID_MSG_LENGTH");
          }
          if (dataLength > maxDataLength) {
            throw (0, import_err_code.default)(new Error("message length too long"), "ERR_MSG_DATA_TOO_LONG");
          }
          const dataLengthLength = lengthDecoder.bytes;
          buffer.consume(dataLengthLength);
          if ((options == null ? void 0 : options.onLength) != null) {
            options.onLength(dataLength);
          }
          mode = ReadMode.DATA;
        } catch (err) {
          if (err instanceof RangeError) {
            if (buffer.byteLength > maxLengthLength) {
              throw (0, import_err_code.default)(new Error("message length length too long"), "ERR_MSG_LENGTH_TOO_LONG");
            }
            break;
          }
          throw err;
        }
      }
      if (mode === ReadMode.DATA) {
        if (buffer.byteLength < dataLength) {
          break;
        }
        const data = buffer.sublist(0, dataLength);
        buffer.consume(dataLength);
        if ((options == null ? void 0 : options.onData) != null) {
          options.onData(data);
        }
        yield data;
        mode = ReadMode.LENGTH;
      }
    }
  }
  if (isAsyncIterable2(source)) {
    return async function* () {
      for await (const buf of source) {
        buffer.append(buf);
        yield* maybeYield();
      }
      if (buffer.byteLength > 0) {
        throw (0, import_err_code.default)(new Error("unexpected end of input"), "ERR_UNEXPECTED_EOF");
      }
    }();
  }
  return function* () {
    for (const buf of source) {
      buffer.append(buf);
      yield* maybeYield();
    }
    if (buffer.byteLength > 0) {
      throw (0, import_err_code.default)(new Error("unexpected end of input"), "ERR_UNEXPECTED_EOF");
    }
  }();
}
decode2.fromReader = (reader2, options) => {
  let byteLength = 1;
  const varByteSource = async function* () {
    while (true) {
      try {
        const { done, value } = await reader2.next(byteLength);
        if (done === true) {
          return;
        }
        if (value != null) {
          yield value;
        }
      } catch (err) {
        if (err.code === "ERR_UNDER_READ") {
          return { done: true, value: null };
        }
        throw err;
      } finally {
        byteLength = 1;
      }
    }
  }();
  const onLength = (l) => {
    byteLength = l;
  };
  return decode2(varByteSource, {
    ...options ?? {},
    onLength
  });
};

// node_modules/p-defer/index.js
function pDefer() {
  const deferred = {};
  deferred.promise = new Promise((resolve, reject) => {
    deferred.resolve = resolve;
    deferred.reject = reject;
  });
  return deferred;
}

// node_modules/it-pushable/dist/src/fifo.js
var FixedFIFO = class {
  constructor(hwm) {
    __publicField(this, "buffer");
    __publicField(this, "mask");
    __publicField(this, "top");
    __publicField(this, "btm");
    __publicField(this, "next");
    if (!(hwm > 0) || (hwm - 1 & hwm) !== 0) {
      throw new Error("Max size for a FixedFIFO should be a power of two");
    }
    this.buffer = new Array(hwm);
    this.mask = hwm - 1;
    this.top = 0;
    this.btm = 0;
    this.next = null;
  }
  push(data) {
    if (this.buffer[this.top] !== void 0) {
      return false;
    }
    this.buffer[this.top] = data;
    this.top = this.top + 1 & this.mask;
    return true;
  }
  shift() {
    const last = this.buffer[this.btm];
    if (last === void 0) {
      return void 0;
    }
    this.buffer[this.btm] = void 0;
    this.btm = this.btm + 1 & this.mask;
    return last;
  }
  isEmpty() {
    return this.buffer[this.btm] === void 0;
  }
};
var FIFO = class {
  constructor(options = {}) {
    __publicField(this, "size");
    __publicField(this, "hwm");
    __publicField(this, "head");
    __publicField(this, "tail");
    this.hwm = options.splitLimit ?? 16;
    this.head = new FixedFIFO(this.hwm);
    this.tail = this.head;
    this.size = 0;
  }
  calculateSize(obj) {
    if ((obj == null ? void 0 : obj.byteLength) != null) {
      return obj.byteLength;
    }
    return 1;
  }
  push(val) {
    if ((val == null ? void 0 : val.value) != null) {
      this.size += this.calculateSize(val.value);
    }
    if (!this.head.push(val)) {
      const prev = this.head;
      this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length);
      this.head.push(val);
    }
  }
  shift() {
    let val = this.tail.shift();
    if (val === void 0 && this.tail.next != null) {
      const next = this.tail.next;
      this.tail.next = null;
      this.tail = next;
      val = this.tail.shift();
    }
    if ((val == null ? void 0 : val.value) != null) {
      this.size -= this.calculateSize(val.value);
    }
    return val;
  }
  isEmpty() {
    return this.head.isEmpty();
  }
};

// node_modules/it-pushable/dist/src/index.js
var AbortError2 = class extends Error {
  constructor(message2, code2) {
    super(message2 ?? "The operation was aborted");
    __publicField(this, "type");
    __publicField(this, "code");
    this.type = "aborted";
    this.code = code2 ?? "ABORT_ERR";
  }
};
function pushable(options = {}) {
  const getNext = (buffer) => {
    const next = buffer.shift();
    if (next == null) {
      return { done: true };
    }
    if (next.error != null) {
      throw next.error;
    }
    return {
      done: next.done === true,
      // @ts-expect-error if done is false, value will be present
      value: next.value
    };
  };
  return _pushable(getNext, options);
}
function pushableV(options = {}) {
  const getNext = (buffer) => {
    let next;
    const values = [];
    while (!buffer.isEmpty()) {
      next = buffer.shift();
      if (next == null) {
        break;
      }
      if (next.error != null) {
        throw next.error;
      }
      if (next.done === false) {
        values.push(next.value);
      }
    }
    if (next == null) {
      return { done: true };
    }
    return {
      done: next.done === true,
      value: values
    };
  };
  return _pushable(getNext, options);
}
function _pushable(getNext, options) {
  options = options ?? {};
  let onEnd = options.onEnd;
  let buffer = new FIFO();
  let pushable3;
  let onNext;
  let ended;
  let drain2 = pDefer();
  const waitNext = async () => {
    try {
      if (!buffer.isEmpty()) {
        return getNext(buffer);
      }
      if (ended) {
        return { done: true };
      }
      return await new Promise((resolve, reject) => {
        onNext = (next) => {
          onNext = null;
          buffer.push(next);
          try {
            resolve(getNext(buffer));
          } catch (err) {
            reject(err);
          }
          return pushable3;
        };
      });
    } finally {
      if (buffer.isEmpty()) {
        queueMicrotask(() => {
          drain2.resolve();
          drain2 = pDefer();
        });
      }
    }
  };
  const bufferNext = (next) => {
    if (onNext != null) {
      return onNext(next);
    }
    buffer.push(next);
    return pushable3;
  };
  const bufferError = (err) => {
    buffer = new FIFO();
    if (onNext != null) {
      return onNext({ error: err });
    }
    buffer.push({ error: err });
    return pushable3;
  };
  const push = (value) => {
    if (ended) {
      return pushable3;
    }
    if ((options == null ? void 0 : options.objectMode) !== true && (value == null ? void 0 : value.byteLength) == null) {
      throw new Error("objectMode was not true but tried to push non-Uint8Array value");
    }
    return bufferNext({ done: false, value });
  };
  const end = (err) => {
    if (ended)
      return pushable3;
    ended = true;
    return err != null ? bufferError(err) : bufferNext({ done: true });
  };
  const _return = () => {
    buffer = new FIFO();
    end();
    return { done: true };
  };
  const _throw = (err) => {
    end(err);
    return { done: true };
  };
  pushable3 = {
    [Symbol.asyncIterator]() {
      return this;
    },
    next: waitNext,
    return: _return,
    throw: _throw,
    push,
    end,
    get readableLength() {
      return buffer.size;
    },
    onEmpty: async (options2) => {
      const signal = options2 == null ? void 0 : options2.signal;
      signal == null ? void 0 : signal.throwIfAborted();
      if (buffer.isEmpty()) {
        return;
      }
      let cancel;
      let listener;
      if (signal != null) {
        cancel = new Promise((resolve, reject) => {
          listener = () => {
            reject(new AbortError2());
          };
          signal.addEventListener("abort", listener);
        });
      }
      try {
        await Promise.race([
          drain2.promise,
          cancel
        ]);
      } finally {
        if (listener != null && signal != null) {
          signal == null ? void 0 : signal.removeEventListener("abort", listener);
        }
      }
    }
  };
  if (onEnd == null) {
    return pushable3;
  }
  const _pushable2 = pushable3;
  pushable3 = {
    [Symbol.asyncIterator]() {
      return this;
    },
    next() {
      return _pushable2.next();
    },
    throw(err) {
      _pushable2.throw(err);
      if (onEnd != null) {
        onEnd(err);
        onEnd = void 0;
      }
      return { done: true };
    },
    return() {
      _pushable2.return();
      if (onEnd != null) {
        onEnd();
        onEnd = void 0;
      }
      return { done: true };
    },
    push,
    end(err) {
      _pushable2.end(err);
      if (onEnd != null) {
        onEnd(err);
        onEnd = void 0;
      }
      return pushable3;
    },
    get readableLength() {
      return _pushable2.readableLength;
    },
    onEmpty: (opts) => {
      return _pushable2.onEmpty(opts);
    }
  };
  return pushable3;
}

// node_modules/it-merge/dist/src/index.js
function isAsyncIterable3(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function merge(...sources) {
  const syncSources = [];
  for (const source of sources) {
    if (!isAsyncIterable3(source)) {
      syncSources.push(source);
    }
  }
  if (syncSources.length === sources.length) {
    return function* () {
      for (const source of syncSources) {
        yield* source;
      }
    }();
  }
  return async function* () {
    const output2 = pushable({
      objectMode: true
    });
    void Promise.resolve().then(async () => {
      try {
        await Promise.all(sources.map(async (source) => {
          for await (const item of source) {
            output2.push(item);
          }
        }));
        output2.end();
      } catch (err) {
        output2.end(err);
      }
    });
    yield* output2;
  }();
}
var src_default2 = merge;

// node_modules/it-pipe/dist/src/index.js
function pipe(first2, ...rest) {
  if (first2 == null) {
    throw new Error("Empty pipeline");
  }
  if (isDuplex(first2)) {
    const duplex = first2;
    first2 = () => duplex.source;
  } else if (isIterable(first2) || isAsyncIterable4(first2)) {
    const source = first2;
    first2 = () => source;
  }
  const fns = [first2, ...rest];
  if (fns.length > 1) {
    if (isDuplex(fns[fns.length - 1])) {
      fns[fns.length - 1] = fns[fns.length - 1].sink;
    }
  }
  if (fns.length > 2) {
    for (let i = 1; i < fns.length - 1; i++) {
      if (isDuplex(fns[i])) {
        fns[i] = duplexPipelineFn(fns[i]);
      }
    }
  }
  return rawPipe(...fns);
}
var rawPipe = (...fns) => {
  let res;
  while (fns.length > 0) {
    res = fns.shift()(res);
  }
  return res;
};
var isAsyncIterable4 = (obj) => {
  return (obj == null ? void 0 : obj[Symbol.asyncIterator]) != null;
};
var isIterable = (obj) => {
  return (obj == null ? void 0 : obj[Symbol.iterator]) != null;
};
var isDuplex = (obj) => {
  if (obj == null) {
    return false;
  }
  return obj.sink != null && obj.source != null;
};
var duplexPipelineFn = (duplex) => {
  return (source) => {
    const p = duplex.sink(source);
    if ((p == null ? void 0 : p.then) != null) {
      const stream = pushable({
        objectMode: true
      });
      p.then(() => {
        stream.end();
      }, (err) => {
        stream.end(err);
      });
      let sourceWrap;
      const source2 = duplex.source;
      if (isAsyncIterable4(source2)) {
        sourceWrap = async function* () {
          yield* source2;
          stream.end();
        };
      } else if (isIterable(source2)) {
        sourceWrap = function* () {
          yield* source2;
          stream.end();
        };
      } else {
        throw new Error("Unknown duplex source type - must be Iterable or AsyncIterable");
      }
      return src_default2(stream, sourceWrap());
    }
    return duplex.source;
  };
};

// node_modules/@waku/utils/dist/libp2p/index.js
function selectRandomPeer(peers) {
  if (peers.length === 0)
    return;
  const index = Math.round(Math.random() * (peers.length - 1));
  return peers[index];
}
async function selectLowestLatencyPeer(peerStore, peers) {
  if (peers.length === 0)
    return;
  const results = await Promise.all(peers.map(async (peer) => {
    const pingBytes = (await peerStore.get(peer.id)).metadata.get("ping");
    if (!pingBytes)
      return { peer, ping: Infinity };
    const ping = Number(bytesToUtf8(pingBytes)) ?? Infinity;
    return { peer, ping };
  }));
  const lowestLatencyResult = results.sort((a, b) => a.ping - b.ping)[0];
  if (!lowestLatencyResult) {
    return void 0;
  }
  return lowestLatencyResult.ping !== Infinity ? lowestLatencyResult.peer : void 0;
}
async function getPeersForProtocol(peerStore, protocols) {
  const peers = [];
  await peerStore.forEach((peer) => {
    for (let i = 0; i < protocols.length; i++) {
      if (peer.protocols.includes(protocols[i])) {
        peers.push(peer);
        break;
      }
    }
  });
  return peers;
}
async function selectPeerForProtocol(peerStore, protocols, peerId2) {
  let peer;
  if (peerId2) {
    peer = await peerStore.get(peerId2);
    if (!peer) {
      throw new Error(`Failed to retrieve connection details for provided peer in peer store: ${peerId2.toString()}`);
    }
  } else {
    const peers = await getPeersForProtocol(peerStore, protocols);
    peer = await selectLowestLatencyPeer(peerStore, peers);
    if (!peer) {
      peer = selectRandomPeer(peers);
      if (!peer)
        throw new Error(`Failed to find known peer that registers protocols: ${protocols}`);
    }
  }
  let protocol;
  for (const codec of protocols) {
    if (peer.protocols.includes(codec)) {
      protocol = codec;
    }
  }
  if (!protocol) {
    throw new Error(`Peer does not register required protocols (${peer.id.toString()}): ${protocols}`);
  }
  return { peer, protocol };
}
function selectConnection(connections) {
  if (!connections.length)
    return;
  if (connections.length === 1)
    return connections[0];
  let latestConnection;
  connections.forEach((connection) => {
    if (connection.status === "open") {
      if (!latestConnection) {
        latestConnection = connection;
      } else if (connection.timeline.open > latestConnection.timeline.open) {
        latestConnection = connection;
      }
    }
  });
  return latestConnection;
}

// node_modules/@waku/core/dist/lib/filterPeers.js
async function filterPeers(peers, numPeers, maxBootstrapPeers) {
  const bootstrapPeers = peers.filter((peer) => peer.tags.has(Tags.BOOTSTRAP)).slice(0, maxBootstrapPeers);
  const nonBootstrapPeers = peers.filter((peer) => !peer.tags.has(Tags.BOOTSTRAP));
  if (numPeers === 0) {
    return [...bootstrapPeers, ...nonBootstrapPeers];
  }
  const selectedPeers = [...bootstrapPeers];
  while (selectedPeers.length < numPeers && nonBootstrapPeers.length > 0) {
    const randomIndex = Math.floor(Math.random() * nonBootstrapPeers.length);
    const randomPeer = nonBootstrapPeers.splice(randomIndex, 1)[0];
    selectedPeers.push(randomPeer);
  }
  return selectedPeers;
}

// node_modules/@waku/core/dist/lib/stream_manager.js
var StreamManager = class {
  constructor(multicodec, getConnections, addEventListener) {
    __publicField(this, "multicodec");
    __publicField(this, "getConnections");
    __publicField(this, "addEventListener");
    __publicField(this, "streamPool");
    __publicField(this, "log");
    __publicField(this, "handlePeerUpdateStreamPool", (evt) => {
      const peer = evt.detail.peer;
      if (peer.protocols.includes(this.multicodec)) {
        this.log.info(`Preemptively opening a stream to ${peer.id.toString()}`);
        this.prepareNewStream(peer);
      }
    });
    this.multicodec = multicodec;
    this.getConnections = getConnections;
    this.addEventListener = addEventListener;
    this.log = new Logger(`stream-manager:${multicodec}`);
    this.addEventListener("peer:update", this.handlePeerUpdateStreamPool.bind(this));
    this.getStream = this.getStream.bind(this);
    this.streamPool = /* @__PURE__ */ new Map();
  }
  async getStream(peer) {
    const peerIdStr = peer.id.toString();
    const streamPromise = this.streamPool.get(peerIdStr);
    if (!streamPromise) {
      return this.newStream(peer);
    }
    this.streamPool.delete(peerIdStr);
    this.prepareNewStream(peer);
    const stream = await streamPromise;
    if (!stream || stream.status === "closed") {
      return this.newStream(peer);
    }
    return stream;
  }
  async newStream(peer) {
    const connections = this.getConnections(peer.id);
    const connection = selectConnection(connections);
    if (!connection) {
      throw new Error("Failed to get a connection to the peer");
    }
    return connection.newStream(this.multicodec);
  }
  prepareNewStream(peer) {
    const streamPromise = this.newStream(peer).catch(() => {
      this.log.error(`Failed to prepare a new stream for ${peer.id.toString()}`);
    });
    this.streamPool.set(peer.id.toString(), streamPromise);
  }
};

// node_modules/@waku/core/dist/lib/base_protocol.js
var BaseProtocol = class {
  constructor(multicodec, components) {
    __publicField(this, "multicodec");
    __publicField(this, "components");
    __publicField(this, "addLibp2pEventListener");
    __publicField(this, "removeLibp2pEventListener");
    __publicField(this, "streamManager");
    this.multicodec = multicodec;
    this.components = components;
    this.addLibp2pEventListener = components.events.addEventListener.bind(components.events);
    this.removeLibp2pEventListener = components.events.removeEventListener.bind(components.events);
    this.streamManager = new StreamManager(multicodec, components.connectionManager.getConnections.bind(components.connectionManager), this.addLibp2pEventListener);
  }
  async getStream(peer) {
    return this.streamManager.getStream(peer);
  }
  get peerStore() {
    return this.components.peerStore;
  }
  /**
   * Returns known peers from the address book (`libp2p.peerStore`) that support
   * the class protocol. Waku may or may not be currently connected to these
   * peers.
   */
  async peers() {
    return getPeersForProtocol(this.peerStore, [this.multicodec]);
  }
  async getPeer(peerId2) {
    const { peer } = await selectPeerForProtocol(this.peerStore, [this.multicodec], peerId2);
    return peer;
  }
  /**
   * Retrieves a list of peers based on the specified criteria.
   *
   * @param numPeers - The total number of peers to retrieve. If 0, all peers are returned.
   * @param maxBootstrapPeers - The maximum number of bootstrap peers to retrieve.
   * @returns A Promise that resolves to an array of peers based on the specified criteria.
   */
  async getPeers({ numPeers, maxBootstrapPeers } = {
    maxBootstrapPeers: 1,
    numPeers: 0
  }) {
    const allPeersForProtocol = await getPeersForProtocol(this.peerStore, [
      this.multicodec
    ]);
    return filterPeers(allPeersForProtocol, numPeers, maxBootstrapPeers);
  }
};

// node_modules/@waku/core/node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/@waku/core/node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

// node_modules/@waku/core/node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate;

// node_modules/@waku/core/node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}

// node_modules/@waku/core/node_modules/uuid/dist/esm-browser/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v;
  const arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
var parse_default = parse;

// node_modules/@waku/core/node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes2 = [];
  for (let i = 0; i < str.length; ++i) {
    bytes2.push(str.charCodeAt(i));
  }
  return bytes2;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(name2, version2, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    var _namespace;
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    let bytes2 = new Uint8Array(16 + value.length);
    bytes2.set(namespace);
    bytes2.set(value, namespace.length);
    bytes2 = hashfunc(bytes2);
    bytes2[6] = bytes2[6] & 15 | version2;
    bytes2[8] = bytes2[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes2[i];
      }
      return buf;
    }
    return unsafeStringify(bytes2);
  }
  try {
    generateUUID.name = name2;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL2;
  return generateUUID;
}

// node_modules/@waku/core/node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes2) {
  if (typeof bytes2 === "string") {
    const msg = unescape(encodeURIComponent(bytes2));
    bytes2 = new Uint8Array(msg.length);
    for (let i = 0; i < msg.length; ++i) {
      bytes2[i] = msg.charCodeAt(i);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes2), bytes2.length * 8));
}
function md5ToHexEncodedArray(input) {
  const output2 = [];
  const length32 = input.length * 32;
  const hexTab = "0123456789abcdef";
  for (let i = 0; i < length32; i += 8) {
    const x = input[i >> 5] >>> i % 32 & 255;
    const hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
    output2.push(hex);
  }
  return output2;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
  x[len >> 5] |= 128 << len % 32;
  x[getOutputLength(len) - 1] = len;
  let a = 1732584193;
  let b = -271733879;
  let c = -1732584194;
  let d = 271733878;
  for (let i = 0; i < x.length; i += 16) {
    const olda = a;
    const oldb = b;
    const oldc = c;
    const oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }
  return [a, b, c, d];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  const length8 = input.length * 8;
  const output2 = new Uint32Array(getOutputLength(length8));
  for (let i = 0; i < length8; i += 8) {
    output2[i >> 5] |= (input[i / 8] & 255) << i % 32;
  }
  return output2;
}
function safeAdd(x, y) {
  const lsw = (x & 65535) + (y & 65535);
  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}
function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}
function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}
function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}
var md5_default = md5;

// node_modules/@waku/core/node_modules/uuid/dist/esm-browser/v3.js
var v3 = v35("v3", 48, md5_default);

// node_modules/@waku/core/node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// node_modules/@waku/core/node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// node_modules/@waku/core/node_modules/uuid/dist/esm-browser/sha1.js
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}
function sha1(bytes2) {
  const K = [1518500249, 1859775393, 2400959708, 3395469782];
  const H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes2 === "string") {
    const msg = unescape(encodeURIComponent(bytes2));
    bytes2 = [];
    for (let i = 0; i < msg.length; ++i) {
      bytes2.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes2)) {
    bytes2 = Array.prototype.slice.call(bytes2);
  }
  bytes2.push(128);
  const l = bytes2.length / 4 + 2;
  const N = Math.ceil(l / 16);
  const M = new Array(N);
  for (let i = 0; i < N; ++i) {
    const arr = new Uint32Array(16);
    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes2[i * 64 + j * 4] << 24 | bytes2[i * 64 + j * 4 + 1] << 16 | bytes2[i * 64 + j * 4 + 2] << 8 | bytes2[i * 64 + j * 4 + 3];
    }
    M[i] = arr;
  }
  M[N - 1][14] = (bytes2.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes2.length - 1) * 8 & 4294967295;
  for (let i = 0; i < N; ++i) {
    const W = new Uint32Array(80);
    for (let t = 0; t < 16; ++t) {
      W[t] = M[i][t];
    }
    for (let t = 16; t < 80; ++t) {
      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }
    let a = H[0];
    let b = H[1];
    let c = H[2];
    let d = H[3];
    let e = H[4];
    for (let t = 0; t < 80; ++t) {
      const s = Math.floor(t / 20);
      const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
}
var sha1_default = sha1;

// node_modules/@waku/core/node_modules/uuid/dist/esm-browser/v5.js
var v5 = v35("v5", 80, sha1_default);

// node_modules/@waku/core/dist/lib/filter/filter_rpc.js
var FilterPushRpc = class _FilterPushRpc {
  constructor(proto) {
    __publicField(this, "proto");
    this.proto = proto;
  }
  static decode(bytes2) {
    const res = filter_v2_exports.MessagePush.decode(bytes2);
    return new _FilterPushRpc(res);
  }
  encode() {
    return filter_v2_exports.MessagePush.encode(this.proto);
  }
  get wakuMessage() {
    return this.proto.wakuMessage;
  }
  /**
   * Get the pubsub topic from the FilterPushRpc object.
   * @returns string
   */
  get pubsubTopic() {
    return this.proto.pubsubTopic;
  }
};
var FilterSubscribeRpc = class _FilterSubscribeRpc {
  constructor(proto) {
    __publicField(this, "proto");
    this.proto = proto;
  }
  static createSubscribeRequest(pubsubTopic, contentTopics) {
    return new _FilterSubscribeRpc({
      requestId: v4_default(),
      filterSubscribeType: filter_v2_exports.FilterSubscribeRequest.FilterSubscribeType.SUBSCRIBE,
      pubsubTopic,
      contentTopics
    });
  }
  static createUnsubscribeRequest(pubsubTopic, contentTopics) {
    return new _FilterSubscribeRpc({
      requestId: v4_default(),
      filterSubscribeType: filter_v2_exports.FilterSubscribeRequest.FilterSubscribeType.UNSUBSCRIBE,
      pubsubTopic,
      contentTopics
    });
  }
  static createUnsubscribeAllRequest(pubsubTopic) {
    return new _FilterSubscribeRpc({
      requestId: v4_default(),
      filterSubscribeType: filter_v2_exports.FilterSubscribeRequest.FilterSubscribeType.UNSUBSCRIBE_ALL,
      pubsubTopic,
      contentTopics: []
    });
  }
  static createSubscriberPingRequest() {
    return new _FilterSubscribeRpc({
      requestId: v4_default(),
      filterSubscribeType: filter_v2_exports.FilterSubscribeRequest.FilterSubscribeType.SUBSCRIBER_PING,
      pubsubTopic: "",
      contentTopics: []
    });
  }
  static decode(bytes2) {
    const res = filter_v2_exports.FilterSubscribeRequest.decode(bytes2);
    return new _FilterSubscribeRpc(res);
  }
  encode() {
    return filter_v2_exports.FilterSubscribeRequest.encode(this.proto);
  }
  get filterSubscribeType() {
    return this.proto.filterSubscribeType;
  }
  get requestId() {
    return this.proto.requestId;
  }
  get pubsubTopic() {
    return this.proto.pubsubTopic;
  }
  get contentTopics() {
    return this.proto.contentTopics;
  }
};
var FilterSubscribeResponse2 = class _FilterSubscribeResponse {
  constructor(proto) {
    __publicField(this, "proto");
    this.proto = proto;
  }
  static decode(bytes2) {
    const res = filter_v2_exports.FilterSubscribeResponse.decode(bytes2);
    return new _FilterSubscribeResponse(res);
  }
  encode() {
    return filter_v2_exports.FilterSubscribeResponse.encode(this.proto);
  }
  get statusCode() {
    return this.proto.statusCode;
  }
  get statusDesc() {
    return this.proto.statusDesc;
  }
  get requestId() {
    return this.proto.requestId;
  }
};

// node_modules/@waku/core/dist/lib/filter/index.js
var log5 = new Logger("filter:v2");
var FilterCodecs = {
  SUBSCRIBE: "/vac/waku/filter-subscribe/2.0.0-beta1",
  PUSH: "/vac/waku/filter-push/2.0.0-beta1"
};
var Subscription = class {
  constructor(pubsubTopic, remotePeer, newStream) {
    __publicField(this, "peer");
    __publicField(this, "pubsubTopic");
    __publicField(this, "newStream");
    __publicField(this, "subscriptionCallbacks");
    this.peer = remotePeer;
    this.pubsubTopic = pubsubTopic;
    this.newStream = newStream;
    this.subscriptionCallbacks = /* @__PURE__ */ new Map();
  }
  async subscribe(decoders, callback) {
    const decodersArray = Array.isArray(decoders) ? decoders : [decoders];
    decodersArray.forEach((decoder) => {
      if (decoder.pubsubTopic !== this.pubsubTopic) {
        throw new Error(`Pubsub topic not configured: decoder is configured for pubsub topic ${decoder.pubsubTopic} but this subscription is for pubsub topic ${this.pubsubTopic}. Please create a new Subscription for the different pubsub topic.`);
      }
    });
    const decodersGroupedByCT = groupByContentTopic(decodersArray);
    const contentTopics = Array.from(decodersGroupedByCT.keys());
    const stream = await this.newStream(this.peer);
    const request2 = FilterSubscribeRpc.createSubscribeRequest(this.pubsubTopic, contentTopics);
    try {
      const res = await pipe([request2.encode()], encode2, stream, decode2, async (source) => await src_default(source));
      if (!res || !res.length) {
        throw Error(`No response received for request ${request2.requestId}: ${res}`);
      }
      const { statusCode, requestId, statusDesc } = FilterSubscribeResponse2.decode(res[0].slice());
      if (statusCode < 200 || statusCode >= 300) {
        throw new Error(`Filter subscribe request ${requestId} failed with status code ${statusCode}: ${statusDesc}`);
      }
      log5.info("Subscribed to peer ", this.peer.id.toString(), "for content topics", contentTopics);
    } catch (e) {
      throw new Error("Error subscribing to peer: " + this.peer.id.toString() + " for content topics: " + contentTopics + ": " + e);
    }
    decodersGroupedByCT.forEach((decoders2, contentTopic) => {
      const subscriptionCallback = {
        decoders: decoders2,
        callback
      };
      this.subscriptionCallbacks.set(contentTopic, subscriptionCallback);
    });
  }
  async unsubscribe(contentTopics) {
    const stream = await this.newStream(this.peer);
    const unsubscribeRequest = FilterSubscribeRpc.createUnsubscribeRequest(this.pubsubTopic, contentTopics);
    try {
      await pipe([unsubscribeRequest.encode()], encode2, stream.sink);
    } catch (error) {
      throw new Error("Error subscribing: " + error);
    }
    contentTopics.forEach((contentTopic) => {
      this.subscriptionCallbacks.delete(contentTopic);
    });
  }
  async ping() {
    const stream = await this.newStream(this.peer);
    const request2 = FilterSubscribeRpc.createSubscriberPingRequest();
    try {
      const res = await pipe([request2.encode()], encode2, stream, decode2, async (source) => await src_default(source));
      if (!res || !res.length) {
        throw Error(`No response received for request ${request2.requestId}: ${res}`);
      }
      const { statusCode, requestId, statusDesc } = FilterSubscribeResponse2.decode(res[0].slice());
      if (statusCode < 200 || statusCode >= 300) {
        throw new Error(`Filter ping request ${requestId} failed with status code ${statusCode}: ${statusDesc}`);
      }
      log5.info("Ping successful");
    } catch (error) {
      log5.error("Error pinging: ", error);
      throw new Error("Error pinging: " + error);
    }
  }
  async unsubscribeAll() {
    const stream = await this.newStream(this.peer);
    const request2 = FilterSubscribeRpc.createUnsubscribeAllRequest(this.pubsubTopic);
    try {
      const res = await pipe([request2.encode()], encode2, stream, decode2, async (source) => await src_default(source));
      if (!res || !res.length) {
        throw Error(`No response received for request ${request2.requestId}: ${res}`);
      }
      const { statusCode, requestId, statusDesc } = FilterSubscribeResponse2.decode(res[0].slice());
      if (statusCode < 200 || statusCode >= 300) {
        throw new Error(`Filter unsubscribe all request ${requestId} failed with status code ${statusCode}: ${statusDesc}`);
      }
      this.subscriptionCallbacks.clear();
      log5.info("Unsubscribed from all content topics");
    } catch (error) {
      throw new Error("Error unsubscribing from all content topics: " + error);
    }
  }
  async processMessage(message2) {
    const contentTopic = message2.contentTopic;
    const subscriptionCallback = this.subscriptionCallbacks.get(contentTopic);
    if (!subscriptionCallback) {
      log5.error("No subscription callback available for ", contentTopic);
      return;
    }
    await pushMessage(subscriptionCallback, this.pubsubTopic, message2);
  }
};
var Filter = class extends BaseProtocol {
  constructor(libp2p, options) {
    super(FilterCodecs.SUBSCRIBE, libp2p.components);
    __publicField(this, "pubsubTopics", []);
    __publicField(this, "activeSubscriptions", /* @__PURE__ */ new Map());
    __publicField(this, "NUM_PEERS_PROTOCOL", 1);
    this.pubsubTopics = (options == null ? void 0 : options.pubsubTopics) || [DefaultPubSubTopic];
    libp2p.handle(FilterCodecs.PUSH, this.onRequest.bind(this)).catch((e) => {
      log5.error("Failed to register ", FilterCodecs.PUSH, e);
    });
    this.activeSubscriptions = /* @__PURE__ */ new Map();
  }
  getActiveSubscription(pubsubTopic, peerIdStr) {
    return this.activeSubscriptions.get(`${pubsubTopic}_${peerIdStr}`);
  }
  setActiveSubscription(pubsubTopic, peerIdStr, subscription) {
    this.activeSubscriptions.set(`${pubsubTopic}_${peerIdStr}`, subscription);
    return subscription;
  }
  async createSubscription(pubsubTopic = DefaultPubSubTopic) {
    ensurePubsubTopicIsConfigured(pubsubTopic, this.pubsubTopics);
    const peer = (await this.getPeers({
      maxBootstrapPeers: 1,
      numPeers: this.NUM_PEERS_PROTOCOL
    }))[0];
    const subscription = this.getActiveSubscription(pubsubTopic, peer.id.toString()) ?? this.setActiveSubscription(pubsubTopic, peer.id.toString(), new Subscription(pubsubTopic, peer, this.getStream.bind(this, peer)));
    return subscription;
  }
  toSubscriptionIterator(decoders) {
    return toAsyncIterator(this, decoders);
  }
  /**
   * This method is used to satisfy the `IReceiver` interface.
   *
   * @hidden
   *
   * @param decoders The decoders to use for the subscription.
   * @param callback The callback function to use for the subscription.
   * @param opts Optional protocol options for the subscription.
   *
   * @returns A Promise that resolves to a function that unsubscribes from the subscription.
   *
   * @remarks
   * This method should not be used directly.
   * Instead, use `createSubscription` to create a new subscription.
   */
  async subscribe(decoders, callback) {
    const subscription = await this.createSubscription();
    await subscription.subscribe(decoders, callback);
    const contentTopics = Array.from(groupByContentTopic(Array.isArray(decoders) ? decoders : [decoders]).keys());
    return async () => {
      await subscription.unsubscribe(contentTopics);
    };
  }
  onRequest(streamData) {
    try {
      pipe(streamData.stream, decode2, async (source) => {
        for await (const bytes2 of source) {
          const response = FilterPushRpc.decode(bytes2.slice());
          const { pubsubTopic, wakuMessage } = response;
          if (!wakuMessage) {
            log5.error("Received empty message");
            return;
          }
          if (!pubsubTopic) {
            log5.error("PubSub topic missing from push message");
            return;
          }
          const peerIdStr = streamData.connection.remotePeer.toString();
          const subscription = this.getActiveSubscription(pubsubTopic, peerIdStr);
          if (!subscription) {
            log5.error(`No subscription locally registered for topic ${pubsubTopic}`);
            return;
          }
          await subscription.processMessage(wakuMessage);
        }
      }).then(() => {
        log5.info("Receiving pipe closed.");
      }, (e) => {
        log5.error("Error with receiving pipe", e);
      });
    } catch (e) {
      log5.error("Error decoding message", e);
    }
  }
};
function wakuFilter(init = {}) {
  return (libp2p) => new Filter(libp2p, init);
}
async function pushMessage(subscriptionCallback, pubsubTopic, message2) {
  const { decoders, callback } = subscriptionCallback;
  const { contentTopic } = message2;
  if (!contentTopic) {
    log5.warn("Message has no content topic, skipping");
    return;
  }
  try {
    const decodePromises = decoders.map((dec) => dec.fromProtoObj(pubsubTopic, message2).then((decoded) => decoded || Promise.reject("Decoding failed")));
    const decodedMessage = await Promise.any(decodePromises);
    await callback(decodedMessage);
  } catch (e) {
    log5.error("Error decoding message", e);
  }
}

// node_modules/@waku/core/dist/lib/light_push/index.js
var light_push_exports2 = {};
__export(light_push_exports2, {
  LightPushCodec: () => LightPushCodec,
  PushResponse: () => PushResponse,
  wakuLightPush: () => wakuLightPush
});

// node_modules/@waku/core/dist/lib/light_push/push_rpc.js
var PushRpc2 = class _PushRpc {
  constructor(proto) {
    __publicField(this, "proto");
    this.proto = proto;
  }
  static createRequest(message2, pubsubTopic) {
    return new _PushRpc({
      requestId: v4_default(),
      request: {
        message: message2,
        pubsubTopic
      },
      response: void 0
    });
  }
  static decode(bytes2) {
    const res = light_push_exports.PushRpc.decode(bytes2);
    return new _PushRpc(res);
  }
  encode() {
    return light_push_exports.PushRpc.encode(this.proto);
  }
  get query() {
    return this.proto.request;
  }
  get response() {
    return this.proto.response;
  }
};

// node_modules/@waku/core/dist/lib/light_push/index.js
var log6 = new Logger("light-push");
var LightPushCodec = "/vac/waku/lightpush/2.0.0-beta1";
var LightPush = class extends BaseProtocol {
  constructor(libp2p, options) {
    super(LightPushCodec, libp2p.components);
    __publicField(this, "pubsubTopics");
    __publicField(this, "NUM_PEERS_PROTOCOL", 1);
    this.pubsubTopics = (options == null ? void 0 : options.pubsubTopics) ?? [DefaultPubSubTopic];
  }
  async preparePushMessage(encoder2, message2, pubsubTopic) {
    try {
      if (!message2.payload || message2.payload.length === 0) {
        log6.error("Failed to send waku light push: payload is empty");
        return { query: null, error: SendError.EMPTY_PAYLOAD };
      }
      if (!await isMessageSizeUnderCap(encoder2, message2)) {
        log6.error("Failed to send waku light push: message is bigger than 1MB");
        return { query: null, error: SendError.SIZE_TOO_BIG };
      }
      const protoMessage = await encoder2.toProtoObj(message2);
      if (!protoMessage) {
        log6.error("Failed to encode to protoMessage, aborting push");
        return {
          query: null,
          error: SendError.ENCODE_FAILED
        };
      }
      const query = PushRpc2.createRequest(protoMessage, pubsubTopic);
      return { query, error: null };
    } catch (error) {
      log6.error("Failed to prepare push message", error);
      return {
        query: null,
        error: SendError.GENERIC_FAIL
      };
    }
  }
  async send(encoder2, message2) {
    const { pubsubTopic } = encoder2;
    ensurePubsubTopicIsConfigured(pubsubTopic, this.pubsubTopics);
    const recipients = [];
    const { query, error: preparationError } = await this.preparePushMessage(encoder2, message2, pubsubTopic);
    if (preparationError || !query) {
      return {
        recipients,
        errors: [preparationError]
      };
    }
    const peers = await this.getPeers({
      maxBootstrapPeers: 1,
      numPeers: this.NUM_PEERS_PROTOCOL
    });
    if (!peers.length) {
      return {
        recipients,
        errors: [SendError.NO_PEER_AVAILABLE]
      };
    }
    const promises = peers.map(async (peer) => {
      let stream;
      try {
        stream = await this.getStream(peer);
      } catch (err) {
        log6.error(`Failed to get a stream for remote peer${peer.id.toString()}`, err);
        return { recipients, error: SendError.REMOTE_PEER_FAULT };
      }
      let res;
      try {
        res = await pipe([query.encode()], encode2, stream, decode2, async (source) => await src_default(source));
      } catch (err) {
        log6.error("Failed to send waku light push request", err);
        return { recipients, error: SendError.GENERIC_FAIL };
      }
      const bytes2 = new Uint8ArrayList();
      res.forEach((chunk) => {
        bytes2.append(chunk);
      });
      let response;
      try {
        response = PushRpc2.decode(bytes2).response;
      } catch (err) {
        log6.error("Failed to decode push reply", err);
        return { recipients, error: SendError.DECODE_FAILED };
      }
      if (!response) {
        log6.error("Remote peer fault: No response in PushRPC");
        return { recipients, error: SendError.REMOTE_PEER_FAULT };
      }
      if (!response.isSuccess) {
        log6.error("Remote peer rejected the message: ", response.info);
        return { recipients, error: SendError.REMOTE_PEER_REJECTED };
      }
      recipients.some((recipient) => recipient.equals(peer.id)) || recipients.push(peer.id);
      return { recipients };
    });
    const results = await Promise.allSettled(promises);
    const errors = results.filter((result) => result.status === "fulfilled").map((result) => result.value.error).filter((error) => error !== void 0);
    return {
      recipients,
      errors
    };
  }
};
function wakuLightPush(init = {}) {
  return (libp2p) => new LightPush(libp2p, init);
}

// node_modules/@waku/core/dist/lib/store/index.js
var store_exports2 = {};
__export(store_exports2, {
  DefaultPageSize: () => DefaultPageSize,
  PageDirection: () => PageDirection2,
  StoreCodec: () => StoreCodec,
  createCursor: () => createCursor,
  wakuStore: () => wakuStore
});

// node_modules/@waku/core/dist/lib/to_proto_message.js
var EmptyMessage = {
  payload: new Uint8Array(),
  contentTopic: "",
  version: void 0,
  timestamp: void 0,
  meta: void 0,
  rateLimitProof: void 0,
  ephemeral: void 0
};
function toProtoMessage(wire) {
  return { ...EmptyMessage, ...wire };
}

// node_modules/@waku/core/dist/lib/store/history_rpc.js
var OneMillion2 = BigInt(1e6);
var PageDirection2;
(function(PageDirection3) {
  PageDirection3["BACKWARD"] = "backward";
  PageDirection3["FORWARD"] = "forward";
})(PageDirection2 || (PageDirection2 = {}));
var HistoryRpc2 = class _HistoryRpc {
  constructor(proto) {
    __publicField(this, "proto");
    this.proto = proto;
  }
  get query() {
    return this.proto.query;
  }
  get response() {
    return this.proto.response;
  }
  /**
   * Create History Query.
   */
  static createQuery(params) {
    const contentFilters = params.contentTopics.map((contentTopic) => {
      return { contentTopic };
    });
    const direction = directionToProto(params.pageDirection);
    const pagingInfo = {
      pageSize: BigInt(params.pageSize),
      cursor: params.cursor,
      direction
    };
    let startTime, endTime;
    if (params.startTime) {
      startTime = BigInt(params.startTime.valueOf()) * OneMillion2;
    }
    if (params.endTime) {
      endTime = BigInt(params.endTime.valueOf()) * OneMillion2;
    }
    return new _HistoryRpc({
      requestId: v4_default(),
      query: {
        pubsubTopic: params.pubsubTopic,
        contentFilters,
        pagingInfo,
        startTime,
        endTime
      },
      response: void 0
    });
  }
  decode(bytes2) {
    const res = store_exports.HistoryRpc.decode(bytes2);
    return new _HistoryRpc(res);
  }
  encode() {
    return store_exports.HistoryRpc.encode(this.proto);
  }
};
function directionToProto(pageDirection) {
  switch (pageDirection) {
    case PageDirection2.BACKWARD:
      return store_exports.PagingInfo.Direction.BACKWARD;
    case PageDirection2.FORWARD:
      return store_exports.PagingInfo.Direction.FORWARD;
    default:
      return store_exports.PagingInfo.Direction.BACKWARD;
  }
}

// node_modules/@waku/core/dist/lib/store/index.js
var HistoryError = store_exports.HistoryResponse.HistoryError;
var log7 = new Logger("store");
var StoreCodec = "/vac/waku/store/2.0.0-beta4";
var DefaultPageSize = 10;
var Store = class extends BaseProtocol {
  constructor(libp2p, options) {
    super(StoreCodec, libp2p.components);
    __publicField(this, "pubsubTopics");
    __publicField(this, "NUM_PEERS_PROTOCOL", 1);
    /**
     * @deprecated Use `queryWithOrderedCallback` instead
     **/
    __publicField(this, "queryOrderedCallback", this.queryWithOrderedCallback);
    this.pubsubTopics = (options == null ? void 0 : options.pubsubTopics) ?? [DefaultPubSubTopic];
  }
  /**
   * Processes messages based on the provided callback and options.
   * @private
   */
  async processMessages(messages2, callback, options) {
    let abort = false;
    const messagesOrUndef = await Promise.all(messages2);
    let processedMessages = messagesOrUndef.filter(isDefined);
    if (this.shouldReverseOrder(options)) {
      processedMessages = processedMessages.reverse();
    }
    await Promise.all(processedMessages.map(async (msg) => {
      if (msg && !abort) {
        abort = Boolean(await callback(msg));
      }
    }));
    return abort;
  }
  /**
   * Determines whether to reverse the order of messages based on the provided options.
   *
   * Messages in pages are ordered from oldest (first) to most recent (last).
   * https://github.com/vacp2p/rfc/issues/533
   *
   * @private
   */
  shouldReverseOrder(options) {
    return typeof (options == null ? void 0 : options.pageDirection) === "undefined" || (options == null ? void 0 : options.pageDirection) === PageDirection2.BACKWARD;
  }
  /**
   * Do a query to a Waku Store to retrieve historical/missed messages.
   *
   * The callback function takes a `WakuMessage` in input,
   * messages are processed in order:
   * - oldest to latest if `options.pageDirection` == { @link PageDirection.FORWARD }
   * - latest to oldest if `options.pageDirection` == { @link PageDirection.BACKWARD }
   *
   * The ordering may affect performance.
   * The ordering depends on the behavior of the remote store node.
   * If strong ordering is needed, you may need to handle this at application level
   * and set your own timestamps too (the WakuMessage timestamps are not certified).
   *
   * @throws If not able to reach a Waku Store peer to query,
   * or if an error is encountered when processing the reply,
   * or if two decoders with the same content topic are passed.
   */
  async queryWithOrderedCallback(decoders, callback, options) {
    for await (const promises of this.queryGenerator(decoders, options)) {
      if (await this.processMessages(promises, callback, options))
        break;
    }
  }
  /**
   * Do a query to a Waku Store to retrieve historical/missed messages.
   * The callback function takes a `Promise<WakuMessage>` in input,
   * useful if messages need to be decrypted and performance matters.
   *
   * The order of the messages passed to the callback is as follows:
   * - within a page, messages are expected to be ordered from oldest to most recent
   * - pages direction depends on { @link QueryOptions.pageDirection }
   *
   * Do note that the resolution of the `Promise<WakuMessage | undefined` may
   * break the order as it may rely on the browser decryption API, which in turn,
   * may have a different speed depending on the type of decryption.
   *
   * @throws If not able to reach a Waku Store peer to query,
   * or if an error is encountered when processing the reply,
   * or if two decoders with the same content topic are passed.
   */
  async queryWithPromiseCallback(decoders, callback, options) {
    let abort = false;
    for await (const page of this.queryGenerator(decoders, options)) {
      const _promises = page.map(async (msgPromise) => {
        if (abort)
          return;
        abort = Boolean(await callback(msgPromise));
      });
      await Promise.all(_promises);
      if (abort)
        break;
    }
  }
  /**
   * Do a query to a Waku Store to retrieve historical/missed messages.
   *
   * This is a generator, useful if you want most control on how messages
   * are processed.
   *
   * The order of the messages returned by the remote Waku node SHOULD BE
   * as follows:
   * - within a page, messages SHOULD be ordered from oldest to most recent
   * - pages direction depends on { @link QueryOptions.pageDirection }
   * @throws If not able to reach a Waku Store peer to query,
   * or if an error is encountered when processing the reply,
   * or if two decoders with the same content topic are passed.
   *
   * This API only supports querying a single pubsub topic at a time.
   * If multiple decoders are provided, they must all have the same pubsub topic.
   * @throws If multiple decoders with different pubsub topics are provided.
   * @throws If no decoders are provided.
   * @throws If no decoders are found for the provided pubsub topic.
   */
  async *queryGenerator(decoders, options) {
    var _a4, _b4;
    if (decoders.length === 0) {
      throw new Error("No decoders provided");
    }
    let startTime, endTime;
    if (options == null ? void 0 : options.timeFilter) {
      startTime = options.timeFilter.startTime;
      endTime = options.timeFilter.endTime;
    }
    const uniquePubSubTopicsInQuery = Array.from(new Set(decoders.map((decoder) => decoder.pubsubTopic)));
    if (uniquePubSubTopicsInQuery.length > 1) {
      throw new Error("API does not support querying multiple pubsub topics at once");
    }
    const pubSubTopicForQuery = uniquePubSubTopicsInQuery[0];
    ensurePubsubTopicIsConfigured(pubSubTopicForQuery, this.pubsubTopics);
    if (((_a4 = options == null ? void 0 : options.cursor) == null ? void 0 : _a4.pubsubTopic) && options.cursor.pubsubTopic !== pubSubTopicForQuery) {
      throw new Error(`Cursor pubsub topic (${(_b4 = options == null ? void 0 : options.cursor) == null ? void 0 : _b4.pubsubTopic}) does not match decoder pubsub topic (${pubSubTopicForQuery})`);
    }
    const decodersAsMap = /* @__PURE__ */ new Map();
    decoders.forEach((dec) => {
      if (decodersAsMap.has(dec.contentTopic)) {
        throw new Error("API does not support different decoder per content topic");
      }
      decodersAsMap.set(dec.contentTopic, dec);
    });
    const contentTopics = decoders.filter((decoder) => decoder.pubsubTopic === pubSubTopicForQuery).map((dec) => dec.contentTopic);
    if (contentTopics.length === 0) {
      throw new Error("No decoders found for topic " + pubSubTopicForQuery);
    }
    const queryOpts = Object.assign({
      pubsubTopic: pubSubTopicForQuery,
      pageDirection: PageDirection2.BACKWARD,
      pageSize: DefaultPageSize
    }, options, { contentTopics, startTime, endTime });
    const peer = (await this.getPeers({
      numPeers: this.NUM_PEERS_PROTOCOL,
      maxBootstrapPeers: 1
    }))[0];
    for await (const messages2 of paginate(this.getStream.bind(this, peer), queryOpts, decodersAsMap, options == null ? void 0 : options.cursor)) {
      yield messages2;
    }
  }
};
async function* paginate(streamFactory, queryOpts, decoders, cursor) {
  var _a4, _b4, _c, _d;
  if (queryOpts.contentTopics.toString() !== Array.from(decoders.keys()).toString()) {
    throw new Error("Internal error, the decoders should match the query's content topics");
  }
  let currentCursor = cursor;
  while (true) {
    queryOpts.cursor = currentCursor;
    const historyRpcQuery = HistoryRpc2.createQuery(queryOpts);
    log7.info("Querying store peer", `for (${queryOpts.pubsubTopic})`, queryOpts.contentTopics);
    const stream = await streamFactory();
    const res = await pipe([historyRpcQuery.encode()], encode2, stream, decode2, async (source) => await src_default(source));
    const bytes2 = new Uint8ArrayList();
    res.forEach((chunk) => {
      bytes2.append(chunk);
    });
    const reply = historyRpcQuery.decode(bytes2);
    if (!reply.response) {
      log7.warn("Stopping pagination due to store `response` field missing");
      break;
    }
    const response = reply.response;
    if (response.error && response.error !== HistoryError.NONE) {
      throw "History response contains an Error: " + response.error;
    }
    if (!response.messages || !response.messages.length) {
      log7.warn("Stopping pagination due to store `response.messages` field missing or empty");
      break;
    }
    log7.error(`${response.messages.length} messages retrieved from store`);
    yield response.messages.map((protoMsg) => {
      const contentTopic = protoMsg.contentTopic;
      if (typeof contentTopic !== "undefined") {
        const decoder = decoders.get(contentTopic);
        if (decoder) {
          return decoder.fromProtoObj(queryOpts.pubsubTopic, toProtoMessage(protoMsg));
        }
      }
      return Promise.resolve(void 0);
    });
    const nextCursor = (_a4 = response.pagingInfo) == null ? void 0 : _a4.cursor;
    if (typeof nextCursor === "undefined") {
      log7.warn("Stopping pagination due to `response.pagingInfo.cursor` missing from store response");
      break;
    }
    currentCursor = nextCursor;
    const responsePageSize = (_b4 = response.pagingInfo) == null ? void 0 : _b4.pageSize;
    const queryPageSize = (_d = (_c = historyRpcQuery.query) == null ? void 0 : _c.pagingInfo) == null ? void 0 : _d.pageSize;
    if (
      // Response page size smaller than query, meaning this is the last page
      responsePageSize && queryPageSize && responsePageSize < queryPageSize
    ) {
      break;
    }
  }
}
async function createCursor(message2) {
  if (!message2 || !message2.timestamp || !message2.payload || !message2.contentTopic) {
    throw new Error("Message is missing required fields");
  }
  const contentTopicBytes = utf8ToBytes(message2.contentTopic);
  const digest2 = sha256(concat2([contentTopicBytes, message2.payload]));
  const messageTime = BigInt(message2.timestamp.getTime()) * BigInt(1e6);
  return {
    digest: digest2,
    pubsubTopic: message2.pubsubTopic,
    senderTime: messageTime,
    receiverTime: messageTime
  };
}
function wakuStore(init = {}) {
  return (libp2p) => new Store(libp2p, init);
}

// node_modules/p-timeout/index.js
var TimeoutError = class extends Error {
  constructor(message2) {
    super(message2);
    this.name = "TimeoutError";
  }
};
var AbortError3 = class extends Error {
  constructor(message2) {
    super();
    this.name = "AbortError";
    this.message = message2;
  }
};
var getDOMException = (errorMessage) => globalThis.DOMException === void 0 ? new AbortError3(errorMessage) : new DOMException(errorMessage);
var getAbortedReason = (signal) => {
  const reason = signal.reason === void 0 ? getDOMException("This operation was aborted.") : signal.reason;
  return reason instanceof Error ? reason : getDOMException(reason);
};
function pTimeout(promise, options) {
  const {
    milliseconds,
    fallback,
    message: message2,
    customTimers = { setTimeout, clearTimeout }
  } = options;
  let timer;
  const wrappedPromise = new Promise((resolve, reject) => {
    if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
      throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
    }
    if (options.signal) {
      const { signal } = options;
      if (signal.aborted) {
        reject(getAbortedReason(signal));
      }
      signal.addEventListener("abort", () => {
        reject(getAbortedReason(signal));
      });
    }
    if (milliseconds === Number.POSITIVE_INFINITY) {
      promise.then(resolve, reject);
      return;
    }
    const timeoutError = new TimeoutError();
    timer = customTimers.setTimeout.call(void 0, () => {
      if (fallback) {
        try {
          resolve(fallback());
        } catch (error) {
          reject(error);
        }
        return;
      }
      if (typeof promise.cancel === "function") {
        promise.cancel();
      }
      if (message2 === false) {
        resolve();
      } else if (message2 instanceof Error) {
        reject(message2);
      } else {
        timeoutError.message = message2 ?? `Promise timed out after ${milliseconds} milliseconds`;
        reject(timeoutError);
      }
    }, milliseconds);
    (async () => {
      try {
        resolve(await promise);
      } catch (error) {
        reject(error);
      }
    })();
  });
  const cancelablePromise = wrappedPromise.finally(() => {
    cancelablePromise.clear();
  });
  cancelablePromise.clear = () => {
    customTimers.clearTimeout.call(void 0, timer);
    timer = void 0;
  };
  return cancelablePromise;
}

// node_modules/p-event/index.js
var normalizeEmitter = (emitter) => {
  const addListener = emitter.on || emitter.addListener || emitter.addEventListener;
  const removeListener = emitter.off || emitter.removeListener || emitter.removeEventListener;
  if (!addListener || !removeListener) {
    throw new TypeError("Emitter is not compatible");
  }
  return {
    addListener: addListener.bind(emitter),
    removeListener: removeListener.bind(emitter)
  };
};
function pEventMultiple(emitter, event, options) {
  let cancel;
  const returnValue = new Promise((resolve, reject) => {
    var _a4;
    options = {
      rejectionEvents: ["error"],
      multiArgs: false,
      resolveImmediately: false,
      ...options
    };
    if (!(options.count >= 0 && (options.count === Number.POSITIVE_INFINITY || Number.isInteger(options.count)))) {
      throw new TypeError("The `count` option should be at least 0 or more");
    }
    (_a4 = options.signal) == null ? void 0 : _a4.throwIfAborted();
    const events2 = [event].flat();
    const items = [];
    const { addListener, removeListener } = normalizeEmitter(emitter);
    const onItem = (...arguments_) => {
      const value = options.multiArgs ? arguments_ : arguments_[0];
      if (options.filter && !options.filter(value)) {
        return;
      }
      items.push(value);
      if (options.count === items.length) {
        cancel();
        resolve(items);
      }
    };
    const rejectHandler = (error) => {
      cancel();
      reject(error);
    };
    cancel = () => {
      for (const event2 of events2) {
        removeListener(event2, onItem);
      }
      for (const rejectionEvent of options.rejectionEvents) {
        removeListener(rejectionEvent, rejectHandler);
      }
    };
    for (const event2 of events2) {
      addListener(event2, onItem);
    }
    for (const rejectionEvent of options.rejectionEvents) {
      addListener(rejectionEvent, rejectHandler);
    }
    if (options.signal) {
      options.signal.addEventListener("abort", () => {
        rejectHandler(options.signal.reason);
      }, { once: true });
    }
    if (options.resolveImmediately) {
      resolve(items);
    }
  });
  returnValue.cancel = cancel;
  if (typeof options.timeout === "number") {
    const timeout = pTimeout(returnValue, { milliseconds: options.timeout });
    timeout.cancel = cancel;
    return timeout;
  }
  return returnValue;
}
function pEvent(emitter, event, options) {
  if (typeof options === "function") {
    options = { filter: options };
  }
  options = {
    ...options,
    count: 1,
    resolveImmediately: false
  };
  const arrayPromise = pEventMultiple(emitter, event, options);
  const promise = arrayPromise.then((array) => array[0]);
  promise.cancel = arrayPromise.cancel;
  return promise;
}

// node_modules/@waku/core/dist/lib/wait_for_remote_peer.js
var log8 = new Logger("wait-for-remote-peer");
async function waitForRemotePeer(waku, protocols, timeoutMs) {
  protocols = protocols ?? getEnabledProtocols(waku);
  if (!waku.isStarted())
    return Promise.reject("Waku node is not started");
  const promises = [];
  if (protocols.includes(Protocols.Relay)) {
    if (!waku.relay)
      throw new Error("Cannot wait for Relay peer: protocol not mounted");
    promises.push(waitForGossipSubPeerInMesh(waku.relay));
  }
  if (protocols.includes(Protocols.Store)) {
    if (!waku.store)
      throw new Error("Cannot wait for Store peer: protocol not mounted");
    promises.push(waitForConnectedPeer(waku.store));
  }
  if (protocols.includes(Protocols.LightPush)) {
    if (!waku.lightPush)
      throw new Error("Cannot wait for LightPush peer: protocol not mounted");
    promises.push(waitForConnectedPeer(waku.lightPush));
  }
  if (protocols.includes(Protocols.Filter)) {
    if (!waku.filter)
      throw new Error("Cannot wait for Filter peer: protocol not mounted");
    promises.push(waitForConnectedPeer(waku.filter));
  }
  if (timeoutMs) {
    await rejectOnTimeout(Promise.all(promises), timeoutMs, "Timed out waiting for a remote peer.");
  } else {
    await Promise.all(promises);
  }
}
async function waitForConnectedPeer(protocol) {
  const codec = protocol.multicodec;
  const peers = await protocol.peers();
  if (peers.length) {
    log8.info(`${codec} peer found: `, peers[0].id.toString());
    return;
  }
  await new Promise((resolve) => {
    const cb = (evt) => {
      var _a4, _b4;
      if ((_b4 = (_a4 = evt.detail) == null ? void 0 : _a4.protocols) == null ? void 0 : _b4.includes(codec)) {
        protocol.removeLibp2pEventListener("peer:identify", cb);
        resolve();
      }
    };
    protocol.addLibp2pEventListener("peer:identify", cb);
  });
}
async function waitForGossipSubPeerInMesh(waku) {
  let peers = waku.getMeshPeers();
  const pubsubTopics = waku.pubsubTopics;
  for (const topic of pubsubTopics) {
    while (peers.length == 0) {
      await pEvent(waku.gossipSub, "gossipsub:heartbeat");
      peers = waku.getMeshPeers(topic);
    }
  }
}
var awaitTimeout = (ms, rejectReason) => new Promise((_resolve, reject) => setTimeout(() => reject(rejectReason), ms));
async function rejectOnTimeout(promise, timeoutMs, rejectReason) {
  await Promise.race([promise, awaitTimeout(timeoutMs, rejectReason)]);
}
function getEnabledProtocols(waku) {
  const protocols = [];
  if (waku.relay) {
    protocols.push(Protocols.Relay);
  }
  if (waku.filter) {
    protocols.push(Protocols.Filter);
  }
  if (waku.store) {
    protocols.push(Protocols.Store);
  }
  if (waku.lightPush) {
    protocols.push(Protocols.LightPush);
  }
  return protocols;
}

// node_modules/race-signal/dist/src/index.js
var AbortError4 = class extends Error {
  constructor(message2, code2) {
    super(message2 ?? "The operation was aborted");
    __publicField(this, "type");
    __publicField(this, "code");
    this.type = "aborted";
    this.name = "AbortError";
    this.code = code2 ?? "ABORT_ERR";
  }
};
async function raceSignal(promise, signal, opts) {
  if (signal == null) {
    return promise;
  }
  if (signal.aborted) {
    return Promise.reject(new AbortError4(opts == null ? void 0 : opts.errorMessage, opts == null ? void 0 : opts.errorCode));
  }
  let listener;
  const error = new AbortError4(opts == null ? void 0 : opts.errorMessage, opts == null ? void 0 : opts.errorCode);
  try {
    return await Promise.race([
      promise,
      new Promise((resolve, reject) => {
        listener = () => {
          reject(error);
        };
        signal.addEventListener("abort", listener);
      })
    ]);
  } finally {
    if (listener != null) {
      signal.removeEventListener("abort", listener);
    }
  }
}

// node_modules/it-byte-stream/dist/src/pushable.js
var QueuelessPushable = class {
  constructor() {
    __publicField(this, "needNext");
    __publicField(this, "haveNext");
    __publicField(this, "ended");
    __publicField(this, "nextResult");
    this.ended = false;
    this.needNext = pDefer();
    this.needNext.resolve();
    this.haveNext = pDefer();
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  async next() {
    if (this.nextResult == null) {
      await this.haveNext.promise;
    }
    if (this.nextResult == null) {
      throw new Error("Have next but next was undefined");
    }
    const nextResult = this.nextResult;
    this.nextResult = void 0;
    this.needNext.resolve();
    this.needNext = pDefer();
    return nextResult;
  }
  async throw(err) {
    this.ended = true;
    if (err != null) {
      this.haveNext.reject(err);
    }
    const result = {
      done: true,
      value: void 0
    };
    return result;
  }
  async return() {
    const result = {
      done: true,
      value: void 0
    };
    await this._push(void 0);
    return result;
  }
  async push(value, options) {
    await this._push(value, options);
  }
  async end(err, options) {
    if (err != null) {
      await this.throw(err);
    } else {
      await this._push(void 0, options);
    }
  }
  async _push(value, options) {
    if (value != null && this.ended) {
      throw new Error("Cannot push value onto an ended pushable");
    }
    if (this.nextResult != null) {
      await this.needNext.promise;
    }
    if (value != null) {
      this.nextResult = { done: false, value };
    } else {
      this.ended = true;
      this.nextResult = { done: true, value: void 0 };
    }
    this.haveNext.resolve();
    this.haveNext = pDefer();
    await raceSignal(this.needNext.promise, options == null ? void 0 : options.signal, options);
  }
};
function pushable2() {
  return new QueuelessPushable();
}

// node_modules/it-byte-stream/dist/src/index.js
var CodeError2 = class extends Error {
  constructor(message2, code2) {
    super(message2);
    __publicField(this, "code");
    this.code = code2;
  }
};
var AbortError5 = class extends CodeError2 {
  constructor(message2) {
    super(message2, "ABORT_ERR");
    __publicField(this, "type");
    this.type = "aborted";
  }
};
function byteStream(duplex) {
  const write2 = pushable2();
  duplex.sink(write2).catch(async (err) => {
    await write2.end(err);
  });
  duplex.sink = async (source2) => {
    for await (const buf of source2) {
      await write2.push(buf);
    }
    await write2.end();
  };
  let source = duplex.source;
  if (duplex.source[Symbol.iterator] != null) {
    source = duplex.source[Symbol.iterator]();
  } else if (duplex.source[Symbol.asyncIterator] != null) {
    source = duplex.source[Symbol.asyncIterator]();
  }
  const readBuffer = new Uint8ArrayList();
  const W = {
    read: async (bytes2, options) => {
      var _a4, _b4;
      (_a4 = options == null ? void 0 : options.signal) == null ? void 0 : _a4.throwIfAborted();
      let listener;
      const abortPromise = new Promise((resolve, reject) => {
        var _a5;
        listener = () => {
          reject(new AbortError5("Read aborted"));
        };
        (_a5 = options == null ? void 0 : options.signal) == null ? void 0 : _a5.addEventListener("abort", listener);
      });
      try {
        if (bytes2 == null) {
          const { done, value } = await Promise.race([
            source.next(),
            abortPromise
          ]);
          if (done === true) {
            return new Uint8ArrayList();
          }
          return value;
        }
        while (readBuffer.byteLength < bytes2) {
          const { value, done } = await Promise.race([
            source.next(),
            abortPromise
          ]);
          if (done === true) {
            throw new CodeError2("unexpected end of input", "ERR_UNEXPECTED_EOF");
          }
          readBuffer.append(value);
        }
        const buf = readBuffer.sublist(0, bytes2);
        readBuffer.consume(bytes2);
        return buf;
      } finally {
        if (listener != null) {
          (_b4 = options == null ? void 0 : options.signal) == null ? void 0 : _b4.removeEventListener("abort", listener);
        }
      }
    },
    write: async (data, options) => {
      var _a4;
      (_a4 = options == null ? void 0 : options.signal) == null ? void 0 : _a4.throwIfAborted();
      if (data instanceof Uint8Array) {
        await write2.push(data, options);
      } else {
        await write2.push(data.subarray(), options);
      }
    },
    unwrap: () => {
      const originalStream = duplex.source;
      duplex.source = async function* () {
        yield* readBuffer;
        yield* originalStream;
      }();
      return duplex;
    }
  };
  return W;
}

// node_modules/it-length-prefixed-stream/dist/src/index.js
var CodeError3 = class extends Error {
  constructor(message2, code2) {
    super(message2);
    __publicField(this, "code");
    this.code = code2;
  }
};
var defaultLengthDecoder = (buf) => {
  return decode(buf);
};
defaultLengthDecoder.bytes = 0;
function lpStream(duplex, opts) {
  const bytes2 = byteStream(duplex);
  const W = {
    read: async (options) => {
      let dataLength = -1;
      const lengthBuffer = new Uint8ArrayList();
      const decodeLength = (opts == null ? void 0 : opts.lengthDecoder) ?? defaultLengthDecoder;
      while (true) {
        lengthBuffer.append(await bytes2.read(1, options));
        try {
          dataLength = decodeLength(lengthBuffer);
        } catch (err) {
          if (err instanceof RangeError) {
            continue;
          }
          throw err;
        }
        if (dataLength > -1) {
          break;
        }
        if ((opts == null ? void 0 : opts.maxLengthLength) != null && lengthBuffer.byteLength > opts.maxLengthLength) {
          throw new CodeError3("message length length too long", "ERR_MSG_LENGTH_TOO_LONG");
        }
      }
      if ((opts == null ? void 0 : opts.maxDataLength) != null && dataLength > opts.maxDataLength) {
        throw new CodeError3("message length too long", "ERR_MSG_DATA_TOO_LONG");
      }
      return bytes2.read(dataLength, options);
    },
    write: async (data, options) => {
      await bytes2.write(encode2.single(data, opts), options);
    },
    writeV: async (data, options) => {
      const list = new Uint8ArrayList(...data.map((buf) => encode2.single(buf, opts)));
      await bytes2.write(list, options);
    },
    unwrap: () => {
      return bytes2.unwrap();
    }
  };
  return W;
}

// node_modules/it-pair/dist/src/index.js
function pair() {
  const deferred = pDefer();
  let piped = false;
  return {
    sink: async (source) => {
      if (piped) {
        throw new Error("already piped");
      }
      piped = true;
      deferred.resolve(source);
    },
    source: async function* () {
      const source = await deferred.promise;
      yield* source;
    }()
  };
}

// node_modules/it-pair/dist/src/duplex.js
function duplexPair() {
  const a = pair();
  const b = pair();
  return [
    {
      source: a.source,
      sink: b.sink
    },
    {
      source: b.source,
      sink: a.sink
    }
  ];
}

// node_modules/@chainsafe/libp2p-noise/dist/src/constants.js
var NOISE_MSG_MAX_LENGTH_BYTES = 65535;
var NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG = NOISE_MSG_MAX_LENGTH_BYTES - 16;
var _a, _b;
var DUMP_SESSION_KEYS = Boolean((_b = (_a = globalThis.process) == null ? void 0 : _a.env) == null ? void 0 : _b.DUMP_SESSION_KEYS);

// node_modules/@noble/ciphers/esm/utils.js
var u8a = (a) => a instanceof Uint8Array;
var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
  throw new Error("Non little-endian hardware is not supported");
var hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
function utf8ToBytes3(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes2(data) {
  if (typeof data === "string")
    data = utf8ToBytes3(data);
  else if (u8a(data))
    data = data.slice();
  else
    throw new Error(`expected Uint8Array, got ${typeof data}`);
  return data;
}
var isPlainObject = (obj) => Object.prototype.toString.call(obj) === "[object Object]" && obj.constructor === Object;
function checkOpts(defaults, opts) {
  if (opts !== void 0 && (typeof opts !== "object" || !isPlainObject(opts)))
    throw new Error("options must be object or undefined");
  const merged = Object.assign(defaults, opts);
  return merged;
}
function ensureBytes2(b, len) {
  if (!(b instanceof Uint8Array))
    throw new Error("Uint8Array expected");
  if (typeof len === "number") {
    if (b.length !== len)
      throw new Error(`Uint8Array length ${len} expected`);
  }
}
function equalBytes2(a, b) {
  if (a.length !== b.length)
    throw new Error("equalBytes: Different size of Uint8Arrays");
  let isSame = true;
  for (let i = 0; i < a.length; i++)
    isSame && (isSame = a[i] === b[i]);
  return isSame;
}
var wrapCipher = (params, c) => {
  Object.assign(c, params);
  return c;
};
function setBigUint64(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE2 ? 4 : 0;
  const l = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE2);
  view.setUint32(byteOffset + l, wl, isLE2);
}

// node_modules/@noble/ciphers/esm/_assert.js
function number2(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`Wrong positive integer: ${n}`);
}
function bool(b) {
  if (typeof b !== "boolean")
    throw new Error(`Expected boolean, not ${b}`);
}
function bytes(b, ...lengths) {
  if (!(b instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
function exists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
  bytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}

// node_modules/@noble/ciphers/esm/_poly1305.js
var u8to16 = (a, i) => a[i++] & 255 | (a[i++] & 255) << 8;
var Poly1305 = class {
  constructor(key) {
    this.blockLen = 16;
    this.outputLen = 16;
    this.buffer = new Uint8Array(16);
    this.r = new Uint16Array(10);
    this.h = new Uint16Array(10);
    this.pad = new Uint16Array(8);
    this.pos = 0;
    this.finished = false;
    key = toBytes2(key);
    ensureBytes2(key, 32);
    const t0 = u8to16(key, 0);
    const t1 = u8to16(key, 2);
    const t2 = u8to16(key, 4);
    const t3 = u8to16(key, 6);
    const t4 = u8to16(key, 8);
    const t5 = u8to16(key, 10);
    const t6 = u8to16(key, 12);
    const t7 = u8to16(key, 14);
    this.r[0] = t0 & 8191;
    this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
    this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
    this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
    this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
    this.r[5] = t4 >>> 1 & 8190;
    this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
    this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
    this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
    this.r[9] = t7 >>> 5 & 127;
    for (let i = 0; i < 8; i++)
      this.pad[i] = u8to16(key, 16 + 2 * i);
  }
  process(data, offset, isLast = false) {
    const hibit = isLast ? 0 : 1 << 11;
    const { h, r } = this;
    const r0 = r[0];
    const r1 = r[1];
    const r2 = r[2];
    const r3 = r[3];
    const r4 = r[4];
    const r5 = r[5];
    const r6 = r[6];
    const r7 = r[7];
    const r8 = r[8];
    const r9 = r[9];
    const t0 = u8to16(data, offset + 0);
    const t1 = u8to16(data, offset + 2);
    const t2 = u8to16(data, offset + 4);
    const t3 = u8to16(data, offset + 6);
    const t4 = u8to16(data, offset + 8);
    const t5 = u8to16(data, offset + 10);
    const t6 = u8to16(data, offset + 12);
    const t7 = u8to16(data, offset + 14);
    let h0 = h[0] + (t0 & 8191);
    let h1 = h[1] + ((t0 >>> 13 | t1 << 3) & 8191);
    let h2 = h[2] + ((t1 >>> 10 | t2 << 6) & 8191);
    let h3 = h[3] + ((t2 >>> 7 | t3 << 9) & 8191);
    let h4 = h[4] + ((t3 >>> 4 | t4 << 12) & 8191);
    let h5 = h[5] + (t4 >>> 1 & 8191);
    let h6 = h[6] + ((t4 >>> 14 | t5 << 2) & 8191);
    let h7 = h[7] + ((t5 >>> 11 | t6 << 5) & 8191);
    let h8 = h[8] + ((t6 >>> 8 | t7 << 8) & 8191);
    let h9 = h[9] + (t7 >>> 5 | hibit);
    let c = 0;
    let d0 = c + h0 * r0 + h1 * (5 * r9) + h2 * (5 * r8) + h3 * (5 * r7) + h4 * (5 * r6);
    c = d0 >>> 13;
    d0 &= 8191;
    d0 += h5 * (5 * r5) + h6 * (5 * r4) + h7 * (5 * r3) + h8 * (5 * r2) + h9 * (5 * r1);
    c += d0 >>> 13;
    d0 &= 8191;
    let d1 = c + h0 * r1 + h1 * r0 + h2 * (5 * r9) + h3 * (5 * r8) + h4 * (5 * r7);
    c = d1 >>> 13;
    d1 &= 8191;
    d1 += h5 * (5 * r6) + h6 * (5 * r5) + h7 * (5 * r4) + h8 * (5 * r3) + h9 * (5 * r2);
    c += d1 >>> 13;
    d1 &= 8191;
    let d2 = c + h0 * r2 + h1 * r1 + h2 * r0 + h3 * (5 * r9) + h4 * (5 * r8);
    c = d2 >>> 13;
    d2 &= 8191;
    d2 += h5 * (5 * r7) + h6 * (5 * r6) + h7 * (5 * r5) + h8 * (5 * r4) + h9 * (5 * r3);
    c += d2 >>> 13;
    d2 &= 8191;
    let d3 = c + h0 * r3 + h1 * r2 + h2 * r1 + h3 * r0 + h4 * (5 * r9);
    c = d3 >>> 13;
    d3 &= 8191;
    d3 += h5 * (5 * r8) + h6 * (5 * r7) + h7 * (5 * r6) + h8 * (5 * r5) + h9 * (5 * r4);
    c += d3 >>> 13;
    d3 &= 8191;
    let d4 = c + h0 * r4 + h1 * r3 + h2 * r2 + h3 * r1 + h4 * r0;
    c = d4 >>> 13;
    d4 &= 8191;
    d4 += h5 * (5 * r9) + h6 * (5 * r8) + h7 * (5 * r7) + h8 * (5 * r6) + h9 * (5 * r5);
    c += d4 >>> 13;
    d4 &= 8191;
    let d5 = c + h0 * r5 + h1 * r4 + h2 * r3 + h3 * r2 + h4 * r1;
    c = d5 >>> 13;
    d5 &= 8191;
    d5 += h5 * r0 + h6 * (5 * r9) + h7 * (5 * r8) + h8 * (5 * r7) + h9 * (5 * r6);
    c += d5 >>> 13;
    d5 &= 8191;
    let d6 = c + h0 * r6 + h1 * r5 + h2 * r4 + h3 * r3 + h4 * r2;
    c = d6 >>> 13;
    d6 &= 8191;
    d6 += h5 * r1 + h6 * r0 + h7 * (5 * r9) + h8 * (5 * r8) + h9 * (5 * r7);
    c += d6 >>> 13;
    d6 &= 8191;
    let d7 = c + h0 * r7 + h1 * r6 + h2 * r5 + h3 * r4 + h4 * r3;
    c = d7 >>> 13;
    d7 &= 8191;
    d7 += h5 * r2 + h6 * r1 + h7 * r0 + h8 * (5 * r9) + h9 * (5 * r8);
    c += d7 >>> 13;
    d7 &= 8191;
    let d8 = c + h0 * r8 + h1 * r7 + h2 * r6 + h3 * r5 + h4 * r4;
    c = d8 >>> 13;
    d8 &= 8191;
    d8 += h5 * r3 + h6 * r2 + h7 * r1 + h8 * r0 + h9 * (5 * r9);
    c += d8 >>> 13;
    d8 &= 8191;
    let d9 = c + h0 * r9 + h1 * r8 + h2 * r7 + h3 * r6 + h4 * r5;
    c = d9 >>> 13;
    d9 &= 8191;
    d9 += h5 * r4 + h6 * r3 + h7 * r2 + h8 * r1 + h9 * r0;
    c += d9 >>> 13;
    d9 &= 8191;
    c = (c << 2) + c | 0;
    c = c + d0 | 0;
    d0 = c & 8191;
    c = c >>> 13;
    d1 += c;
    h[0] = d0;
    h[1] = d1;
    h[2] = d2;
    h[3] = d3;
    h[4] = d4;
    h[5] = d5;
    h[6] = d6;
    h[7] = d7;
    h[8] = d8;
    h[9] = d9;
  }
  finalize() {
    const { h, pad } = this;
    const g = new Uint16Array(10);
    let c = h[1] >>> 13;
    h[1] &= 8191;
    for (let i = 2; i < 10; i++) {
      h[i] += c;
      c = h[i] >>> 13;
      h[i] &= 8191;
    }
    h[0] += c * 5;
    c = h[0] >>> 13;
    h[0] &= 8191;
    h[1] += c;
    c = h[1] >>> 13;
    h[1] &= 8191;
    h[2] += c;
    g[0] = h[0] + 5;
    c = g[0] >>> 13;
    g[0] &= 8191;
    for (let i = 1; i < 10; i++) {
      g[i] = h[i] + c;
      c = g[i] >>> 13;
      g[i] &= 8191;
    }
    g[9] -= 1 << 13;
    let mask = (c ^ 1) - 1;
    for (let i = 0; i < 10; i++)
      g[i] &= mask;
    mask = ~mask;
    for (let i = 0; i < 10; i++)
      h[i] = h[i] & mask | g[i];
    h[0] = (h[0] | h[1] << 13) & 65535;
    h[1] = (h[1] >>> 3 | h[2] << 10) & 65535;
    h[2] = (h[2] >>> 6 | h[3] << 7) & 65535;
    h[3] = (h[3] >>> 9 | h[4] << 4) & 65535;
    h[4] = (h[4] >>> 12 | h[5] << 1 | h[6] << 14) & 65535;
    h[5] = (h[6] >>> 2 | h[7] << 11) & 65535;
    h[6] = (h[7] >>> 5 | h[8] << 8) & 65535;
    h[7] = (h[8] >>> 8 | h[9] << 5) & 65535;
    let f2 = h[0] + pad[0];
    h[0] = f2 & 65535;
    for (let i = 1; i < 8; i++) {
      f2 = (h[i] + pad[i] | 0) + (f2 >>> 16) | 0;
      h[i] = f2 & 65535;
    }
  }
  update(data) {
    exists(this);
    const { buffer, blockLen } = this;
    data = toBytes2(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take2 = Math.min(blockLen - this.pos, len - pos);
      if (take2 === blockLen) {
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(data, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take2), this.pos);
      this.pos += take2;
      pos += take2;
      if (this.pos === blockLen) {
        this.process(buffer, 0, false);
        this.pos = 0;
      }
    }
    return this;
  }
  destroy() {
    this.h.fill(0);
    this.r.fill(0);
    this.buffer.fill(0);
    this.pad.fill(0);
  }
  digestInto(out) {
    exists(this);
    output(out, this);
    this.finished = true;
    const { buffer, h } = this;
    let { pos } = this;
    if (pos) {
      buffer[pos++] = 1;
      for (; pos < 16; pos++)
        buffer[pos] = 0;
      this.process(buffer, 0, true);
    }
    this.finalize();
    let opos = 0;
    for (let i = 0; i < 8; i++) {
      out[opos++] = h[i] >>> 0;
      out[opos++] = h[i] >>> 8;
    }
    return out;
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
};
function wrapConstructorWithKey(hashCons) {
  const hashC = (msg, key) => hashCons(key).update(toBytes2(msg)).digest();
  const tmp = hashCons(new Uint8Array(32));
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (key) => hashCons(key);
  return hashC;
}
var poly1305 = wrapConstructorWithKey((key) => new Poly1305(key));

// node_modules/@noble/ciphers/esm/_arx.js
var sigma16 = utf8ToBytes3("expand 16-byte k");
var sigma32 = utf8ToBytes3("expand 32-byte k");
var sigma16_32 = u32(sigma16);
var sigma32_32 = u32(sigma32);
function rotl(a, b) {
  return a << b | a >>> 32 - b;
}
function isAligned32(b) {
  return b.byteOffset % 4 === 0;
}
var BLOCK_LEN = 64;
var BLOCK_LEN32 = 16;
var MAX_COUNTER = 2 ** 32 - 1;
var U32_EMPTY = new Uint32Array();
function runCipher(core, sigma, key, nonce, data, output2, counter, rounds) {
  const len = data.length;
  const block = new Uint8Array(BLOCK_LEN);
  const b32 = u32(block);
  const isAligned = isAligned32(data) && isAligned32(output2);
  const d32 = isAligned ? u32(data) : U32_EMPTY;
  const o32 = isAligned ? u32(output2) : U32_EMPTY;
  for (let pos = 0; pos < len; counter++) {
    core(sigma, key, nonce, b32, counter, rounds);
    if (counter >= MAX_COUNTER)
      throw new Error("arx: counter overflow");
    const take2 = Math.min(BLOCK_LEN, len - pos);
    if (isAligned && take2 === BLOCK_LEN) {
      const pos32 = pos / 4;
      if (pos % 4 !== 0)
        throw new Error("arx: invalid block position");
      for (let j = 0, posj; j < BLOCK_LEN32; j++) {
        posj = pos32 + j;
        o32[posj] = d32[posj] ^ b32[j];
      }
      pos += BLOCK_LEN;
      continue;
    }
    for (let j = 0, posj; j < take2; j++) {
      posj = pos + j;
      output2[posj] = data[posj] ^ block[j];
    }
    pos += take2;
  }
}
function createCipher(core, opts) {
  const { allowShortKeys, extendNonceFn, counterLength, counterRight, rounds } = checkOpts({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, opts);
  if (typeof core !== "function")
    throw new Error("core must be a function");
  number2(counterLength);
  number2(rounds);
  bool(counterRight);
  bool(allowShortKeys);
  return (key, nonce, data, output2, counter = 0) => {
    bytes(key);
    bytes(nonce);
    bytes(data);
    const len = data.length;
    if (!output2)
      output2 = new Uint8Array(len);
    bytes(output2);
    number2(counter);
    if (counter < 0 || counter >= MAX_COUNTER)
      throw new Error("arx: counter overflow");
    if (output2.length < len)
      throw new Error(`arx: output (${output2.length}) is shorter than data (${len})`);
    const toClean = [];
    let l = key.length, k, sigma;
    if (l === 32) {
      k = key.slice();
      toClean.push(k);
      sigma = sigma32_32;
    } else if (l === 16 && allowShortKeys) {
      k = new Uint8Array(32);
      k.set(key);
      k.set(key, 16);
      sigma = sigma16_32;
      toClean.push(k);
    } else {
      throw new Error(`arx: invalid 32-byte key, got length=${l}`);
    }
    if (!isAligned32(nonce)) {
      nonce = nonce.slice();
      toClean.push(nonce);
    }
    const k32 = u32(k);
    if (extendNonceFn) {
      if (nonce.length !== 24)
        throw new Error(`arx: extended nonce must be 24 bytes`);
      extendNonceFn(sigma, k32, u32(nonce.subarray(0, 16)), k32);
      nonce = nonce.subarray(16);
    }
    const nonceNcLen = 16 - counterLength;
    if (nonceNcLen !== nonce.length)
      throw new Error(`arx: nonce must be ${nonceNcLen} or 16 bytes`);
    if (nonceNcLen !== 12) {
      const nc = new Uint8Array(12);
      nc.set(nonce, counterRight ? 0 : 12 - nonce.length);
      nonce = nc;
      toClean.push(nonce);
    }
    const n32 = u32(nonce);
    runCipher(core, sigma, k32, n32, data, output2, counter, rounds);
    while (toClean.length > 0)
      toClean.pop().fill(0);
    return output2;
  };
}

// node_modules/@noble/ciphers/esm/chacha.js
function chachaCore(s, k, n, out, cnt, rounds = 20) {
  let y00 = s[0], y01 = s[1], y02 = s[2], y03 = s[3], y04 = k[0], y05 = k[1], y06 = k[2], y07 = k[3], y08 = k[4], y09 = k[5], y10 = k[6], y11 = k[7], y12 = cnt, y13 = n[0], y14 = n[1], y15 = n[2];
  let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
  for (let r = 0; r < rounds; r += 2) {
    x00 = x00 + x04 | 0;
    x12 = rotl(x12 ^ x00, 16);
    x08 = x08 + x12 | 0;
    x04 = rotl(x04 ^ x08, 12);
    x00 = x00 + x04 | 0;
    x12 = rotl(x12 ^ x00, 8);
    x08 = x08 + x12 | 0;
    x04 = rotl(x04 ^ x08, 7);
    x01 = x01 + x05 | 0;
    x13 = rotl(x13 ^ x01, 16);
    x09 = x09 + x13 | 0;
    x05 = rotl(x05 ^ x09, 12);
    x01 = x01 + x05 | 0;
    x13 = rotl(x13 ^ x01, 8);
    x09 = x09 + x13 | 0;
    x05 = rotl(x05 ^ x09, 7);
    x02 = x02 + x06 | 0;
    x14 = rotl(x14 ^ x02, 16);
    x10 = x10 + x14 | 0;
    x06 = rotl(x06 ^ x10, 12);
    x02 = x02 + x06 | 0;
    x14 = rotl(x14 ^ x02, 8);
    x10 = x10 + x14 | 0;
    x06 = rotl(x06 ^ x10, 7);
    x03 = x03 + x07 | 0;
    x15 = rotl(x15 ^ x03, 16);
    x11 = x11 + x15 | 0;
    x07 = rotl(x07 ^ x11, 12);
    x03 = x03 + x07 | 0;
    x15 = rotl(x15 ^ x03, 8);
    x11 = x11 + x15 | 0;
    x07 = rotl(x07 ^ x11, 7);
    x00 = x00 + x05 | 0;
    x15 = rotl(x15 ^ x00, 16);
    x10 = x10 + x15 | 0;
    x05 = rotl(x05 ^ x10, 12);
    x00 = x00 + x05 | 0;
    x15 = rotl(x15 ^ x00, 8);
    x10 = x10 + x15 | 0;
    x05 = rotl(x05 ^ x10, 7);
    x01 = x01 + x06 | 0;
    x12 = rotl(x12 ^ x01, 16);
    x11 = x11 + x12 | 0;
    x06 = rotl(x06 ^ x11, 12);
    x01 = x01 + x06 | 0;
    x12 = rotl(x12 ^ x01, 8);
    x11 = x11 + x12 | 0;
    x06 = rotl(x06 ^ x11, 7);
    x02 = x02 + x07 | 0;
    x13 = rotl(x13 ^ x02, 16);
    x08 = x08 + x13 | 0;
    x07 = rotl(x07 ^ x08, 12);
    x02 = x02 + x07 | 0;
    x13 = rotl(x13 ^ x02, 8);
    x08 = x08 + x13 | 0;
    x07 = rotl(x07 ^ x08, 7);
    x03 = x03 + x04 | 0;
    x14 = rotl(x14 ^ x03, 16);
    x09 = x09 + x14 | 0;
    x04 = rotl(x04 ^ x09, 12);
    x03 = x03 + x04 | 0;
    x14 = rotl(x14 ^ x03, 8);
    x09 = x09 + x14 | 0;
    x04 = rotl(x04 ^ x09, 7);
  }
  let oi = 0;
  out[oi++] = y00 + x00 | 0;
  out[oi++] = y01 + x01 | 0;
  out[oi++] = y02 + x02 | 0;
  out[oi++] = y03 + x03 | 0;
  out[oi++] = y04 + x04 | 0;
  out[oi++] = y05 + x05 | 0;
  out[oi++] = y06 + x06 | 0;
  out[oi++] = y07 + x07 | 0;
  out[oi++] = y08 + x08 | 0;
  out[oi++] = y09 + x09 | 0;
  out[oi++] = y10 + x10 | 0;
  out[oi++] = y11 + x11 | 0;
  out[oi++] = y12 + x12 | 0;
  out[oi++] = y13 + x13 | 0;
  out[oi++] = y14 + x14 | 0;
  out[oi++] = y15 + x15 | 0;
}
function hchacha(s, k, i, o32) {
  let x00 = s[0], x01 = s[1], x02 = s[2], x03 = s[3], x04 = k[0], x05 = k[1], x06 = k[2], x07 = k[3], x08 = k[4], x09 = k[5], x10 = k[6], x11 = k[7], x12 = i[0], x13 = i[1], x14 = i[2], x15 = i[3];
  for (let r = 0; r < 20; r += 2) {
    x00 = x00 + x04 | 0;
    x12 = rotl(x12 ^ x00, 16);
    x08 = x08 + x12 | 0;
    x04 = rotl(x04 ^ x08, 12);
    x00 = x00 + x04 | 0;
    x12 = rotl(x12 ^ x00, 8);
    x08 = x08 + x12 | 0;
    x04 = rotl(x04 ^ x08, 7);
    x01 = x01 + x05 | 0;
    x13 = rotl(x13 ^ x01, 16);
    x09 = x09 + x13 | 0;
    x05 = rotl(x05 ^ x09, 12);
    x01 = x01 + x05 | 0;
    x13 = rotl(x13 ^ x01, 8);
    x09 = x09 + x13 | 0;
    x05 = rotl(x05 ^ x09, 7);
    x02 = x02 + x06 | 0;
    x14 = rotl(x14 ^ x02, 16);
    x10 = x10 + x14 | 0;
    x06 = rotl(x06 ^ x10, 12);
    x02 = x02 + x06 | 0;
    x14 = rotl(x14 ^ x02, 8);
    x10 = x10 + x14 | 0;
    x06 = rotl(x06 ^ x10, 7);
    x03 = x03 + x07 | 0;
    x15 = rotl(x15 ^ x03, 16);
    x11 = x11 + x15 | 0;
    x07 = rotl(x07 ^ x11, 12);
    x03 = x03 + x07 | 0;
    x15 = rotl(x15 ^ x03, 8);
    x11 = x11 + x15 | 0;
    x07 = rotl(x07 ^ x11, 7);
    x00 = x00 + x05 | 0;
    x15 = rotl(x15 ^ x00, 16);
    x10 = x10 + x15 | 0;
    x05 = rotl(x05 ^ x10, 12);
    x00 = x00 + x05 | 0;
    x15 = rotl(x15 ^ x00, 8);
    x10 = x10 + x15 | 0;
    x05 = rotl(x05 ^ x10, 7);
    x01 = x01 + x06 | 0;
    x12 = rotl(x12 ^ x01, 16);
    x11 = x11 + x12 | 0;
    x06 = rotl(x06 ^ x11, 12);
    x01 = x01 + x06 | 0;
    x12 = rotl(x12 ^ x01, 8);
    x11 = x11 + x12 | 0;
    x06 = rotl(x06 ^ x11, 7);
    x02 = x02 + x07 | 0;
    x13 = rotl(x13 ^ x02, 16);
    x08 = x08 + x13 | 0;
    x07 = rotl(x07 ^ x08, 12);
    x02 = x02 + x07 | 0;
    x13 = rotl(x13 ^ x02, 8);
    x08 = x08 + x13 | 0;
    x07 = rotl(x07 ^ x08, 7);
    x03 = x03 + x04 | 0;
    x14 = rotl(x14 ^ x03, 16);
    x09 = x09 + x14 | 0;
    x04 = rotl(x04 ^ x09, 12);
    x03 = x03 + x04 | 0;
    x14 = rotl(x14 ^ x03, 8);
    x09 = x09 + x14 | 0;
    x04 = rotl(x04 ^ x09, 7);
  }
  let oi = 0;
  o32[oi++] = x00;
  o32[oi++] = x01;
  o32[oi++] = x02;
  o32[oi++] = x03;
  o32[oi++] = x12;
  o32[oi++] = x13;
  o32[oi++] = x14;
  o32[oi++] = x15;
}
var chacha20orig = createCipher(chachaCore, {
  counterRight: false,
  counterLength: 8,
  allowShortKeys: true
});
var chacha20 = createCipher(chachaCore, {
  counterRight: false,
  counterLength: 4,
  allowShortKeys: false
});
var xchacha20 = createCipher(chachaCore, {
  counterRight: false,
  counterLength: 8,
  extendNonceFn: hchacha,
  allowShortKeys: false
});
var chacha8 = createCipher(chachaCore, {
  counterRight: false,
  counterLength: 4,
  rounds: 8
});
var chacha12 = createCipher(chachaCore, {
  counterRight: false,
  counterLength: 4,
  rounds: 12
});
var ZEROS16 = new Uint8Array(16);
var updatePadded = (h, msg) => {
  h.update(msg);
  const left = msg.length % 16;
  if (left)
    h.update(ZEROS16.subarray(left));
};
var ZEROS32 = new Uint8Array(32);
function computeTag(fn, key, nonce, data, AAD) {
  const authKey = fn(key, nonce, ZEROS32);
  const h = poly1305.create(authKey);
  if (AAD)
    updatePadded(h, AAD);
  updatePadded(h, data);
  const num = new Uint8Array(16);
  const view = createView(num);
  setBigUint64(view, 0, BigInt(AAD ? AAD.length : 0), true);
  setBigUint64(view, 8, BigInt(data.length), true);
  h.update(num);
  const res = h.digest();
  authKey.fill(0);
  return res;
}
var _poly1305_aead = (xorStream) => (key, nonce, AAD) => {
  const tagLength = 16;
  ensureBytes2(key, 32);
  ensureBytes2(nonce);
  return {
    encrypt: (plaintext, output2) => {
      const plength = plaintext.length;
      const clength = plength + tagLength;
      if (output2) {
        ensureBytes2(output2, clength);
      } else {
        output2 = new Uint8Array(clength);
      }
      xorStream(key, nonce, plaintext, output2, 1);
      const tag = computeTag(xorStream, key, nonce, output2.subarray(0, -tagLength), AAD);
      output2.set(tag, plength);
      return output2;
    },
    decrypt: (ciphertext, output2) => {
      const clength = ciphertext.length;
      const plength = clength - tagLength;
      if (clength < tagLength)
        throw new Error(`encrypted data must be at least ${tagLength} bytes`);
      if (output2) {
        ensureBytes2(output2, plength);
      } else {
        output2 = new Uint8Array(plength);
      }
      const data = ciphertext.subarray(0, -tagLength);
      const passedTag = ciphertext.subarray(-tagLength);
      const tag = computeTag(xorStream, key, nonce, data, AAD);
      if (!equalBytes2(passedTag, tag))
        throw new Error("invalid tag");
      xorStream(key, nonce, data, output2, 1);
      return output2;
    }
  };
};
var chacha20poly1305 = wrapCipher({ blockSize: 64, nonceLength: 12, tagLength: 16 }, _poly1305_aead(chacha20));
var xchacha20poly1305 = wrapCipher({ blockSize: 64, nonceLength: 24, tagLength: 16 }, _poly1305_aead(xchacha20));

// node_modules/@noble/hashes/esm/sha512.js
var [SHA512_Kh, SHA512_Kl] = (() => u64_default.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n) => BigInt(n))))();
var SHA512_W_H = new Uint32Array(80);
var SHA512_W_L = new Uint32Array(80);
var SHA512 = class extends SHA2 {
  constructor() {
    super(128, 64, 16, false);
    this.Ah = 1779033703 | 0;
    this.Al = 4089235720 | 0;
    this.Bh = 3144134277 | 0;
    this.Bl = 2227873595 | 0;
    this.Ch = 1013904242 | 0;
    this.Cl = 4271175723 | 0;
    this.Dh = 2773480762 | 0;
    this.Dl = 1595750129 | 0;
    this.Eh = 1359893119 | 0;
    this.El = 2917565137 | 0;
    this.Fh = 2600822924 | 0;
    this.Fl = 725511199 | 0;
    this.Gh = 528734635 | 0;
    this.Gl = 4215389547 | 0;
    this.Hh = 1541459225 | 0;
    this.Hl = 327033209 | 0;
  }
  // prettier-ignore
  get() {
    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  // prettier-ignore
  set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4) {
      SHA512_W_H[i] = view.getUint32(offset);
      SHA512_W_L[i] = view.getUint32(offset += 4);
    }
    for (let i = 16; i < 80; i++) {
      const W15h = SHA512_W_H[i - 15] | 0;
      const W15l = SHA512_W_L[i - 15] | 0;
      const s0h = u64_default.rotrSH(W15h, W15l, 1) ^ u64_default.rotrSH(W15h, W15l, 8) ^ u64_default.shrSH(W15h, W15l, 7);
      const s0l = u64_default.rotrSL(W15h, W15l, 1) ^ u64_default.rotrSL(W15h, W15l, 8) ^ u64_default.shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i - 2] | 0;
      const W2l = SHA512_W_L[i - 2] | 0;
      const s1h = u64_default.rotrSH(W2h, W2l, 19) ^ u64_default.rotrBH(W2h, W2l, 61) ^ u64_default.shrSH(W2h, W2l, 6);
      const s1l = u64_default.rotrSL(W2h, W2l, 19) ^ u64_default.rotrBL(W2h, W2l, 61) ^ u64_default.shrSL(W2h, W2l, 6);
      const SUMl = u64_default.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
      const SUMh = u64_default.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
      SHA512_W_H[i] = SUMh | 0;
      SHA512_W_L[i] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i = 0; i < 80; i++) {
      const sigma1h = u64_default.rotrSH(Eh, El, 14) ^ u64_default.rotrSH(Eh, El, 18) ^ u64_default.rotrBH(Eh, El, 41);
      const sigma1l = u64_default.rotrSL(Eh, El, 14) ^ u64_default.rotrSL(Eh, El, 18) ^ u64_default.rotrBL(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = u64_default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
      const T1h = u64_default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
      const T1l = T1ll | 0;
      const sigma0h = u64_default.rotrSH(Ah, Al, 28) ^ u64_default.rotrBH(Ah, Al, 34) ^ u64_default.rotrBH(Ah, Al, 39);
      const sigma0l = u64_default.rotrSL(Ah, Al, 28) ^ u64_default.rotrBL(Ah, Al, 34) ^ u64_default.rotrBL(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = u64_default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl | 0;
      Bh = Ah | 0;
      Bl = Al | 0;
      const All = u64_default.add3L(T1l, sigma0l, MAJl);
      Ah = u64_default.add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = u64_default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl } = u64_default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
    ({ h: Ch, l: Cl } = u64_default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = u64_default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = u64_default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = u64_default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = u64_default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = u64_default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    SHA512_W_H.fill(0);
    SHA512_W_L.fill(0);
  }
  destroy() {
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var SHA512_224 = class extends SHA512 {
  constructor() {
    super();
    this.Ah = 2352822216 | 0;
    this.Al = 424955298 | 0;
    this.Bh = 1944164710 | 0;
    this.Bl = 2312950998 | 0;
    this.Ch = 502970286 | 0;
    this.Cl = 855612546 | 0;
    this.Dh = 1738396948 | 0;
    this.Dl = 1479516111 | 0;
    this.Eh = 258812777 | 0;
    this.El = 2077511080 | 0;
    this.Fh = 2011393907 | 0;
    this.Fl = 79989058 | 0;
    this.Gh = 1067287976 | 0;
    this.Gl = 1780299464 | 0;
    this.Hh = 286451373 | 0;
    this.Hl = 2446758561 | 0;
    this.outputLen = 28;
  }
};
var SHA512_256 = class extends SHA512 {
  constructor() {
    super();
    this.Ah = 573645204 | 0;
    this.Al = 4230739756 | 0;
    this.Bh = 2673172387 | 0;
    this.Bl = 3360449730 | 0;
    this.Ch = 596883563 | 0;
    this.Cl = 1867755857 | 0;
    this.Dh = 2520282905 | 0;
    this.Dl = 1497426621 | 0;
    this.Eh = 2519219938 | 0;
    this.El = 2827943907 | 0;
    this.Fh = 3193839141 | 0;
    this.Fl = 1401305490 | 0;
    this.Gh = 721525244 | 0;
    this.Gl = 746961066 | 0;
    this.Hh = 246885852 | 0;
    this.Hl = 2177182882 | 0;
    this.outputLen = 32;
  }
};
var SHA384 = class extends SHA512 {
  constructor() {
    super();
    this.Ah = 3418070365 | 0;
    this.Al = 3238371032 | 0;
    this.Bh = 1654270250 | 0;
    this.Bl = 914150663 | 0;
    this.Ch = 2438529370 | 0;
    this.Cl = 812702999 | 0;
    this.Dh = 355462360 | 0;
    this.Dl = 4144912697 | 0;
    this.Eh = 1731405415 | 0;
    this.El = 4290775857 | 0;
    this.Fh = 2394180231 | 0;
    this.Fl = 1750603025 | 0;
    this.Gh = 3675008525 | 0;
    this.Gl = 1694076839 | 0;
    this.Hh = 1203062813 | 0;
    this.Hl = 3204075428 | 0;
    this.outputLen = 48;
  }
};
var sha512 = wrapConstructor(() => new SHA512());
var sha512_224 = wrapConstructor(() => new SHA512_224());
var sha512_256 = wrapConstructor(() => new SHA512_256());
var sha384 = wrapConstructor(() => new SHA384());

// node_modules/@noble/curves/esm/abstract/edwards.js
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
var _8n = BigInt(8);
var VERIFY_DEFAULT = { zip215: true };
function validateOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(curve, {
    hash: "function",
    a: "bigint",
    d: "bigint",
    randomBytes: "function"
  }, {
    adjustScalarBytes: "function",
    domain: "function",
    uvRatio: "function",
    mapToCurve: "function"
  });
  return Object.freeze({ ...opts });
}
function twistedEdwards(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { Fp: Fp2, n: CURVE_ORDER, prehash, hash: cHash, randomBytes: randomBytes3, nByteLength, h: cofactor } = CURVE;
  const MASK = _2n << BigInt(nByteLength * 8) - _1n;
  const modP = Fp2.create;
  const uvRatio2 = CURVE.uvRatio || ((u, v) => {
    try {
      return { isValid: true, value: Fp2.sqrt(u * Fp2.inv(v)) };
    } catch (e) {
      return { isValid: false, value: _0n };
    }
  });
  const adjustScalarBytes2 = CURVE.adjustScalarBytes || ((bytes2) => bytes2);
  const domain = CURVE.domain || ((data, ctx, phflag) => {
    if (ctx.length || phflag)
      throw new Error("Contexts/pre-hash are not supported");
    return data;
  });
  const inBig = (n) => typeof n === "bigint" && _0n < n;
  const inRange = (n, max) => inBig(n) && inBig(max) && n < max;
  const in0MaskRange = (n) => n === _0n || inRange(n, MASK);
  function assertInRange(n, max) {
    if (inRange(n, max))
      return n;
    throw new Error(`Expected valid scalar < ${max}, got ${typeof n} ${n}`);
  }
  function assertGE0(n) {
    return n === _0n ? n : assertInRange(n, CURVE_ORDER);
  }
  const pointPrecomputes = /* @__PURE__ */ new Map();
  function isPoint(other) {
    if (!(other instanceof Point))
      throw new Error("ExtendedPoint expected");
  }
  class Point {
    constructor(ex, ey, ez, et) {
      this.ex = ex;
      this.ey = ey;
      this.ez = ez;
      this.et = et;
      if (!in0MaskRange(ex))
        throw new Error("x required");
      if (!in0MaskRange(ey))
        throw new Error("y required");
      if (!in0MaskRange(ez))
        throw new Error("z required");
      if (!in0MaskRange(et))
        throw new Error("t required");
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static fromAffine(p) {
      if (p instanceof Point)
        throw new Error("extended point not allowed");
      const { x, y } = p || {};
      if (!in0MaskRange(x) || !in0MaskRange(y))
        throw new Error("invalid affine point");
      return new Point(x, y, _1n, modP(x * y));
    }
    static normalizeZ(points) {
      const toInv = Fp2.invertBatch(points.map((p) => p.ez));
      return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      this._WINDOW_SIZE = windowSize;
      pointPrecomputes.delete(this);
    }
    // Not required for fromHex(), which always creates valid points.
    // Could be useful for fromAffine().
    assertValidity() {
      const { a, d } = CURVE;
      if (this.is0())
        throw new Error("bad point: ZERO");
      const { ex: X, ey: Y, ez: Z, et: T } = this;
      const X2 = modP(X * X);
      const Y2 = modP(Y * Y);
      const Z2 = modP(Z * Z);
      const Z4 = modP(Z2 * Z2);
      const aX2 = modP(X2 * a);
      const left = modP(Z2 * modP(aX2 + Y2));
      const right = modP(Z4 + modP(d * modP(X2 * Y2)));
      if (left !== right)
        throw new Error("bad point: equation left != right (1)");
      const XY = modP(X * Y);
      const ZT = modP(Z * T);
      if (XY !== ZT)
        throw new Error("bad point: equation left != right (2)");
    }
    // Compare one point to another.
    equals(other) {
      isPoint(other);
      const { ex: X1, ey: Y1, ez: Z1 } = this;
      const { ex: X2, ey: Y2, ez: Z2 } = other;
      const X1Z2 = modP(X1 * Z2);
      const X2Z1 = modP(X2 * Z1);
      const Y1Z2 = modP(Y1 * Z2);
      const Y2Z1 = modP(Y2 * Z1);
      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
    }
    is0() {
      return this.equals(Point.ZERO);
    }
    negate() {
      return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));
    }
    // Fast algo for doubling Extended Point.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
    // Cost: 4M + 4S + 1*a + 6add + 1*2.
    double() {
      const { a } = CURVE;
      const { ex: X1, ey: Y1, ez: Z1 } = this;
      const A = modP(X1 * X1);
      const B = modP(Y1 * Y1);
      const C = modP(_2n * modP(Z1 * Z1));
      const D = modP(a * A);
      const x1y1 = X1 + Y1;
      const E = modP(modP(x1y1 * x1y1) - A - B);
      const G2 = D + B;
      const F = G2 - C;
      const H = D - B;
      const X3 = modP(E * F);
      const Y3 = modP(G2 * H);
      const T3 = modP(E * H);
      const Z3 = modP(F * G2);
      return new Point(X3, Y3, Z3, T3);
    }
    // Fast algo for adding 2 Extended Points.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
    // Cost: 9M + 1*a + 1*d + 7add.
    add(other) {
      isPoint(other);
      const { a, d } = CURVE;
      const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;
      const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;
      if (a === BigInt(-1)) {
        const A2 = modP((Y1 - X1) * (Y2 + X2));
        const B2 = modP((Y1 + X1) * (Y2 - X2));
        const F2 = modP(B2 - A2);
        if (F2 === _0n)
          return this.double();
        const C2 = modP(Z1 * _2n * T2);
        const D2 = modP(T1 * _2n * Z2);
        const E2 = D2 + C2;
        const G3 = B2 + A2;
        const H2 = D2 - C2;
        const X32 = modP(E2 * F2);
        const Y32 = modP(G3 * H2);
        const T32 = modP(E2 * H2);
        const Z32 = modP(F2 * G3);
        return new Point(X32, Y32, Z32, T32);
      }
      const A = modP(X1 * X2);
      const B = modP(Y1 * Y2);
      const C = modP(T1 * d * T2);
      const D = modP(Z1 * Z2);
      const E = modP((X1 + Y1) * (X2 + Y2) - A - B);
      const F = D - C;
      const G2 = D + C;
      const H = modP(B - a * A);
      const X3 = modP(E * F);
      const Y3 = modP(G2 * H);
      const T3 = modP(E * H);
      const Z3 = modP(F * G2);
      return new Point(X3, Y3, Z3, T3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    wNAF(n) {
      return wnaf.wNAFCached(this, pointPrecomputes, n, Point.normalizeZ);
    }
    // Constant-time multiplication.
    multiply(scalar) {
      const { p, f: f2 } = this.wNAF(assertInRange(scalar, CURVE_ORDER));
      return Point.normalizeZ([p, f2])[0];
    }
    // Non-constant-time multiplication. Uses double-and-add algorithm.
    // It's faster, but should only be used when you don't care about
    // an exposed private key e.g. sig verification.
    // Does NOT allow scalars higher than CURVE.n.
    multiplyUnsafe(scalar) {
      let n = assertGE0(scalar);
      if (n === _0n)
        return I;
      if (this.equals(I) || n === _1n)
        return this;
      if (this.equals(G))
        return this.wNAF(n).p;
      return wnaf.unsafeLadder(this, n);
    }
    // Checks if point is of small order.
    // If you add something to small order point, you will have "dirty"
    // point with torsion component.
    // Multiplies point by cofactor and checks if the result is 0.
    isSmallOrder() {
      return this.multiplyUnsafe(cofactor).is0();
    }
    // Multiplies point by curve order and checks if the result is 0.
    // Returns `false` is the point is dirty.
    isTorsionFree() {
      return wnaf.unsafeLadder(this, CURVE_ORDER).is0();
    }
    // Converts Extended point to default (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    toAffine(iz) {
      const { ex: x, ey: y, ez: z } = this;
      const is0 = this.is0();
      if (iz == null)
        iz = is0 ? _8n : Fp2.inv(z);
      const ax = modP(x * iz);
      const ay = modP(y * iz);
      const zz = modP(z * iz);
      if (is0)
        return { x: _0n, y: _1n };
      if (zz !== _1n)
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    }
    clearCofactor() {
      const { h: cofactor2 } = CURVE;
      if (cofactor2 === _1n)
        return this;
      return this.multiplyUnsafe(cofactor2);
    }
    // Converts hash string or Uint8Array to Point.
    // Uses algo from RFC8032 5.1.3.
    static fromHex(hex, zip215 = false) {
      const { d, a } = CURVE;
      const len = Fp2.BYTES;
      hex = ensureBytes("pointHex", hex, len);
      const normed = hex.slice();
      const lastByte = hex[len - 1];
      normed[len - 1] = lastByte & ~128;
      const y = bytesToNumberLE(normed);
      if (y === _0n) {
      } else {
        if (zip215)
          assertInRange(y, MASK);
        else
          assertInRange(y, Fp2.ORDER);
      }
      const y2 = modP(y * y);
      const u = modP(y2 - _1n);
      const v = modP(d * y2 - a);
      let { isValid, value: x } = uvRatio2(u, v);
      if (!isValid)
        throw new Error("Point.fromHex: invalid y coordinate");
      const isXOdd = (x & _1n) === _1n;
      const isLastByteOdd = (lastByte & 128) !== 0;
      if (!zip215 && x === _0n && isLastByteOdd)
        throw new Error("Point.fromHex: x=0 and x_0=1");
      if (isLastByteOdd !== isXOdd)
        x = modP(-x);
      return Point.fromAffine({ x, y });
    }
    static fromPrivateKey(privKey) {
      return getExtendedPublicKey(privKey).point;
    }
    toRawBytes() {
      const { x, y } = this.toAffine();
      const bytes2 = numberToBytesLE(y, Fp2.BYTES);
      bytes2[bytes2.length - 1] |= x & _1n ? 128 : 0;
      return bytes2;
    }
    toHex() {
      return bytesToHex(this.toRawBytes());
    }
  }
  Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));
  Point.ZERO = new Point(_0n, _1n, _1n, _0n);
  const { BASE: G, ZERO: I } = Point;
  const wnaf = wNAF(Point, nByteLength * 8);
  function modN(a) {
    return mod(a, CURVE_ORDER);
  }
  function modN_LE(hash2) {
    return modN(bytesToNumberLE(hash2));
  }
  function getExtendedPublicKey(key) {
    const len = nByteLength;
    key = ensureBytes("private key", key, len);
    const hashed = ensureBytes("hashed private key", cHash(key), 2 * len);
    const head = adjustScalarBytes2(hashed.slice(0, len));
    const prefix = hashed.slice(len, 2 * len);
    const scalar = modN_LE(head);
    const point = G.multiply(scalar);
    const pointBytes = point.toRawBytes();
    return { head, prefix, scalar, point, pointBytes };
  }
  function getPublicKey(privKey) {
    return getExtendedPublicKey(privKey).pointBytes;
  }
  function hashDomainToScalar(context = new Uint8Array(), ...msgs) {
    const msg = concatBytes2(...msgs);
    return modN_LE(cHash(domain(msg, ensureBytes("context", context), !!prehash)));
  }
  function sign(msg, privKey, options = {}) {
    msg = ensureBytes("message", msg);
    if (prehash)
      msg = prehash(msg);
    const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);
    const r = hashDomainToScalar(options.context, prefix, msg);
    const R = G.multiply(r).toRawBytes();
    const k = hashDomainToScalar(options.context, R, pointBytes, msg);
    const s = modN(r + k * scalar);
    assertGE0(s);
    const res = concatBytes2(R, numberToBytesLE(s, Fp2.BYTES));
    return ensureBytes("result", res, nByteLength * 2);
  }
  const verifyOpts = VERIFY_DEFAULT;
  function verify(sig, msg, publicKey, options = verifyOpts) {
    const { context, zip215 } = options;
    const len = Fp2.BYTES;
    sig = ensureBytes("signature", sig, 2 * len);
    msg = ensureBytes("message", msg);
    if (prehash)
      msg = prehash(msg);
    const s = bytesToNumberLE(sig.slice(len, 2 * len));
    let A, R, SB;
    try {
      A = Point.fromHex(publicKey, zip215);
      R = Point.fromHex(sig.slice(0, len), zip215);
      SB = G.multiplyUnsafe(s);
    } catch (error) {
      return false;
    }
    if (!zip215 && A.isSmallOrder())
      return false;
    const k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);
    const RkA = R.add(A.multiplyUnsafe(k));
    return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);
  }
  G._setWindowSize(8);
  const utils = {
    getExtendedPublicKey,
    // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.
    randomPrivateKey: () => randomBytes3(Fp2.BYTES),
    /**
     * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT
     * values. This slows down first getPublicKey() by milliseconds (see Speed section),
     * but allows to speed-up subsequent getPublicKey() calls up to 20x.
     * @param windowSize 2, 4, 8, 16
     */
    precompute(windowSize = 8, point = Point.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  return {
    CURVE,
    getPublicKey,
    sign,
    verify,
    ExtendedPoint: Point,
    utils
  };
}

// node_modules/@noble/curves/esm/abstract/montgomery.js
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
function validateOpts2(curve) {
  validateObject(curve, {
    a: "bigint"
  }, {
    montgomeryBits: "isSafeInteger",
    nByteLength: "isSafeInteger",
    adjustScalarBytes: "function",
    domain: "function",
    powPminus2: "function",
    Gu: "bigint"
  });
  return Object.freeze({ ...curve });
}
function montgomery(curveDef) {
  const CURVE = validateOpts2(curveDef);
  const { P } = CURVE;
  const modP = (n) => mod(n, P);
  const montgomeryBits = CURVE.montgomeryBits;
  const montgomeryBytes = Math.ceil(montgomeryBits / 8);
  const fieldLen = CURVE.nByteLength;
  const adjustScalarBytes2 = CURVE.adjustScalarBytes || ((bytes2) => bytes2);
  const powPminus2 = CURVE.powPminus2 || ((x) => pow(x, P - BigInt(2), P));
  function cswap(swap, x_2, x_3) {
    const dummy = modP(swap * (x_2 - x_3));
    x_2 = modP(x_2 - dummy);
    x_3 = modP(x_3 + dummy);
    return [x_2, x_3];
  }
  function assertFieldElement(n) {
    if (typeof n === "bigint" && _0n2 <= n && n < P)
      return n;
    throw new Error("Expected valid scalar 0 < scalar < CURVE.P");
  }
  const a24 = (CURVE.a - BigInt(2)) / BigInt(4);
  function montgomeryLadder(pointU, scalar) {
    const u = assertFieldElement(pointU);
    const k = assertFieldElement(scalar);
    const x_1 = u;
    let x_2 = _1n2;
    let z_2 = _0n2;
    let x_3 = u;
    let z_3 = _1n2;
    let swap = _0n2;
    let sw;
    for (let t = BigInt(montgomeryBits - 1); t >= _0n2; t--) {
      const k_t = k >> t & _1n2;
      swap ^= k_t;
      sw = cswap(swap, x_2, x_3);
      x_2 = sw[0];
      x_3 = sw[1];
      sw = cswap(swap, z_2, z_3);
      z_2 = sw[0];
      z_3 = sw[1];
      swap = k_t;
      const A = x_2 + z_2;
      const AA = modP(A * A);
      const B = x_2 - z_2;
      const BB = modP(B * B);
      const E = AA - BB;
      const C = x_3 + z_3;
      const D = x_3 - z_3;
      const DA = modP(D * A);
      const CB = modP(C * B);
      const dacb = DA + CB;
      const da_cb = DA - CB;
      x_3 = modP(dacb * dacb);
      z_3 = modP(x_1 * modP(da_cb * da_cb));
      x_2 = modP(AA * BB);
      z_2 = modP(E * (AA + modP(a24 * E)));
    }
    sw = cswap(swap, x_2, x_3);
    x_2 = sw[0];
    x_3 = sw[1];
    sw = cswap(swap, z_2, z_3);
    z_2 = sw[0];
    z_3 = sw[1];
    const z2 = powPminus2(z_2);
    return modP(x_2 * z2);
  }
  function encodeUCoordinate(u) {
    return numberToBytesLE(modP(u), montgomeryBytes);
  }
  function decodeUCoordinate(uEnc) {
    const u = ensureBytes("u coordinate", uEnc, montgomeryBytes);
    if (fieldLen === montgomeryBytes)
      u[fieldLen - 1] &= 127;
    return bytesToNumberLE(u);
  }
  function decodeScalar(n) {
    const bytes2 = ensureBytes("scalar", n);
    if (bytes2.length !== montgomeryBytes && bytes2.length !== fieldLen)
      throw new Error(`Expected ${montgomeryBytes} or ${fieldLen} bytes, got ${bytes2.length}`);
    return bytesToNumberLE(adjustScalarBytes2(bytes2));
  }
  function scalarMult(scalar, u) {
    const pointU = decodeUCoordinate(u);
    const _scalar = decodeScalar(scalar);
    const pu = montgomeryLadder(pointU, _scalar);
    if (pu === _0n2)
      throw new Error("Invalid private or public key received");
    return encodeUCoordinate(pu);
  }
  const GuBytes = encodeUCoordinate(CURVE.Gu);
  function scalarMultBase(scalar) {
    return scalarMult(scalar, GuBytes);
  }
  return {
    scalarMult,
    scalarMultBase,
    getSharedSecret: (privateKey, publicKey) => scalarMult(privateKey, publicKey),
    getPublicKey: (privateKey) => scalarMultBase(privateKey),
    utils: { randomPrivateKey: () => CURVE.randomBytes(CURVE.nByteLength) },
    GuBytes
  };
}

// node_modules/@noble/curves/esm/ed25519.js
var ED25519_P = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
var ED25519_SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
var _0n3 = BigInt(0);
var _1n3 = BigInt(1);
var _2n2 = BigInt(2);
var _5n = BigInt(5);
var _10n = BigInt(10);
var _20n = BigInt(20);
var _40n = BigInt(40);
var _80n = BigInt(80);
function ed25519_pow_2_252_3(x) {
  const P = ED25519_P;
  const x2 = x * x % P;
  const b2 = x2 * x % P;
  const b4 = pow2(b2, _2n2, P) * b2 % P;
  const b5 = pow2(b4, _1n3, P) * x % P;
  const b10 = pow2(b5, _5n, P) * b5 % P;
  const b20 = pow2(b10, _10n, P) * b10 % P;
  const b40 = pow2(b20, _20n, P) * b20 % P;
  const b80 = pow2(b40, _40n, P) * b40 % P;
  const b160 = pow2(b80, _80n, P) * b80 % P;
  const b240 = pow2(b160, _80n, P) * b80 % P;
  const b250 = pow2(b240, _10n, P) * b10 % P;
  const pow_p_5_8 = pow2(b250, _2n2, P) * x % P;
  return { pow_p_5_8, b2 };
}
function adjustScalarBytes(bytes2) {
  bytes2[0] &= 248;
  bytes2[31] &= 127;
  bytes2[31] |= 64;
  return bytes2;
}
function uvRatio(u, v) {
  const P = ED25519_P;
  const v32 = mod(v * v * v, P);
  const v7 = mod(v32 * v32 * v, P);
  const pow3 = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
  let x = mod(u * v32 * pow3, P);
  const vx2 = mod(v * x * x, P);
  const root1 = x;
  const root2 = mod(x * ED25519_SQRT_M1, P);
  const useRoot1 = vx2 === u;
  const useRoot2 = vx2 === mod(-u, P);
  const noRoot = vx2 === mod(-u * ED25519_SQRT_M1, P);
  if (useRoot1)
    x = root1;
  if (useRoot2 || noRoot)
    x = root2;
  if (isNegativeLE(x, P))
    x = mod(-x, P);
  return { isValid: useRoot1 || useRoot2, value: x };
}
var Fp = Field(ED25519_P, void 0, true);
var ed25519Defaults = {
  // Param: a
  a: BigInt(-1),
  // d is equal to -121665/121666 over finite field.
  // Negative number is P - number, and division is invert(number, P)
  d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
  // Finite field 𝔽p over which we'll do calculations; 2n**255n - 19n
  Fp,
  // Subgroup order: how many points curve has
  // 2n**252n + 27742317777372353535851937790883648493n;
  n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
  // Cofactor
  h: BigInt(8),
  // Base point (x, y) aka generator point
  Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
  Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
  hash: sha512,
  randomBytes,
  adjustScalarBytes,
  // dom2
  // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
  // Constant-time, u/√v
  uvRatio
};
var ed25519 = twistedEdwards(ed25519Defaults);
function ed25519_domain(data, ctx, phflag) {
  if (ctx.length > 255)
    throw new Error("Context is too big");
  return concatBytes(utf8ToBytes2("SigEd25519 no Ed25519 collisions"), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);
}
var ed25519ctx = twistedEdwards({
  ...ed25519Defaults,
  domain: ed25519_domain
});
var ed25519ph = twistedEdwards({
  ...ed25519Defaults,
  domain: ed25519_domain,
  prehash: sha512
});
var x25519 = (() => montgomery({
  P: ED25519_P,
  a: BigInt(486662),
  montgomeryBits: 255,
  nByteLength: 32,
  Gu: BigInt(9),
  powPminus2: (x) => {
    const P = ED25519_P;
    const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);
    return mod(pow2(pow_p_5_8, BigInt(3), P) * b2, P);
  },
  adjustScalarBytes,
  randomBytes
}))();
var ELL2_C1 = (Fp.ORDER + BigInt(3)) / BigInt(8);
var ELL2_C2 = Fp.pow(_2n2, ELL2_C1);
var ELL2_C3 = Fp.sqrt(Fp.neg(Fp.ONE));
var ELL2_C4 = (Fp.ORDER - BigInt(5)) / BigInt(8);
var ELL2_J = BigInt(486662);
function map_to_curve_elligator2_curve25519(u) {
  let tv1 = Fp.sqr(u);
  tv1 = Fp.mul(tv1, _2n2);
  let xd = Fp.add(tv1, Fp.ONE);
  let x1n = Fp.neg(ELL2_J);
  let tv2 = Fp.sqr(xd);
  let gxd = Fp.mul(tv2, xd);
  let gx1 = Fp.mul(tv1, ELL2_J);
  gx1 = Fp.mul(gx1, x1n);
  gx1 = Fp.add(gx1, tv2);
  gx1 = Fp.mul(gx1, x1n);
  let tv3 = Fp.sqr(gxd);
  tv2 = Fp.sqr(tv3);
  tv3 = Fp.mul(tv3, gxd);
  tv3 = Fp.mul(tv3, gx1);
  tv2 = Fp.mul(tv2, tv3);
  let y11 = Fp.pow(tv2, ELL2_C4);
  y11 = Fp.mul(y11, tv3);
  let y12 = Fp.mul(y11, ELL2_C3);
  tv2 = Fp.sqr(y11);
  tv2 = Fp.mul(tv2, gxd);
  let e1 = Fp.eql(tv2, gx1);
  let y1 = Fp.cmov(y12, y11, e1);
  let x2n = Fp.mul(x1n, tv1);
  let y21 = Fp.mul(y11, u);
  y21 = Fp.mul(y21, ELL2_C2);
  let y22 = Fp.mul(y21, ELL2_C3);
  let gx2 = Fp.mul(gx1, tv1);
  tv2 = Fp.sqr(y21);
  tv2 = Fp.mul(tv2, gxd);
  let e2 = Fp.eql(tv2, gx2);
  let y2 = Fp.cmov(y22, y21, e2);
  tv2 = Fp.sqr(y1);
  tv2 = Fp.mul(tv2, gxd);
  let e3 = Fp.eql(tv2, gx1);
  let xn = Fp.cmov(x2n, x1n, e3);
  let y = Fp.cmov(y2, y1, e3);
  let e4 = Fp.isOdd(y);
  y = Fp.cmov(y, Fp.neg(y), e3 !== e4);
  return { xMn: xn, xMd: xd, yMn: y, yMd: _1n3 };
}
var ELL2_C1_EDWARDS = FpSqrtEven(Fp, Fp.neg(BigInt(486664)));
function map_to_curve_elligator2_edwards25519(u) {
  const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u);
  let xn = Fp.mul(xMn, yMd);
  xn = Fp.mul(xn, ELL2_C1_EDWARDS);
  let xd = Fp.mul(xMd, yMn);
  let yn = Fp.sub(xMn, xMd);
  let yd = Fp.add(xMn, xMd);
  let tv1 = Fp.mul(xd, yd);
  let e = Fp.eql(tv1, Fp.ZERO);
  xn = Fp.cmov(xn, Fp.ZERO, e);
  xd = Fp.cmov(xd, Fp.ONE, e);
  yn = Fp.cmov(yn, Fp.ONE, e);
  yd = Fp.cmov(yd, Fp.ONE, e);
  const inv = Fp.invertBatch([xd, yd]);
  return { x: Fp.mul(xn, inv[0]), y: Fp.mul(yn, inv[1]) };
}
var htf = (() => createHasher(ed25519.ExtendedPoint, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {
  DST: "edwards25519_XMD:SHA-512_ELL2_RO_",
  encodeDST: "edwards25519_XMD:SHA-512_ELL2_NU_",
  p: Fp.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha512
}))();
var hashToCurve = (() => htf.hashToCurve)();
var encodeToCurve = (() => htf.encodeToCurve)();
function assertRstPoint(other) {
  if (!(other instanceof RistPoint))
    throw new Error("RistrettoPoint expected");
}
var SQRT_M1 = ED25519_SQRT_M1;
var SQRT_AD_MINUS_ONE = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
var INVSQRT_A_MINUS_D = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
var ONE_MINUS_D_SQ = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
var D_MINUS_ONE_SQ = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
var invertSqrt = (number4) => uvRatio(_1n3, number4);
var MAX_255B = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var bytes255ToNumberLE = (bytes2) => ed25519.CURVE.Fp.create(bytesToNumberLE(bytes2) & MAX_255B);
function calcElligatorRistrettoMap(r0) {
  const { d } = ed25519.CURVE;
  const P = ed25519.CURVE.Fp.ORDER;
  const mod2 = ed25519.CURVE.Fp.create;
  const r = mod2(SQRT_M1 * r0 * r0);
  const Ns = mod2((r + _1n3) * ONE_MINUS_D_SQ);
  let c = BigInt(-1);
  const D = mod2((c - d * r) * mod2(r + d));
  let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);
  let s_ = mod2(s * r0);
  if (!isNegativeLE(s_, P))
    s_ = mod2(-s_);
  if (!Ns_D_is_sq)
    s = s_;
  if (!Ns_D_is_sq)
    c = r;
  const Nt = mod2(c * (r - _1n3) * D_MINUS_ONE_SQ - D);
  const s2 = s * s;
  const W0 = mod2((s + s) * D);
  const W1 = mod2(Nt * SQRT_AD_MINUS_ONE);
  const W2 = mod2(_1n3 - s2);
  const W3 = mod2(_1n3 + s2);
  return new ed25519.ExtendedPoint(mod2(W0 * W3), mod2(W2 * W1), mod2(W1 * W3), mod2(W0 * W2));
}
var RistPoint = class _RistPoint {
  // Private property to discourage combining ExtendedPoint + RistrettoPoint
  // Always use Ristretto encoding/decoding instead.
  constructor(ep) {
    this.ep = ep;
  }
  static fromAffine(ap) {
    return new _RistPoint(ed25519.ExtendedPoint.fromAffine(ap));
  }
  /**
   * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.
   * The hash-to-group operation applies Elligator twice and adds the results.
   * **Note:** this is one-way map, there is no conversion from point to hash.
   * https://ristretto.group/formulas/elligator.html
   * @param hex 64-byte output of a hash function
   */
  static hashToCurve(hex) {
    hex = ensureBytes("ristrettoHash", hex, 64);
    const r1 = bytes255ToNumberLE(hex.slice(0, 32));
    const R1 = calcElligatorRistrettoMap(r1);
    const r2 = bytes255ToNumberLE(hex.slice(32, 64));
    const R2 = calcElligatorRistrettoMap(r2);
    return new _RistPoint(R1.add(R2));
  }
  /**
   * Converts ristretto-encoded string to ristretto point.
   * https://ristretto.group/formulas/decoding.html
   * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding
   */
  static fromHex(hex) {
    hex = ensureBytes("ristrettoHex", hex, 32);
    const { a, d } = ed25519.CURVE;
    const P = ed25519.CURVE.Fp.ORDER;
    const mod2 = ed25519.CURVE.Fp.create;
    const emsg = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint";
    const s = bytes255ToNumberLE(hex);
    if (!equalBytes(numberToBytesLE(s, 32), hex) || isNegativeLE(s, P))
      throw new Error(emsg);
    const s2 = mod2(s * s);
    const u1 = mod2(_1n3 + a * s2);
    const u2 = mod2(_1n3 - a * s2);
    const u1_2 = mod2(u1 * u1);
    const u2_2 = mod2(u2 * u2);
    const v = mod2(a * d * u1_2 - u2_2);
    const { isValid, value: I } = invertSqrt(mod2(v * u2_2));
    const Dx = mod2(I * u2);
    const Dy = mod2(I * Dx * v);
    let x = mod2((s + s) * Dx);
    if (isNegativeLE(x, P))
      x = mod2(-x);
    const y = mod2(u1 * Dy);
    const t = mod2(x * y);
    if (!isValid || isNegativeLE(t, P) || y === _0n3)
      throw new Error(emsg);
    return new _RistPoint(new ed25519.ExtendedPoint(x, y, _1n3, t));
  }
  /**
   * Encodes ristretto point to Uint8Array.
   * https://ristretto.group/formulas/encoding.html
   */
  toRawBytes() {
    let { ex: x, ey: y, ez: z, et: t } = this.ep;
    const P = ed25519.CURVE.Fp.ORDER;
    const mod2 = ed25519.CURVE.Fp.create;
    const u1 = mod2(mod2(z + y) * mod2(z - y));
    const u2 = mod2(x * y);
    const u2sq = mod2(u2 * u2);
    const { value: invsqrt } = invertSqrt(mod2(u1 * u2sq));
    const D1 = mod2(invsqrt * u1);
    const D2 = mod2(invsqrt * u2);
    const zInv = mod2(D1 * D2 * t);
    let D;
    if (isNegativeLE(t * zInv, P)) {
      let _x = mod2(y * SQRT_M1);
      let _y = mod2(x * SQRT_M1);
      x = _x;
      y = _y;
      D = mod2(D1 * INVSQRT_A_MINUS_D);
    } else {
      D = D2;
    }
    if (isNegativeLE(x * zInv, P))
      y = mod2(-y);
    let s = mod2((z - y) * D);
    if (isNegativeLE(s, P))
      s = mod2(-s);
    return numberToBytesLE(s, 32);
  }
  toHex() {
    return bytesToHex(this.toRawBytes());
  }
  toString() {
    return this.toHex();
  }
  // Compare one point to another.
  equals(other) {
    assertRstPoint(other);
    const { ex: X1, ey: Y1 } = this.ep;
    const { ex: X2, ey: Y2 } = other.ep;
    const mod2 = ed25519.CURVE.Fp.create;
    const one = mod2(X1 * Y2) === mod2(Y1 * X2);
    const two = mod2(Y1 * Y2) === mod2(X1 * X2);
    return one || two;
  }
  add(other) {
    assertRstPoint(other);
    return new _RistPoint(this.ep.add(other.ep));
  }
  subtract(other) {
    assertRstPoint(other);
    return new _RistPoint(this.ep.subtract(other.ep));
  }
  multiply(scalar) {
    return new _RistPoint(this.ep.multiply(scalar));
  }
  multiplyUnsafe(scalar) {
    return new _RistPoint(this.ep.multiplyUnsafe(scalar));
  }
};
var RistrettoPoint = (() => {
  if (!RistPoint.BASE)
    RistPoint.BASE = new RistPoint(ed25519.ExtendedPoint.BASE);
  if (!RistPoint.ZERO)
    RistPoint.ZERO = new RistPoint(ed25519.ExtendedPoint.ZERO);
  return RistPoint;
})();

// node_modules/@noble/hashes/esm/hkdf.js
function extract(hash2, ikm, salt) {
  hash(hash2);
  if (salt === void 0)
    salt = new Uint8Array(hash2.outputLen);
  return hmac(hash2, toBytes(salt), toBytes(ikm));
}
var HKDF_COUNTER = new Uint8Array([0]);
var EMPTY_BUFFER = new Uint8Array();
function expand(hash2, prk, info, length4 = 32) {
  hash(hash2);
  number(length4);
  if (length4 > 255 * hash2.outputLen)
    throw new Error("Length should be <= 255*HashLen");
  const blocks = Math.ceil(length4 / hash2.outputLen);
  if (info === void 0)
    info = EMPTY_BUFFER;
  const okm = new Uint8Array(blocks * hash2.outputLen);
  const HMAC = hmac.create(hash2, prk);
  const HMACTmp = HMAC._cloneInto();
  const T = new Uint8Array(HMAC.outputLen);
  for (let counter = 0; counter < blocks; counter++) {
    HKDF_COUNTER[0] = counter + 1;
    HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T).update(info).update(HKDF_COUNTER).digestInto(T);
    okm.set(T, hash2.outputLen * counter);
    HMAC._cloneInto(HMACTmp);
  }
  HMAC.destroy();
  HMACTmp.destroy();
  T.fill(0);
  HKDF_COUNTER.fill(0);
  return okm.slice(0, length4);
}

// node_modules/@chainsafe/libp2p-noise/dist/src/crypto/js.js
var pureJsCrypto = {
  hashSHA256(data) {
    return sha256(data);
  },
  getHKDF(ck, ikm) {
    const prk = extract(sha256, ikm, ck);
    const okmU8Array = expand(sha256, prk, void 0, 96);
    const okm = okmU8Array;
    const k1 = okm.subarray(0, 32);
    const k2 = okm.subarray(32, 64);
    const k3 = okm.subarray(64, 96);
    return [k1, k2, k3];
  },
  generateX25519KeyPair() {
    const secretKey = x25519.utils.randomPrivateKey();
    const publicKey = x25519.getPublicKey(secretKey);
    return {
      publicKey,
      privateKey: secretKey
    };
  },
  generateX25519KeyPairFromSeed(seed) {
    const publicKey = x25519.getPublicKey(seed);
    return {
      publicKey,
      privateKey: seed
    };
  },
  generateX25519SharedKey(privateKey, publicKey) {
    return x25519.getSharedSecret(privateKey, publicKey);
  },
  chaCha20Poly1305Encrypt(plaintext, nonce, ad, k) {
    return chacha20poly1305(k, nonce, ad).encrypt(plaintext);
  },
  chaCha20Poly1305Decrypt(ciphertext, nonce, ad, k, dst) {
    return chacha20poly1305(k, nonce, ad).decrypt(ciphertext, dst);
  }
};

// node_modules/@chainsafe/libp2p-noise/dist/src/crypto/index.browser.js
var defaultCrypto = pureJsCrypto;

// node_modules/@chainsafe/libp2p-noise/dist/src/encoder.js
var allocUnsafe2 = (len) => {
  if (globalThis.Buffer) {
    return globalThis.Buffer.allocUnsafe(len);
  }
  return new Uint8Array(len);
};
var uint16BEEncode = (value) => {
  const target = allocUnsafe2(2);
  new DataView(target.buffer, target.byteOffset, target.byteLength).setUint16(0, value, false);
  return target;
};
uint16BEEncode.bytes = 2;
var uint16BEDecode = (data) => {
  if (data.length < 2)
    throw RangeError("Could not decode int16BE");
  if (data instanceof Uint8Array) {
    return new DataView(data.buffer, data.byteOffset, data.byteLength).getUint16(0, false);
  }
  return data.getUint16(0);
};
uint16BEDecode.bytes = 2;
function encode0(message2) {
  return concat([message2.ne, message2.ciphertext], message2.ne.length + message2.ciphertext.length);
}
function encode1(message2) {
  return concat([message2.ne, message2.ns, message2.ciphertext], message2.ne.length + message2.ns.length + message2.ciphertext.length);
}
function encode22(message2) {
  return concat([message2.ns, message2.ciphertext], message2.ns.length + message2.ciphertext.length);
}
function decode0(input) {
  if (input.length < 32) {
    throw new Error("Cannot decode stage 0 MessageBuffer: length less than 32 bytes.");
  }
  return {
    ne: input.subarray(0, 32),
    ciphertext: input.subarray(32, input.length),
    ns: new Uint8Array(0)
  };
}
function decode1(input) {
  if (input.length < 80) {
    throw new Error("Cannot decode stage 1 MessageBuffer: length less than 80 bytes.");
  }
  return {
    ne: input.subarray(0, 32),
    ns: input.subarray(32, 80),
    ciphertext: input.subarray(80, input.length)
  };
}
function decode22(input) {
  if (input.length < 48) {
    throw new Error("Cannot decode stage 2 MessageBuffer: length less than 48 bytes.");
  }
  return {
    ne: new Uint8Array(0),
    ns: input.subarray(0, 48),
    ciphertext: input.subarray(48, input.length)
  };
}

// node_modules/@chainsafe/libp2p-noise/dist/src/crypto/streaming.js
var CHACHA_TAG_LENGTH = 16;
function encryptStream(handshake2, metrics) {
  return async function* (source) {
    for await (const chunk of source) {
      for (let i = 0; i < chunk.length; i += NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG) {
        let end = i + NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG;
        if (end > chunk.length) {
          end = chunk.length;
        }
        const data = handshake2.encrypt(chunk.subarray(i, end), handshake2.session);
        metrics == null ? void 0 : metrics.encryptedPackets.increment();
        yield concat([
          uint16BEEncode(data.byteLength),
          data
        ], 2 + data.byteLength);
      }
    }
  };
}
function decryptStream(handshake2, metrics) {
  return async function* (source) {
    for await (const chunk of source) {
      for (let i = 0; i < chunk.length; i += NOISE_MSG_MAX_LENGTH_BYTES) {
        let end = i + NOISE_MSG_MAX_LENGTH_BYTES;
        if (end > chunk.length) {
          end = chunk.length;
        }
        if (end - CHACHA_TAG_LENGTH < i) {
          throw new Error("Invalid chunk");
        }
        const encrypted = chunk.subarray(i, end);
        const dst = chunk.subarray(i, end - CHACHA_TAG_LENGTH);
        const { plaintext: decrypted, valid } = handshake2.decrypt(encrypted, handshake2.session, dst);
        if (!valid) {
          metrics == null ? void 0 : metrics.decryptErrors.increment();
          throw new Error("Failed to validate decrypted chunk");
        }
        metrics == null ? void 0 : metrics.decryptedPackets.increment();
        yield decrypted;
      }
    }
  };
}

// node_modules/@libp2p/crypto/dist/src/keys/index.js
var import_asn12 = __toESM(require_asn1());
var import_pbe = __toESM(require_pbe());
var import_forge5 = __toESM(require_forge());

// node_modules/@libp2p/crypto/dist/src/keys/ed25519-class.js
var ed25519_class_exports = {};
__export(ed25519_class_exports, {
  Ed25519PrivateKey: () => Ed25519PrivateKey,
  Ed25519PublicKey: () => Ed25519PublicKey,
  generateKeyPair: () => generateKeyPair,
  generateKeyPairFromSeed: () => generateKeyPairFromSeed,
  unmarshalEd25519PrivateKey: () => unmarshalEd25519PrivateKey,
  unmarshalEd25519PublicKey: () => unmarshalEd25519PublicKey
});

// node_modules/@libp2p/crypto/node_modules/multiformats/vendor/base-x.js
function base(ALPHABET, name2) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode12(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length4 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length4) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length4 = i2;
      pbegin++;
    }
    var it2 = size - length4;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length4 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length4) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length4 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length4;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode12(string2) {
    var buffer = decodeUnsafe(string2);
    if (buffer) {
      return buffer;
    }
    throw new Error(`Non-${name2} character`);
  }
  return {
    encode: encode12,
    decodeUnsafe,
    decode: decode12
  };
}
var src = base;
var _brrp__multiformats_scope_baseX = src;
var base_x_default = _brrp__multiformats_scope_baseX;

// node_modules/@libp2p/crypto/node_modules/multiformats/src/bytes.js
var empty = new Uint8Array(0);
var coerce = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};

// node_modules/@libp2p/crypto/node_modules/multiformats/src/bases/base.js
var Encoder2 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor(name2, prefix, baseEncode) {
    this.name = name2;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode(bytes2) {
    if (bytes2 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes2)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder2 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name2, prefix, baseDecode) {
    this.name = name2;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = /** @type {number} */
    prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  /**
   * @param {string} text
   */
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or(this, decoder);
  }
};
var ComposedDecoder = class {
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor(decoders) {
    this.decoders = decoders;
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or(this, decoder);
  }
  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode(input) {
    const prefix = (
      /** @type {Prefix} */
      input[0]
    );
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or = (left, right) => new ComposedDecoder(
  /** @type {Decoders<L|R>} */
  {
    ...left.decoders || { [
      /** @type API.UnibaseDecoder<L> */
      left.prefix
    ]: left },
    ...right.decoders || { [
      /** @type API.UnibaseDecoder<R> */
      right.prefix
    ]: right }
  }
);
var Codec = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name2, prefix, baseEncode, baseDecode) {
    this.name = name2;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder2(name2, prefix, baseEncode);
    this.decoder = new Decoder2(name2, prefix, baseDecode);
  }
  /**
   * @param {Uint8Array} input
   */
  encode(input) {
    return this.encoder.encode(input);
  }
  /**
   * @param {string} input
   */
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from = ({ name: name2, prefix, encode: encode12, decode: decode12 }) => new Codec(name2, prefix, encode12, decode12);
var baseX = ({ prefix, name: name2, alphabet }) => {
  const { encode: encode12, decode: decode12 } = base_x_default(alphabet, name2);
  return from({
    prefix,
    name: name2,
    encode: encode12,
    /**
     * @param {string} text
     */
    decode: (text) => coerce(decode12(text))
  });
};
var decode3 = (string2, alphabet, bitsPerChar, name2) => {
  const codes6 = {};
  for (let i = 0; i < alphabet.length; ++i) {
    codes6[alphabet[i]] = i;
  }
  let end = string2.length;
  while (string2[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes6[string2[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name2} character`);
    }
    buffer = buffer << bitsPerChar | value;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || 255 & buffer << 8 - bits2) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode3 = (data, alphabet, bitsPerChar) => {
  const pad = alphabet[alphabet.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer = buffer << 8 | data[i];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet[mask & buffer >> bits2];
    }
  }
  if (bits2) {
    out += alphabet[mask & buffer << bitsPerChar - bits2];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc4648 = ({ name: name2, prefix, bitsPerChar, alphabet }) => {
  return from({
    prefix,
    name: name2,
    encode(input) {
      return encode3(input, alphabet, bitsPerChar);
    },
    decode(input) {
      return decode3(input, alphabet, bitsPerChar, name2);
    }
  });
};

// node_modules/@libp2p/crypto/node_modules/multiformats/src/bases/base58.js
var base58btc = baseX({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr = baseX({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@libp2p/crypto/node_modules/multiformats/vendor/varint.js
var encode_1 = encode4;
var MSB = 128;
var REST = 127;
var MSBALL = ~REST;
var INT = Math.pow(2, 31);
function encode4(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT) {
    out[offset++] = num & 255 | MSB;
    num /= 128;
  }
  while (num & MSBALL) {
    out[offset++] = num & 255 | MSB;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode4.bytes = offset - oldOffset + 1;
  return out;
}
var decode4 = read;
var MSB$1 = 128;
var REST$1 = 127;
function read(buf, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
  do {
    if (counter >= l) {
      read.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf[counter++];
    res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$1);
  read.bytes = counter - offset;
  return res;
}
var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
var length = function(value) {
  return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
};
var varint = {
  encode: encode_1,
  decode: decode4,
  encodingLength: length
};
var _brrp_varint = varint;
var varint_default = _brrp_varint;

// node_modules/@libp2p/crypto/node_modules/multiformats/src/varint.js
var encodeTo = (int, target, offset = 0) => {
  varint_default.encode(int, target, offset);
  return target;
};
var encodingLength2 = (int) => {
  return varint_default.encodingLength(int);
};

// node_modules/@libp2p/crypto/node_modules/multiformats/src/hashes/digest.js
var create = (code2, digest2) => {
  const size = digest2.byteLength;
  const sizeOffset = encodingLength2(code2);
  const digestOffset = sizeOffset + encodingLength2(size);
  const bytes2 = new Uint8Array(digestOffset + size);
  encodeTo(code2, bytes2, 0);
  encodeTo(size, bytes2, sizeOffset);
  bytes2.set(digest2, digestOffset);
  return new Digest(code2, size, digest2, bytes2);
};
var Digest = class {
  /**
   * Creates a multihash digest.
   *
   * @param {Code} code
   * @param {Size} size
   * @param {Uint8Array} digest
   * @param {Uint8Array} bytes
   */
  constructor(code2, size, digest2, bytes2) {
    this.code = code2;
    this.size = size;
    this.digest = digest2;
    this.bytes = bytes2;
  }
};

// node_modules/@libp2p/crypto/node_modules/multiformats/src/hashes/identity.js
var code = 0;
var name = "identity";
var encode5 = coerce;
var digest = (input) => create(code, encode5(input));
var identity = { code, name, encode: encode5, digest };

// node_modules/@libp2p/crypto/node_modules/multiformats/src/hashes/hasher.js
var from2 = ({ name: name2, code: code2, encode: encode12 }) => new Hasher(name2, code2, encode12);
var Hasher = class {
  /**
   *
   * @param {Name} name
   * @param {Code} code
   * @param {(input: Uint8Array) => Await<Uint8Array>} encode
   */
  constructor(name2, code2, encode12) {
    this.name = name2;
    this.code = code2;
    this.encode = encode12;
  }
  /**
   * @param {Uint8Array} input
   * @returns {Await<Digest.Digest<Code, number>>}
   */
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create(this.code, result) : result.then((digest2) => create(this.code, digest2));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/@libp2p/crypto/node_modules/multiformats/src/hashes/sha2-browser.js
var sha = (name2) => (
  /**
   * @param {Uint8Array} data
   */
  async (data) => new Uint8Array(await crypto.subtle.digest(name2, data))
);
var sha2562 = from2({
  name: "sha2-256",
  code: 18,
  encode: sha("SHA-256")
});
var sha5122 = from2({
  name: "sha2-512",
  code: 19,
  encode: sha("SHA-512")
});

// node_modules/@libp2p/crypto/dist/src/keys/ed25519-browser.js
var PUBLIC_KEY_BYTE_LENGTH = 32;
var PRIVATE_KEY_BYTE_LENGTH = 64;
var KEYS_BYTE_LENGTH = 32;
async function generateKey() {
  const privateKeyRaw = ed25519.utils.randomPrivateKey();
  const publicKey = ed25519.getPublicKey(privateKeyRaw);
  const privateKey = concatKeys(privateKeyRaw, publicKey);
  return {
    privateKey,
    publicKey
  };
}
async function generateKeyFromSeed(seed) {
  if (seed.length !== KEYS_BYTE_LENGTH) {
    throw new TypeError('"seed" must be 32 bytes in length.');
  } else if (!(seed instanceof Uint8Array)) {
    throw new TypeError('"seed" must be a node.js Buffer, or Uint8Array.');
  }
  const privateKeyRaw = seed;
  const publicKey = ed25519.getPublicKey(privateKeyRaw);
  const privateKey = concatKeys(privateKeyRaw, publicKey);
  return {
    privateKey,
    publicKey
  };
}
async function hashAndSign(privateKey, msg) {
  const privateKeyRaw = privateKey.subarray(0, KEYS_BYTE_LENGTH);
  return ed25519.sign(msg, privateKeyRaw);
}
async function hashAndVerify(publicKey, sig, msg) {
  return ed25519.verify(sig, msg, publicKey);
}
function concatKeys(privateKeyRaw, publicKey) {
  const privateKey = new Uint8Array(PRIVATE_KEY_BYTE_LENGTH);
  for (let i = 0; i < KEYS_BYTE_LENGTH; i++) {
    privateKey[i] = privateKeyRaw[i];
    privateKey[KEYS_BYTE_LENGTH + i] = publicKey[i];
  }
  return privateKey;
}

// node_modules/@libp2p/crypto/node_modules/multiformats/src/bases/base64.js
var base64 = rfc4648({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad = rfc4648({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url = rfc4648({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad = rfc4648({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@libp2p/crypto/dist/src/webcrypto.js
var webcrypto_default = {
  get(win = globalThis) {
    const nativeCrypto = win.crypto;
    if (nativeCrypto == null || nativeCrypto.subtle == null) {
      throw Object.assign(new Error("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p-crypto/blob/master/README.md#web-crypto-api"), { code: "ERR_MISSING_WEB_CRYPTO" });
    }
    return nativeCrypto;
  }
};

// node_modules/@libp2p/crypto/dist/src/ciphers/aes-gcm.browser.js
var derivedEmptyPasswordKey = { alg: "A128GCM", ext: true, k: "scm9jmO_4BJAgdwWGVulLg", key_ops: ["encrypt", "decrypt"], kty: "oct" };
function create2(opts) {
  const algorithm = (opts == null ? void 0 : opts.algorithm) ?? "AES-GCM";
  let keyLength = (opts == null ? void 0 : opts.keyLength) ?? 16;
  const nonceLength = (opts == null ? void 0 : opts.nonceLength) ?? 12;
  const digest2 = (opts == null ? void 0 : opts.digest) ?? "SHA-256";
  const saltLength = (opts == null ? void 0 : opts.saltLength) ?? 16;
  const iterations = (opts == null ? void 0 : opts.iterations) ?? 32767;
  const crypto2 = webcrypto_default.get();
  keyLength *= 8;
  async function encrypt2(data, password) {
    const salt = crypto2.getRandomValues(new Uint8Array(saltLength));
    const nonce = crypto2.getRandomValues(new Uint8Array(nonceLength));
    const aesGcm = { name: algorithm, iv: nonce };
    if (typeof password === "string") {
      password = fromString(password);
    }
    let cryptoKey;
    if (password.length === 0) {
      cryptoKey = await crypto2.subtle.importKey("jwk", derivedEmptyPasswordKey, { name: "AES-GCM" }, true, ["encrypt"]);
      try {
        const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest2 } };
        const runtimeDerivedEmptyPassword = await crypto2.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
        cryptoKey = await crypto2.subtle.deriveKey(deriveParams, runtimeDerivedEmptyPassword, { name: algorithm, length: keyLength }, true, ["encrypt"]);
      } catch {
        cryptoKey = await crypto2.subtle.importKey("jwk", derivedEmptyPasswordKey, { name: "AES-GCM" }, true, ["encrypt"]);
      }
    } else {
      const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest2 } };
      const rawKey = await crypto2.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
      cryptoKey = await crypto2.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ["encrypt"]);
    }
    const ciphertext = await crypto2.subtle.encrypt(aesGcm, cryptoKey, data);
    return concat([salt, aesGcm.iv, new Uint8Array(ciphertext)]);
  }
  async function decrypt2(data, password) {
    const salt = data.subarray(0, saltLength);
    const nonce = data.subarray(saltLength, saltLength + nonceLength);
    const ciphertext = data.subarray(saltLength + nonceLength);
    const aesGcm = { name: algorithm, iv: nonce };
    if (typeof password === "string") {
      password = fromString(password);
    }
    let cryptoKey;
    if (password.length === 0) {
      try {
        const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest2 } };
        const runtimeDerivedEmptyPassword = await crypto2.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
        cryptoKey = await crypto2.subtle.deriveKey(deriveParams, runtimeDerivedEmptyPassword, { name: algorithm, length: keyLength }, true, ["decrypt"]);
      } catch {
        cryptoKey = await crypto2.subtle.importKey("jwk", derivedEmptyPasswordKey, { name: "AES-GCM" }, true, ["decrypt"]);
      }
    } else {
      const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest2 } };
      const rawKey = await crypto2.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
      cryptoKey = await crypto2.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ["decrypt"]);
    }
    const plaintext = await crypto2.subtle.decrypt(aesGcm, cryptoKey, ciphertext);
    return new Uint8Array(plaintext);
  }
  const cipher = {
    encrypt: encrypt2,
    decrypt: decrypt2
  };
  return cipher;
}

// node_modules/@libp2p/crypto/dist/src/keys/exporter.js
async function exporter(privateKey, password) {
  const cipher = create2();
  const encryptedKey = await cipher.encrypt(privateKey, password);
  return base64.encode(encryptedKey);
}

// node_modules/@libp2p/crypto/dist/src/keys/keys.js
var KeyType;
(function(KeyType2) {
  KeyType2["RSA"] = "RSA";
  KeyType2["Ed25519"] = "Ed25519";
  KeyType2["Secp256k1"] = "Secp256k1";
})(KeyType || (KeyType = {}));
var __KeyTypeValues;
(function(__KeyTypeValues2) {
  __KeyTypeValues2[__KeyTypeValues2["RSA"] = 0] = "RSA";
  __KeyTypeValues2[__KeyTypeValues2["Ed25519"] = 1] = "Ed25519";
  __KeyTypeValues2[__KeyTypeValues2["Secp256k1"] = 2] = "Secp256k1";
})(__KeyTypeValues || (__KeyTypeValues = {}));
(function(KeyType2) {
  KeyType2.codec = () => {
    return enumeration(__KeyTypeValues);
  };
})(KeyType || (KeyType = {}));
var PublicKey;
(function(PublicKey2) {
  let _codec;
  PublicKey2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.Type != null) {
          w.uint32(8);
          KeyType.codec().encode(obj.Type, w);
        }
        if (obj.Data != null) {
          w.uint32(18);
          w.bytes(obj.Data);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length4) => {
        const obj = {};
        const end = length4 == null ? reader2.len : reader2.pos + length4;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.Type = KeyType.codec().decode(reader2);
              break;
            case 2:
              obj.Data = reader2.bytes();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PublicKey2.encode = (obj) => {
    return encodeMessage(obj, PublicKey2.codec());
  };
  PublicKey2.decode = (buf) => {
    return decodeMessage(buf, PublicKey2.codec());
  };
})(PublicKey || (PublicKey = {}));
var PrivateKey;
(function(PrivateKey2) {
  let _codec;
  PrivateKey2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.Type != null) {
          w.uint32(8);
          KeyType.codec().encode(obj.Type, w);
        }
        if (obj.Data != null) {
          w.uint32(18);
          w.bytes(obj.Data);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length4) => {
        const obj = {};
        const end = length4 == null ? reader2.len : reader2.pos + length4;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.Type = KeyType.codec().decode(reader2);
              break;
            case 2:
              obj.Data = reader2.bytes();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PrivateKey2.encode = (obj) => {
    return encodeMessage(obj, PrivateKey2.codec());
  };
  PrivateKey2.decode = (buf) => {
    return decodeMessage(buf, PrivateKey2.codec());
  };
})(PrivateKey || (PrivateKey = {}));

// node_modules/@libp2p/crypto/dist/src/keys/ed25519-class.js
var Ed25519PublicKey = class {
  constructor(key) {
    __publicField(this, "_key");
    this._key = ensureKey(key, PUBLIC_KEY_BYTE_LENGTH);
  }
  async verify(data, sig) {
    return hashAndVerify(this._key, sig, data);
  }
  marshal() {
    return this._key;
  }
  get bytes() {
    return PublicKey.encode({
      Type: KeyType.Ed25519,
      Data: this.marshal()
    }).subarray();
  }
  equals(key) {
    return equals(this.bytes, key.bytes);
  }
  async hash() {
    const { bytes: bytes2 } = await sha2562.digest(this.bytes);
    return bytes2;
  }
};
var Ed25519PrivateKey = class {
  // key       - 64 byte Uint8Array containing private key
  // publicKey - 32 byte Uint8Array containing public key
  constructor(key, publicKey) {
    __publicField(this, "_key");
    __publicField(this, "_publicKey");
    this._key = ensureKey(key, PRIVATE_KEY_BYTE_LENGTH);
    this._publicKey = ensureKey(publicKey, PUBLIC_KEY_BYTE_LENGTH);
  }
  async sign(message2) {
    return hashAndSign(this._key, message2);
  }
  get public() {
    return new Ed25519PublicKey(this._publicKey);
  }
  marshal() {
    return this._key;
  }
  get bytes() {
    return PrivateKey.encode({
      Type: KeyType.Ed25519,
      Data: this.marshal()
    }).subarray();
  }
  equals(key) {
    return equals(this.bytes, key.bytes);
  }
  async hash() {
    const { bytes: bytes2 } = await sha2562.digest(this.bytes);
    return bytes2;
  }
  /**
   * Gets the ID of the key.
   *
   * The key id is the base58 encoding of the identity multihash containing its public key.
   * The public key is a protobuf encoding containing a type and the DER encoding
   * of the PKCS SubjectPublicKeyInfo.
   *
   * @returns {Promise<string>}
   */
  async id() {
    const encoding = identity.digest(this.public.bytes);
    return base58btc.encode(encoding.bytes).substring(1);
  }
  /**
   * Exports the key into a password protected `format`
   */
  async export(password, format = "libp2p-key") {
    if (format === "libp2p-key") {
      return exporter(this.bytes, password);
    } else {
      throw new CodeError(`export format '${format}' is not supported`, "ERR_INVALID_EXPORT_FORMAT");
    }
  }
};
function unmarshalEd25519PrivateKey(bytes2) {
  if (bytes2.length > PRIVATE_KEY_BYTE_LENGTH) {
    bytes2 = ensureKey(bytes2, PRIVATE_KEY_BYTE_LENGTH + PUBLIC_KEY_BYTE_LENGTH);
    const privateKeyBytes2 = bytes2.subarray(0, PRIVATE_KEY_BYTE_LENGTH);
    const publicKeyBytes2 = bytes2.subarray(PRIVATE_KEY_BYTE_LENGTH, bytes2.length);
    return new Ed25519PrivateKey(privateKeyBytes2, publicKeyBytes2);
  }
  bytes2 = ensureKey(bytes2, PRIVATE_KEY_BYTE_LENGTH);
  const privateKeyBytes = bytes2.subarray(0, PRIVATE_KEY_BYTE_LENGTH);
  const publicKeyBytes = bytes2.subarray(PUBLIC_KEY_BYTE_LENGTH);
  return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes);
}
function unmarshalEd25519PublicKey(bytes2) {
  bytes2 = ensureKey(bytes2, PUBLIC_KEY_BYTE_LENGTH);
  return new Ed25519PublicKey(bytes2);
}
async function generateKeyPair() {
  const { privateKey, publicKey } = await generateKey();
  return new Ed25519PrivateKey(privateKey, publicKey);
}
async function generateKeyPairFromSeed(seed) {
  const { privateKey, publicKey } = await generateKeyFromSeed(seed);
  return new Ed25519PrivateKey(privateKey, publicKey);
}
function ensureKey(key, length4) {
  key = Uint8Array.from(key ?? []);
  if (key.length !== length4) {
    throw new CodeError(`Key must be a Uint8Array of length ${length4}, got ${key.length}`, "ERR_INVALID_KEY_TYPE");
  }
  return key;
}

// node_modules/@libp2p/crypto/dist/src/util.js
var import_util = __toESM(require_util(), 1);
var import_jsbn = __toESM(require_jsbn(), 1);
var import_forge = __toESM(require_forge(), 1);
function bigIntegerToUintBase64url(num, len) {
  let buf = Uint8Array.from(num.abs().toByteArray());
  buf = buf[0] === 0 ? buf.subarray(1) : buf;
  if (len != null) {
    if (buf.length > len)
      throw new Error("byte array longer than desired length");
    buf = concat([new Uint8Array(len - buf.length), buf]);
  }
  return toString(buf, "base64url");
}
function base64urlToBigInteger(str) {
  const buf = base64urlToBuffer(str);
  return new import_forge.default.jsbn.BigInteger(toString(buf, "base16"), 16);
}
function base64urlToBuffer(str, len) {
  let buf = fromString(str, "base64urlpad");
  if (len != null) {
    if (buf.length > len)
      throw new Error("byte array longer than desired length");
    buf = concat([new Uint8Array(len - buf.length), buf]);
  }
  return buf;
}

// node_modules/@libp2p/crypto/dist/src/keys/ecdh-browser.js
var bits = {
  "P-256": 256,
  "P-384": 384,
  "P-521": 521
};
var curveTypes = Object.keys(bits);
var names = curveTypes.join(" / ");

// node_modules/@libp2p/crypto/dist/src/keys/importer.js
async function importer(privateKey, password) {
  const encryptedKey = base64.decode(privateKey);
  const cipher = create2();
  return cipher.decrypt(encryptedKey, password);
}

// node_modules/@libp2p/crypto/dist/src/keys/rsa-class.js
var rsa_class_exports = {};
__export(rsa_class_exports, {
  MAX_KEY_SIZE: () => MAX_KEY_SIZE,
  RsaPrivateKey: () => RsaPrivateKey,
  RsaPublicKey: () => RsaPublicKey,
  fromJwk: () => fromJwk,
  generateKeyPair: () => generateKeyPair2,
  unmarshalRsaPrivateKey: () => unmarshalRsaPrivateKey,
  unmarshalRsaPublicKey: () => unmarshalRsaPublicKey
});
var import_forge4 = __toESM(require_forge(), 1);
var import_sha5122 = __toESM(require_sha512(), 1);

// node_modules/@libp2p/crypto/dist/src/random-bytes.js
function randomBytes2(length4) {
  if (isNaN(length4) || length4 <= 0) {
    throw new CodeError("random bytes length must be a Number bigger than 0", "ERR_INVALID_LENGTH");
  }
  return randomBytes(length4);
}

// node_modules/@libp2p/crypto/dist/src/keys/jwk2pem.js
var import_rsa = __toESM(require_rsa(), 1);
var import_forge2 = __toESM(require_forge(), 1);
function convert(key, types) {
  return types.map((t) => base64urlToBigInteger(key[t]));
}
function jwk2priv(key) {
  return import_forge2.default.pki.setRsaPrivateKey(...convert(key, ["n", "e", "d", "p", "q", "dp", "dq", "qi"]));
}
function jwk2pub(key) {
  return import_forge2.default.pki.setRsaPublicKey(...convert(key, ["n", "e"]));
}

// node_modules/@libp2p/crypto/dist/src/keys/rsa-utils.js
var rsa_utils_exports = {};
__export(rsa_utils_exports, {
  jwkToPkcs1: () => jwkToPkcs1,
  jwkToPkix: () => jwkToPkix,
  pkcs1ToJwk: () => pkcs1ToJwk,
  pkixToJwk: () => pkixToJwk
});
var import_asn1 = __toESM(require_asn1(), 1);
var import_rsa2 = __toESM(require_rsa(), 1);
var import_forge3 = __toESM(require_forge(), 1);
function pkcs1ToJwk(bytes2) {
  const asn1 = import_forge3.default.asn1.fromDer(toString(bytes2, "ascii"));
  const privateKey = import_forge3.default.pki.privateKeyFromAsn1(asn1);
  return {
    kty: "RSA",
    n: bigIntegerToUintBase64url(privateKey.n),
    e: bigIntegerToUintBase64url(privateKey.e),
    d: bigIntegerToUintBase64url(privateKey.d),
    p: bigIntegerToUintBase64url(privateKey.p),
    q: bigIntegerToUintBase64url(privateKey.q),
    dp: bigIntegerToUintBase64url(privateKey.dP),
    dq: bigIntegerToUintBase64url(privateKey.dQ),
    qi: bigIntegerToUintBase64url(privateKey.qInv),
    alg: "RS256"
  };
}
function jwkToPkcs1(jwk) {
  if (jwk.n == null || jwk.e == null || jwk.d == null || jwk.p == null || jwk.q == null || jwk.dp == null || jwk.dq == null || jwk.qi == null) {
    throw new CodeError("JWK was missing components", "ERR_INVALID_PARAMETERS");
  }
  const asn1 = import_forge3.default.pki.privateKeyToAsn1({
    n: base64urlToBigInteger(jwk.n),
    e: base64urlToBigInteger(jwk.e),
    d: base64urlToBigInteger(jwk.d),
    p: base64urlToBigInteger(jwk.p),
    q: base64urlToBigInteger(jwk.q),
    dP: base64urlToBigInteger(jwk.dp),
    dQ: base64urlToBigInteger(jwk.dq),
    qInv: base64urlToBigInteger(jwk.qi)
  });
  return fromString(import_forge3.default.asn1.toDer(asn1).getBytes(), "ascii");
}
function pkixToJwk(bytes2) {
  const asn1 = import_forge3.default.asn1.fromDer(toString(bytes2, "ascii"));
  const publicKey = import_forge3.default.pki.publicKeyFromAsn1(asn1);
  return {
    kty: "RSA",
    n: bigIntegerToUintBase64url(publicKey.n),
    e: bigIntegerToUintBase64url(publicKey.e)
  };
}
function jwkToPkix(jwk) {
  if (jwk.n == null || jwk.e == null) {
    throw new CodeError("JWK was missing components", "ERR_INVALID_PARAMETERS");
  }
  const asn1 = import_forge3.default.pki.publicKeyToAsn1({
    n: base64urlToBigInteger(jwk.n),
    e: base64urlToBigInteger(jwk.e)
  });
  return fromString(import_forge3.default.asn1.toDer(asn1).getBytes(), "ascii");
}

// node_modules/@libp2p/crypto/dist/src/keys/rsa-browser.js
async function generateKey2(bits2) {
  const pair2 = await webcrypto_default.get().subtle.generateKey({
    name: "RSASSA-PKCS1-v1_5",
    modulusLength: bits2,
    publicExponent: new Uint8Array([1, 0, 1]),
    hash: { name: "SHA-256" }
  }, true, ["sign", "verify"]);
  const keys = await exportKey(pair2);
  return {
    privateKey: keys[0],
    publicKey: keys[1]
  };
}
async function unmarshalPrivateKey(key) {
  const privateKey = await webcrypto_default.get().subtle.importKey("jwk", key, {
    name: "RSASSA-PKCS1-v1_5",
    hash: { name: "SHA-256" }
  }, true, ["sign"]);
  const pair2 = [
    privateKey,
    await derivePublicFromPrivate(key)
  ];
  const keys = await exportKey({
    privateKey: pair2[0],
    publicKey: pair2[1]
  });
  return {
    privateKey: keys[0],
    publicKey: keys[1]
  };
}
async function hashAndSign2(key, msg) {
  const privateKey = await webcrypto_default.get().subtle.importKey("jwk", key, {
    name: "RSASSA-PKCS1-v1_5",
    hash: { name: "SHA-256" }
  }, false, ["sign"]);
  const sig = await webcrypto_default.get().subtle.sign({ name: "RSASSA-PKCS1-v1_5" }, privateKey, Uint8Array.from(msg));
  return new Uint8Array(sig, 0, sig.byteLength);
}
async function hashAndVerify2(key, sig, msg) {
  const publicKey = await webcrypto_default.get().subtle.importKey("jwk", key, {
    name: "RSASSA-PKCS1-v1_5",
    hash: { name: "SHA-256" }
  }, false, ["verify"]);
  return webcrypto_default.get().subtle.verify({ name: "RSASSA-PKCS1-v1_5" }, publicKey, sig, msg);
}
async function exportKey(pair2) {
  if (pair2.privateKey == null || pair2.publicKey == null) {
    throw new CodeError("Private and public key are required", "ERR_INVALID_PARAMETERS");
  }
  return Promise.all([
    webcrypto_default.get().subtle.exportKey("jwk", pair2.privateKey),
    webcrypto_default.get().subtle.exportKey("jwk", pair2.publicKey)
  ]);
}
async function derivePublicFromPrivate(jwKey) {
  return webcrypto_default.get().subtle.importKey("jwk", {
    kty: jwKey.kty,
    n: jwKey.n,
    e: jwKey.e
  }, {
    name: "RSASSA-PKCS1-v1_5",
    hash: { name: "SHA-256" }
  }, true, ["verify"]);
}
function convertKey(key, pub, msg, handle2) {
  const fkey = pub ? jwk2pub(key) : jwk2priv(key);
  const fmsg = toString(Uint8Array.from(msg), "ascii");
  const fomsg = handle2(fmsg, fkey);
  return fromString(fomsg, "ascii");
}
function encrypt(key, msg) {
  return convertKey(key, true, msg, (msg2, key2) => key2.encrypt(msg2));
}
function decrypt(key, msg) {
  return convertKey(key, false, msg, (msg2, key2) => key2.decrypt(msg2));
}
function keySize(jwk) {
  if (jwk.kty !== "RSA") {
    throw new CodeError("invalid key type", "ERR_INVALID_KEY_TYPE");
  } else if (jwk.n == null) {
    throw new CodeError("invalid key modulus", "ERR_INVALID_KEY_MODULUS");
  }
  const bytes2 = fromString(jwk.n, "base64url");
  return bytes2.length * 8;
}

// node_modules/@libp2p/crypto/dist/src/keys/rsa-class.js
var MAX_KEY_SIZE = 8192;
var RsaPublicKey = class {
  constructor(key) {
    __publicField(this, "_key");
    this._key = key;
  }
  async verify(data, sig) {
    return hashAndVerify2(this._key, sig, data);
  }
  marshal() {
    return rsa_utils_exports.jwkToPkix(this._key);
  }
  get bytes() {
    return PublicKey.encode({
      Type: KeyType.RSA,
      Data: this.marshal()
    }).subarray();
  }
  encrypt(bytes2) {
    return encrypt(this._key, bytes2);
  }
  equals(key) {
    return equals(this.bytes, key.bytes);
  }
  async hash() {
    const { bytes: bytes2 } = await sha2562.digest(this.bytes);
    return bytes2;
  }
};
var RsaPrivateKey = class {
  constructor(key, publicKey) {
    __publicField(this, "_key");
    __publicField(this, "_publicKey");
    this._key = key;
    this._publicKey = publicKey;
  }
  genSecret() {
    return randomBytes2(16);
  }
  async sign(message2) {
    return hashAndSign2(this._key, message2);
  }
  get public() {
    if (this._publicKey == null) {
      throw new CodeError("public key not provided", "ERR_PUBKEY_NOT_PROVIDED");
    }
    return new RsaPublicKey(this._publicKey);
  }
  decrypt(bytes2) {
    return decrypt(this._key, bytes2);
  }
  marshal() {
    return rsa_utils_exports.jwkToPkcs1(this._key);
  }
  get bytes() {
    return PrivateKey.encode({
      Type: KeyType.RSA,
      Data: this.marshal()
    }).subarray();
  }
  equals(key) {
    return equals(this.bytes, key.bytes);
  }
  async hash() {
    const { bytes: bytes2 } = await sha2562.digest(this.bytes);
    return bytes2;
  }
  /**
   * Gets the ID of the key.
   *
   * The key id is the base58 encoding of the SHA-256 multihash of its public key.
   * The public key is a protobuf encoding containing a type and the DER encoding
   * of the PKCS SubjectPublicKeyInfo.
   */
  async id() {
    const hash2 = await this.public.hash();
    return toString(hash2, "base58btc");
  }
  /**
   * Exports the key into a password protected PEM format
   */
  async export(password, format = "pkcs-8") {
    if (format === "pkcs-8") {
      const buffer = new import_forge4.default.util.ByteBuffer(this.marshal());
      const asn1 = import_forge4.default.asn1.fromDer(buffer);
      const privateKey = import_forge4.default.pki.privateKeyFromAsn1(asn1);
      const options = {
        algorithm: "aes256",
        count: 1e4,
        saltSize: 128 / 8,
        prfAlgorithm: "sha512"
      };
      return import_forge4.default.pki.encryptRsaPrivateKey(privateKey, password, options);
    } else if (format === "libp2p-key") {
      return exporter(this.bytes, password);
    } else {
      throw new CodeError(`export format '${format}' is not supported`, "ERR_INVALID_EXPORT_FORMAT");
    }
  }
};
async function unmarshalRsaPrivateKey(bytes2) {
  const jwk = rsa_utils_exports.pkcs1ToJwk(bytes2);
  if (keySize(jwk) > MAX_KEY_SIZE) {
    throw new CodeError("key size is too large", "ERR_KEY_SIZE_TOO_LARGE");
  }
  const keys = await unmarshalPrivateKey(jwk);
  return new RsaPrivateKey(keys.privateKey, keys.publicKey);
}
function unmarshalRsaPublicKey(bytes2) {
  const jwk = rsa_utils_exports.pkixToJwk(bytes2);
  if (keySize(jwk) > MAX_KEY_SIZE) {
    throw new CodeError("key size is too large", "ERR_KEY_SIZE_TOO_LARGE");
  }
  return new RsaPublicKey(jwk);
}
async function fromJwk(jwk) {
  if (keySize(jwk) > MAX_KEY_SIZE) {
    throw new CodeError("key size is too large", "ERR_KEY_SIZE_TOO_LARGE");
  }
  const keys = await unmarshalPrivateKey(jwk);
  return new RsaPrivateKey(keys.privateKey, keys.publicKey);
}
async function generateKeyPair2(bits2) {
  if (bits2 > MAX_KEY_SIZE) {
    throw new CodeError("key size is too large", "ERR_KEY_SIZE_TOO_LARGE");
  }
  const keys = await generateKey2(bits2);
  return new RsaPrivateKey(keys.privateKey, keys.publicKey);
}

// node_modules/@libp2p/crypto/dist/src/keys/secp256k1-class.js
var secp256k1_class_exports = {};
__export(secp256k1_class_exports, {
  Secp256k1PrivateKey: () => Secp256k1PrivateKey,
  Secp256k1PublicKey: () => Secp256k1PublicKey,
  generateKeyPair: () => generateKeyPair3,
  unmarshalSecp256k1PrivateKey: () => unmarshalSecp256k1PrivateKey,
  unmarshalSecp256k1PublicKey: () => unmarshalSecp256k1PublicKey
});

// node_modules/@libp2p/crypto/dist/src/keys/secp256k1.js
function generateKey3() {
  return secp256k1.utils.randomPrivateKey();
}
async function hashAndSign3(key, msg) {
  const { digest: digest2 } = await sha2562.digest(msg);
  try {
    const signature = secp256k1.sign(digest2, key);
    return signature.toDERRawBytes();
  } catch (err) {
    throw new CodeError(String(err), "ERR_INVALID_INPUT");
  }
}
async function hashAndVerify3(key, sig, msg) {
  try {
    const { digest: digest2 } = await sha2562.digest(msg);
    return secp256k1.verify(sig, digest2, key);
  } catch (err) {
    throw new CodeError(String(err), "ERR_INVALID_INPUT");
  }
}
function compressPublicKey(key) {
  const point = secp256k1.ProjectivePoint.fromHex(key).toRawBytes(true);
  return point;
}
function validatePrivateKey(key) {
  try {
    secp256k1.getPublicKey(key, true);
  } catch (err) {
    throw new CodeError(String(err), "ERR_INVALID_PRIVATE_KEY");
  }
}
function validatePublicKey(key) {
  try {
    secp256k1.ProjectivePoint.fromHex(key);
  } catch (err) {
    throw new CodeError(String(err), "ERR_INVALID_PUBLIC_KEY");
  }
}
function computePublicKey(privateKey) {
  try {
    return secp256k1.getPublicKey(privateKey, true);
  } catch (err) {
    throw new CodeError(String(err), "ERR_INVALID_PRIVATE_KEY");
  }
}

// node_modules/@libp2p/crypto/dist/src/keys/secp256k1-class.js
var Secp256k1PublicKey = class {
  constructor(key) {
    __publicField(this, "_key");
    validatePublicKey(key);
    this._key = key;
  }
  async verify(data, sig) {
    return hashAndVerify3(this._key, sig, data);
  }
  marshal() {
    return compressPublicKey(this._key);
  }
  get bytes() {
    return PublicKey.encode({
      Type: KeyType.Secp256k1,
      Data: this.marshal()
    }).subarray();
  }
  equals(key) {
    return equals(this.bytes, key.bytes);
  }
  async hash() {
    const { bytes: bytes2 } = await sha2562.digest(this.bytes);
    return bytes2;
  }
};
var Secp256k1PrivateKey = class {
  constructor(key, publicKey) {
    __publicField(this, "_key");
    __publicField(this, "_publicKey");
    this._key = key;
    this._publicKey = publicKey ?? computePublicKey(key);
    validatePrivateKey(this._key);
    validatePublicKey(this._publicKey);
  }
  async sign(message2) {
    return hashAndSign3(this._key, message2);
  }
  get public() {
    return new Secp256k1PublicKey(this._publicKey);
  }
  marshal() {
    return this._key;
  }
  get bytes() {
    return PrivateKey.encode({
      Type: KeyType.Secp256k1,
      Data: this.marshal()
    }).subarray();
  }
  equals(key) {
    return equals(this.bytes, key.bytes);
  }
  async hash() {
    const { bytes: bytes2 } = await sha2562.digest(this.bytes);
    return bytes2;
  }
  /**
   * Gets the ID of the key.
   *
   * The key id is the base58 encoding of the SHA-256 multihash of its public key.
   * The public key is a protobuf encoding containing a type and the DER encoding
   * of the PKCS SubjectPublicKeyInfo.
   */
  async id() {
    const hash2 = await this.public.hash();
    return toString(hash2, "base58btc");
  }
  /**
   * Exports the key into a password protected `format`
   */
  async export(password, format = "libp2p-key") {
    if (format === "libp2p-key") {
      return exporter(this.bytes, password);
    } else {
      throw new CodeError(`export format '${format}' is not supported`, "ERR_INVALID_EXPORT_FORMAT");
    }
  }
};
function unmarshalSecp256k1PrivateKey(bytes2) {
  return new Secp256k1PrivateKey(bytes2);
}
function unmarshalSecp256k1PublicKey(bytes2) {
  return new Secp256k1PublicKey(bytes2);
}
async function generateKeyPair3() {
  const privateKeyBytes = generateKey3();
  return new Secp256k1PrivateKey(privateKeyBytes);
}

// node_modules/@libp2p/crypto/dist/src/keys/index.js
var supportedKeys = {
  rsa: rsa_class_exports,
  ed25519: ed25519_class_exports,
  secp256k1: secp256k1_class_exports
};
function unsupportedKey(type) {
  const supported = Object.keys(supportedKeys).join(" / ");
  return new CodeError(`invalid or unsupported key type ${type}. Must be ${supported}`, "ERR_UNSUPPORTED_KEY_TYPE");
}
function typeToKey(type) {
  type = type.toLowerCase();
  if (type === "rsa" || type === "ed25519" || type === "secp256k1") {
    return supportedKeys[type];
  }
  throw unsupportedKey(type);
}
async function generateKeyPair4(type, bits2) {
  return typeToKey(type).generateKeyPair(bits2 ?? 2048);
}
function unmarshalPublicKey(buf) {
  const decoded = PublicKey.decode(buf);
  const data = decoded.Data ?? new Uint8Array();
  switch (decoded.Type) {
    case KeyType.RSA:
      return supportedKeys.rsa.unmarshalRsaPublicKey(data);
    case KeyType.Ed25519:
      return supportedKeys.ed25519.unmarshalEd25519PublicKey(data);
    case KeyType.Secp256k1:
      return supportedKeys.secp256k1.unmarshalSecp256k1PublicKey(data);
    default:
      throw unsupportedKey(decoded.Type ?? "unknown");
  }
}
function marshalPublicKey(key, type) {
  type = (type ?? "rsa").toLowerCase();
  typeToKey(type);
  return key.bytes;
}
async function unmarshalPrivateKey2(buf) {
  const decoded = PrivateKey.decode(buf);
  const data = decoded.Data ?? new Uint8Array();
  switch (decoded.Type) {
    case KeyType.RSA:
      return supportedKeys.rsa.unmarshalRsaPrivateKey(data);
    case KeyType.Ed25519:
      return supportedKeys.ed25519.unmarshalEd25519PrivateKey(data);
    case KeyType.Secp256k1:
      return supportedKeys.secp256k1.unmarshalSecp256k1PrivateKey(data);
    default:
      throw unsupportedKey(decoded.Type ?? "RSA");
  }
}
function marshalPrivateKey(key, type) {
  type = (type ?? "rsa").toLowerCase();
  typeToKey(type);
  return key.bytes;
}
async function importKey(encryptedKey, password) {
  try {
    const key2 = await importer(encryptedKey, password);
    return await unmarshalPrivateKey2(key2);
  } catch (_) {
  }
  const key = import_forge5.default.pki.decryptRsaPrivateKey(encryptedKey, password);
  if (key === null) {
    throw new CodeError("Cannot read the key, most likely the password is wrong or not a RSA key", "ERR_CANNOT_DECRYPT_PEM");
  }
  let der = import_forge5.default.asn1.toDer(import_forge5.default.pki.privateKeyToAsn1(key));
  der = fromString(der.getBytes(), "ascii");
  return supportedKeys.rsa.unmarshalRsaPrivateKey(der);
}

// node_modules/@chainsafe/libp2p-noise/dist/src/proto/payload.js
var NoiseExtensions;
(function(NoiseExtensions2) {
  let _codec;
  NoiseExtensions2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.webtransportCerthashes != null) {
          for (const value of obj.webtransportCerthashes) {
            w.uint32(10);
            w.bytes(value);
          }
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length4) => {
        const obj = {
          webtransportCerthashes: []
        };
        const end = length4 == null ? reader2.len : reader2.pos + length4;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.webtransportCerthashes.push(reader2.bytes());
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  NoiseExtensions2.encode = (obj) => {
    return encodeMessage(obj, NoiseExtensions2.codec());
  };
  NoiseExtensions2.decode = (buf) => {
    return decodeMessage(buf, NoiseExtensions2.codec());
  };
})(NoiseExtensions || (NoiseExtensions = {}));
var NoiseHandshakePayload;
(function(NoiseHandshakePayload2) {
  let _codec;
  NoiseHandshakePayload2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (opts.writeDefaults === true || obj.identityKey != null && obj.identityKey.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.identityKey ?? new Uint8Array(0));
        }
        if (opts.writeDefaults === true || obj.identitySig != null && obj.identitySig.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.identitySig ?? new Uint8Array(0));
        }
        if (obj.extensions != null) {
          w.uint32(34);
          NoiseExtensions.codec().encode(obj.extensions, w, {
            writeDefaults: false
          });
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length4) => {
        const obj = {
          identityKey: new Uint8Array(0),
          identitySig: new Uint8Array(0)
        };
        const end = length4 == null ? reader2.len : reader2.pos + length4;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.identityKey = reader2.bytes();
              break;
            case 2:
              obj.identitySig = reader2.bytes();
              break;
            case 4:
              obj.extensions = NoiseExtensions.codec().decode(reader2, reader2.uint32());
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  NoiseHandshakePayload2.encode = (obj) => {
    return encodeMessage(obj, NoiseHandshakePayload2.codec());
  };
  NoiseHandshakePayload2.decode = (buf) => {
    return decodeMessage(buf, NoiseHandshakePayload2.codec());
  };
})(NoiseHandshakePayload || (NoiseHandshakePayload = {}));

// node_modules/@chainsafe/libp2p-noise/dist/src/utils.js
async function getPayload(localPeer, staticPublicKey, extensions) {
  const signedPayload = await signPayload(localPeer, getHandshakePayload(staticPublicKey));
  if (localPeer.publicKey == null) {
    throw new Error("PublicKey was missing from local PeerId");
  }
  return createHandshakePayload(localPeer.publicKey, signedPayload, extensions);
}
function createHandshakePayload(libp2pPublicKey, signedPayload, extensions) {
  return NoiseHandshakePayload.encode({
    identityKey: libp2pPublicKey,
    identitySig: signedPayload,
    extensions: extensions ?? { webtransportCerthashes: [] }
  }).subarray();
}
async function signPayload(peerId2, payload) {
  if (peerId2.privateKey == null) {
    throw new Error("PrivateKey was missing from PeerId");
  }
  const privateKey = await unmarshalPrivateKey2(peerId2.privateKey);
  return privateKey.sign(payload);
}
async function getPeerIdFromPayload(payload) {
  return peerIdFromKeys(payload.identityKey);
}
function decodePayload(payload) {
  return NoiseHandshakePayload.decode(payload);
}
function getHandshakePayload(publicKey) {
  const prefix = fromString("noise-libp2p-static-key:");
  return concat([prefix, publicKey], prefix.length + publicKey.length);
}
async function verifySignedPayload(noiseStaticKey, payload, remotePeer) {
  const payloadPeerId = await peerIdFromKeys(payload.identityKey);
  if (!payloadPeerId.equals(remotePeer)) {
    throw new Error(`Payload identity key ${payloadPeerId.toString()} does not match expected remote peer ${remotePeer.toString()}`);
  }
  const generatedPayload = getHandshakePayload(noiseStaticKey);
  if (payloadPeerId.publicKey == null) {
    throw new Error("PublicKey was missing from PeerId");
  }
  if (payload.identitySig == null) {
    throw new Error("Signature was missing from message");
  }
  const publicKey = unmarshalPublicKey(payloadPeerId.publicKey);
  const valid = await publicKey.verify(generatedPayload, payload.identitySig);
  if (!valid) {
    throw new Error("Static key doesn't match to peer that signed payload!");
  }
  return payloadPeerId;
}
function isValidPublicKey(pk) {
  if (!(pk instanceof Uint8Array)) {
    return false;
  }
  if (pk.length !== 32) {
    return false;
  }
  return true;
}

// node_modules/@chainsafe/libp2p-noise/dist/src/logger.js
var log9 = logger("libp2p:noise");
var keyLogger;
if (DUMP_SESSION_KEYS) {
  keyLogger = log9;
} else {
  keyLogger = Object.assign(() => {
  }, {
    enabled: false,
    trace: () => {
    },
    error: () => {
    }
  });
}
function logLocalStaticKeys(s) {
  keyLogger(`LOCAL_STATIC_PUBLIC_KEY ${toString(s.publicKey, "hex")}`);
  keyLogger(`LOCAL_STATIC_PRIVATE_KEY ${toString(s.privateKey, "hex")}`);
}
function logLocalEphemeralKeys(e) {
  if (e) {
    keyLogger(`LOCAL_PUBLIC_EPHEMERAL_KEY ${toString(e.publicKey, "hex")}`);
    keyLogger(`LOCAL_PRIVATE_EPHEMERAL_KEY ${toString(e.privateKey, "hex")}`);
  } else {
    keyLogger("Missing local ephemeral keys.");
  }
}
function logRemoteStaticKey(rs) {
  keyLogger(`REMOTE_STATIC_PUBLIC_KEY ${toString(rs, "hex")}`);
}
function logRemoteEphemeralKey(re) {
  keyLogger(`REMOTE_EPHEMERAL_PUBLIC_KEY ${toString(re, "hex")}`);
}
function logCipherState(session) {
  if (session.cs1 && session.cs2) {
    keyLogger(`CIPHER_STATE_1 ${session.cs1.n.getUint64()} ${toString(session.cs1.k, "hex")}`);
    keyLogger(`CIPHER_STATE_2 ${session.cs2.n.getUint64()} ${toString(session.cs2.k, "hex")}`);
  } else {
    keyLogger("Missing cipher state.");
  }
}

// node_modules/@chainsafe/libp2p-noise/dist/src/nonce.js
var MIN_NONCE = 0;
var MAX_NONCE = 4294967295;
var ERR_MAX_NONCE = "Cipherstate has reached maximum n, a new handshake must be performed";
var Nonce = class {
  constructor(n = MIN_NONCE) {
    __publicField(this, "n");
    __publicField(this, "bytes");
    __publicField(this, "view");
    this.n = n;
    this.bytes = new Uint8Array(12);
    this.view = new DataView(this.bytes.buffer, this.bytes.byteOffset, this.bytes.byteLength);
    this.view.setUint32(4, n, true);
  }
  increment() {
    this.n++;
    this.view.setUint32(4, this.n, true);
  }
  getBytes() {
    return this.bytes;
  }
  getUint64() {
    return this.n;
  }
  assertValue() {
    if (this.n > MAX_NONCE) {
      throw new Error(ERR_MAX_NONCE);
    }
  }
};

// node_modules/@chainsafe/libp2p-noise/dist/src/handshakes/abstract-handshake.js
var AbstractHandshake = class {
  constructor(crypto2) {
    __publicField(this, "crypto");
    this.crypto = crypto2;
  }
  encryptWithAd(cs, ad, plaintext) {
    const e = this.encrypt(cs.k, cs.n, ad, plaintext);
    cs.n.increment();
    return e;
  }
  decryptWithAd(cs, ad, ciphertext, dst) {
    const { plaintext, valid } = this.decrypt(cs.k, cs.n, ad, ciphertext, dst);
    if (valid)
      cs.n.increment();
    return { plaintext, valid };
  }
  // Cipher state related
  hasKey(cs) {
    return !this.isEmptyKey(cs.k);
  }
  createEmptyKey() {
    return new Uint8Array(32);
  }
  isEmptyKey(k) {
    const emptyKey = this.createEmptyKey();
    return equals(emptyKey, k);
  }
  encrypt(k, n, ad, plaintext) {
    n.assertValue();
    return this.crypto.chaCha20Poly1305Encrypt(plaintext, n.getBytes(), ad, k);
  }
  encryptAndHash(ss, plaintext) {
    let ciphertext;
    if (this.hasKey(ss.cs)) {
      ciphertext = this.encryptWithAd(ss.cs, ss.h, plaintext);
    } else {
      ciphertext = plaintext;
    }
    this.mixHash(ss, ciphertext);
    return ciphertext;
  }
  decrypt(k, n, ad, ciphertext, dst) {
    n.assertValue();
    const encryptedMessage = this.crypto.chaCha20Poly1305Decrypt(ciphertext, n.getBytes(), ad, k, dst);
    if (encryptedMessage) {
      return {
        plaintext: encryptedMessage,
        valid: true
      };
    } else {
      return {
        plaintext: new Uint8Array(0),
        valid: false
      };
    }
  }
  decryptAndHash(ss, ciphertext) {
    let plaintext;
    let valid = true;
    if (this.hasKey(ss.cs)) {
      ({ plaintext, valid } = this.decryptWithAd(ss.cs, ss.h, ciphertext));
    } else {
      plaintext = ciphertext;
    }
    this.mixHash(ss, ciphertext);
    return { plaintext, valid };
  }
  dh(privateKey, publicKey) {
    try {
      const derivedU8 = this.crypto.generateX25519SharedKey(privateKey, publicKey);
      if (derivedU8.length === 32) {
        return derivedU8;
      }
      return derivedU8.subarray(0, 32);
    } catch (e) {
      const err = e;
      log9.error(err);
      return new Uint8Array(32);
    }
  }
  mixHash(ss, data) {
    ss.h = this.getHash(ss.h, data);
  }
  getHash(a, b) {
    const u = this.crypto.hashSHA256(concat([a, b], a.length + b.length));
    return u;
  }
  mixKey(ss, ikm) {
    const [ck, tempK] = this.crypto.getHKDF(ss.ck, ikm);
    ss.cs = this.initializeKey(tempK);
    ss.ck = ck;
  }
  initializeKey(k) {
    return { k, n: new Nonce() };
  }
  // Symmetric state related
  initializeSymmetric(protocolName) {
    const protocolNameBytes = fromString(protocolName, "utf-8");
    const h = this.hashProtocolName(protocolNameBytes);
    const ck = h;
    const key = this.createEmptyKey();
    const cs = this.initializeKey(key);
    return { cs, ck, h };
  }
  hashProtocolName(protocolName) {
    if (protocolName.length <= 32) {
      const h = new Uint8Array(32);
      h.set(protocolName);
      return h;
    } else {
      return this.getHash(protocolName, new Uint8Array(0));
    }
  }
  split(ss) {
    const [tempk1, tempk2] = this.crypto.getHKDF(ss.ck, new Uint8Array(0));
    const cs1 = this.initializeKey(tempk1);
    const cs2 = this.initializeKey(tempk2);
    return { cs1, cs2 };
  }
  writeMessageRegular(cs, payload) {
    const ciphertext = this.encryptWithAd(cs, new Uint8Array(0), payload);
    const ne = this.createEmptyKey();
    const ns = new Uint8Array(0);
    return { ne, ns, ciphertext };
  }
  readMessageRegular(cs, message2) {
    return this.decryptWithAd(cs, new Uint8Array(0), message2.ciphertext);
  }
};

// node_modules/@chainsafe/libp2p-noise/dist/src/handshakes/xx.js
var XX = class extends AbstractHandshake {
  initializeInitiator(prologue, s, rs, psk) {
    const name2 = "Noise_XX_25519_ChaChaPoly_SHA256";
    const ss = this.initializeSymmetric(name2);
    this.mixHash(ss, prologue);
    const re = new Uint8Array(32);
    return { ss, s, rs, psk, re };
  }
  initializeResponder(prologue, s, rs, psk) {
    const name2 = "Noise_XX_25519_ChaChaPoly_SHA256";
    const ss = this.initializeSymmetric(name2);
    this.mixHash(ss, prologue);
    const re = new Uint8Array(32);
    return { ss, s, rs, psk, re };
  }
  writeMessageA(hs, payload, e) {
    const ns = new Uint8Array(0);
    if (e !== void 0) {
      hs.e = e;
    } else {
      hs.e = this.crypto.generateX25519KeyPair();
    }
    const ne = hs.e.publicKey;
    this.mixHash(hs.ss, ne);
    const ciphertext = this.encryptAndHash(hs.ss, payload);
    return { ne, ns, ciphertext };
  }
  writeMessageB(hs, payload) {
    hs.e = this.crypto.generateX25519KeyPair();
    const ne = hs.e.publicKey;
    this.mixHash(hs.ss, ne);
    this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re));
    const spk = hs.s.publicKey;
    const ns = this.encryptAndHash(hs.ss, spk);
    this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re));
    const ciphertext = this.encryptAndHash(hs.ss, payload);
    return { ne, ns, ciphertext };
  }
  writeMessageC(hs, payload) {
    const spk = hs.s.publicKey;
    const ns = this.encryptAndHash(hs.ss, spk);
    this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re));
    const ciphertext = this.encryptAndHash(hs.ss, payload);
    const ne = this.createEmptyKey();
    const messageBuffer = { ne, ns, ciphertext };
    const { cs1, cs2 } = this.split(hs.ss);
    return { h: hs.ss.h, messageBuffer, cs1, cs2 };
  }
  readMessageA(hs, message2) {
    if (isValidPublicKey(message2.ne)) {
      hs.re = message2.ne;
    }
    this.mixHash(hs.ss, hs.re);
    return this.decryptAndHash(hs.ss, message2.ciphertext);
  }
  readMessageB(hs, message2) {
    if (isValidPublicKey(message2.ne)) {
      hs.re = message2.ne;
    }
    this.mixHash(hs.ss, hs.re);
    if (!hs.e) {
      throw new Error("Handshake state `e` param is missing.");
    }
    this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re));
    const { plaintext: ns, valid: valid1 } = this.decryptAndHash(hs.ss, message2.ns);
    if (valid1 && isValidPublicKey(ns)) {
      hs.rs = ns;
    }
    this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs));
    const { plaintext, valid: valid2 } = this.decryptAndHash(hs.ss, message2.ciphertext);
    return { plaintext, valid: valid1 && valid2 };
  }
  readMessageC(hs, message2) {
    const { plaintext: ns, valid: valid1 } = this.decryptAndHash(hs.ss, message2.ns);
    if (valid1 && isValidPublicKey(ns)) {
      hs.rs = ns;
    }
    if (!hs.e) {
      throw new Error("Handshake state `e` param is missing.");
    }
    this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs));
    const { plaintext, valid: valid2 } = this.decryptAndHash(hs.ss, message2.ciphertext);
    const { cs1, cs2 } = this.split(hs.ss);
    return { h: hs.ss.h, plaintext, valid: valid1 && valid2, cs1, cs2 };
  }
  initSession(initiator, prologue, s) {
    const psk = this.createEmptyKey();
    const rs = new Uint8Array(32);
    let hs;
    if (initiator) {
      hs = this.initializeInitiator(prologue, s, rs, psk);
    } else {
      hs = this.initializeResponder(prologue, s, rs, psk);
    }
    return {
      hs,
      i: initiator,
      mc: 0
    };
  }
  sendMessage(session, message2, ephemeral) {
    let messageBuffer;
    if (session.mc === 0) {
      messageBuffer = this.writeMessageA(session.hs, message2, ephemeral);
    } else if (session.mc === 1) {
      messageBuffer = this.writeMessageB(session.hs, message2);
    } else if (session.mc === 2) {
      const { h, messageBuffer: resultingBuffer, cs1, cs2 } = this.writeMessageC(session.hs, message2);
      messageBuffer = resultingBuffer;
      session.h = h;
      session.cs1 = cs1;
      session.cs2 = cs2;
    } else if (session.mc > 2) {
      if (session.i) {
        if (!session.cs1) {
          throw new Error("CS1 (cipher state) is not defined");
        }
        messageBuffer = this.writeMessageRegular(session.cs1, message2);
      } else {
        if (!session.cs2) {
          throw new Error("CS2 (cipher state) is not defined");
        }
        messageBuffer = this.writeMessageRegular(session.cs2, message2);
      }
    } else {
      throw new Error("Session invalid.");
    }
    session.mc++;
    return messageBuffer;
  }
  recvMessage(session, message2) {
    let plaintext = new Uint8Array(0);
    let valid = false;
    if (session.mc === 0) {
      ({ plaintext, valid } = this.readMessageA(session.hs, message2));
    } else if (session.mc === 1) {
      ({ plaintext, valid } = this.readMessageB(session.hs, message2));
    } else if (session.mc === 2) {
      const { h, plaintext: resultingPlaintext, valid: resultingValid, cs1, cs2 } = this.readMessageC(session.hs, message2);
      plaintext = resultingPlaintext;
      valid = resultingValid;
      session.h = h;
      session.cs1 = cs1;
      session.cs2 = cs2;
    }
    session.mc++;
    return { plaintext, valid };
  }
};

// node_modules/@chainsafe/libp2p-noise/dist/src/handshake-xx.js
var XXHandshake = class {
  constructor(isInitiator, payload, prologue, crypto2, staticKeypair, connection, remotePeer, handshake2) {
    __publicField(this, "isInitiator");
    __publicField(this, "session");
    __publicField(this, "remotePeer");
    __publicField(this, "remoteExtensions", { webtransportCerthashes: [] });
    __publicField(this, "payload");
    __publicField(this, "connection");
    __publicField(this, "xx");
    __publicField(this, "staticKeypair");
    __publicField(this, "prologue");
    this.isInitiator = isInitiator;
    this.payload = payload;
    this.prologue = prologue;
    this.staticKeypair = staticKeypair;
    this.connection = connection;
    if (remotePeer) {
      this.remotePeer = remotePeer;
    }
    this.xx = handshake2 ?? new XX(crypto2);
    this.session = this.xx.initSession(this.isInitiator, this.prologue, this.staticKeypair);
  }
  // stage 0
  async propose() {
    logLocalStaticKeys(this.session.hs.s);
    if (this.isInitiator) {
      log9.trace("Stage 0 - Initiator starting to send first message.");
      const messageBuffer = this.xx.sendMessage(this.session, new Uint8Array(0));
      await this.connection.write(encode0(messageBuffer));
      log9.trace("Stage 0 - Initiator finished sending first message.");
      logLocalEphemeralKeys(this.session.hs.e);
    } else {
      log9.trace("Stage 0 - Responder waiting to receive first message...");
      const receivedMessageBuffer = decode0((await this.connection.read()).subarray());
      const { valid } = this.xx.recvMessage(this.session, receivedMessageBuffer);
      if (!valid) {
        throw new InvalidCryptoExchangeError("xx handshake stage 0 validation fail");
      }
      log9.trace("Stage 0 - Responder received first message.");
      logRemoteEphemeralKey(this.session.hs.re);
    }
  }
  // stage 1
  async exchange() {
    if (this.isInitiator) {
      log9.trace("Stage 1 - Initiator waiting to receive first message from responder...");
      const receivedMessageBuffer = decode1((await this.connection.read()).subarray());
      const { plaintext, valid } = this.xx.recvMessage(this.session, receivedMessageBuffer);
      if (!valid) {
        throw new InvalidCryptoExchangeError("xx handshake stage 1 validation fail");
      }
      log9.trace("Stage 1 - Initiator received the message.");
      logRemoteEphemeralKey(this.session.hs.re);
      logRemoteStaticKey(this.session.hs.rs);
      log9.trace("Initiator going to check remote's signature...");
      try {
        const decodedPayload = decodePayload(plaintext);
        this.remotePeer = this.remotePeer || await getPeerIdFromPayload(decodedPayload);
        await verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);
        this.setRemoteNoiseExtension(decodedPayload.extensions);
      } catch (e) {
        const err = e;
        throw new UnexpectedPeerError(`Error occurred while verifying signed payload: ${err.message}`);
      }
      log9.trace("All good with the signature!");
    } else {
      log9.trace("Stage 1 - Responder sending out first message with signed payload and static key.");
      const messageBuffer = this.xx.sendMessage(this.session, this.payload);
      await this.connection.write(encode1(messageBuffer));
      log9.trace("Stage 1 - Responder sent the second handshake message with signed payload.");
      logLocalEphemeralKeys(this.session.hs.e);
    }
  }
  // stage 2
  async finish() {
    if (this.isInitiator) {
      log9.trace("Stage 2 - Initiator sending third handshake message.");
      const messageBuffer = this.xx.sendMessage(this.session, this.payload);
      await this.connection.write(encode22(messageBuffer));
      log9.trace("Stage 2 - Initiator sent message with signed payload.");
    } else {
      log9.trace("Stage 2 - Responder waiting for third handshake message...");
      const receivedMessageBuffer = decode22((await this.connection.read()).subarray());
      const { plaintext, valid } = this.xx.recvMessage(this.session, receivedMessageBuffer);
      if (!valid) {
        throw new InvalidCryptoExchangeError("xx handshake stage 2 validation fail");
      }
      log9.trace("Stage 2 - Responder received the message, finished handshake.");
      try {
        const decodedPayload = decodePayload(plaintext);
        this.remotePeer = this.remotePeer || await getPeerIdFromPayload(decodedPayload);
        await verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);
        this.setRemoteNoiseExtension(decodedPayload.extensions);
      } catch (e) {
        const err = e;
        throw new UnexpectedPeerError(`Error occurred while verifying signed payload: ${err.message}`);
      }
    }
    logCipherState(this.session);
  }
  encrypt(plaintext, session) {
    const cs = this.getCS(session);
    return this.xx.encryptWithAd(cs, new Uint8Array(0), plaintext);
  }
  decrypt(ciphertext, session, dst) {
    const cs = this.getCS(session, false);
    return this.xx.decryptWithAd(cs, new Uint8Array(0), ciphertext, dst);
  }
  getRemoteStaticKey() {
    return this.session.hs.rs;
  }
  getCS(session, encryption = true) {
    if (!session.cs1 || !session.cs2) {
      throw new InvalidCryptoExchangeError("Handshake not completed properly, cipher state does not exist.");
    }
    if (this.isInitiator) {
      return encryption ? session.cs1 : session.cs2;
    } else {
      return encryption ? session.cs2 : session.cs1;
    }
  }
  setRemoteNoiseExtension(e) {
    if (e) {
      this.remoteExtensions = e;
    }
  }
};

// node_modules/@chainsafe/libp2p-noise/dist/src/metrics.js
function registerMetrics(metrics) {
  return {
    xxHandshakeSuccesses: metrics.registerCounter("libp2p_noise_xxhandshake_successes_total", {
      help: "Total count of noise xxHandshakes successes_"
    }),
    xxHandshakeErrors: metrics.registerCounter("libp2p_noise_xxhandshake_error_total", {
      help: "Total count of noise xxHandshakes errors"
    }),
    encryptedPackets: metrics.registerCounter("libp2p_noise_encrypted_packets_total", {
      help: "Total count of noise encrypted packets successfully"
    }),
    decryptedPackets: metrics.registerCounter("libp2p_noise_decrypted_packets_total", {
      help: "Total count of noise decrypted packets"
    }),
    decryptErrors: metrics.registerCounter("libp2p_noise_decrypt_errors_total", {
      help: "Total count of noise decrypt errors"
    })
  };
}

// node_modules/@chainsafe/libp2p-noise/dist/src/noise.js
var Noise = class {
  constructor(init = {}) {
    __publicField(this, "protocol", "/noise");
    __publicField(this, "crypto");
    __publicField(this, "prologue");
    __publicField(this, "staticKeys");
    __publicField(this, "extensions");
    __publicField(this, "metrics");
    const { staticNoiseKey, extensions, crypto: crypto2, prologueBytes, metrics } = init;
    this.crypto = crypto2 ?? defaultCrypto;
    this.extensions = extensions;
    this.metrics = metrics ? registerMetrics(metrics) : void 0;
    if (staticNoiseKey) {
      this.staticKeys = this.crypto.generateX25519KeyPairFromSeed(staticNoiseKey);
    } else {
      this.staticKeys = this.crypto.generateX25519KeyPair();
    }
    this.prologue = prologueBytes ?? new Uint8Array(0);
  }
  /**
   * Encrypt outgoing data to the remote party (handshake as initiator)
   *
   * @param {PeerId} localPeer - PeerId of the receiving peer
   * @param {Duplex<AsyncGenerator<Uint8Array>, AsyncIterable<Uint8Array>, Promise<void>>} connection - streaming iterable duplex that will be encrypted
   * @param {PeerId} remotePeer - PeerId of the remote peer. Used to validate the integrity of the remote peer.
   * @returns {Promise<SecuredConnection>}
   */
  async secureOutbound(localPeer, connection, remotePeer) {
    const wrappedConnection = lpStream(connection, {
      lengthEncoder: uint16BEEncode,
      lengthDecoder: uint16BEDecode,
      maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES
    });
    const handshake2 = await this.performHandshake({
      connection: wrappedConnection,
      isInitiator: true,
      localPeer,
      remotePeer
    });
    const conn = await this.createSecureConnection(wrappedConnection, handshake2);
    return {
      conn,
      remoteExtensions: handshake2.remoteExtensions,
      remotePeer: handshake2.remotePeer
    };
  }
  /**
   * Decrypt incoming data (handshake as responder).
   *
   * @param {PeerId} localPeer - PeerId of the receiving peer.
   * @param {Duplex<AsyncGenerator<Uint8Array>, AsyncIterable<Uint8Array>, Promise<void>>} connection - streaming iterable duplex that will be encryption.
   * @param {PeerId} remotePeer - optional PeerId of the initiating peer, if known. This may only exist during transport upgrades.
   * @returns {Promise<SecuredConnection>}
   */
  async secureInbound(localPeer, connection, remotePeer) {
    const wrappedConnection = lpStream(connection, {
      lengthEncoder: uint16BEEncode,
      lengthDecoder: uint16BEDecode,
      maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES
    });
    const handshake2 = await this.performHandshake({
      connection: wrappedConnection,
      isInitiator: false,
      localPeer,
      remotePeer
    });
    const conn = await this.createSecureConnection(wrappedConnection, handshake2);
    return {
      conn,
      remotePeer: handshake2.remotePeer,
      remoteExtensions: handshake2.remoteExtensions
    };
  }
  /**
   * If Noise pipes supported, tries IK handshake first with XX as fallback if it fails.
   * If noise pipes disabled or remote peer static key is unknown, use XX.
   *
   * @param {HandshakeParams} params
   */
  async performHandshake(params) {
    const payload = await getPayload(params.localPeer, this.staticKeys.publicKey, this.extensions);
    return this.performXXHandshake(params, payload);
  }
  async performXXHandshake(params, payload) {
    var _a4, _b4;
    const { isInitiator, remotePeer, connection } = params;
    const handshake2 = new XXHandshake(isInitiator, payload, this.prologue, this.crypto, this.staticKeys, connection, remotePeer);
    try {
      await handshake2.propose();
      await handshake2.exchange();
      await handshake2.finish();
      (_a4 = this.metrics) == null ? void 0 : _a4.xxHandshakeSuccesses.increment();
    } catch (e) {
      (_b4 = this.metrics) == null ? void 0 : _b4.xxHandshakeErrors.increment();
      if (e instanceof Error) {
        e.message = `Error occurred during XX handshake: ${e.message}`;
        throw e;
      }
    }
    return handshake2;
  }
  async createSecureConnection(connection, handshake2) {
    const [secure, user] = duplexPair();
    const network = connection.unwrap();
    await pipe(
      secure,
      // write to wrapper
      encryptStream(handshake2, this.metrics),
      // encrypt data + prefix with message length
      network,
      // send to the remote peer
      (source) => decode2(source, { lengthDecoder: uint16BEDecode }),
      // read message length prefix
      decryptStream(handshake2, this.metrics),
      // decrypt the incoming data
      secure
      // pipe to the wrapper
    );
    return user;
  }
};

// node_modules/@chainsafe/libp2p-noise/dist/src/index.js
function noise(init = {}) {
  return () => new Noise(init);
}

// node_modules/abortable-iterator/dist/src/abort-error.js
var AbortError6 = class extends Error {
  constructor(message2, code2) {
    super(message2 ?? "The operation was aborted");
    this.type = "aborted";
    this.code = code2 ?? "ABORT_ERR";
  }
};

// node_modules/abortable-iterator/node_modules/get-iterator/dist/src/index.js
function getIterator(obj) {
  if (obj != null) {
    if (typeof obj[Symbol.iterator] === "function") {
      return obj[Symbol.iterator]();
    }
    if (typeof obj[Symbol.asyncIterator] === "function") {
      return obj[Symbol.asyncIterator]();
    }
    if (typeof obj.next === "function") {
      return obj;
    }
  }
  throw new Error("argument is not an iterator or iterable");
}

// node_modules/abortable-iterator/dist/src/index.js
function abortableSource(source, signal, options) {
  const opts = options ?? {};
  const iterator = getIterator(source);
  async function* abortable() {
    let nextAbortHandler;
    const abortHandler = () => {
      if (nextAbortHandler != null)
        nextAbortHandler();
    };
    signal.addEventListener("abort", abortHandler);
    while (true) {
      let result;
      try {
        if (signal.aborted) {
          const { abortMessage, abortCode } = opts;
          throw new AbortError6(abortMessage, abortCode);
        }
        const abort = new Promise((resolve, reject) => {
          nextAbortHandler = () => {
            const { abortMessage, abortCode } = opts;
            reject(new AbortError6(abortMessage, abortCode));
          };
        });
        result = await Promise.race([abort, iterator.next()]);
        nextAbortHandler = null;
      } catch (err) {
        signal.removeEventListener("abort", abortHandler);
        const isKnownAborter = err.type === "aborted" && signal.aborted;
        if (isKnownAborter && opts.onAbort != null) {
          opts.onAbort(source);
        }
        if (typeof iterator.return === "function") {
          try {
            const p = iterator.return();
            if (p instanceof Promise) {
              p.catch((err2) => {
                if (opts.onReturnError != null) {
                  opts.onReturnError(err2);
                }
              });
            }
          } catch (err2) {
            if (opts.onReturnError != null) {
              opts.onReturnError(err2);
            }
          }
        }
        if (isKnownAborter && opts.returnOnAbort === true) {
          return;
        }
        throw err;
      }
      if (result.done === true) {
        break;
      }
      yield result.value;
    }
    signal.removeEventListener("abort", abortHandler);
  }
  return abortable();
}

// node_modules/@libp2p/mplex/dist/src/mplex.js
var import_rate_limiter_flexible = __toESM(require_rate_limiter_flexible(), 1);

// node_modules/@libp2p/mplex/dist/src/message-types.js
var MessageTypes;
(function(MessageTypes2) {
  MessageTypes2[MessageTypes2["NEW_STREAM"] = 0] = "NEW_STREAM";
  MessageTypes2[MessageTypes2["MESSAGE_RECEIVER"] = 1] = "MESSAGE_RECEIVER";
  MessageTypes2[MessageTypes2["MESSAGE_INITIATOR"] = 2] = "MESSAGE_INITIATOR";
  MessageTypes2[MessageTypes2["CLOSE_RECEIVER"] = 3] = "CLOSE_RECEIVER";
  MessageTypes2[MessageTypes2["CLOSE_INITIATOR"] = 4] = "CLOSE_INITIATOR";
  MessageTypes2[MessageTypes2["RESET_RECEIVER"] = 5] = "RESET_RECEIVER";
  MessageTypes2[MessageTypes2["RESET_INITIATOR"] = 6] = "RESET_INITIATOR";
})(MessageTypes || (MessageTypes = {}));
var MessageTypeNames = Object.freeze({
  0: "NEW_STREAM",
  1: "MESSAGE_RECEIVER",
  2: "MESSAGE_INITIATOR",
  3: "CLOSE_RECEIVER",
  4: "CLOSE_INITIATOR",
  5: "RESET_RECEIVER",
  6: "RESET_INITIATOR"
});
var InitiatorMessageTypes = Object.freeze({
  NEW_STREAM: MessageTypes.NEW_STREAM,
  MESSAGE: MessageTypes.MESSAGE_INITIATOR,
  CLOSE: MessageTypes.CLOSE_INITIATOR,
  RESET: MessageTypes.RESET_INITIATOR
});
var ReceiverMessageTypes = Object.freeze({
  MESSAGE: MessageTypes.MESSAGE_RECEIVER,
  CLOSE: MessageTypes.CLOSE_RECEIVER,
  RESET: MessageTypes.RESET_RECEIVER
});

// node_modules/@libp2p/mplex/dist/src/decode.js
var MAX_MSG_SIZE = 1 << 20;
var MAX_MSG_QUEUE_SIZE = 4 << 20;
var Decoder3 = class {
  constructor(maxMessageSize = MAX_MSG_SIZE, maxUnprocessedMessageQueueSize = MAX_MSG_QUEUE_SIZE) {
    __publicField(this, "_buffer");
    __publicField(this, "_headerInfo");
    __publicField(this, "_maxMessageSize");
    __publicField(this, "_maxUnprocessedMessageQueueSize");
    this._buffer = new Uint8ArrayList();
    this._headerInfo = null;
    this._maxMessageSize = maxMessageSize;
    this._maxUnprocessedMessageQueueSize = maxUnprocessedMessageQueueSize;
  }
  write(chunk) {
    if (chunk == null || chunk.length === 0) {
      return [];
    }
    this._buffer.append(chunk);
    if (this._buffer.byteLength > this._maxUnprocessedMessageQueueSize) {
      throw Object.assign(new Error("unprocessed message queue size too large!"), { code: "ERR_MSG_QUEUE_TOO_BIG" });
    }
    const msgs = [];
    while (this._buffer.length !== 0) {
      if (this._headerInfo == null) {
        try {
          this._headerInfo = this._decodeHeader(this._buffer);
        } catch (err) {
          if (err.code === "ERR_MSG_TOO_BIG") {
            throw err;
          }
          break;
        }
      }
      const { id, type, length: length4, offset } = this._headerInfo;
      const bufferedDataLength = this._buffer.length - offset;
      if (bufferedDataLength < length4) {
        break;
      }
      const msg = {
        id,
        type
      };
      if (type === MessageTypes.NEW_STREAM || type === MessageTypes.MESSAGE_INITIATOR || type === MessageTypes.MESSAGE_RECEIVER) {
        msg.data = this._buffer.sublist(offset, offset + length4);
      }
      msgs.push(msg);
      this._buffer.consume(offset + length4);
      this._headerInfo = null;
    }
    return msgs;
  }
  /**
   * Attempts to decode the message header from the buffer
   */
  _decodeHeader(data) {
    const { value: h, offset } = readVarInt(data);
    const { value: length4, offset: end } = readVarInt(data, offset);
    const type = h & 7;
    if (MessageTypeNames[type] == null) {
      throw new Error(`Invalid type received: ${type}`);
    }
    if (length4 > this._maxMessageSize) {
      throw Object.assign(new Error("message size too large!"), { code: "ERR_MSG_TOO_BIG" });
    }
    return { id: h >> 3, type, offset: offset + end, length: length4 };
  }
};
var MSB2 = 128;
var REST2 = 127;
function readVarInt(buf, offset = 0) {
  let res = 0;
  let shift = 0;
  let counter = offset;
  let b;
  const l = buf.length;
  do {
    if (counter >= l || shift > 49) {
      offset = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf.get(counter++);
    res += shift < 28 ? (b & REST2) << shift : (b & REST2) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB2);
  offset = counter - offset;
  return {
    value: res,
    offset
  };
}

// node_modules/it-batched-bytes/dist/src/index.js
function isAsyncIterable5(thing) {
  return thing[Symbol.asyncIterator] != null;
}
var DEFAULT_BATCH_SIZE = 1024 * 1024;
var DEFAULT_SERIALIZE = (buf, list) => {
  list.append(buf);
};
function batchedBytes(source, options) {
  if (isAsyncIterable5(source)) {
    return async function* () {
      let buffer = new Uint8ArrayList();
      let ended = false;
      let deferred = pDefer();
      let size = Number((options == null ? void 0 : options.size) ?? DEFAULT_BATCH_SIZE);
      if (isNaN(size) || size === 0 || size < 0) {
        size = DEFAULT_BATCH_SIZE;
      }
      if (size !== Math.round(size)) {
        throw new Error("Batch size must be an integer");
      }
      const yieldAfter = (options == null ? void 0 : options.yieldAfter) ?? 0;
      const serialize = (options == null ? void 0 : options.serialize) ?? DEFAULT_SERIALIZE;
      void Promise.resolve().then(async () => {
        try {
          let timeout;
          for await (const buf of source) {
            serialize(buf, buffer);
            if (buffer.byteLength >= size) {
              clearTimeout(timeout);
              deferred.resolve();
              continue;
            }
            timeout = setTimeout(() => {
              deferred.resolve();
            }, yieldAfter);
          }
          clearTimeout(timeout);
          deferred.resolve();
        } catch (err) {
          deferred.reject(err);
        } finally {
          ended = true;
        }
      });
      while (!ended) {
        await deferred.promise;
        deferred = pDefer();
        if (buffer.byteLength > 0) {
          const b = buffer;
          buffer = new Uint8ArrayList();
          yield b.subarray();
        }
      }
    }();
  }
  return function* () {
    const buffer = new Uint8ArrayList();
    let size = Number((options == null ? void 0 : options.size) ?? DEFAULT_BATCH_SIZE);
    if (isNaN(size) || size === 0 || size < 0) {
      size = DEFAULT_BATCH_SIZE;
    }
    if (size !== Math.round(size)) {
      throw new Error("Batch size must be an integer");
    }
    const serialize = (options == null ? void 0 : options.serialize) ?? DEFAULT_SERIALIZE;
    for (const buf of source) {
      serialize(buf, buffer);
      if (buffer.byteLength >= size) {
        yield buffer.subarray(0, size);
        buffer.consume(size);
      }
    }
    if (buffer.byteLength > 0) {
      yield buffer.subarray();
    }
  }();
}
var src_default3 = batchedBytes;

// node_modules/@libp2p/mplex/dist/src/alloc-unsafe-browser.js
function allocUnsafe3(size) {
  return new Uint8Array(size);
}

// node_modules/@libp2p/mplex/dist/src/encode.js
var POOL_SIZE = 10 * 1024;
var Encoder3 = class {
  constructor() {
    __publicField(this, "_pool");
    __publicField(this, "_poolOffset");
    this._pool = allocUnsafe3(POOL_SIZE);
    this._poolOffset = 0;
  }
  /**
   * Encodes the given message and adds it to the passed list
   */
  write(msg, list) {
    const pool = this._pool;
    let offset = this._poolOffset;
    encode(msg.id << 3 | msg.type, pool, offset);
    offset += encodingLength(msg.id << 3 | msg.type);
    if ((msg.type === MessageTypes.NEW_STREAM || msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) && msg.data != null) {
      encode(msg.data.length, pool, offset);
      offset += encodingLength(msg.data.length);
    } else {
      encode(0, pool, offset);
      offset += encodingLength(0);
    }
    const header = pool.subarray(this._poolOffset, offset);
    if (POOL_SIZE - offset < 100) {
      this._pool = allocUnsafe3(POOL_SIZE);
      this._poolOffset = 0;
    } else {
      this._poolOffset = offset;
    }
    list.append(header);
    if ((msg.type === MessageTypes.NEW_STREAM || msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) && msg.data != null) {
      list.append(msg.data);
    }
  }
};
var encoder = new Encoder3();
async function* encode6(source, minSendBytes = 0) {
  if (minSendBytes == null || minSendBytes === 0) {
    for await (const messages2 of source) {
      const list = new Uint8ArrayList();
      for (const msg of messages2) {
        encoder.write(msg, list);
      }
      yield list.subarray();
    }
    return;
  }
  yield* src_default3(source, {
    size: minSendBytes,
    serialize: (obj, list) => {
      for (const m of obj) {
        encoder.write(m, list);
      }
    }
  });
}

// node_modules/@libp2p/interface/dist/src/stream-muxer/stream.js
var ERR_STREAM_RESET = "ERR_STREAM_RESET";
var ERR_SINK_INVALID_STATE = "ERR_SINK_INVALID_STATE";
var DEFAULT_SEND_CLOSE_WRITE_TIMEOUT = 5e3;
function isPromise(res) {
  return res != null && typeof res.then === "function";
}
var AbstractStream = class {
  constructor(init) {
    __publicField(this, "id");
    __publicField(this, "direction");
    __publicField(this, "timeline");
    __publicField(this, "protocol");
    __publicField(this, "metadata");
    __publicField(this, "source");
    __publicField(this, "status");
    __publicField(this, "readStatus");
    __publicField(this, "writeStatus");
    __publicField(this, "sinkController");
    __publicField(this, "sinkEnd");
    __publicField(this, "endErr");
    __publicField(this, "streamSource");
    __publicField(this, "onEnd");
    __publicField(this, "onCloseRead");
    __publicField(this, "onCloseWrite");
    __publicField(this, "onReset");
    __publicField(this, "onAbort");
    __publicField(this, "sendCloseWriteTimeout");
    __publicField(this, "log");
    this.sinkController = new AbortController();
    this.sinkEnd = pDefer();
    this.log = init.log;
    this.status = "open";
    this.readStatus = "ready";
    this.writeStatus = "ready";
    this.id = init.id;
    this.metadata = init.metadata ?? {};
    this.direction = init.direction;
    this.timeline = {
      open: Date.now()
    };
    this.sendCloseWriteTimeout = init.sendCloseWriteTimeout ?? DEFAULT_SEND_CLOSE_WRITE_TIMEOUT;
    this.onEnd = init.onEnd;
    this.onCloseRead = init == null ? void 0 : init.onCloseRead;
    this.onCloseWrite = init == null ? void 0 : init.onCloseWrite;
    this.onReset = init == null ? void 0 : init.onReset;
    this.onAbort = init == null ? void 0 : init.onAbort;
    this.source = this.streamSource = pushable({
      onEnd: (err) => {
        if (err != null) {
          this.log.trace("source ended with error", err);
        } else {
          this.log.trace("source ended");
        }
        this.onSourceEnd(err);
      }
    });
    this.sink = this.sink.bind(this);
  }
  async sink(source) {
    if (this.writeStatus !== "ready") {
      throw new CodeError(`writable end state is "${this.writeStatus}" not "ready"`, ERR_SINK_INVALID_STATE);
    }
    try {
      this.writeStatus = "writing";
      const options = {
        signal: this.sinkController.signal
      };
      if (this.direction === "outbound") {
        const res = this.sendNewStream(options);
        if (isPromise(res)) {
          await res;
        }
      }
      source = abortableSource(source, this.sinkController.signal, {
        returnOnAbort: true
      });
      this.log.trace("sink reading from source");
      for await (let data of source) {
        data = data instanceof Uint8Array ? new Uint8ArrayList(data) : data;
        const res = this.sendData(data, options);
        if (isPromise(res)) {
          await res;
        }
      }
      this.log.trace('sink finished reading from source, write status is "%s"', this.writeStatus);
      if (this.writeStatus === "writing") {
        this.writeStatus = "closing";
        this.log.trace("send close write to remote");
        await this.sendCloseWrite({
          signal: AbortSignal.timeout(this.sendCloseWriteTimeout)
        });
        this.writeStatus = "closed";
      }
      this.onSinkEnd();
    } catch (err) {
      this.log.trace("sink ended with error, calling abort with error", err);
      this.abort(err);
      throw err;
    } finally {
      this.log.trace("resolve sink end");
      this.sinkEnd.resolve();
    }
  }
  onSourceEnd(err) {
    var _a4;
    if (this.timeline.closeRead != null) {
      return;
    }
    this.timeline.closeRead = Date.now();
    this.readStatus = "closed";
    if (err != null && this.endErr == null) {
      this.endErr = err;
    }
    (_a4 = this.onCloseRead) == null ? void 0 : _a4.call(this);
    if (this.timeline.closeWrite != null) {
      this.log.trace("source and sink ended");
      this.timeline.close = Date.now();
      if (this.status !== "aborted" && this.status !== "reset") {
        this.status = "closed";
      }
      if (this.onEnd != null) {
        this.onEnd(this.endErr);
      }
    } else {
      this.log.trace("source ended, waiting for sink to end");
    }
  }
  onSinkEnd(err) {
    var _a4;
    if (this.timeline.closeWrite != null) {
      return;
    }
    this.timeline.closeWrite = Date.now();
    this.writeStatus = "closed";
    if (err != null && this.endErr == null) {
      this.endErr = err;
    }
    (_a4 = this.onCloseWrite) == null ? void 0 : _a4.call(this);
    if (this.timeline.closeRead != null) {
      this.log.trace("sink and source ended");
      this.timeline.close = Date.now();
      if (this.status !== "aborted" && this.status !== "reset") {
        this.status = "closed";
      }
      if (this.onEnd != null) {
        this.onEnd(this.endErr);
      }
    } else {
      this.log.trace("sink ended, waiting for source to end");
    }
  }
  // Close for both Reading and Writing
  async close(options) {
    this.log.trace("closing gracefully");
    this.status = "closing";
    await Promise.all([
      this.closeRead(options),
      this.closeWrite(options)
    ]);
    this.status = "closed";
    this.log.trace("closed gracefully");
  }
  async closeRead(options = {}) {
    if (this.readStatus === "closing" || this.readStatus === "closed") {
      return;
    }
    this.log.trace('closing readable end of stream with starting read status "%s"', this.readStatus);
    const readStatus = this.readStatus;
    this.readStatus = "closing";
    if (this.status !== "reset" && this.status !== "aborted" && this.timeline.closeRead == null) {
      this.log.trace("send close read to remote");
      await this.sendCloseRead(options);
    }
    if (readStatus === "ready") {
      this.log.trace("ending internal source queue");
      this.streamSource.end();
    }
    this.log.trace("closed readable end of stream");
  }
  async closeWrite(options = {}) {
    if (this.writeStatus === "closing" || this.writeStatus === "closed") {
      return;
    }
    this.log.trace('closing writable end of stream with starting write status "%s"', this.writeStatus);
    if (this.writeStatus === "ready") {
      this.log.trace("sink was never sunk, sink an empty array");
      await raceSignal(this.sink([]), options.signal);
    }
    if (this.writeStatus === "writing") {
      await new Promise((resolve, reject) => {
        queueMicrotask(() => {
          this.log.trace("aborting source passed to .sink");
          this.sinkController.abort();
          raceSignal(this.sinkEnd.promise, options.signal).then(resolve, reject);
        });
      });
    }
    this.writeStatus = "closed";
    this.log.trace("closed writable end of stream");
  }
  /**
   * Close immediately for reading and writing and send a reset message (local
   * error)
   */
  abort(err) {
    var _a4;
    if (this.status === "closed" || this.status === "aborted" || this.status === "reset") {
      return;
    }
    this.log("abort with error", err);
    this.log("try to send reset to remote");
    const res = this.sendReset();
    if (isPromise(res)) {
      res.catch((err2) => {
        this.log.error("error sending reset message", err2);
      });
    }
    this.status = "aborted";
    this.timeline.abort = Date.now();
    this._closeSinkAndSource(err);
    (_a4 = this.onAbort) == null ? void 0 : _a4.call(this, err);
  }
  /**
   * Receive a reset message - close immediately for reading and writing (remote
   * error)
   */
  reset() {
    var _a4;
    if (this.status === "closed" || this.status === "aborted" || this.status === "reset") {
      return;
    }
    const err = new CodeError("stream reset", ERR_STREAM_RESET);
    this.status = "reset";
    this.timeline.reset = Date.now();
    this._closeSinkAndSource(err);
    (_a4 = this.onReset) == null ? void 0 : _a4.call(this);
  }
  _closeSinkAndSource(err) {
    this._closeSink(err);
    this._closeSource(err);
  }
  _closeSink(err) {
    if (this.writeStatus === "writing") {
      this.log.trace("end sink source");
      this.sinkController.abort();
    }
    this.onSinkEnd(err);
  }
  _closeSource(err) {
    if (this.readStatus !== "closing" && this.readStatus !== "closed") {
      this.log.trace("ending source with %d bytes to be read by consumer", this.streamSource.readableLength);
      this.readStatus = "closing";
      this.streamSource.end(err);
    }
  }
  /**
   * The remote closed for writing so we should expect to receive no more
   * messages
   */
  remoteCloseWrite() {
    if (this.readStatus === "closing" || this.readStatus === "closed") {
      this.log("received remote close write but local source is already closed");
      return;
    }
    this.log.trace("remote close write");
    this._closeSource();
  }
  /**
   * The remote closed for reading so we should not send any more
   * messages
   */
  remoteCloseRead() {
    if (this.writeStatus === "closing" || this.writeStatus === "closed") {
      this.log("received remote close read but local sink is already closed");
      return;
    }
    this.log.trace("remote close read");
    this._closeSink();
  }
  /**
   * The underlying muxer has closed, no more messages can be sent or will
   * be received, close immediately to free up resources
   */
  destroy() {
    if (this.status === "closed" || this.status === "aborted" || this.status === "reset") {
      this.log("received destroy but we are already closed");
      return;
    }
    this.log.trace("stream destroyed");
    this._closeSinkAndSource();
  }
  /**
   * When an extending class reads data from it's implementation-specific source,
   * call this method to allow the stream consumer to read the data.
   */
  sourcePush(data) {
    this.streamSource.push(data);
  }
  /**
   * Returns the amount of unread data - can be used to prevent large amounts of
   * data building up when the stream consumer is too slow.
   */
  sourceReadableLength() {
    return this.streamSource.readableLength;
  }
};

// node_modules/@libp2p/mplex/dist/src/stream.js
var MplexStream = class extends AbstractStream {
  constructor(init) {
    super(init);
    __publicField(this, "name");
    __publicField(this, "streamId");
    __publicField(this, "send");
    __publicField(this, "types");
    __publicField(this, "maxDataSize");
    this.types = init.direction === "outbound" ? InitiatorMessageTypes : ReceiverMessageTypes;
    this.send = init.send;
    this.name = init.name;
    this.streamId = init.streamId;
    this.maxDataSize = init.maxDataSize;
  }
  async sendNewStream() {
    await this.send({ id: this.streamId, type: InitiatorMessageTypes.NEW_STREAM, data: new Uint8ArrayList(fromString(this.name)) });
  }
  async sendData(data) {
    data = data.sublist();
    while (data.byteLength > 0) {
      const toSend = Math.min(data.byteLength, this.maxDataSize);
      await this.send({
        id: this.streamId,
        type: this.types.MESSAGE,
        data: data.sublist(0, toSend)
      });
      data.consume(toSend);
    }
  }
  async sendReset() {
    await this.send({ id: this.streamId, type: this.types.RESET });
  }
  async sendCloseWrite() {
    await this.send({ id: this.streamId, type: this.types.CLOSE });
  }
  async sendCloseRead() {
  }
};
function createStream(options) {
  const { id, name: name2, send, onEnd, type = "initiator", maxMsgSize = MAX_MSG_SIZE } = options;
  return new MplexStream({
    id: type === "initiator" ? `i${id}` : `r${id}`,
    streamId: id,
    name: `${name2 == null ? id : name2}`,
    direction: type === "initiator" ? "outbound" : "inbound",
    maxDataSize: maxMsgSize,
    onEnd,
    send,
    log: logger(`libp2p:mplex:stream:${type}:${id}`)
  });
}

// node_modules/@libp2p/mplex/dist/src/mplex.js
var log10 = logger("libp2p:mplex");
var MAX_STREAMS_INBOUND_STREAMS_PER_CONNECTION = 1024;
var MAX_STREAMS_OUTBOUND_STREAMS_PER_CONNECTION = 1024;
var MAX_STREAM_BUFFER_SIZE = 1024 * 1024 * 4;
var DISCONNECT_THRESHOLD = 5;
var CLOSE_TIMEOUT = 500;
function printMessage(msg) {
  const output2 = {
    ...msg,
    type: `${MessageTypeNames[msg.type]} (${msg.type})`
  };
  if (msg.type === MessageTypes.NEW_STREAM) {
    output2.data = toString(msg.data instanceof Uint8Array ? msg.data : msg.data.subarray());
  }
  if (msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) {
    output2.data = toString(msg.data instanceof Uint8Array ? msg.data : msg.data.subarray(), "base16");
  }
  return output2;
}
var MplexStreamMuxer = class {
  constructor(init) {
    __publicField(this, "protocol", "/mplex/6.7.0");
    __publicField(this, "sink");
    __publicField(this, "source");
    __publicField(this, "_streamId");
    __publicField(this, "_streams");
    __publicField(this, "_init");
    __publicField(this, "_source");
    __publicField(this, "closeController");
    __publicField(this, "rateLimiter");
    __publicField(this, "closeTimeout");
    init = init ?? {};
    this._streamId = 0;
    this._streams = {
      /**
       * Stream to ids map
       */
      initiators: /* @__PURE__ */ new Map(),
      /**
       * Stream to ids map
       */
      receivers: /* @__PURE__ */ new Map()
    };
    this._init = init;
    this.closeTimeout = init.closeTimeout ?? CLOSE_TIMEOUT;
    this.sink = this._createSink();
    this._source = pushableV({
      objectMode: true,
      onEnd: () => {
        for (const stream of this._streams.initiators.values()) {
          stream.destroy();
        }
        for (const stream of this._streams.receivers.values()) {
          stream.destroy();
        }
      }
    });
    this.source = pipe(this._source, (source) => encode6(source, this._init.minSendBytes));
    this.closeController = new AbortController();
    this.rateLimiter = new import_rate_limiter_flexible.RateLimiterMemory({
      points: init.disconnectThreshold ?? DISCONNECT_THRESHOLD,
      duration: 1
    });
  }
  /**
   * Returns a Map of streams and their ids
   */
  get streams() {
    const streams = [];
    for (const stream of this._streams.initiators.values()) {
      streams.push(stream);
    }
    for (const stream of this._streams.receivers.values()) {
      streams.push(stream);
    }
    return streams;
  }
  /**
   * Initiate a new stream with the given name. If no name is
   * provided, the id of the stream will be used.
   */
  newStream(name2) {
    if (this.closeController.signal.aborted) {
      throw new Error("Muxer already closed");
    }
    const id = this._streamId++;
    name2 = name2 == null ? id.toString() : name2.toString();
    const registry = this._streams.initiators;
    return this._newStream({ id, name: name2, type: "initiator", registry });
  }
  /**
   * Close or abort all tracked streams and stop the muxer
   */
  async close(options) {
    if (this.closeController.signal.aborted) {
      return;
    }
    const signal = (options == null ? void 0 : options.signal) ?? AbortSignal.timeout(this.closeTimeout);
    try {
      await Promise.all(this.streams.map(async (s) => s.close({
        signal
      })));
      this._source.end();
      await this._source.onEmpty({
        signal
      });
      this.closeController.abort();
    } catch (err) {
      this.abort(err);
    }
  }
  abort(err) {
    if (this.closeController.signal.aborted) {
      return;
    }
    this.streams.forEach((s) => {
      s.abort(err);
    });
    this.closeController.abort(err);
  }
  /**
   * Called whenever an inbound stream is created
   */
  _newReceiverStream(options) {
    const { id, name: name2 } = options;
    const registry = this._streams.receivers;
    return this._newStream({ id, name: name2, type: "receiver", registry });
  }
  _newStream(options) {
    const { id, name: name2, type, registry } = options;
    log10("new %s stream %s", type, id);
    if (type === "initiator" && this._streams.initiators.size === (this._init.maxOutboundStreams ?? MAX_STREAMS_OUTBOUND_STREAMS_PER_CONNECTION)) {
      throw new CodeError("Too many outbound streams open", "ERR_TOO_MANY_OUTBOUND_STREAMS");
    }
    if (registry.has(id)) {
      throw new Error(`${type} stream ${id} already exists!`);
    }
    const send = async (msg) => {
      if (log10.enabled) {
        log10.trace("%s stream %s send", type, id, printMessage(msg));
      }
      this._source.push(msg);
    };
    const onEnd = () => {
      log10("%s stream with id %s and protocol %s ended", type, id, stream.protocol);
      registry.delete(id);
      if (this._init.onStreamEnd != null) {
        this._init.onStreamEnd(stream);
      }
    };
    const stream = createStream({ id, name: name2, send, type, onEnd, maxMsgSize: this._init.maxMsgSize });
    registry.set(id, stream);
    return stream;
  }
  /**
   * Creates a sink with an abortable source. Incoming messages will
   * also have their size restricted. All messages will be varint decoded.
   */
  _createSink() {
    const sink = async (source) => {
      try {
        source = abortableSource(source, this.closeController.signal, {
          returnOnAbort: true
        });
        const decoder = new Decoder3(this._init.maxMsgSize, this._init.maxUnprocessedMessageQueueSize);
        for await (const chunk of source) {
          for (const msg of decoder.write(chunk)) {
            await this._handleIncoming(msg);
          }
        }
        this._source.end();
      } catch (err) {
        log10("error in sink", err);
        this._source.end(err);
      }
    };
    return sink;
  }
  async _handleIncoming(message2) {
    const { id, type } = message2;
    if (log10.enabled) {
      log10.trace("incoming message", printMessage(message2));
    }
    if (message2.type === MessageTypes.NEW_STREAM) {
      if (this._streams.receivers.size === (this._init.maxInboundStreams ?? MAX_STREAMS_INBOUND_STREAMS_PER_CONNECTION)) {
        log10("too many inbound streams open");
        this._source.push({
          id,
          type: MessageTypes.RESET_RECEIVER
        });
        try {
          await this.rateLimiter.consume("new-stream", 1);
        } catch {
          log10("rate limit hit when opening too many new streams over the inbound stream limit - closing remote connection");
          this.abort(new Error("Too many open streams"));
          return;
        }
        return;
      }
      const stream2 = this._newReceiverStream({ id, name: toString(message2.data instanceof Uint8Array ? message2.data : message2.data.subarray()) });
      if (this._init.onIncomingStream != null) {
        this._init.onIncomingStream(stream2);
      }
      return;
    }
    const list = (type & 1) === 1 ? this._streams.initiators : this._streams.receivers;
    const stream = list.get(id);
    if (stream == null) {
      log10("missing stream %s for message type %s", id, MessageTypeNames[type]);
      try {
        await this.rateLimiter.consume("missing-stream", 1);
      } catch {
        log10("rate limit hit when receiving messages for streams that do not exist - closing remote connection");
        this.abort(new Error("Too many messages for missing streams"));
        return;
      }
      return;
    }
    const maxBufferSize = this._init.maxStreamBufferSize ?? MAX_STREAM_BUFFER_SIZE;
    try {
      switch (type) {
        case MessageTypes.MESSAGE_INITIATOR:
        case MessageTypes.MESSAGE_RECEIVER:
          if (stream.sourceReadableLength() > maxBufferSize) {
            this._source.push({
              id: message2.id,
              type: type === MessageTypes.MESSAGE_INITIATOR ? MessageTypes.RESET_RECEIVER : MessageTypes.RESET_INITIATOR
            });
            throw new CodeError("Input buffer full - increase Mplex maxBufferSize to accommodate slow consumers", "ERR_STREAM_INPUT_BUFFER_FULL");
          }
          stream.sourcePush(message2.data);
          break;
        case MessageTypes.CLOSE_INITIATOR:
        case MessageTypes.CLOSE_RECEIVER:
          stream.remoteCloseWrite();
          break;
        case MessageTypes.RESET_INITIATOR:
        case MessageTypes.RESET_RECEIVER:
          stream.reset();
          break;
        default:
          log10("unknown message type %s", type);
      }
    } catch (err) {
      log10.error("error while processing message", err);
      stream.abort(err);
    }
  }
};

// node_modules/@libp2p/mplex/dist/src/index.js
var Mplex = class {
  constructor(init = {}) {
    __publicField(this, "protocol", "/mplex/6.7.0");
    __publicField(this, "_init");
    this._init = init;
  }
  createStreamMuxer(init = {}) {
    return new MplexStreamMuxer({
      ...init,
      ...this._init
    });
  }
};
function mplex(init = {}) {
  return () => new Mplex(init);
}

// node_modules/@libp2p/interface/dist/src/transport/index.js
var symbol2 = Symbol.for("@libp2p/transport");
var FaultTolerance;
(function(FaultTolerance2) {
  FaultTolerance2[FaultTolerance2["FATAL_ALL"] = 0] = "FATAL_ALL";
  FaultTolerance2[FaultTolerance2["NO_FATAL"] = 1] = "NO_FATAL";
})(FaultTolerance || (FaultTolerance = {}));

// node_modules/@multiformats/multiaddr-to-uri/dist/src/index.js
function extractSNI(ma) {
  let sniProtoCode;
  try {
    sniProtoCode = getProtocol("sni").code;
  } catch (e) {
    return null;
  }
  for (const [proto, value] of ma) {
    if (proto === sniProtoCode && value !== void 0) {
      return value;
    }
  }
  return null;
}
function hasTLS(ma) {
  return ma.some(([proto, _]) => proto === getProtocol("tls").code);
}
function interpretNext(headProtoCode, headProtoVal, restMa) {
  const interpreter = interpreters[getProtocol(headProtoCode).name];
  if (interpreter === void 0) {
    throw new Error(`Can't interpret protocol ${getProtocol(headProtoCode).name}`);
  }
  const restVal = interpreter(headProtoVal, restMa);
  if (headProtoCode === getProtocol("ip6").code) {
    return `[${restVal}]`;
  }
  return restVal;
}
var interpreters = {
  ip4: (value, restMa) => value,
  ip6: (value, restMa) => {
    if (restMa.length === 0) {
      return value;
    }
    return `[${value}]`;
  },
  tcp: (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `tcp://${interpretNext(tailProto[0], tailProto[1] ?? "", restMa)}:${value}`;
  },
  udp: (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `udp://${interpretNext(tailProto[0], tailProto[1] ?? "", restMa)}:${value}`;
  },
  dnsaddr: (value, restMa) => value,
  dns4: (value, restMa) => value,
  dns6: (value, restMa) => value,
  dns: (value, restMa) => value,
  ipfs: (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `${interpretNext(tailProto[0], tailProto[1] ?? "", restMa)}/ipfs/${value}`;
  },
  p2p: (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `${interpretNext(tailProto[0], tailProto[1] ?? "", restMa)}/p2p/${value}`;
  },
  http: (value, restMa) => {
    const maHasTLS = hasTLS(restMa);
    const sni = extractSNI(restMa);
    if (maHasTLS && sni !== null) {
      return `https://${sni}`;
    }
    const protocol = maHasTLS ? "https://" : "http://";
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    let baseVal = interpretNext(tailProto[0], tailProto[1] ?? "", restMa);
    baseVal = baseVal.replace("tcp://", "");
    return `${protocol}${baseVal}`;
  },
  tls: (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return interpretNext(tailProto[0], tailProto[1] ?? "", restMa);
  },
  sni: (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return interpretNext(tailProto[0], tailProto[1] ?? "", restMa);
  },
  https: (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    let baseVal = interpretNext(tailProto[0], tailProto[1] ?? "", restMa);
    baseVal = baseVal.replace("tcp://", "");
    return `https://${baseVal}`;
  },
  ws: (value, restMa) => {
    const maHasTLS = hasTLS(restMa);
    const sni = extractSNI(restMa);
    if (maHasTLS && sni !== null) {
      return `wss://${sni}`;
    }
    const protocol = maHasTLS ? "wss://" : "ws://";
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    let baseVal = interpretNext(tailProto[0], tailProto[1] ?? "", restMa);
    baseVal = baseVal.replace("tcp://", "");
    return `${protocol}${baseVal}`;
  },
  wss: (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    let baseVal = interpretNext(tailProto[0], tailProto[1] ?? "", restMa);
    baseVal = baseVal.replace("tcp://", "");
    return `wss://${baseVal}`;
  },
  "p2p-websocket-star": (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `${interpretNext(tailProto[0], tailProto[1] ?? "", restMa)}/p2p-websocket-star`;
  },
  "p2p-webrtc-star": (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `${interpretNext(tailProto[0], tailProto[1] ?? "", restMa)}/p2p-webrtc-star`;
  },
  "p2p-webrtc-direct": (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `${interpretNext(tailProto[0], tailProto[1] ?? "", restMa)}/p2p-webrtc-direct`;
  }
};
function multiaddrToUri(input, opts) {
  const ma = multiaddr(input);
  const parts = ma.stringTuples();
  const head = parts.pop();
  if (head === void 0) {
    throw new Error("Unexpected end of multiaddr");
  }
  const protocol = getProtocol(head[0]);
  const interpreter = interpreters[protocol.name];
  if (interpreter == null) {
    throw new Error(`No interpreter found for ${protocol.name}`);
  }
  let uri = interpreter(head[1] ?? "", parts);
  if ((opts == null ? void 0 : opts.assumeHttp) !== false && head[0] === getProtocol("tcp").code) {
    uri = uri.replace("tcp://", "http://");
    if (head[1] === "443" || head[1] === "80") {
      if (head[1] === "443") {
        uri = uri.replace("http://", "https://");
      }
      uri = uri.substring(0, uri.lastIndexOf(":"));
    }
  }
  return uri;
}

// node_modules/it-ws/dist/src/ready.js
var ready_default = async (socket) => {
  if (socket.readyState >= 2) {
    throw new Error("socket closed");
  }
  if (socket.readyState === 1) {
    return;
  }
  await new Promise((resolve, reject) => {
    function cleanup() {
      socket.removeEventListener("open", handleOpen);
      socket.removeEventListener("error", handleErr);
    }
    function handleOpen() {
      cleanup();
      resolve();
    }
    function handleErr(event) {
      cleanup();
      reject(event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`));
    }
    socket.addEventListener("open", handleOpen);
    socket.addEventListener("error", handleErr);
  });
};

// node_modules/it-ws/dist/src/sink.js
var sink_default = (socket, options) => {
  options = options ?? {};
  options.closeOnEnd = options.closeOnEnd !== false;
  const sink = async (source) => {
    for await (const data of source) {
      try {
        await ready_default(socket);
      } catch (err) {
        if (err.message === "socket closed")
          break;
        throw err;
      }
      if (socket.readyState === socket.CLOSING || socket.readyState === socket.CLOSED) {
        break;
      }
      socket.send(data);
    }
    if (options.closeOnEnd != null && socket.readyState <= 1) {
      await new Promise((resolve, reject) => {
        socket.addEventListener("close", (event) => {
          if (event.wasClean || event.code === 1006) {
            resolve();
          } else {
            const err = Object.assign(new Error("ws error"), { event });
            reject(err);
          }
        });
        setTimeout(() => {
          socket.close();
        });
      });
    }
  };
  return sink;
};

// node_modules/it-ws/dist/src/source.js
var import_event_iterator = __toESM(require_dom(), 1);
function isArrayBuffer(obj) {
  var _a4;
  return obj instanceof ArrayBuffer || ((_a4 = obj == null ? void 0 : obj.constructor) == null ? void 0 : _a4.name) === "ArrayBuffer" && typeof (obj == null ? void 0 : obj.byteLength) === "number";
}
var source_default = (socket) => {
  socket.binaryType = "arraybuffer";
  const connected = async () => {
    await new Promise((resolve, reject) => {
      if (isConnected) {
        resolve();
        return;
      }
      if (connError != null) {
        reject(connError);
        return;
      }
      const cleanUp = (cont) => {
        socket.removeEventListener("open", onOpen);
        socket.removeEventListener("error", onError);
        cont();
      };
      const onOpen = () => {
        cleanUp(resolve);
      };
      const onError = (event) => {
        cleanUp(() => {
          reject(event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`));
        });
      };
      socket.addEventListener("open", onOpen);
      socket.addEventListener("error", onError);
    });
  };
  const source = async function* () {
    const messages2 = new import_event_iterator.EventIterator(({ push, stop, fail }) => {
      const onMessage = (event) => {
        let data = null;
        if (typeof event.data === "string") {
          data = fromString(event.data);
        }
        if (isArrayBuffer(event.data)) {
          data = new Uint8Array(event.data);
        }
        if (event.data instanceof Uint8Array) {
          data = event.data;
        }
        if (data == null) {
          return;
        }
        push(data);
      };
      const onError = (event) => {
        fail(event.error ?? new Error("Socket error"));
      };
      socket.addEventListener("message", onMessage);
      socket.addEventListener("error", onError);
      socket.addEventListener("close", stop);
      return () => {
        socket.removeEventListener("message", onMessage);
        socket.removeEventListener("error", onError);
        socket.removeEventListener("close", stop);
      };
    }, { highWaterMark: Infinity });
    await connected();
    for await (const chunk of messages2) {
      yield isArrayBuffer(chunk) ? new Uint8Array(chunk) : chunk;
    }
  }();
  let isConnected = socket.readyState === 1;
  let connError;
  socket.addEventListener("open", () => {
    isConnected = true;
    connError = null;
  });
  socket.addEventListener("close", () => {
    isConnected = false;
    connError = null;
  });
  socket.addEventListener("error", (event) => {
    if (!isConnected) {
      connError = event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`);
    }
  });
  return Object.assign(source, {
    connected
  });
};

// node_modules/it-ws/dist/src/duplex.js
var duplex_default = (socket, options) => {
  options = options ?? {};
  const connectedSource = source_default(socket);
  let remoteAddress = options.remoteAddress;
  let remotePort = options.remotePort;
  if (socket.url != null) {
    try {
      const url = new URL(socket.url);
      remoteAddress = url.hostname;
      remotePort = parseInt(url.port, 10);
    } catch {
    }
  }
  if (remoteAddress == null || remotePort == null) {
    throw new Error("Remote connection did not have address and/or port");
  }
  const duplex = {
    sink: sink_default(socket, options),
    source: connectedSource,
    connected: async () => {
      await connectedSource.connected();
    },
    close: async () => {
      if (socket.readyState === socket.CONNECTING || socket.readyState === socket.OPEN) {
        await new Promise((resolve) => {
          socket.addEventListener("close", () => {
            resolve();
          });
          socket.close();
        });
      }
    },
    destroy: () => {
      if (socket.terminate != null) {
        socket.terminate();
      } else {
        socket.close();
      }
    },
    remoteAddress,
    remotePort,
    socket
  };
  return duplex;
};

// node_modules/it-ws/dist/src/web-socket.browser.js
var web_socket_browser_default = WebSocket;

// node_modules/it-ws/dist/src/ws-url.js
var import_iso_url = __toESM(require_iso_url(), 1);
var map = { http: "ws", https: "wss" };
var def = "ws";
var ws_url_default = (url, location) => (0, import_iso_url.relative)(url, location, map, def);

// node_modules/it-ws/dist/src/client.js
function connect(addr, opts) {
  const location = typeof window === "undefined" ? "" : window.location;
  opts = opts ?? {};
  const url = ws_url_default(addr, location.toString());
  const socket = new web_socket_browser_default(url, opts.websocket);
  return duplex_default(socket, opts);
}

// node_modules/wherearewe/src/index.js
var import_is_electron = __toESM(require_is_electron());
var isEnvWithDom = typeof window === "object" && typeof document === "object" && document.nodeType === 9;
var isElectron = (0, import_is_electron.default)();
var isBrowser = isEnvWithDom && !isElectron;
var isElectronMain = isElectron && !isEnvWithDom;
var isElectronRenderer = isElectron && isEnvWithDom;
var isNode = typeof globalThis.process !== "undefined" && typeof globalThis.process.release !== "undefined" && globalThis.process.release.name === "node" && !isElectron;
var isWebWorker = typeof importScripts === "function" && typeof self !== "undefined" && typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;
var isTest = typeof globalThis.process !== "undefined" && typeof globalThis.process.env !== "undefined" && globalThis.process.env["NODE" + (() => "_")() + "ENV"] === "test";
var isReactNative = typeof navigator !== "undefined" && navigator.product === "ReactNative";

// node_modules/@libp2p/websockets/dist/src/constants.js
var CODE_P2P = 421;
var CODE_CIRCUIT = 290;
var CLOSE_TIMEOUT2 = 500;

// node_modules/@libp2p/websockets/dist/src/filters.js
function all2(multiaddrs) {
  return multiaddrs.filter((ma) => {
    if (ma.protoCodes().includes(CODE_CIRCUIT)) {
      return false;
    }
    const testMa = ma.decapsulateCode(CODE_P2P);
    return WebSockets.matches(testMa) || WebSocketsSecure.matches(testMa);
  });
}
function wss(multiaddrs) {
  return multiaddrs.filter((ma) => {
    if (ma.protoCodes().includes(CODE_CIRCUIT)) {
      return false;
    }
    const testMa = ma.decapsulateCode(CODE_P2P);
    return WebSocketsSecure.matches(testMa);
  });
}

// node_modules/@libp2p/websockets/dist/src/listener.browser.js
function createListener() {
  throw new Error("WebSocket Servers can not be created in the browser!");
}

// node_modules/@libp2p/websockets/dist/src/socket-to-conn.js
var log11 = logger("libp2p:websockets:socket");
function socketToMaConn(stream, remoteAddr, options) {
  options = options ?? {};
  const maConn = {
    async sink(source) {
      if ((options == null ? void 0 : options.signal) != null) {
        source = abortableSource(source, options.signal);
      }
      try {
        await stream.sink(source);
      } catch (err) {
        if (err.type !== "aborted") {
          log11.error(err);
        }
      }
    },
    source: options.signal != null ? abortableSource(stream.source, options.signal) : stream.source,
    remoteAddr,
    timeline: { open: Date.now() },
    async close(options2 = {}) {
      var _a4, _b4;
      const start = Date.now();
      if (options2.signal == null) {
        const signal = AbortSignal.timeout(CLOSE_TIMEOUT2);
        options2 = {
          ...options2,
          signal
        };
      }
      const listener = () => {
        const { host, port } = maConn.remoteAddr.toOptions();
        log11("timeout closing stream to %s:%s after %dms, destroying it manually", host, port, Date.now() - start);
        this.abort(new CodeError("Socket close timeout", "ERR_SOCKET_CLOSE_TIMEOUT"));
      };
      (_a4 = options2.signal) == null ? void 0 : _a4.addEventListener("abort", listener);
      try {
        await stream.close();
      } catch (err) {
        log11.error("error closing WebSocket gracefully", err);
        this.abort(err);
      } finally {
        (_b4 = options2.signal) == null ? void 0 : _b4.removeEventListener("abort", listener);
        maConn.timeline.close = Date.now();
      }
    },
    abort(err) {
      const { host, port } = maConn.remoteAddr.toOptions();
      log11("timeout closing stream to %s:%s due to error", host, port, err);
      stream.destroy();
      maConn.timeline.close = Date.now();
    }
  };
  stream.socket.addEventListener("close", () => {
    if (maConn.timeline.close == null) {
      maConn.timeline.close = Date.now();
    }
  }, { once: true });
  return maConn;
}

// node_modules/@libp2p/websockets/dist/src/index.js
var log12 = logger("libp2p:websockets");
var _a2, _b2;
var WebSockets2 = class {
  constructor(init) {
    __publicField(this, "init");
    __publicField(this, _a2, "@libp2p/websockets");
    __publicField(this, _b2, true);
    this.init = init;
  }
  async dial(ma, options) {
    log12("dialing %s", ma);
    options = options ?? {};
    const socket = await this._connect(ma, options);
    const maConn = socketToMaConn(socket, ma);
    log12("new outbound connection %s", maConn.remoteAddr);
    const conn = await options.upgrader.upgradeOutbound(maConn);
    log12("outbound connection %s upgraded", maConn.remoteAddr);
    return conn;
  }
  async _connect(ma, options) {
    var _a4, _b4;
    if (((_a4 = options == null ? void 0 : options.signal) == null ? void 0 : _a4.aborted) === true) {
      throw new AbortError();
    }
    const cOpts = ma.toOptions();
    log12("dialing %s:%s", cOpts.host, cOpts.port);
    const errorPromise = pDefer();
    const rawSocket = connect(multiaddrToUri(ma), this.init);
    rawSocket.socket.addEventListener("error", () => {
      const err = new CodeError(`Could not connect to ${ma.toString()}`, "ERR_CONNECTION_FAILED");
      log12.error("connection error:", err);
      errorPromise.reject(err);
    });
    if (options.signal == null) {
      await Promise.race([rawSocket.connected(), errorPromise.promise]);
      log12("connected %s", ma);
      return rawSocket;
    }
    let onAbort;
    const abort = new Promise((resolve, reject) => {
      var _a5, _b5;
      onAbort = () => {
        reject(new AbortError());
        rawSocket.close().catch((err) => {
          log12.error("error closing raw socket", err);
        });
      };
      if (((_a5 = options == null ? void 0 : options.signal) == null ? void 0 : _a5.aborted) === true) {
        onAbort();
        return;
      }
      (_b5 = options == null ? void 0 : options.signal) == null ? void 0 : _b5.addEventListener("abort", onAbort);
    });
    try {
      await Promise.race([abort, errorPromise.promise, rawSocket.connected()]);
    } finally {
      if (onAbort != null) {
        (_b4 = options == null ? void 0 : options.signal) == null ? void 0 : _b4.removeEventListener("abort", onAbort);
      }
    }
    log12("connected %s", ma);
    return rawSocket;
  }
  /**
   * Creates a Websockets listener. The provided `handler` function will be called
   * anytime a new incoming Connection has been successfully upgraded via
   * `upgrader.upgradeInbound`
   */
  createListener(options) {
    return createListener({ ...this.init, ...options });
  }
  /**
   * Takes a list of `Multiaddr`s and returns only valid Websockets addresses.
   * By default, in a browser environment only DNS+WSS multiaddr is accepted,
   * while in a Node.js environment DNS+{WS, WSS} multiaddrs are accepted.
   */
  filter(multiaddrs) {
    var _a4, _b4;
    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];
    if (((_a4 = this.init) == null ? void 0 : _a4.filter) != null) {
      return (_b4 = this.init) == null ? void 0 : _b4.filter(multiaddrs);
    }
    if (isBrowser || isWebWorker) {
      return wss(multiaddrs);
    }
    return all2(multiaddrs);
  }
};
_a2 = Symbol.toStringTag, _b2 = symbol2;
function webSockets(init = {}) {
  return () => {
    return new WebSockets2(init);
  };
}

// node_modules/@waku/peer-exchange/dist/rpc.js
var PeerExchangeRPC2 = class _PeerExchangeRPC {
  constructor(proto) {
    __publicField(this, "proto");
    this.proto = proto;
  }
  static createRequest(params) {
    const { numPeers } = params;
    return new _PeerExchangeRPC({
      query: {
        numPeers
      },
      response: void 0
    });
  }
  /**
   * Encode the current PeerExchangeRPC request to bytes
   * @returns Uint8Array
   */
  encode() {
    return peer_exchange_exports.PeerExchangeRPC.encode(this.proto);
  }
  /**
   * Decode the current PeerExchangeRPC request to bytes
   * @returns Uint8Array
   */
  static decode(bytes2) {
    const res = peer_exchange_exports.PeerExchangeRPC.decode(bytes2);
    return new _PeerExchangeRPC(res);
  }
  get query() {
    return this.proto.query;
  }
  get response() {
    return this.proto.response;
  }
};

// node_modules/@waku/peer-exchange/dist/waku_peer_exchange.js
var PeerExchangeCodec = "/vac/waku/peer-exchange/2.0.0-alpha1";
var log13 = new Logger("peer-exchange");
var WakuPeerExchange = class extends BaseProtocol {
  /**
   * @param components - libp2p components
   */
  constructor(components) {
    super(PeerExchangeCodec, components);
  }
  /**
   * Make a peer exchange query to a peer
   */
  async query(params) {
    const { numPeers } = params;
    const rpcQuery = PeerExchangeRPC2.createRequest({
      numPeers: BigInt(numPeers)
    });
    const peer = await this.getPeer(params.peerId);
    const stream = await this.getStream(peer);
    const res = await pipe([rpcQuery.encode()], encode2, stream, decode2, async (source) => await src_default(source));
    try {
      const bytes2 = new Uint8ArrayList();
      res.forEach((chunk) => {
        bytes2.append(chunk);
      });
      const { response } = PeerExchangeRPC2.decode(bytes2);
      if (!response) {
        log13.error("PeerExchangeRPC message did not contains a `response` field");
        return;
      }
      return Promise.all(response.peerInfos.map((peerInfo) => peerInfo.enr).filter(isDefined).map(async (enr) => {
        return { ENR: await EnrDecoder.fromRLP(enr) };
      }));
    } catch (err) {
      log13.error("Failed to decode push reply", err);
      return;
    }
  }
};

// node_modules/@waku/peer-exchange/dist/waku_peer_exchange_discovery.js
var log14 = new Logger("peer-exchange-discovery");
var DEFAULT_PEER_EXCHANGE_REQUEST_NODES = 10;
var DEFAULT_PEER_EXCHANGE_QUERY_INTERVAL_MS = 10 * 1e3;
var DEFAULT_MAX_RETRIES = 3;
var DEFAULT_PEER_EXCHANGE_TAG_NAME = Tags.PEER_EXCHANGE;
var DEFAULT_PEER_EXCHANGE_TAG_VALUE = 50;
var DEFAULT_PEER_EXCHANGE_TAG_TTL = 1e8;
var PeerExchangeDiscovery = class extends TypedEventEmitter {
  constructor(components, options = {}) {
    super();
    __publicField(this, "components");
    __publicField(this, "peerExchange");
    __publicField(this, "options");
    __publicField(this, "isStarted");
    __publicField(this, "queryingPeers", /* @__PURE__ */ new Set());
    __publicField(this, "queryAttempts", /* @__PURE__ */ new Map());
    __publicField(this, "handleDiscoveredPeer", (event) => {
      const { protocols, peerId: peerId2 } = event.detail;
      if (!protocols.includes(PeerExchangeCodec) || this.queryingPeers.has(peerId2.toString()))
        return;
      this.queryingPeers.add(peerId2.toString());
      this.startRecurringQueries(peerId2).catch((error) => log14.error(`Error querying peer ${error}`));
    });
    __publicField(this, "startRecurringQueries", async (peerId2) => {
      const peerIdStr = peerId2.toString();
      const { queryInterval = DEFAULT_PEER_EXCHANGE_QUERY_INTERVAL_MS, maxRetries = DEFAULT_MAX_RETRIES } = this.options;
      log14.info(`Querying peer: ${peerIdStr} (attempt ${this.queryAttempts.get(peerIdStr) ?? 1})`);
      await this.query(peerId2);
      const currentAttempt = this.queryAttempts.get(peerIdStr) ?? 1;
      if (currentAttempt > maxRetries) {
        this.abortQueriesForPeer(peerIdStr);
        return;
      }
      setTimeout(() => {
        this.queryAttempts.set(peerIdStr, currentAttempt + 1);
        this.startRecurringQueries(peerId2).catch((error) => {
          log14.error(`Error in startRecurringQueries: ${error}`);
        });
      }, queryInterval * currentAttempt);
    });
    this.components = components;
    this.peerExchange = new WakuPeerExchange(components);
    this.options = options;
    this.isStarted = false;
  }
  /**
   * Start emitting events
   */
  start() {
    if (this.isStarted) {
      return;
    }
    log14.info("Starting peer exchange node discovery, discovering peers");
    this.components.events.addEventListener("peer:identify", this.handleDiscoveredPeer);
  }
  /**
   * Remove event listener
   */
  stop() {
    if (!this.isStarted)
      return;
    log14.info("Stopping peer exchange node discovery");
    this.isStarted = false;
    this.queryingPeers.clear();
    this.components.events.removeEventListener("peer:identify", this.handleDiscoveredPeer);
  }
  get [peerDiscovery]() {
    return true;
  }
  get [Symbol.toStringTag]() {
    return "@waku/peer-exchange";
  }
  async query(peerId2) {
    const peerInfos = await this.peerExchange.query({
      numPeers: DEFAULT_PEER_EXCHANGE_REQUEST_NODES,
      peerId: peerId2
    });
    if (!peerInfos) {
      log14.error("Peer exchange query failed, no peer info returned");
      return;
    }
    for (const _peerInfo of peerInfos) {
      const { ENR } = _peerInfo;
      if (!ENR) {
        log14.warn("No ENR in peerInfo object, skipping");
        continue;
      }
      const { peerId: peerId3, peerInfo, shardInfo } = ENR;
      if (!peerId3 || !peerInfo) {
        continue;
      }
      const hasPeer = await this.components.peerStore.has(peerId3);
      if (hasPeer) {
        continue;
      }
      await this.components.peerStore.save(peerId3, {
        tags: {
          [DEFAULT_PEER_EXCHANGE_TAG_NAME]: {
            value: this.options.tagValue ?? DEFAULT_PEER_EXCHANGE_TAG_VALUE,
            ttl: this.options.tagTTL ?? DEFAULT_PEER_EXCHANGE_TAG_TTL
          }
        },
        ...shardInfo && {
          metadata: {
            shardInfo: encodeRelayShard(shardInfo)
          }
        }
      });
      log14.info(`Discovered peer: ${peerId3.toString()}`);
      this.dispatchEvent(new CustomEvent("peer", {
        detail: {
          id: peerId3,
          protocols: [],
          multiaddrs: peerInfo.multiaddrs
        }
      }));
    }
  }
  abortQueriesForPeer(peerIdStr) {
    log14.info(`Aborting queries for peer: ${peerIdStr}`);
    this.queryingPeers.delete(peerIdStr);
    this.queryAttempts.delete(peerIdStr);
  }
};
function wakuPeerExchangeDiscovery() {
  return (components) => new PeerExchangeDiscovery(components);
}

// node_modules/@waku/relay/dist/index.js
var dist_exports3 = {};
__export(dist_exports3, {
  wakuGossipSub: () => wakuGossipSub,
  wakuRelay: () => wakuRelay
});

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/message-cache.js
var MessageCache = class {
  /**
   * Holds history of messages in timebounded history arrays
   */
  constructor(gossip, historyCapacity, msgIdToStrFn) {
    __publicField(this, "gossip");
    __publicField(this, "msgs", /* @__PURE__ */ new Map());
    __publicField(this, "msgIdToStrFn");
    __publicField(this, "history", []);
    /** Track with accounting of messages in the mcache that are not yet validated */
    __publicField(this, "notValidatedCount", 0);
    this.gossip = gossip;
    this.msgIdToStrFn = msgIdToStrFn;
    for (let i = 0; i < historyCapacity; i++) {
      this.history[i] = [];
    }
  }
  get size() {
    return this.msgs.size;
  }
  /**
   * Adds a message to the current window and the cache
   * Returns true if the message is not known and is inserted in the cache
   */
  put(messageId, msg, validated = false) {
    const { msgIdStr } = messageId;
    if (this.msgs.has(msgIdStr)) {
      return false;
    }
    this.msgs.set(msgIdStr, {
      message: msg,
      validated,
      originatingPeers: /* @__PURE__ */ new Set(),
      iwantCounts: /* @__PURE__ */ new Map()
    });
    this.history[0].push({ ...messageId, topic: msg.topic });
    if (!validated) {
      this.notValidatedCount++;
    }
    return true;
  }
  observeDuplicate(msgId2, fromPeerIdStr) {
    const entry = this.msgs.get(msgId2);
    if (entry && // if the message is already validated, we don't need to store extra peers sending us
    // duplicates as the message has already been forwarded
    !entry.validated) {
      entry.originatingPeers.add(fromPeerIdStr);
    }
  }
  /**
   * Retrieves a message from the cache by its ID, if it is still present
   */
  get(msgId2) {
    var _a4;
    return (_a4 = this.msgs.get(this.msgIdToStrFn(msgId2))) == null ? void 0 : _a4.message;
  }
  /**
   * Increases the iwant count for the given message by one and returns the message together
   * with the iwant if the message exists.
   */
  getWithIWantCount(msgIdStr, p) {
    const msg = this.msgs.get(msgIdStr);
    if (!msg) {
      return null;
    }
    const count = (msg.iwantCounts.get(p) ?? 0) + 1;
    msg.iwantCounts.set(p, count);
    return { msg: msg.message, count };
  }
  /**
   * Retrieves a list of message IDs for a set of topics
   */
  getGossipIDs(topics) {
    const msgIdsByTopic = /* @__PURE__ */ new Map();
    for (let i = 0; i < this.gossip; i++) {
      this.history[i].forEach((entry) => {
        const msg = this.msgs.get(entry.msgIdStr);
        if (msg && msg.validated && topics.has(entry.topic)) {
          let msgIds = msgIdsByTopic.get(entry.topic);
          if (!msgIds) {
            msgIds = [];
            msgIdsByTopic.set(entry.topic, msgIds);
          }
          msgIds.push(entry.msgId);
        }
      });
    }
    return msgIdsByTopic;
  }
  /**
   * Gets a message with msgId and tags it as validated.
   * This function also returns the known peers that have sent us this message. This is used to
   * prevent us sending redundant messages to peers who have already propagated it.
   */
  validate(msgId2) {
    const entry = this.msgs.get(msgId2);
    if (!entry) {
      return null;
    }
    if (!entry.validated) {
      this.notValidatedCount--;
    }
    const { message: message2, originatingPeers } = entry;
    entry.validated = true;
    entry.originatingPeers = /* @__PURE__ */ new Set();
    return { message: message2, originatingPeers };
  }
  /**
   * Shifts the current window, discarding messages older than this.history.length of the cache
   */
  shift() {
    const lastCacheEntries = this.history[this.history.length - 1];
    lastCacheEntries.forEach((cacheEntry) => {
      const entry = this.msgs.get(cacheEntry.msgIdStr);
      if (entry) {
        this.msgs.delete(cacheEntry.msgIdStr);
        if (!entry.validated) {
          this.notValidatedCount--;
        }
      }
    });
    this.history.pop();
    this.history.unshift([]);
  }
  remove(msgId2) {
    const entry = this.msgs.get(msgId2);
    if (!entry) {
      return null;
    }
    this.msgs.delete(msgId2);
    return entry;
  }
};

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/message/rpc.js
var import_rpc2 = __toESM(require_rpc(), 1);
var { RPC } = import_rpc2.default;

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/constants.js
var second = 1e3;
var minute = 60 * second;
var FloodsubID = "/floodsub/1.0.0";
var GossipsubIDv10 = "/meshsub/1.0.0";
var GossipsubIDv11 = "/meshsub/1.1.0";
var GossipsubD = 6;
var GossipsubDlo = 4;
var GossipsubDhi = 12;
var GossipsubDscore = 4;
var GossipsubDout = 2;
var GossipsubHistoryLength = 5;
var GossipsubHistoryGossip = 3;
var GossipsubDlazy = 6;
var GossipsubGossipFactor = 0.25;
var GossipsubGossipRetransmission = 3;
var GossipsubHeartbeatInitialDelay = 100;
var GossipsubHeartbeatInterval = second;
var GossipsubFanoutTTL = minute;
var GossipsubPrunePeers = 16;
var GossipsubPruneBackoff = minute;
var GossipsubUnsubscribeBackoff = 10 * second;
var GossipsubPruneBackoffTicks = 15;
var GossipsubConnectionTimeout = 30 * second;
var GossipsubDirectConnectTicks = 300;
var GossipsubDirectConnectInitialDelay = second;
var GossipsubOpportunisticGraftTicks = 60;
var GossipsubOpportunisticGraftPeers = 2;
var GossipsubGraftFloodThreshold = 10 * second;
var GossipsubMaxIHaveLength = 5e3;
var GossipsubMaxIHaveMessages = 10;
var GossipsubIWantFollowupTime = 3 * second;
var GossipsubSeenTTL = 2 * minute;
var TimeCacheDuration = 120 * 1e3;
var ERR_TOPIC_VALIDATOR_REJECT = "ERR_TOPIC_VALIDATOR_REJECT";
var ERR_TOPIC_VALIDATOR_IGNORE = "ERR_TOPIC_VALIDATOR_IGNORE";
var ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE = 0;
var ACCEPT_FROM_WHITELIST_MAX_MESSAGES = 128;
var ACCEPT_FROM_WHITELIST_DURATION_MS = 1e3;
var DEFAULT_METRIC_MESH_MESSAGE_DELIVERIES_WINDOWS = 1e3;
var BACKOFF_SLACK = 1;

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/shuffle.js
function shuffle(arr) {
  if (arr.length <= 1) {
    return arr;
  }
  const randInt = () => {
    return Math.floor(Math.random() * Math.floor(arr.length));
  };
  for (let i = 0; i < arr.length; i++) {
    const j = randInt();
    const tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
  }
  return arr;
}

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/messageIdToString.js
function messageIdToString(msgId2) {
  return toString(msgId2, "base64");
}

// node_modules/@libp2p/interface/dist/src/pubsub/index.js
var StrictSign = "StrictSign";
var StrictNoSign = "StrictNoSign";
var TopicValidatorResult;
(function(TopicValidatorResult2) {
  TopicValidatorResult2["Accept"] = "accept";
  TopicValidatorResult2["Ignore"] = "ignore";
  TopicValidatorResult2["Reject"] = "reject";
})(TopicValidatorResult || (TopicValidatorResult = {}));

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/types.js
var SignaturePolicy;
(function(SignaturePolicy2) {
  SignaturePolicy2["StrictSign"] = "StrictSign";
  SignaturePolicy2["StrictNoSign"] = "StrictNoSign";
})(SignaturePolicy || (SignaturePolicy = {}));
var PublishConfigType;
(function(PublishConfigType2) {
  PublishConfigType2[PublishConfigType2["Signing"] = 0] = "Signing";
  PublishConfigType2[PublishConfigType2["Anonymous"] = 1] = "Anonymous";
})(PublishConfigType || (PublishConfigType = {}));
var RejectReason;
(function(RejectReason2) {
  RejectReason2["Error"] = "error";
  RejectReason2["Ignore"] = "ignore";
  RejectReason2["Reject"] = "reject";
  RejectReason2["Blacklisted"] = "blacklisted";
})(RejectReason || (RejectReason = {}));
var ValidateError;
(function(ValidateError2) {
  ValidateError2["InvalidSignature"] = "invalid_signature";
  ValidateError2["InvalidSeqno"] = "invalid_seqno";
  ValidateError2["InvalidPeerId"] = "invalid_peerid";
  ValidateError2["SignaturePresent"] = "signature_present";
  ValidateError2["SeqnoPresent"] = "seqno_present";
  ValidateError2["FromPresent"] = "from_present";
  ValidateError2["TransformFailed"] = "transform_failed";
})(ValidateError || (ValidateError = {}));
var MessageStatus;
(function(MessageStatus2) {
  MessageStatus2["duplicate"] = "duplicate";
  MessageStatus2["invalid"] = "invalid";
  MessageStatus2["valid"] = "valid";
})(MessageStatus || (MessageStatus = {}));
function rejectReasonFromAcceptance(acceptance) {
  switch (acceptance) {
    case TopicValidatorResult.Ignore:
      return RejectReason.Ignore;
    case TopicValidatorResult.Reject:
      return RejectReason.Reject;
  }
}

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/publishConfig.js
async function getPublishConfigFromPeerId(signaturePolicy, peerId2) {
  switch (signaturePolicy) {
    case StrictSign: {
      if (!peerId2) {
        throw Error("Must provide PeerId");
      }
      if (peerId2.privateKey == null) {
        throw Error("Cannot sign message, no private key present");
      }
      if (peerId2.publicKey == null) {
        throw Error("Cannot sign message, no public key present");
      }
      const privateKey = await unmarshalPrivateKey2(peerId2.privateKey);
      return {
        type: PublishConfigType.Signing,
        author: peerId2,
        key: peerId2.publicKey,
        privateKey
      };
    }
    case StrictNoSign:
      return {
        type: PublishConfigType.Anonymous
      };
    default:
      throw new Error(`Unknown signature policy "${signaturePolicy}"`);
  }
}

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/constants.js
var ERR_INVALID_PEER_SCORE_PARAMS = "ERR_INVALID_PEER_SCORE_PARAMS";

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/peer-score-params.js
var defaultPeerScoreParams = {
  topics: {},
  topicScoreCap: 10,
  appSpecificScore: () => 0,
  appSpecificWeight: 10,
  IPColocationFactorWeight: -5,
  IPColocationFactorThreshold: 10,
  IPColocationFactorWhitelist: /* @__PURE__ */ new Set(),
  behaviourPenaltyWeight: -10,
  behaviourPenaltyThreshold: 0,
  behaviourPenaltyDecay: 0.2,
  decayInterval: 1e3,
  decayToZero: 0.1,
  retainScore: 3600 * 1e3
};
var defaultTopicScoreParams = {
  topicWeight: 0.5,
  timeInMeshWeight: 1,
  timeInMeshQuantum: 1,
  timeInMeshCap: 3600,
  firstMessageDeliveriesWeight: 1,
  firstMessageDeliveriesDecay: 0.5,
  firstMessageDeliveriesCap: 2e3,
  meshMessageDeliveriesWeight: -1,
  meshMessageDeliveriesDecay: 0.5,
  meshMessageDeliveriesCap: 100,
  meshMessageDeliveriesThreshold: 20,
  meshMessageDeliveriesWindow: 10,
  meshMessageDeliveriesActivation: 5e3,
  meshFailurePenaltyWeight: -1,
  meshFailurePenaltyDecay: 0.5,
  invalidMessageDeliveriesWeight: -1,
  invalidMessageDeliveriesDecay: 0.3
};
function createPeerScoreParams(p = {}) {
  return {
    ...defaultPeerScoreParams,
    ...p,
    topics: p.topics ? Object.entries(p.topics).reduce((topics, [topic, topicScoreParams]) => {
      topics[topic] = createTopicScoreParams(topicScoreParams);
      return topics;
    }, {}) : {}
  };
}
function createTopicScoreParams(p = {}) {
  return {
    ...defaultTopicScoreParams,
    ...p
  };
}
function validatePeerScoreParams(p) {
  for (const [topic, params] of Object.entries(p.topics)) {
    try {
      validateTopicScoreParams(params);
    } catch (e) {
      throw new CodeError(`invalid score parameters for topic ${topic}: ${e.message}`, ERR_INVALID_PEER_SCORE_PARAMS);
    }
  }
  if (p.topicScoreCap < 0) {
    throw new CodeError("invalid topic score cap; must be positive (or 0 for no cap)", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.appSpecificScore === null || p.appSpecificScore === void 0) {
    throw new CodeError("missing application specific score function", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.IPColocationFactorWeight > 0) {
    throw new CodeError("invalid IPColocationFactorWeight; must be negative (or 0 to disable)", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.IPColocationFactorWeight !== 0 && p.IPColocationFactorThreshold < 1) {
    throw new CodeError("invalid IPColocationFactorThreshold; must be at least 1", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.behaviourPenaltyWeight > 0) {
    throw new CodeError("invalid BehaviourPenaltyWeight; must be negative (or 0 to disable)", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.behaviourPenaltyWeight !== 0 && (p.behaviourPenaltyDecay <= 0 || p.behaviourPenaltyDecay >= 1)) {
    throw new CodeError("invalid BehaviourPenaltyDecay; must be between 0 and 1", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.decayInterval < 1e3) {
    throw new CodeError("invalid DecayInterval; must be at least 1s", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.decayToZero <= 0 || p.decayToZero >= 1) {
    throw new CodeError("invalid DecayToZero; must be between 0 and 1", ERR_INVALID_PEER_SCORE_PARAMS);
  }
}
function validateTopicScoreParams(p) {
  if (p.topicWeight < 0) {
    throw new CodeError("invalid topic weight; must be >= 0", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.timeInMeshQuantum === 0) {
    throw new CodeError("invalid TimeInMeshQuantum; must be non zero", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.timeInMeshWeight < 0) {
    throw new CodeError("invalid TimeInMeshWeight; must be positive (or 0 to disable)", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.timeInMeshWeight !== 0 && p.timeInMeshQuantum <= 0) {
    throw new CodeError("invalid TimeInMeshQuantum; must be positive", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.timeInMeshWeight !== 0 && p.timeInMeshCap <= 0) {
    throw new CodeError("invalid TimeInMeshCap; must be positive", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.firstMessageDeliveriesWeight < 0) {
    throw new CodeError("invallid FirstMessageDeliveriesWeight; must be positive (or 0 to disable)", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.firstMessageDeliveriesWeight !== 0 && (p.firstMessageDeliveriesDecay <= 0 || p.firstMessageDeliveriesDecay >= 1)) {
    throw new CodeError("invalid FirstMessageDeliveriesDecay; must be between 0 and 1", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.firstMessageDeliveriesWeight !== 0 && p.firstMessageDeliveriesCap <= 0) {
    throw new CodeError("invalid FirstMessageDeliveriesCap; must be positive", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.meshMessageDeliveriesWeight > 0) {
    throw new CodeError("invalid MeshMessageDeliveriesWeight; must be negative (or 0 to disable)", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.meshMessageDeliveriesWeight !== 0 && (p.meshMessageDeliveriesDecay <= 0 || p.meshMessageDeliveriesDecay >= 1)) {
    throw new CodeError("invalid MeshMessageDeliveriesDecay; must be between 0 and 1", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.meshMessageDeliveriesWeight !== 0 && p.meshMessageDeliveriesCap <= 0) {
    throw new CodeError("invalid MeshMessageDeliveriesCap; must be positive", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.meshMessageDeliveriesWeight !== 0 && p.meshMessageDeliveriesThreshold <= 0) {
    throw new CodeError("invalid MeshMessageDeliveriesThreshold; must be positive", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.meshMessageDeliveriesWindow < 0) {
    throw new CodeError("invalid MeshMessageDeliveriesWindow; must be non-negative", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.meshMessageDeliveriesWeight !== 0 && p.meshMessageDeliveriesActivation < 1e3) {
    throw new CodeError("invalid MeshMessageDeliveriesActivation; must be at least 1s", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.meshFailurePenaltyWeight > 0) {
    throw new CodeError("invalid MeshFailurePenaltyWeight; must be negative (or 0 to disable)", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.meshFailurePenaltyWeight !== 0 && (p.meshFailurePenaltyDecay <= 0 || p.meshFailurePenaltyDecay >= 1)) {
    throw new CodeError("invalid MeshFailurePenaltyDecay; must be between 0 and 1", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.invalidMessageDeliveriesWeight > 0) {
    throw new CodeError("invalid InvalidMessageDeliveriesWeight; must be negative (or 0 to disable)", ERR_INVALID_PEER_SCORE_PARAMS);
  }
  if (p.invalidMessageDeliveriesDecay <= 0 || p.invalidMessageDeliveriesDecay >= 1) {
    throw new CodeError("invalid InvalidMessageDeliveriesDecay; must be between 0 and 1", ERR_INVALID_PEER_SCORE_PARAMS);
  }
}

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/peer-score-thresholds.js
var defaultPeerScoreThresholds = {
  gossipThreshold: -10,
  publishThreshold: -50,
  graylistThreshold: -80,
  acceptPXThreshold: 10,
  opportunisticGraftThreshold: 20
};
function createPeerScoreThresholds(p = {}) {
  return {
    ...defaultPeerScoreThresholds,
    ...p
  };
}

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/compute-score.js
function computeScore(peer, pstats, params, peerIPs) {
  let score = 0;
  Object.entries(pstats.topics).forEach(([topic, tstats]) => {
    const topicParams = params.topics[topic];
    if (topicParams === void 0) {
      return;
    }
    let topicScore = 0;
    if (tstats.inMesh) {
      let p1 = tstats.meshTime / topicParams.timeInMeshQuantum;
      if (p1 > topicParams.timeInMeshCap) {
        p1 = topicParams.timeInMeshCap;
      }
      topicScore += p1 * topicParams.timeInMeshWeight;
    }
    let p2 = tstats.firstMessageDeliveries;
    if (p2 > topicParams.firstMessageDeliveriesCap) {
      p2 = topicParams.firstMessageDeliveriesCap;
    }
    topicScore += p2 * topicParams.firstMessageDeliveriesWeight;
    if (tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < topicParams.meshMessageDeliveriesThreshold) {
      const deficit = topicParams.meshMessageDeliveriesThreshold - tstats.meshMessageDeliveries;
      const p3 = deficit * deficit;
      topicScore += p3 * topicParams.meshMessageDeliveriesWeight;
    }
    const p3b = tstats.meshFailurePenalty;
    topicScore += p3b * topicParams.meshFailurePenaltyWeight;
    const p4 = tstats.invalidMessageDeliveries * tstats.invalidMessageDeliveries;
    topicScore += p4 * topicParams.invalidMessageDeliveriesWeight;
    score += topicScore * topicParams.topicWeight;
  });
  if (params.topicScoreCap > 0 && score > params.topicScoreCap) {
    score = params.topicScoreCap;
  }
  const p5 = params.appSpecificScore(peer);
  score += p5 * params.appSpecificWeight;
  pstats.knownIPs.forEach((ip) => {
    if (params.IPColocationFactorWhitelist.has(ip)) {
      return;
    }
    const peersInIP = peerIPs.get(ip);
    const numPeersInIP = peersInIP ? peersInIP.size : 0;
    if (numPeersInIP > params.IPColocationFactorThreshold) {
      const surplus = numPeersInIP - params.IPColocationFactorThreshold;
      const p6 = surplus * surplus;
      score += p6 * params.IPColocationFactorWeight;
    }
  });
  if (pstats.behaviourPenalty > params.behaviourPenaltyThreshold) {
    const excess = pstats.behaviourPenalty - params.behaviourPenaltyThreshold;
    const p7 = excess * excess;
    score += p7 * params.behaviourPenaltyWeight;
  }
  return score;
}

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/message-deliveries.js
var import_denque = __toESM(require_denque(), 1);
var DeliveryRecordStatus;
(function(DeliveryRecordStatus2) {
  DeliveryRecordStatus2[DeliveryRecordStatus2["unknown"] = 0] = "unknown";
  DeliveryRecordStatus2[DeliveryRecordStatus2["valid"] = 1] = "valid";
  DeliveryRecordStatus2[DeliveryRecordStatus2["invalid"] = 2] = "invalid";
  DeliveryRecordStatus2[DeliveryRecordStatus2["ignored"] = 3] = "ignored";
})(DeliveryRecordStatus || (DeliveryRecordStatus = {}));
var MessageDeliveries = class {
  constructor() {
    __publicField(this, "records");
    __publicField(this, "queue");
    this.records = /* @__PURE__ */ new Map();
    this.queue = new import_denque.default();
  }
  getRecord(msgIdStr) {
    return this.records.get(msgIdStr);
  }
  ensureRecord(msgIdStr) {
    let drec = this.records.get(msgIdStr);
    if (drec) {
      return drec;
    }
    drec = {
      status: DeliveryRecordStatus.unknown,
      firstSeenTsMs: Date.now(),
      validated: 0,
      peers: /* @__PURE__ */ new Set()
    };
    this.records.set(msgIdStr, drec);
    const entry = {
      msgId: msgIdStr,
      expire: Date.now() + TimeCacheDuration
    };
    this.queue.push(entry);
    return drec;
  }
  gc() {
    const now = Date.now();
    let head = this.queue.peekFront();
    while (head && head.expire < now) {
      this.records.delete(head.msgId);
      this.queue.shift();
      head = this.queue.peekFront();
    }
  }
  clear() {
    this.records.clear();
    this.queue.clear();
  }
};

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/set.js
function removeItemsFromSet(superSet, ineed, cond = () => true) {
  const subset = /* @__PURE__ */ new Set();
  if (ineed <= 0)
    return subset;
  for (const id of superSet) {
    if (subset.size >= ineed)
      break;
    if (cond(id)) {
      subset.add(id);
      superSet.delete(id);
    }
  }
  return subset;
}
function removeFirstNItemsFromSet(superSet, ineed) {
  return removeItemsFromSet(superSet, ineed, () => true);
}
var MapDef = class extends Map {
  constructor(getDefault) {
    super();
    __publicField(this, "getDefault");
    this.getDefault = getDefault;
  }
  getOrDefault(key) {
    let value = super.get(key);
    if (value === void 0) {
      value = this.getDefault();
      this.set(key, value);
    }
    return value;
  }
};

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/peer-score.js
var log15 = logger("libp2p:gossipsub:score");
var PeerScore = class {
  constructor(params, metrics, opts) {
    __publicField(this, "params");
    __publicField(this, "metrics");
    /**
     * Per-peer stats for score calculation
     */
    __publicField(this, "peerStats", /* @__PURE__ */ new Map());
    /**
     * IP colocation tracking; maps IP => set of peers.
     */
    __publicField(this, "peerIPs", new MapDef(() => /* @__PURE__ */ new Set()));
    /**
     * Cache score up to decayInterval if topic stats are unchanged.
     */
    __publicField(this, "scoreCache", /* @__PURE__ */ new Map());
    /**
     * Recent message delivery timing/participants
     */
    __publicField(this, "deliveryRecords", new MessageDeliveries());
    __publicField(this, "_backgroundInterval");
    __publicField(this, "scoreCacheValidityMs");
    __publicField(this, "computeScore");
    this.params = params;
    this.metrics = metrics;
    validatePeerScoreParams(params);
    this.scoreCacheValidityMs = opts.scoreCacheValidityMs;
    this.computeScore = opts.computeScore ?? computeScore;
  }
  get size() {
    return this.peerStats.size;
  }
  /**
   * Start PeerScore instance
   */
  start() {
    if (this._backgroundInterval) {
      log15("Peer score already running");
      return;
    }
    this._backgroundInterval = setInterval(() => this.background(), this.params.decayInterval);
    log15("started");
  }
  /**
   * Stop PeerScore instance
   */
  stop() {
    if (!this._backgroundInterval) {
      log15("Peer score already stopped");
      return;
    }
    clearInterval(this._backgroundInterval);
    delete this._backgroundInterval;
    this.peerIPs.clear();
    this.peerStats.clear();
    this.deliveryRecords.clear();
    log15("stopped");
  }
  /**
   * Periodic maintenance
   */
  background() {
    this.refreshScores();
    this.deliveryRecords.gc();
  }
  dumpPeerScoreStats() {
    return Object.fromEntries(Array.from(this.peerStats.entries()).map(([peer, stats]) => [peer, stats]));
  }
  messageFirstSeenTimestampMs(msgIdStr) {
    const drec = this.deliveryRecords.getRecord(msgIdStr);
    return drec ? drec.firstSeenTsMs : null;
  }
  /**
   * Decays scores, and purges score records for disconnected peers once their expiry has elapsed.
   */
  refreshScores() {
    const now = Date.now();
    const decayToZero = this.params.decayToZero;
    this.peerStats.forEach((pstats, id) => {
      if (!pstats.connected) {
        if (now > pstats.expire) {
          this.removeIPsForPeer(id, pstats.knownIPs);
          this.peerStats.delete(id);
          this.scoreCache.delete(id);
        }
        return;
      }
      Object.entries(pstats.topics).forEach(([topic, tstats]) => {
        const tparams = this.params.topics[topic];
        if (tparams === void 0) {
          return;
        }
        tstats.firstMessageDeliveries *= tparams.firstMessageDeliveriesDecay;
        if (tstats.firstMessageDeliveries < decayToZero) {
          tstats.firstMessageDeliveries = 0;
        }
        tstats.meshMessageDeliveries *= tparams.meshMessageDeliveriesDecay;
        if (tstats.meshMessageDeliveries < decayToZero) {
          tstats.meshMessageDeliveries = 0;
        }
        tstats.meshFailurePenalty *= tparams.meshFailurePenaltyDecay;
        if (tstats.meshFailurePenalty < decayToZero) {
          tstats.meshFailurePenalty = 0;
        }
        tstats.invalidMessageDeliveries *= tparams.invalidMessageDeliveriesDecay;
        if (tstats.invalidMessageDeliveries < decayToZero) {
          tstats.invalidMessageDeliveries = 0;
        }
        if (tstats.inMesh) {
          tstats.meshTime = now - tstats.graftTime;
          if (tstats.meshTime > tparams.meshMessageDeliveriesActivation) {
            tstats.meshMessageDeliveriesActive = true;
          }
        }
      });
      pstats.behaviourPenalty *= this.params.behaviourPenaltyDecay;
      if (pstats.behaviourPenalty < decayToZero) {
        pstats.behaviourPenalty = 0;
      }
    });
  }
  /**
   * Return the score for a peer
   */
  score(id) {
    var _a4, _b4, _c;
    (_a4 = this.metrics) == null ? void 0 : _a4.scoreFnCalls.inc();
    const pstats = this.peerStats.get(id);
    if (!pstats) {
      return 0;
    }
    const now = Date.now();
    const cacheEntry = this.scoreCache.get(id);
    if (cacheEntry && cacheEntry.cacheUntil > now) {
      return cacheEntry.score;
    }
    (_b4 = this.metrics) == null ? void 0 : _b4.scoreFnRuns.inc();
    const score = this.computeScore(id, pstats, this.params, this.peerIPs);
    const cacheUntil = now + this.scoreCacheValidityMs;
    if (cacheEntry) {
      (_c = this.metrics) == null ? void 0 : _c.scoreCachedDelta.observe(Math.abs(score - cacheEntry.score));
      cacheEntry.score = score;
      cacheEntry.cacheUntil = cacheUntil;
    } else {
      this.scoreCache.set(id, { score, cacheUntil });
    }
    return score;
  }
  /**
   * Apply a behavioural penalty to a peer
   */
  addPenalty(id, penalty, penaltyLabel) {
    var _a4;
    const pstats = this.peerStats.get(id);
    if (pstats) {
      pstats.behaviourPenalty += penalty;
      (_a4 = this.metrics) == null ? void 0 : _a4.onScorePenalty(penaltyLabel);
    }
  }
  addPeer(id) {
    const pstats = {
      connected: true,
      expire: 0,
      topics: {},
      knownIPs: /* @__PURE__ */ new Set(),
      behaviourPenalty: 0
    };
    this.peerStats.set(id, pstats);
  }
  /** Adds a new IP to a peer, if the peer is not known the update is ignored */
  addIP(id, ip) {
    const pstats = this.peerStats.get(id);
    if (pstats) {
      pstats.knownIPs.add(ip);
    }
    this.peerIPs.getOrDefault(ip).add(id);
  }
  /** Remove peer association with IP */
  removeIP(id, ip) {
    const pstats = this.peerStats.get(id);
    if (pstats) {
      pstats.knownIPs.delete(ip);
    }
    const peersWithIP = this.peerIPs.get(ip);
    if (peersWithIP) {
      peersWithIP.delete(id);
      if (peersWithIP.size === 0) {
        this.peerIPs.delete(ip);
      }
    }
  }
  removePeer(id) {
    const pstats = this.peerStats.get(id);
    if (!pstats) {
      return;
    }
    if (this.score(id) > 0) {
      this.removeIPsForPeer(id, pstats.knownIPs);
      this.peerStats.delete(id);
      return;
    }
    Object.entries(pstats.topics).forEach(([topic, tstats]) => {
      tstats.firstMessageDeliveries = 0;
      const threshold = this.params.topics[topic].meshMessageDeliveriesThreshold;
      if (tstats.inMesh && tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {
        const deficit = threshold - tstats.meshMessageDeliveries;
        tstats.meshFailurePenalty += deficit * deficit;
      }
      tstats.inMesh = false;
      tstats.meshMessageDeliveriesActive = false;
    });
    pstats.connected = false;
    pstats.expire = Date.now() + this.params.retainScore;
  }
  /** Handles scoring functionality as a peer GRAFTs to a topic. */
  graft(id, topic) {
    const pstats = this.peerStats.get(id);
    if (pstats) {
      const tstats = this.getPtopicStats(pstats, topic);
      if (tstats) {
        tstats.inMesh = true;
        tstats.graftTime = Date.now();
        tstats.meshTime = 0;
        tstats.meshMessageDeliveriesActive = false;
      }
    }
  }
  /** Handles scoring functionality as a peer PRUNEs from a topic. */
  prune(id, topic) {
    const pstats = this.peerStats.get(id);
    if (pstats) {
      const tstats = this.getPtopicStats(pstats, topic);
      if (tstats) {
        const threshold = this.params.topics[topic].meshMessageDeliveriesThreshold;
        if (tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {
          const deficit = threshold - tstats.meshMessageDeliveries;
          tstats.meshFailurePenalty += deficit * deficit;
        }
        tstats.meshMessageDeliveriesActive = false;
        tstats.inMesh = false;
      }
    }
  }
  validateMessage(msgIdStr) {
    this.deliveryRecords.ensureRecord(msgIdStr);
  }
  deliverMessage(from7, msgIdStr, topic) {
    this.markFirstMessageDelivery(from7, topic);
    const drec = this.deliveryRecords.ensureRecord(msgIdStr);
    const now = Date.now();
    if (drec.status !== DeliveryRecordStatus.unknown) {
      log15("unexpected delivery: message from %s was first seen %s ago and has delivery status %s", from7, now - drec.firstSeenTsMs, DeliveryRecordStatus[drec.status]);
      return;
    }
    drec.status = DeliveryRecordStatus.valid;
    drec.validated = now;
    drec.peers.forEach((p) => {
      if (p !== from7.toString()) {
        this.markDuplicateMessageDelivery(p, topic);
      }
    });
  }
  /**
   * Similar to `rejectMessage` except does not require the message id or reason for an invalid message.
   */
  rejectInvalidMessage(from7, topic) {
    this.markInvalidMessageDelivery(from7, topic);
  }
  rejectMessage(from7, msgIdStr, topic, reason) {
    switch (reason) {
      case RejectReason.Error:
        this.markInvalidMessageDelivery(from7, topic);
        return;
      case RejectReason.Blacklisted:
        return;
    }
    const drec = this.deliveryRecords.ensureRecord(msgIdStr);
    if (drec.status !== DeliveryRecordStatus.unknown) {
      log15("unexpected rejection: message from %s was first seen %s ago and has delivery status %d", from7, Date.now() - drec.firstSeenTsMs, DeliveryRecordStatus[drec.status]);
      return;
    }
    if (reason === RejectReason.Ignore) {
      drec.status = DeliveryRecordStatus.ignored;
      drec.peers.clear();
      return;
    }
    drec.status = DeliveryRecordStatus.invalid;
    this.markInvalidMessageDelivery(from7, topic);
    drec.peers.forEach((p) => {
      this.markInvalidMessageDelivery(p, topic);
    });
    drec.peers.clear();
  }
  duplicateMessage(from7, msgIdStr, topic) {
    const drec = this.deliveryRecords.ensureRecord(msgIdStr);
    if (drec.peers.has(from7)) {
      return;
    }
    switch (drec.status) {
      case DeliveryRecordStatus.unknown:
        drec.peers.add(from7);
        break;
      case DeliveryRecordStatus.valid:
        drec.peers.add(from7);
        this.markDuplicateMessageDelivery(from7, topic, drec.validated);
        break;
      case DeliveryRecordStatus.invalid:
        this.markInvalidMessageDelivery(from7, topic);
        break;
      case DeliveryRecordStatus.ignored:
        break;
    }
  }
  /**
   * Increments the "invalid message deliveries" counter for all scored topics the message is published in.
   */
  markInvalidMessageDelivery(from7, topic) {
    const pstats = this.peerStats.get(from7);
    if (pstats) {
      const tstats = this.getPtopicStats(pstats, topic);
      if (tstats) {
        tstats.invalidMessageDeliveries += 1;
      }
    }
  }
  /**
   * Increments the "first message deliveries" counter for all scored topics the message is published in,
   * as well as the "mesh message deliveries" counter, if the peer is in the mesh for the topic.
   * Messages already known (with the seenCache) are counted with markDuplicateMessageDelivery()
   */
  markFirstMessageDelivery(from7, topic) {
    const pstats = this.peerStats.get(from7);
    if (pstats) {
      const tstats = this.getPtopicStats(pstats, topic);
      if (tstats) {
        let cap = this.params.topics[topic].firstMessageDeliveriesCap;
        tstats.firstMessageDeliveries = Math.min(cap, tstats.firstMessageDeliveries + 1);
        if (tstats.inMesh) {
          cap = this.params.topics[topic].meshMessageDeliveriesCap;
          tstats.meshMessageDeliveries = Math.min(cap, tstats.meshMessageDeliveries + 1);
        }
      }
    }
  }
  /**
   * Increments the "mesh message deliveries" counter for messages we've seen before,
   * as long the message was received within the P3 window.
   */
  markDuplicateMessageDelivery(from7, topic, validatedTime) {
    var _a4;
    const pstats = this.peerStats.get(from7);
    if (pstats) {
      const now = validatedTime !== void 0 ? Date.now() : 0;
      const tstats = this.getPtopicStats(pstats, topic);
      if (tstats && tstats.inMesh) {
        const tparams = this.params.topics[topic];
        if (validatedTime !== void 0) {
          const deliveryDelayMs = now - validatedTime;
          const isLateDelivery = deliveryDelayMs > tparams.meshMessageDeliveriesWindow;
          (_a4 = this.metrics) == null ? void 0 : _a4.onDuplicateMsgDelivery(topic, deliveryDelayMs, isLateDelivery);
          if (isLateDelivery) {
            return;
          }
        }
        const cap = tparams.meshMessageDeliveriesCap;
        tstats.meshMessageDeliveries = Math.min(cap, tstats.meshMessageDeliveries + 1);
      }
    }
  }
  /**
   * Removes an IP list from the tracking list for a peer.
   */
  removeIPsForPeer(id, ipsToRemove) {
    for (const ipToRemove of ipsToRemove) {
      const peerSet = this.peerIPs.get(ipToRemove);
      if (peerSet) {
        peerSet.delete(id);
        if (peerSet.size === 0) {
          this.peerIPs.delete(ipToRemove);
        }
      }
    }
  }
  /**
   * Returns topic stats if they exist, otherwise if the supplied parameters score the
   * topic, inserts the default stats and returns a reference to those. If neither apply, returns None.
   */
  getPtopicStats(pstats, topic) {
    let topicStats = pstats.topics[topic];
    if (topicStats !== void 0) {
      return topicStats;
    }
    if (this.params.topics[topic] !== void 0) {
      topicStats = {
        inMesh: false,
        graftTime: 0,
        meshTime: 0,
        firstMessageDeliveries: 0,
        meshMessageDeliveries: 0,
        meshMessageDeliveriesActive: false,
        meshFailurePenalty: 0,
        invalidMessageDeliveries: 0
      };
      pstats.topics[topic] = topicStats;
      return topicStats;
    }
    return null;
  }
};

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/tracer.js
var IWantTracer = class {
  constructor(gossipsubIWantFollowupMs, msgIdToStrFn, metrics) {
    __publicField(this, "gossipsubIWantFollowupMs");
    __publicField(this, "msgIdToStrFn");
    __publicField(this, "metrics");
    /**
     * Promises to deliver a message
     * Map per message id, per peer, promise expiration time
     */
    __publicField(this, "promises", /* @__PURE__ */ new Map());
    /**
     * First request time by msgId. Used for metrics to track expire times.
     * Necessary to know if peers are actually breaking promises or simply sending them a bit later
     */
    __publicField(this, "requestMsByMsg", /* @__PURE__ */ new Map());
    __publicField(this, "requestMsByMsgExpire");
    this.gossipsubIWantFollowupMs = gossipsubIWantFollowupMs;
    this.msgIdToStrFn = msgIdToStrFn;
    this.metrics = metrics;
    this.requestMsByMsgExpire = 10 * gossipsubIWantFollowupMs;
  }
  get size() {
    return this.promises.size;
  }
  get requestMsByMsgSize() {
    return this.requestMsByMsg.size;
  }
  /**
   * Track a promise to deliver a message from a list of msgIds we are requesting
   */
  addPromise(from7, msgIds) {
    const ix = Math.floor(Math.random() * msgIds.length);
    const msgId2 = msgIds[ix];
    const msgIdStr = this.msgIdToStrFn(msgId2);
    let expireByPeer = this.promises.get(msgIdStr);
    if (!expireByPeer) {
      expireByPeer = /* @__PURE__ */ new Map();
      this.promises.set(msgIdStr, expireByPeer);
    }
    const now = Date.now();
    if (!expireByPeer.has(from7)) {
      expireByPeer.set(from7, now + this.gossipsubIWantFollowupMs);
      if (this.metrics) {
        this.metrics.iwantPromiseStarted.inc(1);
        if (!this.requestMsByMsg.has(msgIdStr)) {
          this.requestMsByMsg.set(msgIdStr, now);
        }
      }
    }
  }
  /**
   * Returns the number of broken promises for each peer who didn't follow up on an IWANT request.
   *
   * This should be called not too often relative to the expire times, since it iterates over the whole data.
   */
  getBrokenPromises() {
    var _a4;
    const now = Date.now();
    const result = /* @__PURE__ */ new Map();
    let brokenPromises = 0;
    this.promises.forEach((expireByPeer, msgId2) => {
      expireByPeer.forEach((expire, p) => {
        if (expire < now) {
          result.set(p, (result.get(p) ?? 0) + 1);
          expireByPeer.delete(p);
          brokenPromises++;
        }
      });
      if (!expireByPeer.size) {
        this.promises.delete(msgId2);
      }
    });
    (_a4 = this.metrics) == null ? void 0 : _a4.iwantPromiseBroken.inc(brokenPromises);
    return result;
  }
  /**
   * Someone delivered a message, stop tracking promises for it
   */
  deliverMessage(msgIdStr, isDuplicate = false) {
    this.trackMessage(msgIdStr);
    const expireByPeer = this.promises.get(msgIdStr);
    if (expireByPeer) {
      this.promises.delete(msgIdStr);
      if (this.metrics) {
        this.metrics.iwantPromiseResolved.inc(1);
        if (isDuplicate)
          this.metrics.iwantPromiseResolvedFromDuplicate.inc(1);
        this.metrics.iwantPromiseResolvedPeers.inc(expireByPeer.size);
      }
    }
  }
  /**
   * A message got rejected, so we can stop tracking promises and let the score penalty apply from invalid message delivery,
   * unless its an obviously invalid message.
   */
  rejectMessage(msgIdStr, reason) {
    this.trackMessage(msgIdStr);
    switch (reason) {
      case RejectReason.Error:
        return;
    }
    this.promises.delete(msgIdStr);
  }
  clear() {
    this.promises.clear();
  }
  prune() {
    var _a4;
    const maxMs = Date.now() - this.requestMsByMsgExpire;
    let count = 0;
    for (const [k, v] of this.requestMsByMsg.entries()) {
      if (v < maxMs) {
        this.requestMsByMsg.delete(k);
        count++;
      } else {
        break;
      }
    }
    (_a4 = this.metrics) == null ? void 0 : _a4.iwantMessagePruned.inc(count);
  }
  trackMessage(msgIdStr) {
    if (this.metrics) {
      const requestMs = this.requestMsByMsg.get(msgIdStr);
      if (requestMs !== void 0) {
        this.metrics.iwantPromiseDeliveryTime.observe((Date.now() - requestMs) / 1e3);
        this.requestMsByMsg.delete(msgIdStr);
      }
    }
  }
};

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/time-cache.js
var SimpleTimeCache = class {
  constructor(opts) {
    __publicField(this, "entries", /* @__PURE__ */ new Map());
    __publicField(this, "validityMs");
    this.validityMs = opts.validityMs;
  }
  get size() {
    return this.entries.size;
  }
  /** Returns true if there was a key collision and the entry is dropped */
  put(key, value) {
    if (this.entries.has(key)) {
      return true;
    }
    this.entries.set(key, { value, validUntilMs: Date.now() + this.validityMs });
    return false;
  }
  prune() {
    const now = Date.now();
    for (const [k, v] of this.entries.entries()) {
      if (v.validUntilMs < now) {
        this.entries.delete(k);
      } else {
        break;
      }
    }
  }
  has(key) {
    return this.entries.has(key);
  }
  get(key) {
    const value = this.entries.get(key);
    return value && value.validUntilMs >= Date.now() ? value.value : void 0;
  }
  clear() {
    this.entries.clear();
  }
};

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/metrics.js
var MessageSource;
(function(MessageSource2) {
  MessageSource2["forward"] = "forward";
  MessageSource2["publish"] = "publish";
})(MessageSource || (MessageSource = {}));
var InclusionReason;
(function(InclusionReason2) {
  InclusionReason2["Fanout"] = "fanout";
  InclusionReason2["Random"] = "random";
  InclusionReason2["Subscribed"] = "subscribed";
  InclusionReason2["Outbound"] = "outbound";
  InclusionReason2["NotEnough"] = "not_enough";
  InclusionReason2["Opportunistic"] = "opportunistic";
})(InclusionReason || (InclusionReason = {}));
var ChurnReason;
(function(ChurnReason2) {
  ChurnReason2["Dc"] = "disconnected";
  ChurnReason2["BadScore"] = "bad_score";
  ChurnReason2["Prune"] = "prune";
  ChurnReason2["Excess"] = "excess";
})(ChurnReason || (ChurnReason = {}));
var ScorePenalty;
(function(ScorePenalty2) {
  ScorePenalty2["GraftBackoff"] = "graft_backoff";
  ScorePenalty2["BrokenPromise"] = "broken_promise";
  ScorePenalty2["MessageDeficit"] = "message_deficit";
  ScorePenalty2["IPColocation"] = "IP_colocation";
})(ScorePenalty || (ScorePenalty = {}));
var IHaveIgnoreReason;
(function(IHaveIgnoreReason2) {
  IHaveIgnoreReason2["LowScore"] = "low_score";
  IHaveIgnoreReason2["MaxIhave"] = "max_ihave";
  IHaveIgnoreReason2["MaxIasked"] = "max_iasked";
})(IHaveIgnoreReason || (IHaveIgnoreReason = {}));
var ScoreThreshold;
(function(ScoreThreshold2) {
  ScoreThreshold2["graylist"] = "graylist";
  ScoreThreshold2["publish"] = "publish";
  ScoreThreshold2["gossip"] = "gossip";
  ScoreThreshold2["mesh"] = "mesh";
})(ScoreThreshold || (ScoreThreshold = {}));
function getMetrics(register, topicStrToLabel, opts) {
  return {
    /* Metrics for static config */
    protocolsEnabled: register.gauge({
      name: "gossipsub_protocol",
      help: "Status of enabled protocols",
      labelNames: ["protocol"]
    }),
    /* Metrics per known topic */
    /** Status of our subscription to this topic. This metric allows analyzing other topic metrics
     *  filtered by our current subscription status.
     *  = rust-libp2p `topic_subscription_status` */
    topicSubscriptionStatus: register.gauge({
      name: "gossipsub_topic_subscription_status",
      help: "Status of our subscription to this topic",
      labelNames: ["topicStr"]
    }),
    /** Number of peers subscribed to each topic. This allows us to analyze a topic's behaviour
     * regardless of our subscription status. */
    topicPeersCount: register.gauge({
      name: "gossipsub_topic_peer_count",
      help: "Number of peers subscribed to each topic",
      labelNames: ["topicStr"]
    }),
    /* Metrics regarding mesh state */
    /** Number of peers in our mesh. This metric should be updated with the count of peers for a
     *  topic in the mesh regardless of inclusion and churn events.
     *  = rust-libp2p `mesh_peer_counts` */
    meshPeerCounts: register.gauge({
      name: "gossipsub_mesh_peer_count",
      help: "Number of peers in our mesh",
      labelNames: ["topicStr"]
    }),
    /** Number of times we include peers in a topic mesh for different reasons.
     *  = rust-libp2p `mesh_peer_inclusion_events` */
    meshPeerInclusionEventsFanout: register.gauge({
      name: "gossipsub_mesh_peer_inclusion_events_fanout_total",
      help: "Number of times we include peers in a topic mesh for fanout reasons",
      labelNames: ["topic"]
    }),
    meshPeerInclusionEventsRandom: register.gauge({
      name: "gossipsub_mesh_peer_inclusion_events_random_total",
      help: "Number of times we include peers in a topic mesh for random reasons",
      labelNames: ["topic"]
    }),
    meshPeerInclusionEventsSubscribed: register.gauge({
      name: "gossipsub_mesh_peer_inclusion_events_subscribed_total",
      help: "Number of times we include peers in a topic mesh for subscribed reasons",
      labelNames: ["topic"]
    }),
    meshPeerInclusionEventsOutbound: register.gauge({
      name: "gossipsub_mesh_peer_inclusion_events_outbound_total",
      help: "Number of times we include peers in a topic mesh for outbound reasons",
      labelNames: ["topic"]
    }),
    meshPeerInclusionEventsNotEnough: register.gauge({
      name: "gossipsub_mesh_peer_inclusion_events_not_enough_total",
      help: "Number of times we include peers in a topic mesh for not_enough reasons",
      labelNames: ["topic"]
    }),
    meshPeerInclusionEventsOpportunistic: register.gauge({
      name: "gossipsub_mesh_peer_inclusion_events_opportunistic_total",
      help: "Number of times we include peers in a topic mesh for opportunistic reasons",
      labelNames: ["topic"]
    }),
    meshPeerInclusionEventsUnknown: register.gauge({
      name: "gossipsub_mesh_peer_inclusion_events_unknown_total",
      help: "Number of times we include peers in a topic mesh for unknown reasons",
      labelNames: ["topic"]
    }),
    /** Number of times we remove peers in a topic mesh for different reasons.
     *  = rust-libp2p `mesh_peer_churn_events` */
    meshPeerChurnEventsDisconnected: register.gauge({
      name: "gossipsub_peer_churn_events_disconnected_total",
      help: "Number of times we remove peers in a topic mesh for disconnected reasons",
      labelNames: ["topic"]
    }),
    meshPeerChurnEventsBadScore: register.gauge({
      name: "gossipsub_peer_churn_events_bad_score_total",
      help: "Number of times we remove peers in a topic mesh for bad_score reasons",
      labelNames: ["topic"]
    }),
    meshPeerChurnEventsPrune: register.gauge({
      name: "gossipsub_peer_churn_events_prune_total",
      help: "Number of times we remove peers in a topic mesh for prune reasons",
      labelNames: ["topic"]
    }),
    meshPeerChurnEventsExcess: register.gauge({
      name: "gossipsub_peer_churn_events_excess_total",
      help: "Number of times we remove peers in a topic mesh for excess reasons",
      labelNames: ["topic"]
    }),
    meshPeerChurnEventsUnknown: register.gauge({
      name: "gossipsub_peer_churn_events_unknown_total",
      help: "Number of times we remove peers in a topic mesh for unknown reasons",
      labelNames: ["topic"]
    }),
    /* General Metrics */
    /** Gossipsub supports floodsub, gossipsub v1.0 and gossipsub v1.1. Peers are classified based
     *  on which protocol they support. This metric keeps track of the number of peers that are
     *  connected of each type. */
    peersPerProtocol: register.gauge({
      name: "gossipsub_peers_per_protocol_count",
      help: "Peers connected for each topic",
      labelNames: ["protocol"]
    }),
    /** The time it takes to complete one iteration of the heartbeat. */
    heartbeatDuration: register.histogram({
      name: "gossipsub_heartbeat_duration_seconds",
      help: "The time it takes to complete one iteration of the heartbeat",
      // Should take <10ms, over 1s it's a huge issue that needs debugging, since a heartbeat will be cancelled
      buckets: [0.01, 0.1, 1]
    }),
    /** Heartbeat run took longer than heartbeat interval so next is skipped */
    heartbeatSkipped: register.gauge({
      name: "gossipsub_heartbeat_skipped",
      help: "Heartbeat run took longer than heartbeat interval so next is skipped"
    }),
    /** Message validation results for each topic.
     *  Invalid == Reject?
     *  = rust-libp2p `invalid_messages`, `accepted_messages`, `ignored_messages`, `rejected_messages` */
    acceptedMessagesTotal: register.gauge({
      name: "gossipsub_accepted_messages_total",
      help: "Total accepted messages for each topic",
      labelNames: ["topic"]
    }),
    ignoredMessagesTotal: register.gauge({
      name: "gossipsub_ignored_messages_total",
      help: "Total ignored messages for each topic",
      labelNames: ["topic"]
    }),
    rejectedMessagesTotal: register.gauge({
      name: "gossipsub_rejected_messages_total",
      help: "Total rejected messages for each topic",
      labelNames: ["topic"]
    }),
    unknownValidationResultsTotal: register.gauge({
      name: "gossipsub_unknown_validation_results_total",
      help: "Total unknown validation results for each topic",
      labelNames: ["topic"]
    }),
    /** When the user validates a message, it tries to re propagate it to its mesh peers. If the
     *  message expires from the memcache before it can be validated, we count this a cache miss
     *  and it is an indicator that the memcache size should be increased.
     *  = rust-libp2p `mcache_misses` */
    asyncValidationMcacheHit: register.gauge({
      name: "gossipsub_async_validation_mcache_hit_total",
      help: "Async validation result reported by the user layer",
      labelNames: ["hit"]
    }),
    asyncValidationDelayFromFirstSeenSec: register.histogram({
      name: "gossipsub_async_validation_delay_from_first_seen",
      help: "Async validation report delay from first seen in second",
      labelNames: ["topic"],
      buckets: [0.01, 0.03, 0.1, 0.3, 1, 3, 10]
    }),
    asyncValidationUnknownFirstSeen: register.gauge({
      name: "gossipsub_async_validation_unknown_first_seen_count_total",
      help: "Async validation report unknown first seen value for message"
    }),
    // peer stream
    peerReadStreamError: register.gauge({
      name: "gossipsub_peer_read_stream_err_count_total",
      help: "Peer read stream error"
    }),
    // RPC outgoing. Track byte length + data structure sizes
    rpcRecvBytes: register.gauge({ name: "gossipsub_rpc_recv_bytes_total", help: "RPC recv" }),
    rpcRecvCount: register.gauge({ name: "gossipsub_rpc_recv_count_total", help: "RPC recv" }),
    rpcRecvSubscription: register.gauge({ name: "gossipsub_rpc_recv_subscription_total", help: "RPC recv" }),
    rpcRecvMessage: register.gauge({ name: "gossipsub_rpc_recv_message_total", help: "RPC recv" }),
    rpcRecvControl: register.gauge({ name: "gossipsub_rpc_recv_control_total", help: "RPC recv" }),
    rpcRecvIHave: register.gauge({ name: "gossipsub_rpc_recv_ihave_total", help: "RPC recv" }),
    rpcRecvIWant: register.gauge({ name: "gossipsub_rpc_recv_iwant_total", help: "RPC recv" }),
    rpcRecvGraft: register.gauge({ name: "gossipsub_rpc_recv_graft_total", help: "RPC recv" }),
    rpcRecvPrune: register.gauge({ name: "gossipsub_rpc_recv_prune_total", help: "RPC recv" }),
    rpcDataError: register.gauge({ name: "gossipsub_rpc_data_err_count_total", help: "RPC data error" }),
    rpcRecvError: register.gauge({ name: "gossipsub_rpc_recv_err_count_total", help: "RPC recv error" }),
    /** Total count of RPC dropped because acceptFrom() == false */
    rpcRecvNotAccepted: register.gauge({
      name: "gossipsub_rpc_rcv_not_accepted_total",
      help: "Total count of RPC dropped because acceptFrom() == false"
    }),
    // RPC incoming. Track byte length + data structure sizes
    rpcSentBytes: register.gauge({ name: "gossipsub_rpc_sent_bytes_total", help: "RPC sent" }),
    rpcSentCount: register.gauge({ name: "gossipsub_rpc_sent_count_total", help: "RPC sent" }),
    rpcSentSubscription: register.gauge({ name: "gossipsub_rpc_sent_subscription_total", help: "RPC sent" }),
    rpcSentMessage: register.gauge({ name: "gossipsub_rpc_sent_message_total", help: "RPC sent" }),
    rpcSentControl: register.gauge({ name: "gossipsub_rpc_sent_control_total", help: "RPC sent" }),
    rpcSentIHave: register.gauge({ name: "gossipsub_rpc_sent_ihave_total", help: "RPC sent" }),
    rpcSentIWant: register.gauge({ name: "gossipsub_rpc_sent_iwant_total", help: "RPC sent" }),
    rpcSentGraft: register.gauge({ name: "gossipsub_rpc_sent_graft_total", help: "RPC sent" }),
    rpcSentPrune: register.gauge({ name: "gossipsub_rpc_sent_prune_total", help: "RPC sent" }),
    // publish message. Track peers sent to and bytes
    /** Total count of msg published by topic */
    msgPublishCount: register.gauge({
      name: "gossipsub_msg_publish_count_total",
      help: "Total count of msg published by topic",
      labelNames: ["topic"]
    }),
    /** Total count of peers that we publish a msg to */
    msgPublishPeersByTopic: register.gauge({
      name: "gossipsub_msg_publish_peers_total",
      help: "Total count of peers that we publish a msg to",
      labelNames: ["topic"]
    }),
    /** Total count of peers (by group) that we publish a msg to */
    directPeersPublishedTotal: register.gauge({
      name: "gossipsub_direct_peers_published_total",
      help: "Total direct peers that we publish a msg to",
      labelNames: ["topic"]
    }),
    floodsubPeersPublishedTotal: register.gauge({
      name: "gossipsub_floodsub_peers_published_total",
      help: "Total floodsub peers that we publish a msg to",
      labelNames: ["topic"]
    }),
    meshPeersPublishedTotal: register.gauge({
      name: "gossipsub_mesh_peers_published_total",
      help: "Total mesh peers that we publish a msg to",
      labelNames: ["topic"]
    }),
    fanoutPeersPublishedTotal: register.gauge({
      name: "gossipsub_fanout_peers_published_total",
      help: "Total fanout peers that we publish a msg to",
      labelNames: ["topic"]
    }),
    /** Total count of msg publish data.length bytes */
    msgPublishBytes: register.gauge({
      name: "gossipsub_msg_publish_bytes_total",
      help: "Total count of msg publish data.length bytes",
      labelNames: ["topic"]
    }),
    /** Total time in seconds to publish a message */
    msgPublishTime: register.histogram({
      name: "gossipsub_msg_publish_seconds",
      help: "Total time in seconds to publish a message",
      buckets: [1e-3, 2e-3, 5e-3, 0.01, 0.1, 0.5, 1],
      labelNames: ["topic"]
    }),
    /** Total count of msg forwarded by topic */
    msgForwardCount: register.gauge({
      name: "gossipsub_msg_forward_count_total",
      help: "Total count of msg forwarded by topic",
      labelNames: ["topic"]
    }),
    /** Total count of peers that we forward a msg to */
    msgForwardPeers: register.gauge({
      name: "gossipsub_msg_forward_peers_total",
      help: "Total count of peers that we forward a msg to",
      labelNames: ["topic"]
    }),
    /** Total count of recv msgs before any validation */
    msgReceivedPreValidation: register.gauge({
      name: "gossipsub_msg_received_prevalidation_total",
      help: "Total count of recv msgs before any validation",
      labelNames: ["topic"]
    }),
    /** Total count of recv msgs error */
    msgReceivedError: register.gauge({
      name: "gossipsub_msg_received_error_total",
      help: "Total count of recv msgs error",
      labelNames: ["topic"]
    }),
    /** Tracks distribution of recv msgs by duplicate, invalid, valid */
    prevalidationInvalidTotal: register.gauge({
      name: "gossipsub_pre_validation_invalid_total",
      help: "Total count of invalid messages received",
      labelNames: ["topic"]
    }),
    prevalidationValidTotal: register.gauge({
      name: "gossipsub_pre_validation_valid_total",
      help: "Total count of valid messages received",
      labelNames: ["topic"]
    }),
    prevalidationDuplicateTotal: register.gauge({
      name: "gossipsub_pre_validation_duplicate_total",
      help: "Total count of duplicate messages received",
      labelNames: ["topic"]
    }),
    prevalidationUnknownTotal: register.gauge({
      name: "gossipsub_pre_validation_unknown_status_total",
      help: "Total count of unknown_status messages received",
      labelNames: ["topic"]
    }),
    /** Tracks specific reason of invalid */
    msgReceivedInvalid: register.gauge({
      name: "gossipsub_msg_received_invalid_total",
      help: "Tracks specific reason of invalid",
      labelNames: ["error"]
    }),
    msgReceivedInvalidByTopic: register.gauge({
      name: "gossipsub_msg_received_invalid_by_topic_total",
      help: "Tracks specific invalid message by topic",
      labelNames: ["topic"]
    }),
    /** Track duplicate message delivery time */
    duplicateMsgDeliveryDelay: register.histogram({
      name: "gossisub_duplicate_msg_delivery_delay_seconds",
      help: "Time since the 1st duplicated message validated",
      labelNames: ["topic"],
      buckets: [
        0.25 * opts.maxMeshMessageDeliveriesWindowSec,
        0.5 * opts.maxMeshMessageDeliveriesWindowSec,
        1 * opts.maxMeshMessageDeliveriesWindowSec,
        2 * opts.maxMeshMessageDeliveriesWindowSec,
        4 * opts.maxMeshMessageDeliveriesWindowSec
      ]
    }),
    /** Total count of late msg delivery total by topic */
    duplicateMsgLateDelivery: register.gauge({
      name: "gossisub_duplicate_msg_late_delivery_total",
      help: "Total count of late duplicate message delivery by topic, which triggers P3 penalty",
      labelNames: ["topic"]
    }),
    duplicateMsgIgnored: register.gauge({
      name: "gossisub_ignored_published_duplicate_msgs_total",
      help: "Total count of published duplicate message ignored by topic",
      labelNames: ["topic"]
    }),
    /* Metrics related to scoring */
    /** Total times score() is called */
    scoreFnCalls: register.gauge({
      name: "gossipsub_score_fn_calls_total",
      help: "Total times score() is called"
    }),
    /** Total times score() call actually computed computeScore(), no cache */
    scoreFnRuns: register.gauge({
      name: "gossipsub_score_fn_runs_total",
      help: "Total times score() call actually computed computeScore(), no cache"
    }),
    scoreCachedDelta: register.histogram({
      name: "gossipsub_score_cache_delta",
      help: "Delta of score between cached values that expired",
      buckets: [10, 100, 1e3]
    }),
    /** Current count of peers by score threshold */
    peersByScoreThreshold: register.gauge({
      name: "gossipsub_peers_by_score_threshold_count",
      help: "Current count of peers by score threshold",
      labelNames: ["threshold"]
    }),
    score: register.avgMinMax({
      name: "gossipsub_score",
      help: "Avg min max of gossip scores"
    }),
    /**
     * Separate score weights
     * Need to use 2-label metrics in this case to debug the score weights
     **/
    scoreWeights: register.avgMinMax({
      name: "gossipsub_score_weights",
      help: "Separate score weights",
      labelNames: ["topic", "p"]
    }),
    /** Histogram of the scores for each mesh topic. */
    // TODO: Not implemented
    scorePerMesh: register.avgMinMax({
      name: "gossipsub_score_per_mesh",
      help: "Histogram of the scores for each mesh topic",
      labelNames: ["topic"]
    }),
    /** A counter of the kind of penalties being applied to peers. */
    // TODO: Not fully implemented
    scoringPenalties: register.gauge({
      name: "gossipsub_scoring_penalties_total",
      help: "A counter of the kind of penalties being applied to peers",
      labelNames: ["penalty"]
    }),
    behaviourPenalty: register.histogram({
      name: "gossipsub_peer_stat_behaviour_penalty",
      help: "Current peer stat behaviour_penalty at each scrape",
      buckets: [
        0.25 * opts.behaviourPenaltyThreshold,
        0.5 * opts.behaviourPenaltyThreshold,
        1 * opts.behaviourPenaltyThreshold,
        2 * opts.behaviourPenaltyThreshold,
        4 * opts.behaviourPenaltyThreshold
      ]
    }),
    // TODO:
    // - iasked per peer (on heartbeat)
    // - when promise is resolved, track messages from promises
    /** Total received IHAVE messages that we ignore for some reason */
    ihaveRcvIgnored: register.gauge({
      name: "gossipsub_ihave_rcv_ignored_total",
      help: "Total received IHAVE messages that we ignore for some reason",
      labelNames: ["reason"]
    }),
    /** Total received IHAVE messages by topic */
    ihaveRcvMsgids: register.gauge({
      name: "gossipsub_ihave_rcv_msgids_total",
      help: "Total received IHAVE messages by topic",
      labelNames: ["topic"]
    }),
    /** Total messages per topic we don't have. Not actual requests.
     *  The number of times we have decided that an IWANT control message is required for this
     *  topic. A very high metric might indicate an underperforming network.
     *  = rust-libp2p `topic_iwant_msgs` */
    ihaveRcvNotSeenMsgids: register.gauge({
      name: "gossipsub_ihave_rcv_not_seen_msgids_total",
      help: "Total messages per topic we do not have, not actual requests",
      labelNames: ["topic"]
    }),
    /** Total received IWANT messages by topic */
    iwantRcvMsgids: register.gauge({
      name: "gossipsub_iwant_rcv_msgids_total",
      help: "Total received IWANT messages by topic",
      labelNames: ["topic"]
    }),
    /** Total requested messageIDs that we don't have */
    iwantRcvDonthaveMsgids: register.gauge({
      name: "gossipsub_iwant_rcv_dont_have_msgids_total",
      help: "Total requested messageIDs that we do not have"
    }),
    iwantPromiseStarted: register.gauge({
      name: "gossipsub_iwant_promise_sent_total",
      help: "Total count of started IWANT promises"
    }),
    /** Total count of resolved IWANT promises */
    iwantPromiseResolved: register.gauge({
      name: "gossipsub_iwant_promise_resolved_total",
      help: "Total count of resolved IWANT promises"
    }),
    /** Total count of resolved IWANT promises from duplicate messages */
    iwantPromiseResolvedFromDuplicate: register.gauge({
      name: "gossipsub_iwant_promise_resolved_from_duplicate_total",
      help: "Total count of resolved IWANT promises from duplicate messages"
    }),
    /** Total count of peers we have asked IWANT promises that are resolved */
    iwantPromiseResolvedPeers: register.gauge({
      name: "gossipsub_iwant_promise_resolved_peers",
      help: "Total count of peers we have asked IWANT promises that are resolved"
    }),
    iwantPromiseBroken: register.gauge({
      name: "gossipsub_iwant_promise_broken",
      help: "Total count of broken IWANT promises"
    }),
    iwantMessagePruned: register.gauge({
      name: "gossipsub_iwant_message_pruned",
      help: "Total count of pruned IWANT messages"
    }),
    /** Histogram of delivery time of resolved IWANT promises */
    iwantPromiseDeliveryTime: register.histogram({
      name: "gossipsub_iwant_promise_delivery_seconds",
      help: "Histogram of delivery time of resolved IWANT promises",
      buckets: [
        0.5 * opts.gossipPromiseExpireSec,
        1 * opts.gossipPromiseExpireSec,
        2 * opts.gossipPromiseExpireSec,
        4 * opts.gossipPromiseExpireSec
      ]
    }),
    iwantPromiseUntracked: register.gauge({
      name: "gossip_iwant_promise_untracked",
      help: "Total count of untracked IWANT promise"
    }),
    /** Backoff time */
    connectedPeersBackoffSec: register.histogram({
      name: "gossipsub_connected_peers_backoff_seconds",
      help: "Backoff time in seconds",
      // Using 1 seconds as minimum as that's close to the heartbeat duration, no need for more resolution.
      // As per spec, backoff times are 10 seconds for UnsubscribeBackoff and 60 seconds for PruneBackoff.
      // Higher values of 60 seconds should not occur, but we add 120 seconds just in case
      // https://github.com/libp2p/specs/blob/master/pubsub/gossipsub/gossipsub-v1.1.md#overview-of-new-parameters
      buckets: [1, 2, 4, 10, 20, 60, 120]
    }),
    /* Data structure sizes */
    /** Unbounded cache sizes */
    cacheSize: register.gauge({
      name: "gossipsub_cache_size",
      help: "Unbounded cache sizes",
      labelNames: ["cache"]
    }),
    /** Current mcache msg count */
    mcacheSize: register.gauge({
      name: "gossipsub_mcache_size",
      help: "Current mcache msg count"
    }),
    mcacheNotValidatedCount: register.gauge({
      name: "gossipsub_mcache_not_validated_count",
      help: "Current mcache msg count not validated"
    }),
    fastMsgIdCacheCollision: register.gauge({
      name: "gossipsub_fastmsgid_cache_collision_total",
      help: "Total count of key collisions on fastmsgid cache put"
    }),
    newConnectionCount: register.gauge({
      name: "gossipsub_new_connection_total",
      help: "Total new connection by status",
      labelNames: ["status"]
    }),
    topicStrToLabel,
    toTopic(topicStr) {
      return this.topicStrToLabel.get(topicStr) ?? topicStr;
    },
    /** We joined a topic */
    onJoin(topicStr) {
      this.topicSubscriptionStatus.set({ topicStr }, 1);
      this.meshPeerCounts.set({ topicStr }, 0);
    },
    /** We left a topic */
    onLeave(topicStr) {
      this.topicSubscriptionStatus.set({ topicStr }, 0);
      this.meshPeerCounts.set({ topicStr }, 0);
    },
    /** Register the inclusion of peers in our mesh due to some reason. */
    onAddToMesh(topicStr, reason, count) {
      const topic = this.toTopic(topicStr);
      switch (reason) {
        case InclusionReason.Fanout:
          this.meshPeerInclusionEventsFanout.inc({ topic }, count);
          break;
        case InclusionReason.Random:
          this.meshPeerInclusionEventsRandom.inc({ topic }, count);
          break;
        case InclusionReason.Subscribed:
          this.meshPeerInclusionEventsSubscribed.inc({ topic }, count);
          break;
        case InclusionReason.Outbound:
          this.meshPeerInclusionEventsOutbound.inc({ topic }, count);
          break;
        case InclusionReason.NotEnough:
          this.meshPeerInclusionEventsNotEnough.inc({ topic }, count);
          break;
        case InclusionReason.Opportunistic:
          this.meshPeerInclusionEventsOpportunistic.inc({ topic }, count);
          break;
        default:
          this.meshPeerInclusionEventsUnknown.inc({ topic }, count);
          break;
      }
    },
    /** Register the removal of peers in our mesh due to some reason */
    // - remove_peer_from_mesh()
    // - heartbeat() Churn::BadScore
    // - heartbeat() Churn::Excess
    // - on_disconnect() Churn::Ds
    onRemoveFromMesh(topicStr, reason, count) {
      const topic = this.toTopic(topicStr);
      switch (reason) {
        case ChurnReason.Dc:
          this.meshPeerChurnEventsDisconnected.inc({ topic }, count);
          break;
        case ChurnReason.BadScore:
          this.meshPeerChurnEventsBadScore.inc({ topic }, count);
          break;
        case ChurnReason.Prune:
          this.meshPeerChurnEventsPrune.inc({ topic }, count);
          break;
        case ChurnReason.Excess:
          this.meshPeerChurnEventsExcess.inc({ topic }, count);
          break;
        default:
          this.meshPeerChurnEventsUnknown.inc({ topic }, count);
          break;
      }
    },
    /**
     * Update validation result to metrics
     * @param messageRecord null means the message's mcache record was not known at the time of acceptance report
     */
    onReportValidation(messageRecord, acceptance, firstSeenTimestampMs) {
      this.asyncValidationMcacheHit.inc({ hit: messageRecord != null ? "hit" : "miss" });
      if (messageRecord != null) {
        const topic = this.toTopic(messageRecord.message.topic);
        switch (acceptance) {
          case TopicValidatorResult.Accept:
            this.acceptedMessagesTotal.inc({ topic });
            break;
          case TopicValidatorResult.Ignore:
            this.ignoredMessagesTotal.inc({ topic });
            break;
          case TopicValidatorResult.Reject:
            this.rejectedMessagesTotal.inc({ topic });
            break;
          default:
            this.unknownValidationResultsTotal.inc({ topic });
            break;
        }
      }
      if (firstSeenTimestampMs != null) {
        this.asyncValidationDelayFromFirstSeenSec.observe((Date.now() - firstSeenTimestampMs) / 1e3);
      } else {
        this.asyncValidationUnknownFirstSeen.inc();
      }
    },
    /**
     * - in handle_graft() Penalty::GraftBackoff
     * - in apply_iwant_penalties() Penalty::BrokenPromise
     * - in metric_score() P3 Penalty::MessageDeficit
     * - in metric_score() P6 Penalty::IPColocation
     */
    onScorePenalty(penalty) {
      this.scoringPenalties.inc({ penalty }, 1);
    },
    onIhaveRcv(topicStr, ihave, idonthave) {
      const topic = this.toTopic(topicStr);
      this.ihaveRcvMsgids.inc({ topic }, ihave);
      this.ihaveRcvNotSeenMsgids.inc({ topic }, idonthave);
    },
    onIwantRcv(iwantByTopic, iwantDonthave) {
      for (const [topicStr, iwant] of iwantByTopic) {
        const topic = this.toTopic(topicStr);
        this.iwantRcvMsgids.inc({ topic }, iwant);
      }
      this.iwantRcvDonthaveMsgids.inc(iwantDonthave);
    },
    onForwardMsg(topicStr, tosendCount) {
      const topic = this.toTopic(topicStr);
      this.msgForwardCount.inc({ topic }, 1);
      this.msgForwardPeers.inc({ topic }, tosendCount);
    },
    onPublishMsg(topicStr, tosendGroupCount, tosendCount, dataLen, ms) {
      const topic = this.toTopic(topicStr);
      this.msgPublishCount.inc({ topic }, 1);
      this.msgPublishBytes.inc({ topic }, tosendCount * dataLen);
      this.msgPublishPeersByTopic.inc({ topic }, tosendCount);
      this.directPeersPublishedTotal.inc({ topic }, tosendGroupCount.direct);
      this.floodsubPeersPublishedTotal.inc({ topic }, tosendGroupCount.floodsub);
      this.meshPeersPublishedTotal.inc({ topic }, tosendGroupCount.mesh);
      this.fanoutPeersPublishedTotal.inc({ topic }, tosendGroupCount.fanout);
      this.msgPublishTime.observe({ topic }, ms / 1e3);
    },
    onMsgRecvPreValidation(topicStr) {
      const topic = this.toTopic(topicStr);
      this.msgReceivedPreValidation.inc({ topic }, 1);
    },
    onMsgRecvError(topicStr) {
      const topic = this.toTopic(topicStr);
      this.msgReceivedError.inc({ topic }, 1);
    },
    onPrevalidationResult(topicStr, status) {
      const topic = this.toTopic(topicStr);
      switch (status) {
        case MessageStatus.duplicate:
          this.prevalidationDuplicateTotal.inc({ topic });
          break;
        case MessageStatus.invalid:
          this.prevalidationInvalidTotal.inc({ topic });
          break;
        case MessageStatus.valid:
          this.prevalidationValidTotal.inc({ topic });
          break;
        default:
          this.prevalidationUnknownTotal.inc({ topic });
          break;
      }
    },
    onMsgRecvInvalid(topicStr, reason) {
      const topic = this.toTopic(topicStr);
      const error = reason.reason === RejectReason.Error ? reason.error : reason.reason;
      this.msgReceivedInvalid.inc({ error }, 1);
      this.msgReceivedInvalidByTopic.inc({ topic }, 1);
    },
    onDuplicateMsgDelivery(topicStr, deliveryDelayMs, isLateDelivery) {
      this.duplicateMsgDeliveryDelay.observe(deliveryDelayMs / 1e3);
      if (isLateDelivery) {
        const topic = this.toTopic(topicStr);
        this.duplicateMsgLateDelivery.inc({ topic }, 1);
      }
    },
    onPublishDuplicateMsg(topicStr) {
      const topic = this.toTopic(topicStr);
      this.duplicateMsgIgnored.inc({ topic }, 1);
    },
    onPeerReadStreamError() {
      this.peerReadStreamError.inc(1);
    },
    onRpcRecvError() {
      this.rpcRecvError.inc(1);
    },
    onRpcDataError() {
      this.rpcDataError.inc(1);
    },
    onRpcRecv(rpc, rpcBytes) {
      this.rpcRecvBytes.inc(rpcBytes);
      this.rpcRecvCount.inc(1);
      if (rpc.subscriptions)
        this.rpcRecvSubscription.inc(rpc.subscriptions.length);
      if (rpc.messages)
        this.rpcRecvMessage.inc(rpc.messages.length);
      if (rpc.control) {
        this.rpcRecvControl.inc(1);
        if (rpc.control.ihave)
          this.rpcRecvIHave.inc(rpc.control.ihave.length);
        if (rpc.control.iwant)
          this.rpcRecvIWant.inc(rpc.control.iwant.length);
        if (rpc.control.graft)
          this.rpcRecvGraft.inc(rpc.control.graft.length);
        if (rpc.control.prune)
          this.rpcRecvPrune.inc(rpc.control.prune.length);
      }
    },
    onRpcSent(rpc, rpcBytes) {
      var _a4, _b4, _c, _d;
      this.rpcSentBytes.inc(rpcBytes);
      this.rpcSentCount.inc(1);
      if (rpc.subscriptions)
        this.rpcSentSubscription.inc(rpc.subscriptions.length);
      if (rpc.messages)
        this.rpcSentMessage.inc(rpc.messages.length);
      if (rpc.control) {
        const ihave = ((_a4 = rpc.control.ihave) == null ? void 0 : _a4.length) ?? 0;
        const iwant = ((_b4 = rpc.control.iwant) == null ? void 0 : _b4.length) ?? 0;
        const graft = ((_c = rpc.control.graft) == null ? void 0 : _c.length) ?? 0;
        const prune = ((_d = rpc.control.prune) == null ? void 0 : _d.length) ?? 0;
        if (ihave > 0)
          this.rpcSentIHave.inc(ihave);
        if (iwant > 0)
          this.rpcSentIWant.inc(iwant);
        if (graft > 0)
          this.rpcSentGraft.inc(graft);
        if (prune > 0)
          this.rpcSentPrune.inc(prune);
        if (ihave > 0 || iwant > 0 || graft > 0 || prune > 0)
          this.rpcSentControl.inc(1);
      }
    },
    registerScores(scores, scoreThresholds) {
      let graylist = 0;
      let publish = 0;
      let gossip = 0;
      let mesh = 0;
      for (const score of scores) {
        if (score >= scoreThresholds.graylistThreshold)
          graylist++;
        if (score >= scoreThresholds.publishThreshold)
          publish++;
        if (score >= scoreThresholds.gossipThreshold)
          gossip++;
        if (score >= 0)
          mesh++;
      }
      this.peersByScoreThreshold.set({ threshold: ScoreThreshold.graylist }, graylist);
      this.peersByScoreThreshold.set({ threshold: ScoreThreshold.publish }, publish);
      this.peersByScoreThreshold.set({ threshold: ScoreThreshold.gossip }, gossip);
      this.peersByScoreThreshold.set({ threshold: ScoreThreshold.mesh }, mesh);
      this.score.set(scores);
    },
    registerScoreWeights(sw) {
      for (const [topic, wsTopic] of sw.byTopic) {
        this.scoreWeights.set({ topic, p: "p1" }, wsTopic.p1w);
        this.scoreWeights.set({ topic, p: "p2" }, wsTopic.p2w);
        this.scoreWeights.set({ topic, p: "p3" }, wsTopic.p3w);
        this.scoreWeights.set({ topic, p: "p3b" }, wsTopic.p3bw);
        this.scoreWeights.set({ topic, p: "p4" }, wsTopic.p4w);
      }
      this.scoreWeights.set({ p: "p5" }, sw.p5w);
      this.scoreWeights.set({ p: "p6" }, sw.p6w);
      this.scoreWeights.set({ p: "p7" }, sw.p7w);
    },
    registerScorePerMesh(mesh, scoreByPeer) {
      const peersPerTopicLabel = /* @__PURE__ */ new Map();
      mesh.forEach((peers, topicStr) => {
        const topicLabel = this.topicStrToLabel.get(topicStr) ?? "unknown";
        let peersInMesh = peersPerTopicLabel.get(topicLabel);
        if (!peersInMesh) {
          peersInMesh = /* @__PURE__ */ new Set();
          peersPerTopicLabel.set(topicLabel, peersInMesh);
        }
        peers.forEach((p) => peersInMesh == null ? void 0 : peersInMesh.add(p));
      });
      for (const [topic, peers] of peersPerTopicLabel) {
        const meshScores = [];
        peers.forEach((peer) => {
          meshScores.push(scoreByPeer.get(peer) ?? 0);
        });
        this.scorePerMesh.set({ topic }, meshScores);
      }
    }
  };
}

// node_modules/@libp2p/crypto/dist/src/aes/ciphers-browser.js
var import_aes = __toESM(require_aes(), 1);
var import_forge6 = __toESM(require_forge(), 1);

// node_modules/@libp2p/crypto/dist/src/pbkdf2.js
var import_pbkdf2 = __toESM(require_pbkdf2(), 1);
var import_util5 = __toESM(require_util(), 1);
var hashName = {
  sha1: "sha1",
  "sha2-256": "sha256",
  "sha2-512": "sha512"
};
function pbkdf2(password, salt, iterations, keySize2, hash2) {
  if (hash2 !== "sha1" && hash2 !== "sha2-256" && hash2 !== "sha2-512") {
    const types = Object.keys(hashName).join(" / ");
    throw new CodeError(`Hash '${hash2}' is unknown or not supported. Must be ${types}`, "ERR_UNSUPPORTED_HASH_TYPE");
  }
  const hasher = hashName[hash2];
  const dek = (0, import_pbkdf2.default)(password, salt, iterations, keySize2, hasher);
  return import_util5.default.encode64(dek, null);
}

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/buildRawMessage.js
var SignPrefix = fromString("libp2p-pubsub:");
async function buildRawMessage(publishConfig, topic, originalData, transformedData) {
  switch (publishConfig.type) {
    case PublishConfigType.Signing: {
      const rpcMsg = {
        from: publishConfig.author.toBytes(),
        data: transformedData,
        seqno: randomBytes2(8),
        topic,
        signature: void 0,
        key: void 0
        // Exclude key field for signing
      };
      const bytes2 = concat([SignPrefix, RPC.Message.encode(rpcMsg).finish()]);
      rpcMsg.signature = await publishConfig.privateKey.sign(bytes2);
      rpcMsg.key = publishConfig.key;
      const msg = {
        type: "signed",
        from: publishConfig.author,
        data: originalData,
        sequenceNumber: BigInt(`0x${toString(rpcMsg.seqno, "base16")}`),
        topic,
        signature: rpcMsg.signature,
        key: rpcMsg.key
      };
      return {
        raw: rpcMsg,
        msg
      };
    }
    case PublishConfigType.Anonymous: {
      return {
        raw: {
          from: void 0,
          data: transformedData,
          seqno: void 0,
          topic,
          signature: void 0,
          key: void 0
        },
        msg: {
          type: "unsigned",
          data: originalData,
          topic
        }
      };
    }
  }
}
async function validateToRawMessage(signaturePolicy, msg) {
  switch (signaturePolicy) {
    case StrictNoSign:
      if (msg.signature != null)
        return { valid: false, error: ValidateError.SignaturePresent };
      if (msg.seqno != null)
        return { valid: false, error: ValidateError.SeqnoPresent };
      if (msg.key != null)
        return { valid: false, error: ValidateError.FromPresent };
      return { valid: true, message: { type: "unsigned", topic: msg.topic, data: msg.data ?? new Uint8Array(0) } };
    case StrictSign: {
      if (msg.seqno == null)
        return { valid: false, error: ValidateError.InvalidSeqno };
      if (msg.seqno.length !== 8) {
        return { valid: false, error: ValidateError.InvalidSeqno };
      }
      if (msg.signature == null)
        return { valid: false, error: ValidateError.InvalidSignature };
      if (msg.from == null)
        return { valid: false, error: ValidateError.InvalidPeerId };
      let fromPeerId;
      try {
        fromPeerId = peerIdFromBytes(msg.from);
      } catch (e) {
        return { valid: false, error: ValidateError.InvalidPeerId };
      }
      let publicKey;
      if (msg.key) {
        publicKey = unmarshalPublicKey(msg.key);
        if (fromPeerId.publicKey !== void 0 && !equals(publicKey.bytes, fromPeerId.publicKey)) {
          return { valid: false, error: ValidateError.InvalidPeerId };
        }
      } else {
        if (fromPeerId.publicKey == null) {
          return { valid: false, error: ValidateError.InvalidPeerId };
        }
        publicKey = unmarshalPublicKey(fromPeerId.publicKey);
      }
      const rpcMsgPreSign = {
        from: msg.from,
        data: msg.data,
        seqno: msg.seqno,
        topic: msg.topic,
        signature: void 0,
        key: void 0
        // Exclude key field for signing
      };
      const bytes2 = concat([SignPrefix, RPC.Message.encode(rpcMsgPreSign).finish()]);
      if (!await publicKey.verify(bytes2, msg.signature)) {
        return { valid: false, error: ValidateError.InvalidSignature };
      }
      return {
        valid: true,
        message: {
          type: "signed",
          from: fromPeerId,
          data: msg.data ?? new Uint8Array(0),
          sequenceNumber: BigInt(`0x${toString(msg.seqno, "base16")}`),
          topic: msg.topic,
          signature: msg.signature,
          key: msg.key ?? marshalPublicKey(publicKey)
        }
      };
    }
  }
}

// node_modules/@chainsafe/libp2p-gossipsub/node_modules/multiformats/src/bytes.js
var empty2 = new Uint8Array(0);

// node_modules/@chainsafe/libp2p-gossipsub/node_modules/multiformats/vendor/varint.js
var encode_12 = encode7;
var MSB3 = 128;
var REST3 = 127;
var MSBALL2 = ~REST3;
var INT2 = Math.pow(2, 31);
function encode7(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT2) {
    out[offset++] = num & 255 | MSB3;
    num /= 128;
  }
  while (num & MSBALL2) {
    out[offset++] = num & 255 | MSB3;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode7.bytes = offset - oldOffset + 1;
  return out;
}
var decode6 = read2;
var MSB$12 = 128;
var REST$12 = 127;
function read2(buf, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
  do {
    if (counter >= l) {
      read2.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf[counter++];
    res += shift < 28 ? (b & REST$12) << shift : (b & REST$12) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$12);
  read2.bytes = counter - offset;
  return res;
}
var N12 = Math.pow(2, 7);
var N22 = Math.pow(2, 14);
var N32 = Math.pow(2, 21);
var N42 = Math.pow(2, 28);
var N52 = Math.pow(2, 35);
var N62 = Math.pow(2, 42);
var N72 = Math.pow(2, 49);
var N82 = Math.pow(2, 56);
var N92 = Math.pow(2, 63);
var length2 = function(value) {
  return value < N12 ? 1 : value < N22 ? 2 : value < N32 ? 3 : value < N42 ? 4 : value < N52 ? 5 : value < N62 ? 6 : value < N72 ? 7 : value < N82 ? 8 : value < N92 ? 9 : 10;
};
var varint2 = {
  encode: encode_12,
  decode: decode6,
  encodingLength: length2
};
var _brrp_varint2 = varint2;
var varint_default2 = _brrp_varint2;

// node_modules/@chainsafe/libp2p-gossipsub/node_modules/multiformats/src/varint.js
var encodeTo2 = (int, target, offset = 0) => {
  varint_default2.encode(int, target, offset);
  return target;
};
var encodingLength3 = (int) => {
  return varint_default2.encodingLength(int);
};

// node_modules/@chainsafe/libp2p-gossipsub/node_modules/multiformats/src/hashes/digest.js
var create4 = (code2, digest2) => {
  const size = digest2.byteLength;
  const sizeOffset = encodingLength3(code2);
  const digestOffset = sizeOffset + encodingLength3(size);
  const bytes2 = new Uint8Array(digestOffset + size);
  encodeTo2(code2, bytes2, 0);
  encodeTo2(size, bytes2, sizeOffset);
  bytes2.set(digest2, digestOffset);
  return new Digest2(code2, size, digest2, bytes2);
};
var Digest2 = class {
  /**
   * Creates a multihash digest.
   *
   * @param {Code} code
   * @param {Size} size
   * @param {Uint8Array} digest
   * @param {Uint8Array} bytes
   */
  constructor(code2, size, digest2, bytes2) {
    this.code = code2;
    this.size = size;
    this.digest = digest2;
    this.bytes = bytes2;
  }
};

// node_modules/@chainsafe/libp2p-gossipsub/node_modules/multiformats/src/hashes/hasher.js
var from3 = ({ name: name2, code: code2, encode: encode12 }) => new Hasher2(name2, code2, encode12);
var Hasher2 = class {
  /**
   *
   * @param {Name} name
   * @param {Code} code
   * @param {(input: Uint8Array) => Await<Uint8Array>} encode
   */
  constructor(name2, code2, encode12) {
    this.name = name2;
    this.code = code2;
    this.encode = encode12;
  }
  /**
   * @param {Uint8Array} input
   * @returns {Await<Digest.Digest<Code, number>>}
   */
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create4(this.code, result) : result.then((digest2) => create4(this.code, digest2));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/@chainsafe/libp2p-gossipsub/node_modules/multiformats/src/hashes/sha2-browser.js
var sha2 = (name2) => (
  /**
   * @param {Uint8Array} data
   */
  async (data) => new Uint8Array(await crypto.subtle.digest(name2, data))
);
var sha2563 = from3({
  name: "sha2-256",
  code: 18,
  encode: sha2("SHA-256")
});
var sha5123 = from3({
  name: "sha2-512",
  code: 19,
  encode: sha2("SHA-512")
});

// node_modules/@libp2p/pubsub/node_modules/multiformats/src/bytes.js
var empty3 = new Uint8Array(0);

// node_modules/@libp2p/pubsub/node_modules/multiformats/vendor/varint.js
var encode_13 = encode8;
var MSB4 = 128;
var REST4 = 127;
var MSBALL3 = ~REST4;
var INT3 = Math.pow(2, 31);
function encode8(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT3) {
    out[offset++] = num & 255 | MSB4;
    num /= 128;
  }
  while (num & MSBALL3) {
    out[offset++] = num & 255 | MSB4;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode8.bytes = offset - oldOffset + 1;
  return out;
}
var decode8 = read3;
var MSB$13 = 128;
var REST$13 = 127;
function read3(buf, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
  do {
    if (counter >= l) {
      read3.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf[counter++];
    res += shift < 28 ? (b & REST$13) << shift : (b & REST$13) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$13);
  read3.bytes = counter - offset;
  return res;
}
var N13 = Math.pow(2, 7);
var N23 = Math.pow(2, 14);
var N33 = Math.pow(2, 21);
var N43 = Math.pow(2, 28);
var N53 = Math.pow(2, 35);
var N63 = Math.pow(2, 42);
var N73 = Math.pow(2, 49);
var N83 = Math.pow(2, 56);
var N93 = Math.pow(2, 63);
var length3 = function(value) {
  return value < N13 ? 1 : value < N23 ? 2 : value < N33 ? 3 : value < N43 ? 4 : value < N53 ? 5 : value < N63 ? 6 : value < N73 ? 7 : value < N83 ? 8 : value < N93 ? 9 : 10;
};
var varint3 = {
  encode: encode_13,
  decode: decode8,
  encodingLength: length3
};
var _brrp_varint3 = varint3;
var varint_default3 = _brrp_varint3;

// node_modules/@libp2p/pubsub/node_modules/multiformats/src/varint.js
var encodeTo3 = (int, target, offset = 0) => {
  varint_default3.encode(int, target, offset);
  return target;
};
var encodingLength4 = (int) => {
  return varint_default3.encodingLength(int);
};

// node_modules/@libp2p/pubsub/node_modules/multiformats/src/hashes/digest.js
var create5 = (code2, digest2) => {
  const size = digest2.byteLength;
  const sizeOffset = encodingLength4(code2);
  const digestOffset = sizeOffset + encodingLength4(size);
  const bytes2 = new Uint8Array(digestOffset + size);
  encodeTo3(code2, bytes2, 0);
  encodeTo3(size, bytes2, sizeOffset);
  bytes2.set(digest2, digestOffset);
  return new Digest3(code2, size, digest2, bytes2);
};
var Digest3 = class {
  /**
   * Creates a multihash digest.
   *
   * @param {Code} code
   * @param {Size} size
   * @param {Uint8Array} digest
   * @param {Uint8Array} bytes
   */
  constructor(code2, size, digest2, bytes2) {
    this.code = code2;
    this.size = size;
    this.digest = digest2;
    this.bytes = bytes2;
  }
};

// node_modules/@libp2p/pubsub/node_modules/multiformats/src/hashes/hasher.js
var from4 = ({ name: name2, code: code2, encode: encode12 }) => new Hasher3(name2, code2, encode12);
var Hasher3 = class {
  /**
   *
   * @param {Name} name
   * @param {Code} code
   * @param {(input: Uint8Array) => Await<Uint8Array>} encode
   */
  constructor(name2, code2, encode12) {
    this.name = name2;
    this.code = code2;
    this.encode = encode12;
  }
  /**
   * @param {Uint8Array} input
   * @returns {Await<Digest.Digest<Code, number>>}
   */
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create5(this.code, result) : result.then((digest2) => create5(this.code, digest2));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/@libp2p/pubsub/node_modules/multiformats/src/hashes/sha2-browser.js
var sha3 = (name2) => (
  /**
   * @param {Uint8Array} data
   */
  async (data) => new Uint8Array(await crypto.subtle.digest(name2, data))
);
var sha2564 = from4({
  name: "sha2-256",
  code: 18,
  encode: sha3("SHA-256")
});
var sha5124 = from4({
  name: "sha2-512",
  code: 19,
  encode: sha3("SHA-512")
});

// node_modules/@libp2p/pubsub/dist/src/utils.js
var msgId = (key, seqno) => {
  const seqnoBytes = fromString(seqno.toString(16).padStart(16, "0"), "base16");
  const msgId2 = new Uint8Array(key.length + seqnoBytes.length);
  msgId2.set(key, 0);
  msgId2.set(seqnoBytes, key.length);
  return msgId2;
};

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/msgIdFn.js
function msgIdFnStrictSign(msg) {
  if (msg.type !== "signed") {
    throw new Error("expected signed message type");
  }
  if (msg.sequenceNumber == null)
    throw Error("missing seqno field");
  return msgId(msg.from.toBytes(), msg.sequenceNumber);
}
async function msgIdFnStrictNoSign(msg) {
  return await sha2563.encode(msg.data);
}

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/scoreMetrics.js
function computeScoreWeights(peer, pstats, params, peerIPs, topicStrToLabel) {
  let score = 0;
  const byTopic = /* @__PURE__ */ new Map();
  Object.entries(pstats.topics).forEach(([topic, tstats]) => {
    const topicLabel = topicStrToLabel.get(topic) ?? "unknown";
    const topicParams = params.topics[topic];
    if (topicParams === void 0) {
      return;
    }
    let topicScores = byTopic.get(topicLabel);
    if (!topicScores) {
      topicScores = {
        p1w: 0,
        p2w: 0,
        p3w: 0,
        p3bw: 0,
        p4w: 0
      };
      byTopic.set(topicLabel, topicScores);
    }
    let p1w = 0;
    let p2w = 0;
    let p3w = 0;
    let p3bw = 0;
    let p4w = 0;
    if (tstats.inMesh) {
      const p1 = Math.max(tstats.meshTime / topicParams.timeInMeshQuantum, topicParams.timeInMeshCap);
      p1w += p1 * topicParams.timeInMeshWeight;
    }
    let p2 = tstats.firstMessageDeliveries;
    if (p2 > topicParams.firstMessageDeliveriesCap) {
      p2 = topicParams.firstMessageDeliveriesCap;
    }
    p2w += p2 * topicParams.firstMessageDeliveriesWeight;
    if (tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < topicParams.meshMessageDeliveriesThreshold) {
      const deficit = topicParams.meshMessageDeliveriesThreshold - tstats.meshMessageDeliveries;
      const p3 = deficit * deficit;
      p3w += p3 * topicParams.meshMessageDeliveriesWeight;
    }
    const p3b = tstats.meshFailurePenalty;
    p3bw += p3b * topicParams.meshFailurePenaltyWeight;
    const p4 = tstats.invalidMessageDeliveries * tstats.invalidMessageDeliveries;
    p4w += p4 * topicParams.invalidMessageDeliveriesWeight;
    score += (p1w + p2w + p3w + p3bw + p4w) * topicParams.topicWeight;
    topicScores.p1w += p1w;
    topicScores.p2w += p2w;
    topicScores.p3w += p3w;
    topicScores.p3bw += p3bw;
    topicScores.p4w += p4w;
  });
  if (params.topicScoreCap > 0 && score > params.topicScoreCap) {
    score = params.topicScoreCap;
    const capF = params.topicScoreCap / score;
    for (const ws of byTopic.values()) {
      ws.p1w *= capF;
      ws.p2w *= capF;
      ws.p3w *= capF;
      ws.p3bw *= capF;
      ws.p4w *= capF;
    }
  }
  let p5w = 0;
  let p6w = 0;
  let p7w = 0;
  const p5 = params.appSpecificScore(peer);
  p5w += p5 * params.appSpecificWeight;
  pstats.knownIPs.forEach((ip) => {
    if (params.IPColocationFactorWhitelist.has(ip)) {
      return;
    }
    const peersInIP = peerIPs.get(ip);
    const numPeersInIP = peersInIP ? peersInIP.size : 0;
    if (numPeersInIP > params.IPColocationFactorThreshold) {
      const surplus = numPeersInIP - params.IPColocationFactorThreshold;
      const p6 = surplus * surplus;
      p6w += p6 * params.IPColocationFactorWeight;
    }
  });
  const p7 = pstats.behaviourPenalty * pstats.behaviourPenalty;
  p7w += p7 * params.behaviourPenaltyWeight;
  score += p5w + p6w + p7w;
  return {
    byTopic,
    p5w,
    p6w,
    p7w,
    score
  };
}
function computeAllPeersScoreWeights(peerIdStrs, peerStats, params, peerIPs, topicStrToLabel) {
  const sw = {
    byTopic: /* @__PURE__ */ new Map(),
    p5w: [],
    p6w: [],
    p7w: [],
    score: []
  };
  for (const peerIdStr of peerIdStrs) {
    const pstats = peerStats.get(peerIdStr);
    if (pstats) {
      const swPeer = computeScoreWeights(peerIdStr, pstats, params, peerIPs, topicStrToLabel);
      for (const [topic, swPeerTopic] of swPeer.byTopic) {
        let swTopic = sw.byTopic.get(topic);
        if (!swTopic) {
          swTopic = {
            p1w: [],
            p2w: [],
            p3w: [],
            p3bw: [],
            p4w: []
          };
          sw.byTopic.set(topic, swTopic);
        }
        swTopic.p1w.push(swPeerTopic.p1w);
        swTopic.p2w.push(swPeerTopic.p2w);
        swTopic.p3w.push(swPeerTopic.p3w);
        swTopic.p3bw.push(swPeerTopic.p3bw);
        swTopic.p4w.push(swPeerTopic.p4w);
      }
      sw.p5w.push(swPeer.p5w);
      sw.p6w.push(swPeer.p6w);
      sw.p7w.push(swPeer.p7w);
      sw.score.push(swPeer.score);
    } else {
      sw.p5w.push(0);
      sw.p6w.push(0);
      sw.p7w.push(0);
      sw.score.push(0);
    }
  }
  return sw;
}

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/stream.js
var OutboundStream = class {
  constructor(rawStream, errCallback, opts) {
    __publicField(this, "rawStream");
    __publicField(this, "pushable");
    __publicField(this, "closeController");
    __publicField(this, "maxBufferSize");
    this.rawStream = rawStream;
    this.pushable = pushable({ objectMode: false });
    this.closeController = new AbortController();
    this.maxBufferSize = opts.maxBufferSize ?? Infinity;
    pipe(abortableSource(this.pushable, this.closeController.signal, { returnOnAbort: true }), (source) => encode2(source), this.rawStream).catch(errCallback);
  }
  get protocol() {
    return this.rawStream.protocol;
  }
  push(data) {
    if (this.pushable.readableLength > this.maxBufferSize) {
      throw Error(`OutboundStream buffer full, size > ${this.maxBufferSize}`);
    }
    this.pushable.push(data);
  }
  close() {
    this.closeController.abort();
    this.pushable.return();
    this.rawStream.close();
  }
};
var InboundStream = class {
  constructor(rawStream, opts = {}) {
    __publicField(this, "source");
    __publicField(this, "rawStream");
    __publicField(this, "closeController");
    this.rawStream = rawStream;
    this.closeController = new AbortController();
    this.source = abortableSource(pipe(this.rawStream, (source) => decode2(source, opts)), this.closeController.signal, {
      returnOnAbort: true
    });
  }
  close() {
    this.closeController.abort();
    this.rawStream.close();
  }
};

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/message/decodeRpc.js
var import_minimal = __toESM(require_minimal(), 1);
var defaultDecodeRpcLimits = {
  maxSubscriptions: Infinity,
  maxMessages: Infinity,
  maxIhaveMessageIDs: Infinity,
  maxIwantMessageIDs: Infinity,
  maxControlMessages: Infinity,
  maxPeerInfos: Infinity
};
function decodeRpc(bytes2, opts) {
  opts = { ...opts };
  const r = import_minimal.default.Reader.create(bytes2);
  const l = bytes2.length;
  const c = l === void 0 ? r.len : r.pos + l;
  const m = {};
  while (r.pos < c) {
    const t = r.uint32();
    switch (t >>> 3) {
      case 1:
        if (!(m.subscriptions && m.subscriptions.length))
          m.subscriptions = [];
        if (m.subscriptions.length < opts.maxSubscriptions)
          m.subscriptions.push(decodeSubOpts(r, r.uint32()));
        else
          r.skipType(t & 7);
        break;
      case 2:
        if (!(m.messages && m.messages.length))
          m.messages = [];
        if (m.messages.length < opts.maxMessages)
          m.messages.push(decodeMessage2(r, r.uint32()));
        else
          r.skipType(t & 7);
        break;
      case 3:
        m.control = decodeControlMessage(r, r.uint32(), opts);
        break;
      default:
        r.skipType(t & 7);
        break;
    }
  }
  return m;
}
function decodeSubOpts(r, l) {
  const c = l === void 0 ? r.len : r.pos + l;
  const m = {};
  while (r.pos < c) {
    const t = r.uint32();
    switch (t >>> 3) {
      case 1:
        m.subscribe = r.bool();
        break;
      case 2:
        m.topic = r.string();
        break;
      default:
        r.skipType(t & 7);
        break;
    }
  }
  return m;
}
function decodeMessage2(r, l) {
  const c = l === void 0 ? r.len : r.pos + l;
  const m = {};
  while (r.pos < c) {
    const t = r.uint32();
    switch (t >>> 3) {
      case 1:
        m.from = r.bytes();
        break;
      case 2:
        m.data = r.bytes();
        break;
      case 3:
        m.seqno = r.bytes();
        break;
      case 4:
        m.topic = r.string();
        break;
      case 5:
        m.signature = r.bytes();
        break;
      case 6:
        m.key = r.bytes();
        break;
      default:
        r.skipType(t & 7);
        break;
    }
  }
  if (!m.topic)
    throw Error("missing required 'topic'");
  return m;
}
function decodeControlMessage(r, l, opts) {
  const c = l === void 0 ? r.len : r.pos + l;
  const m = {};
  while (r.pos < c) {
    const t = r.uint32();
    switch (t >>> 3) {
      case 1:
        if (!(m.ihave && m.ihave.length))
          m.ihave = [];
        if (m.ihave.length < opts.maxControlMessages)
          m.ihave.push(decodeControlIHave(r, r.uint32(), opts));
        else
          r.skipType(t & 7);
        break;
      case 2:
        if (!(m.iwant && m.iwant.length))
          m.iwant = [];
        if (m.iwant.length < opts.maxControlMessages)
          m.iwant.push(decodeControlIWant(r, r.uint32(), opts));
        else
          r.skipType(t & 7);
        break;
      case 3:
        if (!(m.graft && m.graft.length))
          m.graft = [];
        if (m.graft.length < opts.maxControlMessages)
          m.graft.push(decodeControlGraft(r, r.uint32()));
        else
          r.skipType(t & 7);
        break;
      case 4:
        if (!(m.prune && m.prune.length))
          m.prune = [];
        if (m.prune.length < opts.maxControlMessages)
          m.prune.push(decodeControlPrune(r, r.uint32(), opts));
        else
          r.skipType(t & 7);
        break;
      default:
        r.skipType(t & 7);
        break;
    }
  }
  return m;
}
function decodeControlIHave(r, l, opts) {
  const c = l === void 0 ? r.len : r.pos + l;
  const m = {};
  while (r.pos < c) {
    const t = r.uint32();
    switch (t >>> 3) {
      case 1:
        m.topicID = r.string();
        break;
      case 2:
        if (!(m.messageIDs && m.messageIDs.length))
          m.messageIDs = [];
        if (opts.maxIhaveMessageIDs-- > 0)
          m.messageIDs.push(r.bytes());
        else
          r.skipType(t & 7);
        break;
      default:
        r.skipType(t & 7);
        break;
    }
  }
  return m;
}
function decodeControlIWant(r, l, opts) {
  const c = l === void 0 ? r.len : r.pos + l;
  const m = {};
  while (r.pos < c) {
    const t = r.uint32();
    switch (t >>> 3) {
      case 1:
        if (!(m.messageIDs && m.messageIDs.length))
          m.messageIDs = [];
        if (opts.maxIwantMessageIDs-- > 0)
          m.messageIDs.push(r.bytes());
        else
          r.skipType(t & 7);
        break;
      default:
        r.skipType(t & 7);
        break;
    }
  }
  return m;
}
function decodeControlGraft(r, l) {
  const c = l === void 0 ? r.len : r.pos + l;
  const m = {};
  while (r.pos < c) {
    const t = r.uint32();
    switch (t >>> 3) {
      case 1:
        m.topicID = r.string();
        break;
      default:
        r.skipType(t & 7);
        break;
    }
  }
  return m;
}
function decodeControlPrune(r, l, opts) {
  const c = l === void 0 ? r.len : r.pos + l;
  const m = {};
  while (r.pos < c) {
    const t = r.uint32();
    switch (t >>> 3) {
      case 1:
        m.topicID = r.string();
        break;
      case 2:
        if (!(m.peers && m.peers.length))
          m.peers = [];
        if (opts.maxPeerInfos-- > 0)
          m.peers.push(decodePeerInfo(r, r.uint32()));
        else
          r.skipType(t & 7);
        break;
      case 3:
        m.backoff = r.uint64();
        break;
      default:
        r.skipType(t & 7);
        break;
    }
  }
  return m;
}
function decodePeerInfo(r, l) {
  const c = l === void 0 ? r.len : r.pos + l;
  const m = {};
  while (r.pos < c) {
    const t = r.uint32();
    switch (t >>> 3) {
      case 1:
        m.peerID = r.bytes();
        break;
      case 2:
        m.signedPeerRecord = r.bytes();
        break;
      default:
        r.skipType(t & 7);
        break;
    }
  }
  return m;
}

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/multiaddr.js
var Protocol;
(function(Protocol2) {
  Protocol2[Protocol2["ip4"] = 4] = "ip4";
  Protocol2[Protocol2["ip6"] = 41] = "ip6";
})(Protocol || (Protocol = {}));
function multiaddrToIPStr(multiaddr2) {
  for (const tuple of multiaddr2.tuples()) {
    switch (tuple[0]) {
      case Protocol.ip4:
      case Protocol.ip6:
        return convertToString(tuple[0], tuple[1]);
    }
  }
  return null;
}

// node_modules/@chainsafe/libp2p-gossipsub/dist/src/index.js
var GossipStatusCode;
(function(GossipStatusCode2) {
  GossipStatusCode2[GossipStatusCode2["started"] = 0] = "started";
  GossipStatusCode2[GossipStatusCode2["stopped"] = 1] = "stopped";
})(GossipStatusCode || (GossipStatusCode = {}));
var GossipSub = class extends TypedEventEmitter {
  constructor(components, options = {}) {
    super();
    /**
     * The signature policy to follow by default
     */
    __publicField(this, "globalSignaturePolicy");
    __publicField(this, "multicodecs", [GossipsubIDv11, GossipsubIDv10]);
    __publicField(this, "publishConfig");
    __publicField(this, "dataTransform");
    // State
    __publicField(this, "peers", /* @__PURE__ */ new Set());
    __publicField(this, "streamsInbound", /* @__PURE__ */ new Map());
    __publicField(this, "streamsOutbound", /* @__PURE__ */ new Map());
    /** Ensures outbound streams are created sequentially */
    __publicField(this, "outboundInflightQueue", pushable({ objectMode: true }));
    /** Direct peers */
    __publicField(this, "direct", /* @__PURE__ */ new Set());
    /** Floodsub peers */
    __publicField(this, "floodsubPeers", /* @__PURE__ */ new Set());
    /** Cache of seen messages */
    __publicField(this, "seenCache");
    /**
     * Map of peer id and AcceptRequestWhileListEntry
     */
    __publicField(this, "acceptFromWhitelist", /* @__PURE__ */ new Map());
    /**
     * Map of topics to which peers are subscribed to
     */
    __publicField(this, "topics", /* @__PURE__ */ new Map());
    /**
     * List of our subscriptions
     */
    __publicField(this, "subscriptions", /* @__PURE__ */ new Set());
    /**
     * Map of topic meshes
     * topic => peer id set
     */
    __publicField(this, "mesh", /* @__PURE__ */ new Map());
    /**
     * Map of topics to set of peers. These mesh peers are the ones to which we are publishing without a topic membership
     * topic => peer id set
     */
    __publicField(this, "fanout", /* @__PURE__ */ new Map());
    /**
     * Map of last publish time for fanout topics
     * topic => last publish time
     */
    __publicField(this, "fanoutLastpub", /* @__PURE__ */ new Map());
    /**
     * Map of pending messages to gossip
     * peer id => control messages
     */
    __publicField(this, "gossip", /* @__PURE__ */ new Map());
    /**
     * Map of control messages
     * peer id => control message
     */
    __publicField(this, "control", /* @__PURE__ */ new Map());
    /**
     * Number of IHAVEs received from peer in the last heartbeat
     */
    __publicField(this, "peerhave", /* @__PURE__ */ new Map());
    /** Number of messages we have asked from peer in the last heartbeat */
    __publicField(this, "iasked", /* @__PURE__ */ new Map());
    /** Prune backoff map */
    __publicField(this, "backoff", /* @__PURE__ */ new Map());
    /**
     * Connection direction cache, marks peers with outbound connections
     * peer id => direction
     */
    __publicField(this, "outbound", /* @__PURE__ */ new Map());
    __publicField(this, "msgIdFn");
    /**
     * A fast message id function used for internal message de-duplication
     */
    __publicField(this, "fastMsgIdFn");
    __publicField(this, "msgIdToStrFn");
    /** Maps fast message-id to canonical message-id */
    __publicField(this, "fastMsgIdCache");
    /**
     * Short term cache for published message ids. This is used for penalizing peers sending
     * our own messages back if the messages are anonymous or use a random author.
     */
    __publicField(this, "publishedMessageIds");
    /**
     * A message cache that contains the messages for last few heartbeat ticks
     */
    __publicField(this, "mcache");
    /** Peer score tracking */
    __publicField(this, "score");
    /**
     * Custom validator function per topic.
     * Must return or resolve quickly (< 100ms) to prevent causing penalties for late messages.
     * If you need to apply validation that may require longer times use `asyncValidation` option and callback the
     * validation result through `Gossipsub.reportValidationResult`
     */
    __publicField(this, "topicValidators", /* @__PURE__ */ new Map());
    /**
     * Make this protected so child class may want to redirect to its own log.
     */
    __publicField(this, "log");
    /**
     * Number of heartbeats since the beginning of time
     * This allows us to amortize some resource cleanup -- eg: backoff cleanup
     */
    __publicField(this, "heartbeatTicks", 0);
    /**
     * Tracks IHAVE/IWANT promises broken by peers
     */
    __publicField(this, "gossipTracer");
    __publicField(this, "components");
    __publicField(this, "directPeerInitial", null);
    // Options
    __publicField(this, "opts");
    __publicField(this, "decodeRpcLimits");
    __publicField(this, "metrics");
    __publicField(this, "status", { code: GossipStatusCode.stopped });
    __publicField(this, "maxInboundStreams");
    __publicField(this, "maxOutboundStreams");
    __publicField(this, "allowedTopics");
    __publicField(this, "heartbeatTimer", null);
    __publicField(this, "runHeartbeat", () => {
      var _a4;
      const timer = (_a4 = this.metrics) == null ? void 0 : _a4.heartbeatDuration.startTimer();
      this.heartbeat().catch((err) => {
        this.log("Error running heartbeat", err);
      }).finally(() => {
        var _a5;
        if (timer != null) {
          timer();
        }
        if (this.status.code === GossipStatusCode.started) {
          clearTimeout(this.status.heartbeatTimeout);
          let msToNextHeartbeat = this.opts.heartbeatInterval - (Date.now() - this.status.hearbeatStartMs) % this.opts.heartbeatInterval;
          if (msToNextHeartbeat < this.opts.heartbeatInterval * 0.25) {
            msToNextHeartbeat += this.opts.heartbeatInterval;
            (_a5 = this.metrics) == null ? void 0 : _a5.heartbeatSkipped.inc();
          }
          this.status.heartbeatTimeout = setTimeout(this.runHeartbeat, msToNextHeartbeat);
        }
      });
    });
    const opts = {
      fallbackToFloodsub: true,
      floodPublish: true,
      doPX: false,
      directPeers: [],
      D: GossipsubD,
      Dlo: GossipsubDlo,
      Dhi: GossipsubDhi,
      Dscore: GossipsubDscore,
      Dout: GossipsubDout,
      Dlazy: GossipsubDlazy,
      heartbeatInterval: GossipsubHeartbeatInterval,
      fanoutTTL: GossipsubFanoutTTL,
      mcacheLength: GossipsubHistoryLength,
      mcacheGossip: GossipsubHistoryGossip,
      seenTTL: GossipsubSeenTTL,
      gossipsubIWantFollowupMs: GossipsubIWantFollowupTime,
      prunePeers: GossipsubPrunePeers,
      pruneBackoff: GossipsubPruneBackoff,
      unsubcribeBackoff: GossipsubUnsubscribeBackoff,
      graftFloodThreshold: GossipsubGraftFloodThreshold,
      opportunisticGraftPeers: GossipsubOpportunisticGraftPeers,
      opportunisticGraftTicks: GossipsubOpportunisticGraftTicks,
      directConnectTicks: GossipsubDirectConnectTicks,
      ...options,
      scoreParams: createPeerScoreParams(options.scoreParams),
      scoreThresholds: createPeerScoreThresholds(options.scoreThresholds)
    };
    this.components = components;
    this.decodeRpcLimits = opts.decodeRpcLimits ?? defaultDecodeRpcLimits;
    this.globalSignaturePolicy = opts.globalSignaturePolicy ?? StrictSign;
    if (opts.fallbackToFloodsub) {
      this.multicodecs.push(FloodsubID);
    }
    this.log = logger(opts.debugName ?? "libp2p:gossipsub");
    this.opts = opts;
    this.direct = new Set(opts.directPeers.map((p) => p.id.toString()));
    this.seenCache = new SimpleTimeCache({ validityMs: opts.seenTTL });
    this.publishedMessageIds = new SimpleTimeCache({ validityMs: opts.seenTTL });
    if (options.msgIdFn) {
      this.msgIdFn = options.msgIdFn;
    } else {
      switch (this.globalSignaturePolicy) {
        case StrictSign:
          this.msgIdFn = msgIdFnStrictSign;
          break;
        case StrictNoSign:
          this.msgIdFn = msgIdFnStrictNoSign;
          break;
      }
    }
    if (options.fastMsgIdFn) {
      this.fastMsgIdFn = options.fastMsgIdFn;
      this.fastMsgIdCache = new SimpleTimeCache({ validityMs: opts.seenTTL });
    }
    this.msgIdToStrFn = options.msgIdToStrFn ?? messageIdToString;
    this.mcache = options.messageCache || new MessageCache(opts.mcacheGossip, opts.mcacheLength, this.msgIdToStrFn);
    if (options.dataTransform) {
      this.dataTransform = options.dataTransform;
    }
    if (options.metricsRegister) {
      if (!options.metricsTopicStrToLabel) {
        throw Error("Must set metricsTopicStrToLabel with metrics");
      }
      const maxMeshMessageDeliveriesWindowMs = Math.max(...Object.values(opts.scoreParams.topics).map((topicParam) => topicParam.meshMessageDeliveriesWindow), DEFAULT_METRIC_MESH_MESSAGE_DELIVERIES_WINDOWS);
      const metrics = getMetrics(options.metricsRegister, options.metricsTopicStrToLabel, {
        gossipPromiseExpireSec: this.opts.gossipsubIWantFollowupMs / 1e3,
        behaviourPenaltyThreshold: opts.scoreParams.behaviourPenaltyThreshold,
        maxMeshMessageDeliveriesWindowSec: maxMeshMessageDeliveriesWindowMs / 1e3
      });
      metrics.mcacheSize.addCollect(() => this.onScrapeMetrics(metrics));
      for (const protocol of this.multicodecs) {
        metrics.protocolsEnabled.set({ protocol }, 1);
      }
      this.metrics = metrics;
    } else {
      this.metrics = null;
    }
    this.gossipTracer = new IWantTracer(this.opts.gossipsubIWantFollowupMs, this.msgIdToStrFn, this.metrics);
    this.score = new PeerScore(this.opts.scoreParams, this.metrics, {
      scoreCacheValidityMs: opts.heartbeatInterval
    });
    this.maxInboundStreams = options.maxInboundStreams;
    this.maxOutboundStreams = options.maxOutboundStreams;
    this.allowedTopics = opts.allowedTopics ? new Set(opts.allowedTopics) : null;
  }
  getPeers() {
    return [...this.peers.keys()].map((str) => peerIdFromString(str));
  }
  isStarted() {
    return this.status.code === GossipStatusCode.started;
  }
  // LIFECYCLE METHODS
  /**
   * Mounts the gossipsub protocol onto the libp2p node and sends our
   * our subscriptions to every peer connected
   */
  async start() {
    if (this.isStarted()) {
      return;
    }
    this.log("starting");
    this.publishConfig = await getPublishConfigFromPeerId(this.globalSignaturePolicy, this.components.peerId);
    this.outboundInflightQueue = pushable({ objectMode: true });
    pipe(this.outboundInflightQueue, async (source) => {
      for await (const { peerId: peerId2, connection } of source) {
        await this.createOutboundStream(peerId2, connection);
      }
    }).catch((e) => this.log.error("outbound inflight queue error", e));
    await Promise.all(this.opts.directPeers.map(async (p) => {
      await this.components.peerStore.merge(p.id, {
        multiaddrs: p.addrs
      });
    }));
    const registrar = this.components.registrar;
    await Promise.all(this.multicodecs.map((multicodec) => registrar.handle(multicodec, this.onIncomingStream.bind(this), {
      maxInboundStreams: this.maxInboundStreams,
      maxOutboundStreams: this.maxOutboundStreams
    })));
    const topology = {
      onConnect: this.onPeerConnected.bind(this),
      onDisconnect: this.onPeerDisconnected.bind(this)
    };
    const registrarTopologyIds = await Promise.all(this.multicodecs.map((multicodec) => registrar.register(multicodec, topology)));
    const heartbeatTimeout = setTimeout(this.runHeartbeat, GossipsubHeartbeatInitialDelay);
    this.status = {
      code: GossipStatusCode.started,
      registrarTopologyIds,
      heartbeatTimeout,
      hearbeatStartMs: Date.now() + GossipsubHeartbeatInitialDelay
    };
    this.score.start();
    this.directPeerInitial = setTimeout(() => {
      Promise.resolve().then(async () => {
        await Promise.all(Array.from(this.direct).map(async (id) => await this.connect(id)));
      }).catch((err) => {
        this.log(err);
      });
    }, GossipsubDirectConnectInitialDelay);
    this.log("started");
  }
  /**
   * Unmounts the gossipsub protocol and shuts down every connection
   */
  async stop() {
    this.log("stopping");
    if (this.status.code !== GossipStatusCode.started) {
      return;
    }
    const { registrarTopologyIds } = this.status;
    this.status = { code: GossipStatusCode.stopped };
    const registrar = this.components.registrar;
    await Promise.all(this.multicodecs.map((multicodec) => registrar.unhandle(multicodec)));
    registrarTopologyIds.forEach((id) => registrar.unregister(id));
    this.outboundInflightQueue.end();
    for (const outboundStream of this.streamsOutbound.values()) {
      outboundStream.close();
    }
    this.streamsOutbound.clear();
    for (const inboundStream of this.streamsInbound.values()) {
      inboundStream.close();
    }
    this.streamsInbound.clear();
    this.peers.clear();
    this.subscriptions.clear();
    if (this.heartbeatTimer) {
      this.heartbeatTimer.cancel();
      this.heartbeatTimer = null;
    }
    this.score.stop();
    this.mesh.clear();
    this.fanout.clear();
    this.fanoutLastpub.clear();
    this.gossip.clear();
    this.control.clear();
    this.peerhave.clear();
    this.iasked.clear();
    this.backoff.clear();
    this.outbound.clear();
    this.gossipTracer.clear();
    this.seenCache.clear();
    if (this.fastMsgIdCache)
      this.fastMsgIdCache.clear();
    if (this.directPeerInitial)
      clearTimeout(this.directPeerInitial);
    this.log("stopped");
  }
  /** FOR DEBUG ONLY - Dump peer stats for all peers. Data is cloned, safe to mutate */
  dumpPeerScoreStats() {
    return this.score.dumpPeerScoreStats();
  }
  /**
   * On an inbound stream opened
   */
  onIncomingStream({ stream, connection }) {
    if (!this.isStarted()) {
      return;
    }
    const peerId2 = connection.remotePeer;
    this.addPeer(peerId2, connection.direction, connection.remoteAddr);
    this.createInboundStream(peerId2, stream);
    this.outboundInflightQueue.push({ peerId: peerId2, connection });
  }
  /**
   * Registrar notifies an established connection with pubsub protocol
   */
  onPeerConnected(peerId2, connection) {
    var _a4;
    (_a4 = this.metrics) == null ? void 0 : _a4.newConnectionCount.inc({ status: connection.status });
    if (!this.isStarted() || connection.status !== "open") {
      return;
    }
    this.addPeer(peerId2, connection.direction, connection.remoteAddr);
    this.outboundInflightQueue.push({ peerId: peerId2, connection });
  }
  /**
   * Registrar notifies a closing connection with pubsub protocol
   */
  onPeerDisconnected(peerId2) {
    this.log("connection ended %p", peerId2);
    this.removePeer(peerId2);
  }
  async createOutboundStream(peerId2, connection) {
    var _a4;
    if (!this.isStarted()) {
      return;
    }
    const id = peerId2.toString();
    if (!this.peers.has(id)) {
      return;
    }
    if (this.streamsOutbound.has(id)) {
      return;
    }
    try {
      const stream = new OutboundStream(await connection.newStream(this.multicodecs), (e) => this.log.error("outbound pipe error", e), { maxBufferSize: this.opts.maxOutboundBufferSize });
      this.log("create outbound stream %p", peerId2);
      this.streamsOutbound.set(id, stream);
      const protocol = stream.protocol;
      if (protocol === FloodsubID) {
        this.floodsubPeers.add(id);
      }
      (_a4 = this.metrics) == null ? void 0 : _a4.peersPerProtocol.inc({ protocol }, 1);
      if (this.subscriptions.size > 0) {
        this.log("send subscriptions to", id);
        this.sendSubscriptions(id, Array.from(this.subscriptions), true);
      }
    } catch (e) {
      this.log.error("createOutboundStream error", e);
    }
  }
  async createInboundStream(peerId2, stream) {
    if (!this.isStarted()) {
      return;
    }
    const id = peerId2.toString();
    if (!this.peers.has(id)) {
      return;
    }
    const priorInboundStream = this.streamsInbound.get(id);
    if (priorInboundStream !== void 0) {
      this.log("replacing existing inbound steam %s", id);
      priorInboundStream.close();
    }
    this.log("create inbound stream %s", id);
    const inboundStream = new InboundStream(stream, { maxDataLength: this.opts.maxInboundDataLength });
    this.streamsInbound.set(id, inboundStream);
    this.pipePeerReadStream(peerId2, inboundStream.source).catch((err) => this.log(err));
  }
  /**
   * Add a peer to the router
   */
  addPeer(peerId2, direction, addr) {
    const id = peerId2.toString();
    if (!this.peers.has(id)) {
      this.log("new peer %p", peerId2);
      this.peers.add(id);
      this.score.addPeer(id);
      const currentIP = multiaddrToIPStr(addr);
      if (currentIP !== null) {
        this.score.addIP(id, currentIP);
      } else {
        this.log("Added peer has no IP in current address %s %s", id, addr.toString());
      }
      if (!this.outbound.has(id)) {
        this.outbound.set(id, direction === "outbound");
      }
    }
  }
  /**
   * Removes a peer from the router
   */
  removePeer(peerId2) {
    var _a4, _b4;
    const id = peerId2.toString();
    if (!this.peers.has(id)) {
      return;
    }
    this.log("delete peer %p", peerId2);
    this.peers.delete(id);
    const outboundStream = this.streamsOutbound.get(id);
    const inboundStream = this.streamsInbound.get(id);
    if (outboundStream) {
      (_a4 = this.metrics) == null ? void 0 : _a4.peersPerProtocol.inc({ protocol: outboundStream.protocol }, -1);
    }
    outboundStream == null ? void 0 : outboundStream.close();
    inboundStream == null ? void 0 : inboundStream.close();
    this.streamsOutbound.delete(id);
    this.streamsInbound.delete(id);
    for (const peers of this.topics.values()) {
      peers.delete(id);
    }
    for (const [topicStr, peers] of this.mesh) {
      if (peers.delete(id) === true) {
        (_b4 = this.metrics) == null ? void 0 : _b4.onRemoveFromMesh(topicStr, ChurnReason.Dc, 1);
      }
    }
    for (const peers of this.fanout.values()) {
      peers.delete(id);
    }
    this.floodsubPeers.delete(id);
    this.gossip.delete(id);
    this.control.delete(id);
    this.outbound.delete(id);
    this.score.removePeer(id);
    this.acceptFromWhitelist.delete(id);
  }
  // API METHODS
  get started() {
    return this.status.code === GossipStatusCode.started;
  }
  /**
   * Get a the peer-ids in a topic mesh
   */
  getMeshPeers(topic) {
    const peersInTopic = this.mesh.get(topic);
    return peersInTopic ? Array.from(peersInTopic) : [];
  }
  /**
   * Get a list of the peer-ids that are subscribed to one topic.
   */
  getSubscribers(topic) {
    const peersInTopic = this.topics.get(topic);
    return (peersInTopic ? Array.from(peersInTopic) : []).map((str) => peerIdFromString(str));
  }
  /**
   * Get the list of topics which the peer is subscribed to.
   */
  getTopics() {
    return Array.from(this.subscriptions);
  }
  // TODO: Reviewing Pubsub API
  // MESSAGE METHODS
  /**
   * Responsible for processing each RPC message received by other peers.
   */
  async pipePeerReadStream(peerId2, stream) {
    var _a4;
    try {
      await pipe(stream, async (source) => {
        var _a5, _b4, _c;
        for await (const data of source) {
          try {
            const rpcBytes = data.subarray();
            const rpc = decodeRpc(rpcBytes, this.decodeRpcLimits);
            (_a5 = this.metrics) == null ? void 0 : _a5.onRpcRecv(rpc, rpcBytes.length);
            if (this.opts.awaitRpcHandler) {
              try {
                await this.handleReceivedRpc(peerId2, rpc);
              } catch (err) {
                (_b4 = this.metrics) == null ? void 0 : _b4.onRpcRecvError();
                this.log(err);
              }
            } else {
              this.handleReceivedRpc(peerId2, rpc).catch((err) => {
                var _a6;
                (_a6 = this.metrics) == null ? void 0 : _a6.onRpcRecvError();
                this.log(err);
              });
            }
          } catch (e) {
            (_c = this.metrics) == null ? void 0 : _c.onRpcDataError();
            this.log(e);
          }
        }
      });
    } catch (err) {
      (_a4 = this.metrics) == null ? void 0 : _a4.onPeerReadStreamError();
      this.handlePeerReadStreamError(err, peerId2);
    }
  }
  /**
   * Handle error when read stream pipe throws, less of the functional use but more
   * to for testing purposes to spy on the error handling
   * */
  handlePeerReadStreamError(err, peerId2) {
    this.log.error(err);
    this.onPeerDisconnected(peerId2);
  }
  /**
   * Handles an rpc request from a peer
   */
  async handleReceivedRpc(from7, rpc) {
    var _a4;
    if (!this.acceptFrom(from7.toString())) {
      this.log("received message from unacceptable peer %p", from7);
      (_a4 = this.metrics) == null ? void 0 : _a4.rpcRecvNotAccepted.inc();
      return;
    }
    const subscriptions = rpc.subscriptions ? rpc.subscriptions.length : 0;
    const messages2 = rpc.messages ? rpc.messages.length : 0;
    let ihave = 0;
    let iwant = 0;
    let graft = 0;
    let prune = 0;
    if (rpc.control) {
      if (rpc.control.ihave)
        ihave = rpc.control.ihave.length;
      if (rpc.control.iwant)
        iwant = rpc.control.iwant.length;
      if (rpc.control.graft)
        graft = rpc.control.graft.length;
      if (rpc.control.prune)
        prune = rpc.control.prune.length;
    }
    this.log(`rpc.from ${from7.toString()} subscriptions ${subscriptions} messages ${messages2} ihave ${ihave} iwant ${iwant} graft ${graft} prune ${prune}`);
    if (rpc.subscriptions && rpc.subscriptions.length > 0) {
      const subscriptions2 = [];
      rpc.subscriptions.forEach((subOpt) => {
        const topic = subOpt.topic;
        const subscribe = subOpt.subscribe === true;
        if (topic != null) {
          if (this.allowedTopics && !this.allowedTopics.has(topic)) {
            return;
          }
          this.handleReceivedSubscription(from7, topic, subscribe);
          subscriptions2.push({ topic, subscribe });
        }
      });
      this.dispatchEvent(new CustomEvent("subscription-change", {
        detail: { peerId: from7, subscriptions: subscriptions2 }
      }));
    }
    if (rpc.messages) {
      for (const message2 of rpc.messages) {
        if (this.allowedTopics && !this.allowedTopics.has(message2.topic)) {
          continue;
        }
        const handleReceivedMessagePromise = this.handleReceivedMessage(from7, message2).catch((err) => {
          var _a5;
          (_a5 = this.metrics) == null ? void 0 : _a5.onMsgRecvError(message2.topic);
          this.log(err);
        });
        if (this.opts.awaitRpcMessageHandler) {
          await handleReceivedMessagePromise;
        }
      }
    }
    if (rpc.control) {
      await this.handleControlMessage(from7.toString(), rpc.control);
    }
  }
  /**
   * Handles a subscription change from a peer
   */
  handleReceivedSubscription(from7, topic, subscribe) {
    this.log("subscription update from %p topic %s", from7, topic);
    let topicSet = this.topics.get(topic);
    if (topicSet == null) {
      topicSet = /* @__PURE__ */ new Set();
      this.topics.set(topic, topicSet);
    }
    if (subscribe) {
      topicSet.add(from7.toString());
    } else {
      topicSet.delete(from7.toString());
    }
  }
  /**
   * Handles a newly received message from an RPC.
   * May forward to all peers in the mesh.
   */
  async handleReceivedMessage(from7, rpcMsg) {
    var _a4, _b4, _c;
    (_a4 = this.metrics) == null ? void 0 : _a4.onMsgRecvPreValidation(rpcMsg.topic);
    const validationResult = await this.validateReceivedMessage(from7, rpcMsg);
    (_b4 = this.metrics) == null ? void 0 : _b4.onPrevalidationResult(rpcMsg.topic, validationResult.code);
    switch (validationResult.code) {
      case MessageStatus.duplicate:
        this.score.duplicateMessage(from7.toString(), validationResult.msgIdStr, rpcMsg.topic);
        this.gossipTracer.deliverMessage(validationResult.msgIdStr, true);
        this.mcache.observeDuplicate(validationResult.msgIdStr, from7.toString());
        return;
      case MessageStatus.invalid:
        if (validationResult.msgIdStr) {
          const msgIdStr = validationResult.msgIdStr;
          this.score.rejectMessage(from7.toString(), msgIdStr, rpcMsg.topic, validationResult.reason);
          this.gossipTracer.rejectMessage(msgIdStr, validationResult.reason);
        } else {
          this.score.rejectInvalidMessage(from7.toString(), rpcMsg.topic);
        }
        (_c = this.metrics) == null ? void 0 : _c.onMsgRecvInvalid(rpcMsg.topic, validationResult);
        return;
      case MessageStatus.valid:
        this.score.validateMessage(validationResult.messageId.msgIdStr);
        this.gossipTracer.deliverMessage(validationResult.messageId.msgIdStr);
        this.mcache.put(validationResult.messageId, rpcMsg, !this.opts.asyncValidation);
        if (this.subscriptions.has(rpcMsg.topic)) {
          const isFromSelf = this.components.peerId.equals(from7);
          if (!isFromSelf || this.opts.emitSelf) {
            super.dispatchEvent(new CustomEvent("gossipsub:message", {
              detail: {
                propagationSource: from7,
                msgId: validationResult.messageId.msgIdStr,
                msg: validationResult.msg
              }
            }));
            super.dispatchEvent(new CustomEvent("message", { detail: validationResult.msg }));
          }
        }
        if (!this.opts.asyncValidation) {
          this.forwardMessage(validationResult.messageId.msgIdStr, rpcMsg, from7.toString());
        }
    }
  }
  /**
   * Handles a newly received message from an RPC.
   * May forward to all peers in the mesh.
   */
  async validateReceivedMessage(propagationSource, rpcMsg) {
    var _a4, _b4, _c;
    const fastMsgIdStr = (_a4 = this.fastMsgIdFn) == null ? void 0 : _a4.call(this, rpcMsg);
    const msgIdCached = fastMsgIdStr !== void 0 ? (_b4 = this.fastMsgIdCache) == null ? void 0 : _b4.get(fastMsgIdStr) : void 0;
    if (msgIdCached) {
      return { code: MessageStatus.duplicate, msgIdStr: msgIdCached };
    }
    const validationResult = await validateToRawMessage(this.globalSignaturePolicy, rpcMsg);
    if (!validationResult.valid) {
      return { code: MessageStatus.invalid, reason: RejectReason.Error, error: validationResult.error };
    }
    const msg = validationResult.message;
    try {
      if (this.dataTransform) {
        msg.data = this.dataTransform.inboundTransform(rpcMsg.topic, msg.data);
      }
    } catch (e) {
      this.log("Invalid message, transform failed", e);
      return { code: MessageStatus.invalid, reason: RejectReason.Error, error: ValidateError.TransformFailed };
    }
    const msgId2 = await this.msgIdFn(msg);
    const msgIdStr = this.msgIdToStrFn(msgId2);
    const messageId = { msgId: msgId2, msgIdStr };
    if (fastMsgIdStr !== void 0 && this.fastMsgIdCache) {
      const collision = this.fastMsgIdCache.put(fastMsgIdStr, msgIdStr);
      if (collision) {
        (_c = this.metrics) == null ? void 0 : _c.fastMsgIdCacheCollision.inc();
      }
    }
    if (this.seenCache.has(msgIdStr)) {
      return { code: MessageStatus.duplicate, msgIdStr };
    } else {
      this.seenCache.put(msgIdStr);
    }
    const topicValidator = this.topicValidators.get(rpcMsg.topic);
    if (topicValidator != null) {
      let acceptance;
      try {
        acceptance = await topicValidator(propagationSource, msg);
      } catch (e) {
        const errCode3 = e.code;
        if (errCode3 === ERR_TOPIC_VALIDATOR_IGNORE)
          acceptance = TopicValidatorResult.Ignore;
        if (errCode3 === ERR_TOPIC_VALIDATOR_REJECT)
          acceptance = TopicValidatorResult.Reject;
        else
          acceptance = TopicValidatorResult.Ignore;
      }
      if (acceptance !== TopicValidatorResult.Accept) {
        return { code: MessageStatus.invalid, reason: rejectReasonFromAcceptance(acceptance), msgIdStr };
      }
    }
    return { code: MessageStatus.valid, messageId, msg };
  }
  /**
   * Return score of a peer.
   */
  getScore(peerId2) {
    return this.score.score(peerId2);
  }
  /**
   * Send an rpc object to a peer with subscriptions
   */
  sendSubscriptions(toPeer, topics, subscribe) {
    this.sendRpc(toPeer, {
      subscriptions: topics.map((topic) => ({ topic, subscribe }))
    });
  }
  /**
   * Handles an rpc control message from a peer
   */
  async handleControlMessage(id, controlMsg) {
    var _a4, _b4;
    if (controlMsg === void 0) {
      return;
    }
    const iwant = controlMsg.ihave ? this.handleIHave(id, controlMsg.ihave) : [];
    const ihave = controlMsg.iwant ? this.handleIWant(id, controlMsg.iwant) : [];
    const prune = controlMsg.graft ? await this.handleGraft(id, controlMsg.graft) : [];
    controlMsg.prune && await this.handlePrune(id, controlMsg.prune);
    if (!iwant.length && !ihave.length && !prune.length) {
      return;
    }
    const sent = this.sendRpc(id, { messages: ihave, control: { iwant, prune } });
    const iwantMessageIds = (_a4 = iwant[0]) == null ? void 0 : _a4.messageIDs;
    if (iwantMessageIds) {
      if (sent) {
        this.gossipTracer.addPromise(id, iwantMessageIds);
      } else {
        (_b4 = this.metrics) == null ? void 0 : _b4.iwantPromiseUntracked.inc(1);
      }
    }
  }
  /**
   * Whether to accept a message from a peer
   */
  acceptFrom(id) {
    if (this.direct.has(id)) {
      return true;
    }
    const now = Date.now();
    const entry = this.acceptFromWhitelist.get(id);
    if (entry && entry.messagesAccepted < ACCEPT_FROM_WHITELIST_MAX_MESSAGES && entry.acceptUntil >= now) {
      entry.messagesAccepted += 1;
      return true;
    }
    const score = this.score.score(id);
    if (score >= ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE) {
      this.acceptFromWhitelist.set(id, {
        messagesAccepted: 0,
        acceptUntil: now + ACCEPT_FROM_WHITELIST_DURATION_MS
      });
    } else {
      this.acceptFromWhitelist.delete(id);
    }
    return score >= this.opts.scoreThresholds.graylistThreshold;
  }
  /**
   * Handles IHAVE messages
   */
  handleIHave(id, ihave) {
    var _a4, _b4, _c;
    if (!ihave.length) {
      return [];
    }
    const score = this.score.score(id);
    if (score < this.opts.scoreThresholds.gossipThreshold) {
      this.log("IHAVE: ignoring peer %s with score below threshold [ score = %d ]", id, score);
      (_a4 = this.metrics) == null ? void 0 : _a4.ihaveRcvIgnored.inc({ reason: IHaveIgnoreReason.LowScore });
      return [];
    }
    const peerhave = (this.peerhave.get(id) ?? 0) + 1;
    this.peerhave.set(id, peerhave);
    if (peerhave > GossipsubMaxIHaveMessages) {
      this.log("IHAVE: peer %s has advertised too many times (%d) within this heartbeat interval; ignoring", id, peerhave);
      (_b4 = this.metrics) == null ? void 0 : _b4.ihaveRcvIgnored.inc({ reason: IHaveIgnoreReason.MaxIhave });
      return [];
    }
    const iasked = this.iasked.get(id) ?? 0;
    if (iasked >= GossipsubMaxIHaveLength) {
      this.log("IHAVE: peer %s has already advertised too many messages (%d); ignoring", id, iasked);
      (_c = this.metrics) == null ? void 0 : _c.ihaveRcvIgnored.inc({ reason: IHaveIgnoreReason.MaxIasked });
      return [];
    }
    const iwant = /* @__PURE__ */ new Map();
    ihave.forEach(({ topicID, messageIDs }) => {
      var _a5;
      if (!topicID || !messageIDs || !this.mesh.has(topicID)) {
        return;
      }
      let idonthave = 0;
      messageIDs.forEach((msgId2) => {
        const msgIdStr = this.msgIdToStrFn(msgId2);
        if (!this.seenCache.has(msgIdStr)) {
          iwant.set(msgIdStr, msgId2);
          idonthave++;
        }
      });
      (_a5 = this.metrics) == null ? void 0 : _a5.onIhaveRcv(topicID, messageIDs.length, idonthave);
    });
    if (!iwant.size) {
      return [];
    }
    let iask = iwant.size;
    if (iask + iasked > GossipsubMaxIHaveLength) {
      iask = GossipsubMaxIHaveLength - iasked;
    }
    this.log("IHAVE: Asking for %d out of %d messages from %s", iask, iwant.size, id);
    let iwantList = Array.from(iwant.values());
    shuffle(iwantList);
    iwantList = iwantList.slice(0, iask);
    this.iasked.set(id, iasked + iask);
    return [
      {
        messageIDs: iwantList
      }
    ];
  }
  /**
   * Handles IWANT messages
   * Returns messages to send back to peer
   */
  handleIWant(id, iwant) {
    var _a4;
    if (!iwant.length) {
      return [];
    }
    const score = this.score.score(id);
    if (score < this.opts.scoreThresholds.gossipThreshold) {
      this.log("IWANT: ignoring peer %s with score below threshold [score = %d]", id, score);
      return [];
    }
    const ihave = /* @__PURE__ */ new Map();
    const iwantByTopic = /* @__PURE__ */ new Map();
    let iwantDonthave = 0;
    iwant.forEach(({ messageIDs }) => {
      messageIDs && messageIDs.forEach((msgId2) => {
        const msgIdStr = this.msgIdToStrFn(msgId2);
        const entry = this.mcache.getWithIWantCount(msgIdStr, id);
        if (entry == null) {
          iwantDonthave++;
          return;
        }
        iwantByTopic.set(entry.msg.topic, 1 + (iwantByTopic.get(entry.msg.topic) ?? 0));
        if (entry.count > GossipsubGossipRetransmission) {
          this.log("IWANT: Peer %s has asked for message %s too many times: ignoring request", id, msgId2);
          return;
        }
        ihave.set(msgIdStr, entry.msg);
      });
    });
    (_a4 = this.metrics) == null ? void 0 : _a4.onIwantRcv(iwantByTopic, iwantDonthave);
    if (!ihave.size) {
      this.log("IWANT: Could not provide any wanted messages to %s", id);
      return [];
    }
    this.log("IWANT: Sending %d messages to %s", ihave.size, id);
    return Array.from(ihave.values());
  }
  /**
   * Handles Graft messages
   */
  async handleGraft(id, graft) {
    const prune = [];
    const score = this.score.score(id);
    const now = Date.now();
    let doPX = this.opts.doPX;
    graft.forEach(({ topicID }) => {
      var _a4, _b4;
      if (!topicID) {
        return;
      }
      const peersInMesh = this.mesh.get(topicID);
      if (!peersInMesh) {
        doPX = false;
        return;
      }
      if (peersInMesh.has(id)) {
        return;
      }
      if (this.direct.has(id)) {
        this.log("GRAFT: ignoring request from direct peer %s", id);
        prune.push(topicID);
        doPX = false;
        return;
      }
      const expire = (_a4 = this.backoff.get(topicID)) == null ? void 0 : _a4.get(id);
      if (typeof expire === "number" && now < expire) {
        this.log("GRAFT: ignoring backed off peer %s", id);
        this.score.addPenalty(id, 1, ScorePenalty.GraftBackoff);
        doPX = false;
        const floodCutoff = expire + this.opts.graftFloodThreshold - this.opts.pruneBackoff;
        if (now < floodCutoff) {
          this.score.addPenalty(id, 1, ScorePenalty.GraftBackoff);
        }
        this.addBackoff(id, topicID);
        prune.push(topicID);
        return;
      }
      if (score < 0) {
        this.log("GRAFT: ignoring peer %s with negative score: score=%d, topic=%s", id, score, topicID);
        prune.push(topicID);
        doPX = false;
        this.addBackoff(id, topicID);
        return;
      }
      if (peersInMesh.size >= this.opts.Dhi && !this.outbound.get(id)) {
        prune.push(topicID);
        this.addBackoff(id, topicID);
        return;
      }
      this.log("GRAFT: Add mesh link from %s in %s", id, topicID);
      this.score.graft(id, topicID);
      peersInMesh.add(id);
      (_b4 = this.metrics) == null ? void 0 : _b4.onAddToMesh(topicID, InclusionReason.Subscribed, 1);
    });
    if (!prune.length) {
      return [];
    }
    const onUnsubscribe = false;
    return await Promise.all(prune.map((topic) => this.makePrune(id, topic, doPX, onUnsubscribe)));
  }
  /**
   * Handles Prune messages
   */
  async handlePrune(id, prune) {
    var _a4;
    const score = this.score.score(id);
    for (const { topicID, backoff, peers } of prune) {
      if (topicID == null) {
        continue;
      }
      const peersInMesh = this.mesh.get(topicID);
      if (!peersInMesh) {
        return;
      }
      this.log("PRUNE: Remove mesh link to %s in %s", id, topicID);
      this.score.prune(id, topicID);
      if (peersInMesh.has(id)) {
        peersInMesh.delete(id);
        (_a4 = this.metrics) == null ? void 0 : _a4.onRemoveFromMesh(topicID, ChurnReason.Prune, 1);
      }
      if (typeof backoff === "number" && backoff > 0) {
        this.doAddBackoff(id, topicID, backoff * 1e3);
      } else {
        this.addBackoff(id, topicID);
      }
      if (peers && peers.length) {
        if (score < this.opts.scoreThresholds.acceptPXThreshold) {
          this.log("PRUNE: ignoring PX from peer %s with insufficient score [score = %d, topic = %s]", id, score, topicID);
          continue;
        }
        await this.pxConnect(peers);
      }
    }
  }
  /**
   * Add standard backoff log for a peer in a topic
   */
  addBackoff(id, topic) {
    this.doAddBackoff(id, topic, this.opts.pruneBackoff);
  }
  /**
   * Add backoff expiry interval for a peer in a topic
   *
   * @param id
   * @param topic
   * @param intervalMs - backoff duration in milliseconds
   */
  doAddBackoff(id, topic, intervalMs) {
    let backoff = this.backoff.get(topic);
    if (!backoff) {
      backoff = /* @__PURE__ */ new Map();
      this.backoff.set(topic, backoff);
    }
    const expire = Date.now() + intervalMs;
    const existingExpire = backoff.get(id) ?? 0;
    if (existingExpire < expire) {
      backoff.set(id, expire);
    }
  }
  /**
   * Apply penalties from broken IHAVE/IWANT promises
   */
  applyIwantPenalties() {
    this.gossipTracer.getBrokenPromises().forEach((count, p) => {
      this.log("peer %s didn't follow up in %d IWANT requests; adding penalty", p, count);
      this.score.addPenalty(p, count, ScorePenalty.BrokenPromise);
    });
  }
  /**
   * Clear expired backoff expiries
   */
  clearBackoff() {
    if (this.heartbeatTicks % GossipsubPruneBackoffTicks !== 0) {
      return;
    }
    const now = Date.now();
    this.backoff.forEach((backoff, topic) => {
      backoff.forEach((expire, id) => {
        if (expire + BACKOFF_SLACK * this.opts.heartbeatInterval < now) {
          backoff.delete(id);
        }
      });
      if (backoff.size === 0) {
        this.backoff.delete(topic);
      }
    });
  }
  /**
   * Maybe reconnect to direct peers
   */
  async directConnect() {
    const toconnect = [];
    this.direct.forEach((id) => {
      if (!this.streamsOutbound.has(id)) {
        toconnect.push(id);
      }
    });
    await Promise.all(toconnect.map(async (id) => await this.connect(id)));
  }
  /**
   * Maybe attempt connection given signed peer records
   */
  async pxConnect(peers) {
    if (peers.length > this.opts.prunePeers) {
      shuffle(peers);
      peers = peers.slice(0, this.opts.prunePeers);
    }
    const toconnect = [];
    await Promise.all(peers.map(async (pi) => {
      if (!pi.peerID) {
        return;
      }
      const peer = peerIdFromBytes(pi.peerID);
      const p = peer.toString();
      if (this.peers.has(p)) {
        return;
      }
      if (!pi.signedPeerRecord) {
        toconnect.push(p);
        return;
      }
      try {
        if (!await this.components.peerStore.consumePeerRecord(pi.signedPeerRecord, peer)) {
          this.log("bogus peer record obtained through px: could not add peer record to address book");
          return;
        }
        toconnect.push(p);
      } catch (e) {
        this.log("bogus peer record obtained through px: invalid signature or not a peer record");
      }
    }));
    if (!toconnect.length) {
      return;
    }
    await Promise.all(toconnect.map(async (id) => await this.connect(id)));
  }
  /**
   * Connect to a peer using the gossipsub protocol
   */
  async connect(id) {
    var _a4;
    this.log("Initiating connection with %s", id);
    const peerId2 = peerIdFromString(id);
    const connection = await this.components.connectionManager.openConnection(peerId2);
    for (const multicodec of this.multicodecs) {
      for (const topology of this.components.registrar.getTopologies(multicodec)) {
        (_a4 = topology.onConnect) == null ? void 0 : _a4.call(topology, peerId2, connection);
      }
    }
  }
  /**
   * Subscribes to a topic
   */
  subscribe(topic) {
    if (this.status.code !== GossipStatusCode.started) {
      throw new Error("Pubsub has not started");
    }
    if (!this.subscriptions.has(topic)) {
      this.subscriptions.add(topic);
      for (const peerId2 of this.peers.keys()) {
        this.sendSubscriptions(peerId2, [topic], true);
      }
    }
    this.join(topic);
  }
  /**
   * Unsubscribe to a topic
   */
  unsubscribe(topic) {
    if (this.status.code !== GossipStatusCode.started) {
      throw new Error("Pubsub is not started");
    }
    const wasSubscribed = this.subscriptions.delete(topic);
    this.log("unsubscribe from %s - am subscribed %s", topic, wasSubscribed);
    if (wasSubscribed) {
      for (const peerId2 of this.peers.keys()) {
        this.sendSubscriptions(peerId2, [topic], false);
      }
    }
    this.leave(topic);
  }
  /**
   * Join topic
   */
  join(topic) {
    var _a4, _b4, _c;
    if (this.status.code !== GossipStatusCode.started) {
      throw new Error("Gossipsub has not started");
    }
    if (this.mesh.has(topic)) {
      return;
    }
    this.log("JOIN %s", topic);
    (_a4 = this.metrics) == null ? void 0 : _a4.onJoin(topic);
    const toAdd = /* @__PURE__ */ new Set();
    const backoff = this.backoff.get(topic);
    const fanoutPeers = this.fanout.get(topic);
    if (fanoutPeers) {
      this.fanout.delete(topic);
      this.fanoutLastpub.delete(topic);
      fanoutPeers.forEach((id) => {
        if (!this.direct.has(id) && this.score.score(id) >= 0 && (!backoff || !backoff.has(id))) {
          toAdd.add(id);
        }
      });
      (_b4 = this.metrics) == null ? void 0 : _b4.onAddToMesh(topic, InclusionReason.Fanout, toAdd.size);
    }
    if (toAdd.size < this.opts.D) {
      const fanoutCount = toAdd.size;
      const newPeers = this.getRandomGossipPeers(topic, this.opts.D, (id) => (
        // filter direct peers and peers with negative score
        !toAdd.has(id) && !this.direct.has(id) && this.score.score(id) >= 0 && (!backoff || !backoff.has(id))
      ));
      newPeers.forEach((peer) => {
        toAdd.add(peer);
      });
      (_c = this.metrics) == null ? void 0 : _c.onAddToMesh(topic, InclusionReason.Random, toAdd.size - fanoutCount);
    }
    this.mesh.set(topic, toAdd);
    toAdd.forEach((id) => {
      this.log("JOIN: Add mesh link to %s in %s", id, topic);
      this.sendGraft(id, topic);
    });
  }
  /**
   * Leave topic
   */
  leave(topic) {
    var _a4;
    if (this.status.code !== GossipStatusCode.started) {
      throw new Error("Gossipsub has not started");
    }
    this.log("LEAVE %s", topic);
    (_a4 = this.metrics) == null ? void 0 : _a4.onLeave(topic);
    const meshPeers = this.mesh.get(topic);
    if (meshPeers) {
      Promise.all(Array.from(meshPeers).map(async (id) => {
        this.log("LEAVE: Remove mesh link to %s in %s", id, topic);
        return await this.sendPrune(id, topic);
      })).catch((err) => {
        this.log("Error sending prunes to mesh peers", err);
      });
      this.mesh.delete(topic);
    }
  }
  selectPeersToForward(topic, propagationSource, excludePeers) {
    const tosend = /* @__PURE__ */ new Set();
    const peersInTopic = this.topics.get(topic);
    if (peersInTopic) {
      this.direct.forEach((peer) => {
        if (peersInTopic.has(peer) && propagationSource !== peer && !(excludePeers == null ? void 0 : excludePeers.has(peer))) {
          tosend.add(peer);
        }
      });
      this.floodsubPeers.forEach((peer) => {
        if (peersInTopic.has(peer) && propagationSource !== peer && !(excludePeers == null ? void 0 : excludePeers.has(peer)) && this.score.score(peer) >= this.opts.scoreThresholds.publishThreshold) {
          tosend.add(peer);
        }
      });
    }
    const meshPeers = this.mesh.get(topic);
    if (meshPeers && meshPeers.size > 0) {
      meshPeers.forEach((peer) => {
        if (propagationSource !== peer && !(excludePeers == null ? void 0 : excludePeers.has(peer))) {
          tosend.add(peer);
        }
      });
    }
    return tosend;
  }
  selectPeersToPublish(topic) {
    const tosend = /* @__PURE__ */ new Set();
    const tosendCount = {
      direct: 0,
      floodsub: 0,
      mesh: 0,
      fanout: 0
    };
    const peersInTopic = this.topics.get(topic);
    if (peersInTopic) {
      if (this.opts.floodPublish) {
        peersInTopic.forEach((id) => {
          if (this.direct.has(id)) {
            tosend.add(id);
            tosendCount.direct++;
          } else if (this.score.score(id) >= this.opts.scoreThresholds.publishThreshold) {
            tosend.add(id);
            tosendCount.floodsub++;
          }
        });
      } else {
        this.direct.forEach((id) => {
          if (peersInTopic.has(id)) {
            tosend.add(id);
            tosendCount.direct++;
          }
        });
        this.floodsubPeers.forEach((id) => {
          if (peersInTopic.has(id) && this.score.score(id) >= this.opts.scoreThresholds.publishThreshold) {
            tosend.add(id);
            tosendCount.floodsub++;
          }
        });
        const meshPeers = this.mesh.get(topic);
        if (meshPeers && meshPeers.size > 0) {
          meshPeers.forEach((peer) => {
            tosend.add(peer);
            tosendCount.mesh++;
          });
        } else {
          const fanoutPeers = this.fanout.get(topic);
          if (fanoutPeers && fanoutPeers.size > 0) {
            fanoutPeers.forEach((peer) => {
              tosend.add(peer);
              tosendCount.fanout++;
            });
          } else {
            const newFanoutPeers = this.getRandomGossipPeers(topic, this.opts.D, (id) => {
              return this.score.score(id) >= this.opts.scoreThresholds.publishThreshold;
            });
            if (newFanoutPeers.size > 0) {
              this.fanout.set(topic, newFanoutPeers);
              newFanoutPeers.forEach((peer) => {
                tosend.add(peer);
                tosendCount.fanout++;
              });
            }
          }
          this.fanoutLastpub.set(topic, Date.now());
        }
      }
    }
    return { tosend, tosendCount };
  }
  /**
   * Forwards a message from our peers.
   *
   * For messages published by us (the app layer), this class uses `publish`
   */
  forwardMessage(msgIdStr, rawMsg, propagationSource, excludePeers) {
    var _a4;
    if (propagationSource) {
      this.score.deliverMessage(propagationSource, msgIdStr, rawMsg.topic);
    }
    const tosend = this.selectPeersToForward(rawMsg.topic, propagationSource, excludePeers);
    tosend.forEach((id) => {
      this.sendRpc(id, { messages: [rawMsg] });
    });
    (_a4 = this.metrics) == null ? void 0 : _a4.onForwardMsg(rawMsg.topic, tosend.size);
  }
  /**
   * App layer publishes a message to peers, return number of peers this message is published to
   * Note: `async` due to crypto only if `StrictSign`, otherwise it's a sync fn.
   *
   * For messages not from us, this class uses `forwardMessage`.
   */
  async publish(topic, data, opts) {
    var _a4, _b4;
    const startMs = Date.now();
    const transformedData = this.dataTransform ? this.dataTransform.outboundTransform(topic, data) : data;
    if (this.publishConfig == null) {
      throw Error("PublishError.Uninitialized");
    }
    const { raw: rawMsg, msg } = await buildRawMessage(this.publishConfig, topic, data, transformedData);
    const msgId2 = await this.msgIdFn(msg);
    const msgIdStr = this.msgIdToStrFn(msgId2);
    const ignoreDuplicatePublishError = (opts == null ? void 0 : opts.ignoreDuplicatePublishError) ?? this.opts.ignoreDuplicatePublishError;
    if (this.seenCache.has(msgIdStr)) {
      if (ignoreDuplicatePublishError) {
        (_a4 = this.metrics) == null ? void 0 : _a4.onPublishDuplicateMsg(topic);
        return { recipients: [] };
      }
      throw Error("PublishError.Duplicate");
    }
    const { tosend, tosendCount } = this.selectPeersToPublish(topic);
    const willSendToSelf = this.opts.emitSelf === true && this.subscriptions.has(topic);
    const allowPublishToZeroPeers = (opts == null ? void 0 : opts.allowPublishToZeroPeers) ?? this.opts.allowPublishToZeroPeers;
    if (tosend.size === 0 && !allowPublishToZeroPeers && !willSendToSelf) {
      throw Error("PublishError.InsufficientPeers");
    }
    this.seenCache.put(msgIdStr);
    this.mcache.put({ msgId: msgId2, msgIdStr }, rawMsg, true);
    this.publishedMessageIds.put(msgIdStr);
    for (const id of tosend) {
      const sent = this.sendRpc(id, { messages: [rawMsg] });
      if (!sent) {
        tosend.delete(id);
      }
    }
    const durationMs = Date.now() - startMs;
    (_b4 = this.metrics) == null ? void 0 : _b4.onPublishMsg(topic, tosendCount, tosend.size, rawMsg.data != null ? rawMsg.data.length : 0, durationMs);
    if (willSendToSelf) {
      tosend.add(this.components.peerId.toString());
      super.dispatchEvent(new CustomEvent("gossipsub:message", {
        detail: {
          propagationSource: this.components.peerId,
          msgId: msgIdStr,
          msg
        }
      }));
      super.dispatchEvent(new CustomEvent("message", { detail: msg }));
    }
    return {
      recipients: Array.from(tosend.values()).map((str) => peerIdFromString(str))
    };
  }
  /**
   * This function should be called when `asyncValidation` is `true` after
   * the message got validated by the caller. Messages are stored in the `mcache` and
   * validation is expected to be fast enough that the messages should still exist in the cache.
   * There are three possible validation outcomes and the outcome is given in acceptance.
   *
   * If acceptance = `MessageAcceptance.Accept` the message will get propagated to the
   * network. The `propagation_source` parameter indicates who the message was received by and
   * will not be forwarded back to that peer.
   *
   * If acceptance = `MessageAcceptance.Reject` the message will be deleted from the memcache
   * and the P₄ penalty will be applied to the `propagationSource`.
   *
   * If acceptance = `MessageAcceptance.Ignore` the message will be deleted from the memcache
   * but no P₄ penalty will be applied.
   *
   * This function will return true if the message was found in the cache and false if was not
   * in the cache anymore.
   *
   * This should only be called once per message.
   */
  reportMessageValidationResult(msgId2, propagationSource, acceptance) {
    var _a4;
    let cacheEntry;
    if (acceptance === TopicValidatorResult.Accept) {
      cacheEntry = this.mcache.validate(msgId2);
      if (cacheEntry != null) {
        const { message: rawMsg, originatingPeers } = cacheEntry;
        this.score.deliverMessage(propagationSource, msgId2, rawMsg.topic);
        this.forwardMessage(msgId2, cacheEntry.message, propagationSource, originatingPeers);
      }
    } else {
      cacheEntry = this.mcache.remove(msgId2);
      if (cacheEntry) {
        const rejectReason = rejectReasonFromAcceptance(acceptance);
        const { message: rawMsg, originatingPeers } = cacheEntry;
        this.score.rejectMessage(propagationSource, msgId2, rawMsg.topic, rejectReason);
        for (const peer of originatingPeers) {
          this.score.rejectMessage(peer, msgId2, rawMsg.topic, rejectReason);
        }
      }
    }
    const firstSeenTimestampMs = this.score.messageFirstSeenTimestampMs(msgId2);
    (_a4 = this.metrics) == null ? void 0 : _a4.onReportValidation(cacheEntry, acceptance, firstSeenTimestampMs);
  }
  /**
   * Sends a GRAFT message to a peer
   */
  sendGraft(id, topic) {
    const graft = [
      {
        topicID: topic
      }
    ];
    this.sendRpc(id, { control: { graft } });
  }
  /**
   * Sends a PRUNE message to a peer
   */
  async sendPrune(id, topic) {
    const onUnsubscribe = true;
    const prune = [await this.makePrune(id, topic, this.opts.doPX, onUnsubscribe)];
    this.sendRpc(id, { control: { prune } });
  }
  /**
   * Send an rpc object to a peer
   */
  sendRpc(id, rpc) {
    var _a4;
    const outboundStream = this.streamsOutbound.get(id);
    if (!outboundStream) {
      this.log(`Cannot send RPC to ${id} as there is no open stream to it available`);
      return false;
    }
    const ctrl = this.control.get(id);
    if (ctrl) {
      this.piggybackControl(id, rpc, ctrl);
      this.control.delete(id);
    }
    const ihave = this.gossip.get(id);
    if (ihave) {
      this.piggybackGossip(id, rpc, ihave);
      this.gossip.delete(id);
    }
    const rpcBytes = RPC.encode(rpc).finish();
    try {
      outboundStream.push(rpcBytes);
    } catch (e) {
      this.log.error(`Cannot send rpc to ${id}`, e);
      if (ctrl) {
        this.control.set(id, ctrl);
      }
      if (ihave) {
        this.gossip.set(id, ihave);
      }
      return false;
    }
    (_a4 = this.metrics) == null ? void 0 : _a4.onRpcSent(rpc, rpcBytes.length);
    return true;
  }
  /** Mutates `outRpc` adding graft and prune control messages */
  piggybackControl(id, outRpc, ctrl) {
    var _a4, _b4;
    if (ctrl.graft) {
      if (!outRpc.control)
        outRpc.control = {};
      if (!outRpc.control.graft)
        outRpc.control.graft = [];
      for (const graft of ctrl.graft) {
        if (graft.topicID && ((_a4 = this.mesh.get(graft.topicID)) == null ? void 0 : _a4.has(id))) {
          outRpc.control.graft.push(graft);
        }
      }
    }
    if (ctrl.prune) {
      if (!outRpc.control)
        outRpc.control = {};
      if (!outRpc.control.prune)
        outRpc.control.prune = [];
      for (const prune of ctrl.prune) {
        if (prune.topicID && !((_b4 = this.mesh.get(prune.topicID)) == null ? void 0 : _b4.has(id))) {
          outRpc.control.prune.push(prune);
        }
      }
    }
  }
  /** Mutates `outRpc` adding ihave control messages */
  piggybackGossip(id, outRpc, ihave) {
    if (!outRpc.control)
      outRpc.control = {};
    outRpc.control.ihave = ihave;
  }
  /**
   * Send graft and prune messages
   *
   * @param tograft - peer id => topic[]
   * @param toprune - peer id => topic[]
   */
  async sendGraftPrune(tograft, toprune, noPX) {
    const doPX = this.opts.doPX;
    const onUnsubscribe = false;
    for (const [id, topics] of tograft) {
      const graft = topics.map((topicID) => ({ topicID }));
      let prune = [];
      const pruning = toprune.get(id);
      if (pruning) {
        prune = await Promise.all(pruning.map(async (topicID) => await this.makePrune(id, topicID, doPX && !(noPX.get(id) ?? false), onUnsubscribe)));
        toprune.delete(id);
      }
      this.sendRpc(id, { control: { graft, prune } });
    }
    for (const [id, topics] of toprune) {
      const prune = await Promise.all(topics.map(async (topicID) => await this.makePrune(id, topicID, doPX && !(noPX.get(id) ?? false), onUnsubscribe)));
      this.sendRpc(id, { control: { prune } });
    }
  }
  /**
   * Emits gossip - Send IHAVE messages to a random set of gossip peers
   */
  emitGossip(peersToGossipByTopic) {
    const gossipIDsByTopic = this.mcache.getGossipIDs(new Set(peersToGossipByTopic.keys()));
    for (const [topic, peersToGossip] of peersToGossipByTopic) {
      this.doEmitGossip(topic, peersToGossip, gossipIDsByTopic.get(topic) ?? []);
    }
  }
  /**
   * Send gossip messages to GossipFactor peers above threshold with a minimum of D_lazy
   * Peers are randomly selected from the heartbeat which exclude mesh + fanout peers
   * We also exclude direct peers, as there is no reason to emit gossip to them
   * @param topic
   * @param candidateToGossip - peers to gossip
   * @param messageIDs - message ids to gossip
   */
  doEmitGossip(topic, candidateToGossip, messageIDs) {
    if (!messageIDs.length) {
      return;
    }
    shuffle(messageIDs);
    if (messageIDs.length > GossipsubMaxIHaveLength) {
      this.log("too many messages for gossip; will truncate IHAVE list (%d messages)", messageIDs.length);
    }
    if (!candidateToGossip.size)
      return;
    let target = this.opts.Dlazy;
    const factor = GossipsubGossipFactor * candidateToGossip.size;
    let peersToGossip = candidateToGossip;
    if (factor > target) {
      target = factor;
    }
    if (target > peersToGossip.size) {
      target = peersToGossip.size;
    } else {
      peersToGossip = shuffle(Array.from(peersToGossip)).slice(0, target);
    }
    peersToGossip.forEach((id) => {
      let peerMessageIDs = messageIDs;
      if (messageIDs.length > GossipsubMaxIHaveLength) {
        peerMessageIDs = shuffle(peerMessageIDs.slice()).slice(0, GossipsubMaxIHaveLength);
      }
      this.pushGossip(id, {
        topicID: topic,
        messageIDs: peerMessageIDs
      });
    });
  }
  /**
   * Flush gossip and control messages
   */
  flush() {
    for (const [peer, ihave] of this.gossip.entries()) {
      this.gossip.delete(peer);
      this.sendRpc(peer, { control: { ihave } });
    }
    for (const [peer, control] of this.control.entries()) {
      this.control.delete(peer);
      this.sendRpc(peer, { control: { graft: control.graft, prune: control.prune } });
    }
  }
  /**
   * Adds new IHAVE messages to pending gossip
   */
  pushGossip(id, controlIHaveMsgs) {
    this.log("Add gossip to %s", id);
    const gossip = this.gossip.get(id) || [];
    this.gossip.set(id, gossip.concat(controlIHaveMsgs));
  }
  /**
   * Make a PRUNE control message for a peer in a topic
   */
  async makePrune(id, topic, doPX, onUnsubscribe) {
    this.score.prune(id, topic);
    if (this.streamsOutbound.get(id).protocol === GossipsubIDv10) {
      return {
        topicID: topic,
        peers: []
      };
    }
    const backoffMs = onUnsubscribe ? this.opts.unsubcribeBackoff : this.opts.pruneBackoff;
    const backoff = backoffMs / 1e3;
    this.doAddBackoff(id, topic, backoffMs);
    if (!doPX) {
      return {
        topicID: topic,
        peers: [],
        backoff
      };
    }
    const peers = this.getRandomGossipPeers(topic, this.opts.prunePeers, (xid) => {
      return xid !== id && this.score.score(xid) >= 0;
    });
    const px = await Promise.all(Array.from(peers).map(async (peerId2) => {
      const id2 = peerIdFromString(peerId2);
      let peerInfo;
      try {
        peerInfo = await this.components.peerStore.get(id2);
      } catch (err) {
        if (err.code !== "ERR_NOT_FOUND") {
          throw err;
        }
      }
      return {
        peerID: id2.toBytes(),
        signedPeerRecord: peerInfo == null ? void 0 : peerInfo.peerRecordEnvelope
      };
    }));
    return {
      topicID: topic,
      peers: px,
      backoff
    };
  }
  /**
   * Maintains the mesh and fanout maps in gossipsub.
   */
  async heartbeat() {
    var _a4, _b4;
    const { D, Dlo, Dhi, Dscore, Dout, fanoutTTL } = this.opts;
    this.heartbeatTicks++;
    const scores = /* @__PURE__ */ new Map();
    const getScore = (id) => {
      let s = scores.get(id);
      if (s === void 0) {
        s = this.score.score(id);
        scores.set(id, s);
      }
      return s;
    };
    const tograft = /* @__PURE__ */ new Map();
    const toprune = /* @__PURE__ */ new Map();
    const noPX = /* @__PURE__ */ new Map();
    this.clearBackoff();
    this.peerhave.clear();
    (_a4 = this.metrics) == null ? void 0 : _a4.cacheSize.set({ cache: "iasked" }, this.iasked.size);
    this.iasked.clear();
    this.applyIwantPenalties();
    if (this.heartbeatTicks % this.opts.directConnectTicks === 0) {
      await this.directConnect();
    }
    (_b4 = this.fastMsgIdCache) == null ? void 0 : _b4.prune();
    this.seenCache.prune();
    this.gossipTracer.prune();
    this.publishedMessageIds.prune();
    const peersToGossipByTopic = /* @__PURE__ */ new Map();
    this.mesh.forEach((peers, topic) => {
      const peersInTopic = this.topics.get(topic);
      const candidateMeshPeers = /* @__PURE__ */ new Set();
      const peersToGossip = /* @__PURE__ */ new Set();
      peersToGossipByTopic.set(topic, peersToGossip);
      if (peersInTopic) {
        const shuffledPeers = shuffle(Array.from(peersInTopic));
        const backoff = this.backoff.get(topic);
        for (const id of shuffledPeers) {
          const peerStreams = this.streamsOutbound.get(id);
          if (peerStreams && this.multicodecs.includes(peerStreams.protocol) && !peers.has(id) && !this.direct.has(id)) {
            const score = getScore(id);
            if ((!backoff || !backoff.has(id)) && score >= 0)
              candidateMeshPeers.add(id);
            if (score >= this.opts.scoreThresholds.gossipThreshold)
              peersToGossip.add(id);
          }
        }
      }
      const prunePeer = (id, reason) => {
        var _a5;
        this.log("HEARTBEAT: Remove mesh link to %s in %s", id, topic);
        this.addBackoff(id, topic);
        peers.delete(id);
        if (getScore(id) >= this.opts.scoreThresholds.gossipThreshold)
          peersToGossip.add(id);
        (_a5 = this.metrics) == null ? void 0 : _a5.onRemoveFromMesh(topic, reason, 1);
        const topics = toprune.get(id);
        if (!topics) {
          toprune.set(id, [topic]);
        } else {
          topics.push(topic);
        }
      };
      const graftPeer = (id, reason) => {
        var _a5;
        this.log("HEARTBEAT: Add mesh link to %s in %s", id, topic);
        this.score.graft(id, topic);
        peers.add(id);
        peersToGossip.delete(id);
        (_a5 = this.metrics) == null ? void 0 : _a5.onAddToMesh(topic, reason, 1);
        const topics = tograft.get(id);
        if (!topics) {
          tograft.set(id, [topic]);
        } else {
          topics.push(topic);
        }
      };
      peers.forEach((id) => {
        const score = getScore(id);
        if (score < 0) {
          this.log("HEARTBEAT: Prune peer %s with negative score: score=%d, topic=%s", id, score, topic);
          prunePeer(id, ChurnReason.BadScore);
          noPX.set(id, true);
        }
      });
      if (peers.size < Dlo) {
        const ineed = D - peers.size;
        const newMeshPeers = removeFirstNItemsFromSet(candidateMeshPeers, ineed);
        newMeshPeers.forEach((p) => {
          graftPeer(p, InclusionReason.NotEnough);
        });
      }
      if (peers.size > Dhi) {
        let peersArray = Array.from(peers);
        peersArray.sort((a, b) => getScore(b) - getScore(a));
        peersArray = peersArray.slice(0, Dscore).concat(shuffle(peersArray.slice(Dscore)));
        let outbound = 0;
        peersArray.slice(0, D).forEach((p) => {
          if (this.outbound.get(p)) {
            outbound++;
          }
        });
        if (outbound < Dout) {
          const rotate = (i) => {
            const p = peersArray[i];
            for (let j = i; j > 0; j--) {
              peersArray[j] = peersArray[j - 1];
            }
            peersArray[0] = p;
          };
          if (outbound > 0) {
            let ihave = outbound;
            for (let i = 1; i < D && ihave > 0; i++) {
              if (this.outbound.get(peersArray[i])) {
                rotate(i);
                ihave--;
              }
            }
          }
          let ineed = D - outbound;
          for (let i = D; i < peersArray.length && ineed > 0; i++) {
            if (this.outbound.get(peersArray[i])) {
              rotate(i);
              ineed--;
            }
          }
        }
        peersArray.slice(D).forEach((p) => {
          prunePeer(p, ChurnReason.Excess);
        });
      }
      if (peers.size >= Dlo) {
        let outbound = 0;
        peers.forEach((p) => {
          if (this.outbound.get(p)) {
            outbound++;
          }
        });
        if (outbound < Dout) {
          const ineed = Dout - outbound;
          const newMeshPeers = removeItemsFromSet(candidateMeshPeers, ineed, (id) => this.outbound.get(id) === true);
          newMeshPeers.forEach((p) => {
            graftPeer(p, InclusionReason.Outbound);
          });
        }
      }
      if (this.heartbeatTicks % this.opts.opportunisticGraftTicks === 0 && peers.size > 1) {
        const peersList = Array.from(peers).sort((a, b) => getScore(a) - getScore(b));
        const medianIndex = Math.floor(peers.size / 2);
        const medianScore = getScore(peersList[medianIndex]);
        if (medianScore < this.opts.scoreThresholds.opportunisticGraftThreshold) {
          const ineed = this.opts.opportunisticGraftPeers;
          const newMeshPeers = removeItemsFromSet(candidateMeshPeers, ineed, (id) => getScore(id) > medianScore);
          for (const id of newMeshPeers) {
            this.log("HEARTBEAT: Opportunistically graft peer %s on topic %s", id, topic);
            graftPeer(id, InclusionReason.Opportunistic);
          }
        }
      }
    });
    const now = Date.now();
    this.fanoutLastpub.forEach((lastpb, topic) => {
      if (lastpb + fanoutTTL < now) {
        this.fanout.delete(topic);
        this.fanoutLastpub.delete(topic);
      }
    });
    this.fanout.forEach((fanoutPeers, topic) => {
      const topicPeers = this.topics.get(topic);
      fanoutPeers.forEach((id) => {
        if (!topicPeers.has(id) || getScore(id) < this.opts.scoreThresholds.publishThreshold) {
          fanoutPeers.delete(id);
        }
      });
      const peersInTopic = this.topics.get(topic);
      const candidateFanoutPeers = [];
      const peersToGossip = /* @__PURE__ */ new Set();
      peersToGossipByTopic.set(topic, peersToGossip);
      if (peersInTopic) {
        const shuffledPeers = shuffle(Array.from(peersInTopic));
        for (const id of shuffledPeers) {
          const peerStreams = this.streamsOutbound.get(id);
          if (peerStreams && this.multicodecs.includes(peerStreams.protocol) && !fanoutPeers.has(id) && !this.direct.has(id)) {
            const score = getScore(id);
            if (score >= this.opts.scoreThresholds.publishThreshold)
              candidateFanoutPeers.push(id);
            if (score >= this.opts.scoreThresholds.gossipThreshold)
              peersToGossip.add(id);
          }
        }
      }
      if (fanoutPeers.size < D) {
        const ineed = D - fanoutPeers.size;
        candidateFanoutPeers.slice(0, ineed).forEach((id) => {
          fanoutPeers.add(id);
          peersToGossip == null ? void 0 : peersToGossip.delete(id);
        });
      }
    });
    this.emitGossip(peersToGossipByTopic);
    await this.sendGraftPrune(tograft, toprune, noPX);
    this.flush();
    this.mcache.shift();
    this.dispatchEvent(new CustomEvent("gossipsub:heartbeat"));
  }
  /**
   * Given a topic, returns up to count peers subscribed to that topic
   * that pass an optional filter function
   *
   * @param topic
   * @param count
   * @param filter - a function to filter acceptable peers
   */
  getRandomGossipPeers(topic, count, filter2 = () => true) {
    const peersInTopic = this.topics.get(topic);
    if (!peersInTopic) {
      return /* @__PURE__ */ new Set();
    }
    let peers = [];
    peersInTopic.forEach((id) => {
      const peerStreams = this.streamsOutbound.get(id);
      if (!peerStreams) {
        return;
      }
      if (this.multicodecs.includes(peerStreams.protocol) && filter2(id)) {
        peers.push(id);
      }
    });
    peers = shuffle(peers);
    if (count > 0 && peers.length > count) {
      peers = peers.slice(0, count);
    }
    return new Set(peers);
  }
  onScrapeMetrics(metrics) {
    var _a4, _b4;
    metrics.mcacheSize.set(this.mcache.size);
    metrics.mcacheNotValidatedCount.set(this.mcache.notValidatedCount);
    metrics.cacheSize.set({ cache: "direct" }, this.direct.size);
    metrics.cacheSize.set({ cache: "seenCache" }, this.seenCache.size);
    metrics.cacheSize.set({ cache: "fastMsgIdCache" }, ((_a4 = this.fastMsgIdCache) == null ? void 0 : _a4.size) ?? 0);
    metrics.cacheSize.set({ cache: "publishedMessageIds" }, this.publishedMessageIds.size);
    metrics.cacheSize.set({ cache: "mcache" }, this.mcache.size);
    metrics.cacheSize.set({ cache: "score" }, this.score.size);
    metrics.cacheSize.set({ cache: "gossipTracer.promises" }, this.gossipTracer.size);
    metrics.cacheSize.set({ cache: "gossipTracer.requests" }, this.gossipTracer.requestMsByMsgSize);
    metrics.cacheSize.set({ cache: "topics" }, this.topics.size);
    metrics.cacheSize.set({ cache: "subscriptions" }, this.subscriptions.size);
    metrics.cacheSize.set({ cache: "mesh" }, this.mesh.size);
    metrics.cacheSize.set({ cache: "fanout" }, this.fanout.size);
    metrics.cacheSize.set({ cache: "peers" }, this.peers.size);
    metrics.cacheSize.set({ cache: "streamsOutbound" }, this.streamsOutbound.size);
    metrics.cacheSize.set({ cache: "streamsInbound" }, this.streamsInbound.size);
    metrics.cacheSize.set({ cache: "acceptFromWhitelist" }, this.acceptFromWhitelist.size);
    metrics.cacheSize.set({ cache: "gossip" }, this.gossip.size);
    metrics.cacheSize.set({ cache: "control" }, this.control.size);
    metrics.cacheSize.set({ cache: "peerhave" }, this.peerhave.size);
    metrics.cacheSize.set({ cache: "outbound" }, this.outbound.size);
    let backoffSize = 0;
    const now = Date.now();
    metrics.connectedPeersBackoffSec.reset();
    for (const backoff of this.backoff.values()) {
      backoffSize += backoff.size;
      for (const [peer, expiredMs] of backoff.entries()) {
        if (this.peers.has(peer)) {
          metrics.connectedPeersBackoffSec.observe(Math.max(0, expiredMs - now) / 1e3);
        }
      }
    }
    metrics.cacheSize.set({ cache: "backoff" }, backoffSize);
    for (const [topicStr, peers] of this.topics) {
      metrics.topicPeersCount.set({ topicStr }, peers.size);
    }
    for (const [topicStr, peers] of this.mesh) {
      metrics.meshPeerCounts.set({ topicStr }, peers.size);
    }
    const scores = [];
    const scoreByPeer = /* @__PURE__ */ new Map();
    metrics.behaviourPenalty.reset();
    for (const peerIdStr of this.peers.keys()) {
      const score = this.score.score(peerIdStr);
      scores.push(score);
      scoreByPeer.set(peerIdStr, score);
      metrics.behaviourPenalty.observe(((_b4 = this.score.peerStats.get(peerIdStr)) == null ? void 0 : _b4.behaviourPenalty) ?? 0);
    }
    metrics.registerScores(scores, this.opts.scoreThresholds);
    metrics.registerScorePerMesh(this.mesh, scoreByPeer);
    const sw = computeAllPeersScoreWeights(this.peers.keys(), this.score.peerStats, this.score.params, this.score.peerIPs, metrics.topicStrToLabel);
    metrics.registerScoreWeights(sw);
  }
};
__publicField(GossipSub, "multicodec", GossipsubIDv11);

// node_modules/@waku/relay/dist/constants.js
var second2 = 1e3;
var minute2 = 60 * second2;
var RelayCodecs = ["/vac/waku/relay/2.0.0"];

// node_modules/@waku/relay/dist/message_validator.js
var log16 = new Logger("relay");
function messageValidator(peer, message2) {
  const startTime = performance.now();
  log16.info(`validating message from ${peer} received on ${message2.topic}`);
  let result = TopicValidatorResult.Accept;
  try {
    const protoMessage = message_exports.WakuMessage.decode(message2.data);
    if (!protoMessage.contentTopic || !protoMessage.contentTopic.length || !protoMessage.payload || !protoMessage.payload.length) {
      result = TopicValidatorResult.Reject;
    }
  } catch (e) {
    result = TopicValidatorResult.Reject;
  }
  const endTime = performance.now();
  const timeTakenMs = endTime - startTime;
  if (timeTakenMs > 100) {
    log16.warn(`message validation took ${timeTakenMs}ms for peer ${peer} on topic ${message2.topic}. This should be less than 100ms.`);
  } else {
    log16.info(`message validation took ${timeTakenMs}ms for peer ${peer} on topic ${message2.topic}`);
  }
  return result;
}

// node_modules/@waku/relay/dist/topic_only_message.js
var TopicOnlyMessage2 = class {
  constructor(pubsubTopic, proto) {
    __publicField(this, "pubsubTopic");
    __publicField(this, "proto");
    __publicField(this, "payload", new Uint8Array());
    __publicField(this, "rateLimitProof");
    __publicField(this, "timestamp");
    __publicField(this, "meta");
    __publicField(this, "ephemeral");
    this.pubsubTopic = pubsubTopic;
    this.proto = proto;
  }
  get contentTopic() {
    return this.proto.contentTopic;
  }
};
var TopicOnlyDecoder = class {
  constructor() {
    __publicField(this, "pubsubTopic", DefaultPubSubTopic);
    __publicField(this, "contentTopic", "");
  }
  fromWireToProtoObj(bytes2) {
    const protoMessage = TopicOnlyMessage.decode(bytes2);
    return Promise.resolve({
      contentTopic: protoMessage.contentTopic,
      payload: new Uint8Array(),
      rateLimitProof: void 0,
      timestamp: void 0,
      meta: void 0,
      version: void 0,
      ephemeral: void 0
    });
  }
  async fromProtoObj(pubsubTopic, proto) {
    return new TopicOnlyMessage2(pubsubTopic, proto);
  }
};

// node_modules/@waku/relay/dist/index.js
var log17 = new Logger("relay");
var _Relay = class _Relay {
  constructor(libp2p, options) {
    __publicField(this, "pubsubTopics");
    __publicField(this, "defaultDecoder");
    __publicField(this, "gossipSub");
    /**
     * observers called when receiving new message.
     * Observers under key `""` are always called.
     */
    __publicField(this, "observers");
    if (!this.isRelayPubSub(libp2p.services.pubsub)) {
      throw Error(`Failed to initialize Relay. libp2p.pubsub does not support ${_Relay.multicodec}`);
    }
    this.gossipSub = libp2p.services.pubsub;
    this.pubsubTopics = new Set((options == null ? void 0 : options.pubsubTopics) ?? [DefaultPubSubTopic]);
    if (this.gossipSub.isStarted()) {
      this.subscribeToAllTopics();
    }
    this.observers = /* @__PURE__ */ new Map();
    this.defaultDecoder = new TopicOnlyDecoder();
  }
  /**
   * Mounts the gossipsub protocol onto the libp2p node
   * and subscribes to all the topics.
   *
   * @override
   * @returns {void}
   */
  async start() {
    if (this.gossipSub.isStarted()) {
      throw Error("GossipSub already started.");
    }
    await this.gossipSub.start();
    this.subscribeToAllTopics();
  }
  /**
   * Send Waku message.
   */
  async send(encoder2, message2) {
    const recipients = [];
    const { pubsubTopic } = encoder2;
    if (!this.pubsubTopics.has(pubsubTopic)) {
      log17.error("Failed to send waku relay: topic not configured");
      return {
        recipients,
        errors: [SendError.TOPIC_NOT_CONFIGURED]
      };
    }
    const msg = await encoder2.toWire(message2);
    if (!msg) {
      log17.error("Failed to encode message, aborting publish");
      return {
        recipients,
        errors: [SendError.ENCODE_FAILED]
      };
    }
    if (!isWireSizeUnderCap(msg)) {
      log17.error("Failed to send waku relay: message is bigger that 1MB");
      return {
        recipients,
        errors: [SendError.SIZE_TOO_BIG]
      };
    }
    return this.gossipSub.publish(pubsubTopic, msg);
  }
  subscribe(decoders, callback) {
    const observers = [];
    for (const decoder of Array.isArray(decoders) ? decoders : [decoders]) {
      const { pubsubTopic } = decoder;
      const ctObs = this.observers.get(pubsubTopic) ?? /* @__PURE__ */ new Map();
      const observer = { pubsubTopic, decoder, callback };
      pushOrInitMapSet(ctObs, decoder.contentTopic, observer);
      this.observers.set(pubsubTopic, ctObs);
      observers.push([pubsubTopic, observer]);
    }
    return () => {
      this.removeObservers(observers);
    };
  }
  removeObservers(observers) {
    for (const [pubsubTopic, observer] of observers) {
      const ctObs = this.observers.get(pubsubTopic);
      if (!ctObs)
        continue;
      const contentTopic = observer.decoder.contentTopic;
      const _obs = ctObs.get(contentTopic);
      if (!_obs)
        continue;
      _obs.delete(observer);
      ctObs.set(contentTopic, _obs);
      this.observers.set(pubsubTopic, ctObs);
    }
  }
  toSubscriptionIterator(decoders) {
    return toAsyncIterator(this, decoders);
  }
  getActiveSubscriptions() {
    const map3 = /* @__PURE__ */ new Map();
    for (const pubsubTopic of this.pubsubTopics) {
      map3.set(pubsubTopic, Array.from(this.observers.keys()));
    }
    return map3;
  }
  getMeshPeers(topic = DefaultPubSubTopic) {
    return this.gossipSub.getMeshPeers(topic);
  }
  subscribeToAllTopics() {
    for (const pubsubTopic of this.pubsubTopics) {
      this.gossipSubSubscribe(pubsubTopic);
    }
  }
  async processIncomingMessage(pubsubTopic, bytes2) {
    const topicOnlyMsg = await this.defaultDecoder.fromWireToProtoObj(bytes2);
    if (!topicOnlyMsg || !topicOnlyMsg.contentTopic) {
      log17.warn("Message does not have a content topic, skipping");
      return;
    }
    const contentTopicMap = this.observers.get(pubsubTopic);
    if (!contentTopicMap) {
      return;
    }
    const observers = contentTopicMap.get(topicOnlyMsg.contentTopic);
    if (!observers) {
      return;
    }
    await Promise.all(Array.from(observers).map(({ decoder, callback }) => {
      return (async () => {
        try {
          const protoMsg = await decoder.fromWireToProtoObj(bytes2);
          if (!protoMsg) {
            log17.error("Internal error: message previously decoded failed on 2nd pass.");
            return;
          }
          const msg = await decoder.fromProtoObj(pubsubTopic, protoMsg);
          if (msg) {
            await callback(msg);
          } else {
            log17.error("Failed to decode messages on", topicOnlyMsg.contentTopic);
          }
        } catch (error) {
          log17.error("Error while decoding message:", error);
        }
      })();
    }));
  }
  /**
   * Subscribe to a pubsub topic and start emitting Waku messages to observers.
   *
   * @override
   */
  gossipSubSubscribe(pubsubTopic) {
    this.gossipSub.addEventListener("gossipsub:message", (event) => {
      if (event.detail.msg.topic !== pubsubTopic)
        return;
      this.processIncomingMessage(event.detail.msg.topic, event.detail.msg.data).catch((e) => log17.error("Failed to process incoming message", e));
    });
    this.gossipSub.topicValidators.set(pubsubTopic, messageValidator);
    this.gossipSub.subscribe(pubsubTopic);
  }
  isRelayPubSub(pubsub) {
    var _a4;
    return ((_a4 = pubsub == null ? void 0 : pubsub.multicodecs) == null ? void 0 : _a4.includes(_Relay.multicodec)) ?? false;
  }
};
__publicField(_Relay, "multicodec", RelayCodecs[0]);
var Relay = _Relay;
function wakuRelay(init = {}) {
  return (libp2p) => new Relay(libp2p, init);
}
function wakuGossipSub(init = {}) {
  return (components) => {
    init = {
      ...init,
      msgIdFn: ({ data }) => sha256(data),
      // Ensure that no signature is included nor expected in the messages.
      globalSignaturePolicy: SignaturePolicy.StrictNoSign,
      fallbackToFloodsub: false
    };
    const pubsub = new GossipSub(components, init);
    pubsub.multicodecs = RelayCodecs;
    return pubsub;
  };
}

// node_modules/@libp2p/interface/dist/src/content-routing/index.js
var contentRouting = Symbol.for("@libp2p/content-routing");

// node_modules/@libp2p/interface/dist/src/peer-routing/index.js
var peerRouting = Symbol.for("@libp2p/peer-routing");

// node_modules/interface-datastore/node_modules/nanoid/index.browser.js
var nanoid = (size = 21) => crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {
  byte &= 63;
  if (byte < 36) {
    id += byte.toString(36);
  } else if (byte < 62) {
    id += (byte - 26).toString(36).toUpperCase();
  } else if (byte > 62) {
    id += "-";
  } else {
    id += "_";
  }
  return id;
}, "");

// node_modules/interface-datastore/dist/src/key.js
var pathSepS = "/";
var pathSepB = new TextEncoder().encode(pathSepS);
var pathSep = pathSepB[0];
var Key = class _Key {
  /**
   * @param {string | Uint8Array} s
   * @param {boolean} [clean]
   */
  constructor(s, clean) {
    __publicField(this, "_buf");
    if (typeof s === "string") {
      this._buf = fromString(s);
    } else if (s instanceof Uint8Array) {
      this._buf = s;
    } else {
      throw new Error("Invalid key, should be String of Uint8Array");
    }
    if (clean == null) {
      clean = true;
    }
    if (clean) {
      this.clean();
    }
    if (this._buf.byteLength === 0 || this._buf[0] !== pathSep) {
      throw new Error("Invalid key");
    }
  }
  /**
   * Convert to the string representation
   *
   * @param {import('uint8arrays/to-string').SupportedEncodings} [encoding='utf8'] - The encoding to use.
   * @returns {string}
   */
  toString(encoding = "utf8") {
    return toString(this._buf, encoding);
  }
  /**
   * Return the Uint8Array representation of the key
   *
   * @returns {Uint8Array}
   */
  uint8Array() {
    return this._buf;
  }
  /**
   * Return string representation of the key
   *
   * @returns {string}
   */
  get [Symbol.toStringTag]() {
    return `Key(${this.toString()})`;
  }
  /**
   * Constructs a key out of a namespace array.
   *
   * @param {Array<string>} list - The array of namespaces
   * @returns {Key}
   *
   * @example
   * ```js
   * Key.withNamespaces(['one', 'two'])
   * // => Key('/one/two')
   * ```
   */
  static withNamespaces(list) {
    return new _Key(list.join(pathSepS));
  }
  /**
   * Returns a randomly (uuid) generated key.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * Key.random()
   * // => Key('/f98719ea086343f7b71f32ea9d9d521d')
   * ```
   */
  static random() {
    return new _Key(nanoid().replace(/-/g, ""));
  }
  /**
   * @param {*} other
   */
  static asKey(other) {
    if (other instanceof Uint8Array || typeof other === "string") {
      return new _Key(other);
    }
    if (typeof other.uint8Array === "function") {
      return new _Key(other.uint8Array());
    }
    return null;
  }
  /**
   * Cleanup the current key
   *
   * @returns {void}
   */
  clean() {
    if (this._buf == null || this._buf.byteLength === 0) {
      this._buf = pathSepB;
    }
    if (this._buf[0] !== pathSep) {
      const bytes2 = new Uint8Array(this._buf.byteLength + 1);
      bytes2.fill(pathSep, 0, 1);
      bytes2.set(this._buf, 1);
      this._buf = bytes2;
    }
    while (this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === pathSep) {
      this._buf = this._buf.subarray(0, -1);
    }
  }
  /**
   * Check if the given key is sorted lower than ourself.
   *
   * @param {Key} key - The other Key to check against
   * @returns {boolean}
   */
  less(key) {
    const list1 = this.list();
    const list2 = key.list();
    for (let i = 0; i < list1.length; i++) {
      if (list2.length < i + 1) {
        return false;
      }
      const c1 = list1[i];
      const c2 = list2[i];
      if (c1 < c2) {
        return true;
      } else if (c1 > c2) {
        return false;
      }
    }
    return list1.length < list2.length;
  }
  /**
   * Returns the key with all parts in reversed order.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').reverse()
   * // => Key('/Actor:JohnCleese/MontyPython/Comedy')
   * ```
   */
  reverse() {
    return _Key.withNamespaces(this.list().slice().reverse());
  }
  /**
   * Returns the `namespaces` making up this Key.
   *
   * @returns {Array<string>}
   */
  namespaces() {
    return this.list();
  }
  /** Returns the "base" namespace of this key.
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').baseNamespace()
   * // => 'Actor:JohnCleese'
   * ```
   */
  baseNamespace() {
    const ns = this.namespaces();
    return ns[ns.length - 1];
  }
  /**
   * Returns the `list` representation of this key.
   *
   * @returns {Array<string>}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').list()
   * // => ['Comedy', 'MontyPythong', 'Actor:JohnCleese']
   * ```
   */
  list() {
    return this.toString().split(pathSepS).slice(1);
  }
  /**
   * Returns the "type" of this key (value of last namespace).
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').type()
   * // => 'Actor'
   * ```
   */
  type() {
    return namespaceType(this.baseNamespace());
  }
  /**
   * Returns the "name" of this key (field of last namespace).
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').name()
   * // => 'JohnCleese'
   * ```
   */
  name() {
    return namespaceValue(this.baseNamespace());
  }
  /**
   * Returns an "instance" of this type key (appends value to namespace).
   *
   * @param {string} s - The string to append.
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor').instance('JohnClesse')
   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')
   * ```
   */
  instance(s) {
    return new _Key(this.toString() + ":" + s);
  }
  /**
   * Returns the "path" of this key (parent + type).
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').path()
   * // => Key('/Comedy/MontyPython/Actor')
   * ```
   */
  path() {
    let p = this.parent().toString();
    if (!p.endsWith(pathSepS)) {
      p += pathSepS;
    }
    p += this.type();
    return new _Key(p);
  }
  /**
   * Returns the `parent` Key of this Key.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key("/Comedy/MontyPython/Actor:JohnCleese").parent()
   * // => Key("/Comedy/MontyPython")
   * ```
   */
  parent() {
    const list = this.list();
    if (list.length === 1) {
      return new _Key(pathSepS);
    }
    return new _Key(list.slice(0, -1).join(pathSepS));
  }
  /**
   * Returns the `child` Key of this Key.
   *
   * @param {Key} key - The child Key to add
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython').child(new Key('Actor:JohnCleese'))
   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')
   * ```
   */
  child(key) {
    if (this.toString() === pathSepS) {
      return key;
    } else if (key.toString() === pathSepS) {
      return this;
    }
    return new _Key(this.toString() + key.toString(), false);
  }
  /**
   * Returns whether this key is a prefix of `other`
   *
   * @param {Key} other - The other key to test against
   * @returns {boolean}
   *
   * @example
   * ```js
   * new Key('/Comedy').isAncestorOf('/Comedy/MontyPython')
   * // => true
   * ```
   */
  isAncestorOf(other) {
    if (other.toString() === this.toString()) {
      return false;
    }
    return other.toString().startsWith(this.toString());
  }
  /**
   * Returns whether this key is a contains another as prefix.
   *
   * @param {Key} other - The other Key to test against
   * @returns {boolean}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython').isDecendantOf('/Comedy')
   * // => true
   * ```
   */
  isDecendantOf(other) {
    if (other.toString() === this.toString()) {
      return false;
    }
    return this.toString().startsWith(other.toString());
  }
  /**
   * Checks if this key has only one namespace.
   *
   * @returns {boolean}
   */
  isTopLevel() {
    return this.list().length === 1;
  }
  /**
   * Concats one or more Keys into one new Key.
   *
   * @param {Array<Key>} keys - The array of keys to concatenate
   * @returns {Key}
   */
  concat(...keys) {
    return _Key.withNamespaces([...this.namespaces(), ...flatten(keys.map((key) => key.namespaces()))]);
  }
};
function namespaceType(ns) {
  const parts = ns.split(":");
  if (parts.length < 2) {
    return "";
  }
  return parts.slice(0, -1).join(":");
}
function namespaceValue(ns) {
  const parts = ns.split(":");
  return parts[parts.length - 1];
}
function flatten(arr) {
  return [].concat(...arr);
}

// node_modules/@libp2p/keychain/dist/src/index.js
var import_sanitize_filename = __toESM(require_sanitize_filename());

// node_modules/@libp2p/keychain/dist/src/errors.js
var codes2;
(function(codes6) {
  codes6["ERR_INVALID_PARAMETERS"] = "ERR_INVALID_PARAMETERS";
  codes6["ERR_INVALID_KEY_NAME"] = "ERR_INVALID_KEY_NAME";
  codes6["ERR_INVALID_KEY_TYPE"] = "ERR_INVALID_KEY_TYPE";
  codes6["ERR_KEY_ALREADY_EXISTS"] = "ERR_KEY_ALREADY_EXISTS";
  codes6["ERR_INVALID_KEY_SIZE"] = "ERR_INVALID_KEY_SIZE";
  codes6["ERR_KEY_NOT_FOUND"] = "ERR_KEY_NOT_FOUND";
  codes6["ERR_OLD_KEY_NAME_INVALID"] = "ERR_OLD_KEY_NAME_INVALID";
  codes6["ERR_NEW_KEY_NAME_INVALID"] = "ERR_NEW_KEY_NAME_INVALID";
  codes6["ERR_PASSWORD_REQUIRED"] = "ERR_PASSWORD_REQUIRED";
  codes6["ERR_PEM_REQUIRED"] = "ERR_PEM_REQUIRED";
  codes6["ERR_CANNOT_READ_KEY"] = "ERR_CANNOT_READ_KEY";
  codes6["ERR_MISSING_PRIVATE_KEY"] = "ERR_MISSING_PRIVATE_KEY";
  codes6["ERR_INVALID_OLD_PASS_TYPE"] = "ERR_INVALID_OLD_PASS_TYPE";
  codes6["ERR_INVALID_NEW_PASS_TYPE"] = "ERR_INVALID_NEW_PASS_TYPE";
  codes6["ERR_INVALID_PASS_LENGTH"] = "ERR_INVALID_PASS_LENGTH";
})(codes2 || (codes2 = {}));

// node_modules/@libp2p/keychain/dist/src/index.js
var log18 = logger("libp2p:keychain");
var keyPrefix = "/pkcs8/";
var infoPrefix = "/info/";
var privates = /* @__PURE__ */ new WeakMap();
var NIST = {
  minKeyLength: 112 / 8,
  minSaltLength: 128 / 8,
  minIterationCount: 1e3
};
var defaultOptions = {
  // See https://cryptosense.com/parametesr-choice-for-pbkdf2/
  dek: {
    keyLength: 512 / 8,
    iterationCount: 1e4,
    salt: "you should override this value with a crypto secure random number",
    hash: "sha2-512"
  }
};
function validateKeyName(name2) {
  if (name2 == null) {
    return false;
  }
  if (typeof name2 !== "string") {
    return false;
  }
  return name2 === (0, import_sanitize_filename.default)(name2.trim()) && name2.length > 0;
}
async function randomDelay() {
  const min = 200;
  const max = 1e3;
  const delay = Math.random() * (max - min) + min;
  await new Promise((resolve) => setTimeout(resolve, delay));
}
function DsName(name2) {
  return new Key(keyPrefix + name2);
}
function DsInfoName(name2) {
  return new Key(infoPrefix + name2);
}
var DefaultKeyChain = class {
  /**
   * Creates a new instance of a key chain
   */
  constructor(components, init) {
    __publicField(this, "components");
    __publicField(this, "init");
    var _a4, _b4, _c, _d, _e, _f, _g, _h, _i, _j;
    this.components = components;
    this.init = merge_options_default(defaultOptions, init);
    if (this.init.pass != null && ((_a4 = this.init.pass) == null ? void 0 : _a4.length) < 20) {
      throw new Error("pass must be least 20 characters");
    }
    if (((_b4 = this.init.dek) == null ? void 0 : _b4.keyLength) != null && this.init.dek.keyLength < NIST.minKeyLength) {
      throw new Error(`dek.keyLength must be least ${NIST.minKeyLength} bytes`);
    }
    if (((_d = (_c = this.init.dek) == null ? void 0 : _c.salt) == null ? void 0 : _d.length) != null && this.init.dek.salt.length < NIST.minSaltLength) {
      throw new Error(`dek.saltLength must be least ${NIST.minSaltLength} bytes`);
    }
    if (((_e = this.init.dek) == null ? void 0 : _e.iterationCount) != null && this.init.dek.iterationCount < NIST.minIterationCount) {
      throw new Error(`dek.iterationCount must be least ${NIST.minIterationCount}`);
    }
    const dek = this.init.pass != null && ((_f = this.init.dek) == null ? void 0 : _f.salt) != null ? pbkdf2(this.init.pass, (_g = this.init.dek) == null ? void 0 : _g.salt, (_h = this.init.dek) == null ? void 0 : _h.iterationCount, (_i = this.init.dek) == null ? void 0 : _i.keyLength, (_j = this.init.dek) == null ? void 0 : _j.hash) : "";
    privates.set(this, { dek });
  }
  /**
   * Generates the options for a keychain.  A random salt is produced.
   *
   * @returns {object}
   */
  static generateOptions() {
    const options = Object.assign({}, defaultOptions);
    const saltLength = Math.ceil(NIST.minSaltLength / 3) * 3;
    options.dek.salt = toString(randomBytes2(saltLength), "base64");
    return options;
  }
  /**
   * Gets an object that can encrypt/decrypt protected data.
   * The default options for a keychain.
   *
   * @returns {object}
   */
  static get options() {
    return defaultOptions;
  }
  /**
   * Create a new key.
   *
   * @param {string} name - The local key name; cannot already exist.
   * @param {string} type - One of the key types; 'rsa'.
   * @param {number} [size = 2048] - The key size in bits. Used for rsa keys only
   */
  async createKey(name2, type, size = 2048) {
    if (!validateKeyName(name2) || name2 === "self") {
      await randomDelay();
      throw new CodeError("Invalid key name", codes2.ERR_INVALID_KEY_NAME);
    }
    if (typeof type !== "string") {
      await randomDelay();
      throw new CodeError("Invalid key type", codes2.ERR_INVALID_KEY_TYPE);
    }
    const dsname = DsName(name2);
    const exists2 = await this.components.datastore.has(dsname);
    if (exists2) {
      await randomDelay();
      throw new CodeError("Key name already exists", codes2.ERR_KEY_ALREADY_EXISTS);
    }
    switch (type.toLowerCase()) {
      case "rsa":
        if (!Number.isSafeInteger(size) || size < 2048) {
          await randomDelay();
          throw new CodeError("Invalid RSA key size", codes2.ERR_INVALID_KEY_SIZE);
        }
        break;
      default:
        break;
    }
    let keyInfo;
    try {
      const keypair = await generateKeyPair4(type, size);
      const kid = await keypair.id();
      const cached = privates.get(this);
      if (cached == null) {
        throw new CodeError("dek missing", codes2.ERR_INVALID_PARAMETERS);
      }
      const dek = cached.dek;
      const pem = await keypair.export(dek);
      keyInfo = {
        name: name2,
        id: kid
      };
      const batch = this.components.datastore.batch();
      batch.put(dsname, fromString(pem));
      batch.put(DsInfoName(name2), fromString(JSON.stringify(keyInfo)));
      await batch.commit();
    } catch (err) {
      await randomDelay();
      throw err;
    }
    return keyInfo;
  }
  /**
   * List all the keys.
   *
   * @returns {Promise<KeyInfo[]>}
   */
  async listKeys() {
    const query = {
      prefix: infoPrefix
    };
    const info = [];
    for await (const value of this.components.datastore.query(query)) {
      info.push(JSON.parse(toString(value.value)));
    }
    return info;
  }
  /**
   * Find a key by it's id
   */
  async findKeyById(id) {
    try {
      const keys = await this.listKeys();
      const key = keys.find((k) => k.id === id);
      if (key == null) {
        throw new CodeError(`Key with id '${id}' does not exist.`, codes2.ERR_KEY_NOT_FOUND);
      }
      return key;
    } catch (err) {
      await randomDelay();
      throw err;
    }
  }
  /**
   * Find a key by it's name.
   *
   * @param {string} name - The local key name.
   * @returns {Promise<KeyInfo>}
   */
  async findKeyByName(name2) {
    if (!validateKeyName(name2)) {
      await randomDelay();
      throw new CodeError(`Invalid key name '${name2}'`, codes2.ERR_INVALID_KEY_NAME);
    }
    const dsname = DsInfoName(name2);
    try {
      const res = await this.components.datastore.get(dsname);
      return JSON.parse(toString(res));
    } catch (err) {
      await randomDelay();
      log18.error(err);
      throw new CodeError(`Key '${name2}' does not exist.`, codes2.ERR_KEY_NOT_FOUND);
    }
  }
  /**
   * Remove an existing key.
   *
   * @param {string} name - The local key name; must already exist.
   * @returns {Promise<KeyInfo>}
   */
  async removeKey(name2) {
    if (!validateKeyName(name2) || name2 === "self") {
      await randomDelay();
      throw new CodeError(`Invalid key name '${name2}'`, codes2.ERR_INVALID_KEY_NAME);
    }
    const dsname = DsName(name2);
    const keyInfo = await this.findKeyByName(name2);
    const batch = this.components.datastore.batch();
    batch.delete(dsname);
    batch.delete(DsInfoName(name2));
    await batch.commit();
    return keyInfo;
  }
  /**
   * Rename a key
   *
   * @param {string} oldName - The old local key name; must already exist.
   * @param {string} newName - The new local key name; must not already exist.
   * @returns {Promise<KeyInfo>}
   */
  async renameKey(oldName, newName) {
    if (!validateKeyName(oldName) || oldName === "self") {
      await randomDelay();
      throw new CodeError(`Invalid old key name '${oldName}'`, codes2.ERR_OLD_KEY_NAME_INVALID);
    }
    if (!validateKeyName(newName) || newName === "self") {
      await randomDelay();
      throw new CodeError(`Invalid new key name '${newName}'`, codes2.ERR_NEW_KEY_NAME_INVALID);
    }
    const oldDsname = DsName(oldName);
    const newDsname = DsName(newName);
    const oldInfoName = DsInfoName(oldName);
    const newInfoName = DsInfoName(newName);
    const exists2 = await this.components.datastore.has(newDsname);
    if (exists2) {
      await randomDelay();
      throw new CodeError(`Key '${newName}' already exists`, codes2.ERR_KEY_ALREADY_EXISTS);
    }
    try {
      const pem = await this.components.datastore.get(oldDsname);
      const res = await this.components.datastore.get(oldInfoName);
      const keyInfo = JSON.parse(toString(res));
      keyInfo.name = newName;
      const batch = this.components.datastore.batch();
      batch.put(newDsname, pem);
      batch.put(newInfoName, fromString(JSON.stringify(keyInfo)));
      batch.delete(oldDsname);
      batch.delete(oldInfoName);
      await batch.commit();
      return keyInfo;
    } catch (err) {
      await randomDelay();
      throw err;
    }
  }
  /**
   * Export an existing key as a PEM encrypted PKCS #8 string
   */
  async exportKey(name2, password) {
    if (!validateKeyName(name2)) {
      await randomDelay();
      throw new CodeError(`Invalid key name '${name2}'`, codes2.ERR_INVALID_KEY_NAME);
    }
    if (password == null) {
      await randomDelay();
      throw new CodeError("Password is required", codes2.ERR_PASSWORD_REQUIRED);
    }
    const dsname = DsName(name2);
    try {
      const res = await this.components.datastore.get(dsname);
      const pem = toString(res);
      const cached = privates.get(this);
      if (cached == null) {
        throw new CodeError("dek missing", codes2.ERR_INVALID_PARAMETERS);
      }
      const dek = cached.dek;
      const privateKey = await importKey(pem, dek);
      const keyString = await privateKey.export(password);
      return keyString;
    } catch (err) {
      await randomDelay();
      throw err;
    }
  }
  /**
   * Export an existing key as a PeerId
   */
  async exportPeerId(name2) {
    const password = "temporary-password";
    const pem = await this.exportKey(name2, password);
    const privateKey = await importKey(pem, password);
    return peerIdFromKeys(privateKey.public.bytes, privateKey.bytes);
  }
  /**
   * Import a new key from a PEM encoded PKCS #8 string
   *
   * @param {string} name - The local key name; must not already exist.
   * @param {string} pem - The PEM encoded PKCS #8 string
   * @param {string} password - The password.
   * @returns {Promise<KeyInfo>}
   */
  async importKey(name2, pem, password) {
    if (!validateKeyName(name2) || name2 === "self") {
      await randomDelay();
      throw new CodeError(`Invalid key name '${name2}'`, codes2.ERR_INVALID_KEY_NAME);
    }
    if (pem == null) {
      await randomDelay();
      throw new CodeError("PEM encoded key is required", codes2.ERR_PEM_REQUIRED);
    }
    const dsname = DsName(name2);
    const exists2 = await this.components.datastore.has(dsname);
    if (exists2) {
      await randomDelay();
      throw new CodeError(`Key '${name2}' already exists`, codes2.ERR_KEY_ALREADY_EXISTS);
    }
    let privateKey;
    try {
      privateKey = await importKey(pem, password);
    } catch (err) {
      await randomDelay();
      throw new CodeError("Cannot read the key, most likely the password is wrong", codes2.ERR_CANNOT_READ_KEY);
    }
    let kid;
    try {
      kid = await privateKey.id();
      const cached = privates.get(this);
      if (cached == null) {
        throw new CodeError("dek missing", codes2.ERR_INVALID_PARAMETERS);
      }
      const dek = cached.dek;
      pem = await privateKey.export(dek);
    } catch (err) {
      await randomDelay();
      throw err;
    }
    const keyInfo = {
      name: name2,
      id: kid
    };
    const batch = this.components.datastore.batch();
    batch.put(dsname, fromString(pem));
    batch.put(DsInfoName(name2), fromString(JSON.stringify(keyInfo)));
    await batch.commit();
    return keyInfo;
  }
  /**
   * Import a peer key
   */
  async importPeer(name2, peer) {
    try {
      if (!validateKeyName(name2)) {
        throw new CodeError(`Invalid key name '${name2}'`, codes2.ERR_INVALID_KEY_NAME);
      }
      if (peer == null) {
        throw new CodeError("PeerId is required", codes2.ERR_MISSING_PRIVATE_KEY);
      }
      if (peer.privateKey == null) {
        throw new CodeError("PeerId.privKey is required", codes2.ERR_MISSING_PRIVATE_KEY);
      }
      const privateKey = await unmarshalPrivateKey2(peer.privateKey);
      const dsname = DsName(name2);
      const exists2 = await this.components.datastore.has(dsname);
      if (exists2) {
        await randomDelay();
        throw new CodeError(`Key '${name2}' already exists`, codes2.ERR_KEY_ALREADY_EXISTS);
      }
      const cached = privates.get(this);
      if (cached == null) {
        throw new CodeError("dek missing", codes2.ERR_INVALID_PARAMETERS);
      }
      const dek = cached.dek;
      const pem = await privateKey.export(dek);
      const keyInfo = {
        name: name2,
        id: peer.toString()
      };
      const batch = this.components.datastore.batch();
      batch.put(dsname, fromString(pem));
      batch.put(DsInfoName(name2), fromString(JSON.stringify(keyInfo)));
      await batch.commit();
      return keyInfo;
    } catch (err) {
      await randomDelay();
      throw err;
    }
  }
  /**
   * Gets the private key as PEM encoded PKCS #8 string
   */
  async getPrivateKey(name2) {
    if (!validateKeyName(name2)) {
      await randomDelay();
      throw new CodeError(`Invalid key name '${name2}'`, codes2.ERR_INVALID_KEY_NAME);
    }
    try {
      const dsname = DsName(name2);
      const res = await this.components.datastore.get(dsname);
      return toString(res);
    } catch (err) {
      await randomDelay();
      log18.error(err);
      throw new CodeError(`Key '${name2}' does not exist.`, codes2.ERR_KEY_NOT_FOUND);
    }
  }
  /**
   * Rotate keychain password and re-encrypt all associated keys
   */
  async rotateKeychainPass(oldPass, newPass) {
    var _a4, _b4, _c, _d;
    if (typeof oldPass !== "string") {
      await randomDelay();
      throw new CodeError(`Invalid old pass type '${typeof oldPass}'`, codes2.ERR_INVALID_OLD_PASS_TYPE);
    }
    if (typeof newPass !== "string") {
      await randomDelay();
      throw new CodeError(`Invalid new pass type '${typeof newPass}'`, codes2.ERR_INVALID_NEW_PASS_TYPE);
    }
    if (newPass.length < 20) {
      await randomDelay();
      throw new CodeError(`Invalid pass length ${newPass.length}`, codes2.ERR_INVALID_PASS_LENGTH);
    }
    log18("recreating keychain");
    const cached = privates.get(this);
    if (cached == null) {
      throw new CodeError("dek missing", codes2.ERR_INVALID_PARAMETERS);
    }
    const oldDek = cached.dek;
    this.init.pass = newPass;
    const newDek = newPass != null && ((_a4 = this.init.dek) == null ? void 0 : _a4.salt) != null ? pbkdf2(newPass, this.init.dek.salt, (_b4 = this.init.dek) == null ? void 0 : _b4.iterationCount, (_c = this.init.dek) == null ? void 0 : _c.keyLength, (_d = this.init.dek) == null ? void 0 : _d.hash) : "";
    privates.set(this, { dek: newDek });
    const keys = await this.listKeys();
    for (const key of keys) {
      const res = await this.components.datastore.get(DsName(key.name));
      const pem = toString(res);
      const privateKey = await importKey(pem, oldDek);
      const password = newDek.toString();
      const keyAsPEM = await privateKey.export(password);
      const batch = this.components.datastore.batch();
      const keyInfo = {
        name: key.name,
        id: key.id
      };
      batch.put(DsName(key.name), fromString(keyAsPEM));
      batch.put(DsInfoName(key.name), fromString(JSON.stringify(keyInfo)));
      await batch.commit();
    }
    log18("keychain reconstructed");
  }
};

// node_modules/@libp2p/peer-collections/dist/src/util.js
function mapIterable(iter, map3) {
  const iterator = {
    [Symbol.iterator]: () => {
      return iterator;
    },
    next: () => {
      const next = iter.next();
      const val = next.value;
      if (next.done === true || val == null) {
        const result = {
          done: true,
          value: void 0
        };
        return result;
      }
      return {
        done: false,
        value: map3(val)
      };
    }
  };
  return iterator;
}

// node_modules/@libp2p/peer-collections/dist/src/map.js
var PeerMap = class {
  constructor(map3) {
    __publicField(this, "map");
    this.map = /* @__PURE__ */ new Map();
    if (map3 != null) {
      for (const [key, value] of map3.entries()) {
        this.map.set(key.toString(), value);
      }
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  clear() {
    this.map.clear();
  }
  delete(peer) {
    this.map.delete(peer.toString());
  }
  entries() {
    return mapIterable(this.map.entries(), (val) => {
      return [peerIdFromString(val[0]), val[1]];
    });
  }
  forEach(fn) {
    this.map.forEach((value, key) => {
      fn(value, peerIdFromString(key), this);
    });
  }
  get(peer) {
    return this.map.get(peer.toString());
  }
  has(peer) {
    return this.map.has(peer.toString());
  }
  set(peer, value) {
    this.map.set(peer.toString(), value);
  }
  keys() {
    return mapIterable(this.map.keys(), (val) => {
      return peerIdFromString(val);
    });
  }
  values() {
    return this.map.values();
  }
  get size() {
    return this.map.size;
  }
};

// node_modules/@libp2p/peer-collections/dist/src/set.js
var PeerSet = class _PeerSet {
  constructor(set) {
    __publicField(this, "set");
    this.set = /* @__PURE__ */ new Set();
    if (set != null) {
      for (const key of set) {
        this.set.add(key.toString());
      }
    }
  }
  get size() {
    return this.set.size;
  }
  [Symbol.iterator]() {
    return this.values();
  }
  add(peer) {
    this.set.add(peer.toString());
  }
  clear() {
    this.set.clear();
  }
  delete(peer) {
    this.set.delete(peer.toString());
  }
  entries() {
    return mapIterable(this.set.entries(), (val) => {
      const peerId2 = peerIdFromString(val[0]);
      return [peerId2, peerId2];
    });
  }
  forEach(predicate) {
    this.set.forEach((str) => {
      const id = peerIdFromString(str);
      predicate(id, id, this);
    });
  }
  has(peer) {
    return this.set.has(peer.toString());
  }
  values() {
    return mapIterable(this.set.values(), (val) => {
      return peerIdFromString(val);
    });
  }
  intersection(other) {
    const output2 = new _PeerSet();
    for (const peerId2 of other) {
      if (this.has(peerId2)) {
        output2.add(peerId2);
      }
    }
    return output2;
  }
  difference(other) {
    const output2 = new _PeerSet();
    for (const peerId2 of this) {
      if (!other.has(peerId2)) {
        output2.add(peerId2);
      }
    }
    return output2;
  }
  union(other) {
    const output2 = new _PeerSet();
    for (const peerId2 of other) {
      output2.add(peerId2);
    }
    for (const peerId2 of this) {
      output2.add(peerId2);
    }
    return output2;
  }
};

// node_modules/@libp2p/peer-collections/dist/src/list.js
var PeerList = class _PeerList {
  constructor(list) {
    __publicField(this, "list");
    this.list = [];
    if (list != null) {
      for (const value of list) {
        this.list.push(value.toString());
      }
    }
  }
  [Symbol.iterator]() {
    return mapIterable(this.list.entries(), (val) => {
      return peerIdFromString(val[1]);
    });
  }
  concat(list) {
    const output2 = new _PeerList(this);
    for (const value of list) {
      output2.push(value);
    }
    return output2;
  }
  entries() {
    return mapIterable(this.list.entries(), (val) => {
      return [val[0], peerIdFromString(val[1])];
    });
  }
  every(predicate) {
    return this.list.every((str, index) => {
      return predicate(peerIdFromString(str), index, this);
    });
  }
  filter(predicate) {
    const output2 = new _PeerList();
    this.list.forEach((str, index) => {
      const peerId2 = peerIdFromString(str);
      if (predicate(peerId2, index, this)) {
        output2.push(peerId2);
      }
    });
    return output2;
  }
  find(predicate) {
    const str = this.list.find((str2, index) => {
      return predicate(peerIdFromString(str2), index, this);
    });
    if (str == null) {
      return void 0;
    }
    return peerIdFromString(str);
  }
  findIndex(predicate) {
    return this.list.findIndex((str, index) => {
      return predicate(peerIdFromString(str), index, this);
    });
  }
  forEach(predicate) {
    this.list.forEach((str, index) => {
      predicate(peerIdFromString(str), index, this);
    });
  }
  includes(peerId2) {
    return this.list.includes(peerId2.toString());
  }
  indexOf(peerId2) {
    return this.list.indexOf(peerId2.toString());
  }
  pop() {
    const str = this.list.pop();
    if (str == null) {
      return void 0;
    }
    return peerIdFromString(str);
  }
  push(...peerIds) {
    for (const peerId2 of peerIds) {
      this.list.push(peerId2.toString());
    }
  }
  shift() {
    const str = this.list.shift();
    if (str == null) {
      return void 0;
    }
    return peerIdFromString(str);
  }
  unshift(...peerIds) {
    let len = this.list.length;
    for (let i = peerIds.length - 1; i > -1; i--) {
      len = this.list.unshift(peerIds[i].toString());
    }
    return len;
  }
  get length() {
    return this.list.length;
  }
};

// node_modules/@libp2p/peer-id-factory/dist/src/proto.js
var PeerIdProto;
(function(PeerIdProto2) {
  let _codec;
  PeerIdProto2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.id != null) {
          w.uint32(10);
          w.bytes(obj.id);
        }
        if (obj.pubKey != null) {
          w.uint32(18);
          w.bytes(obj.pubKey);
        }
        if (obj.privKey != null) {
          w.uint32(26);
          w.bytes(obj.privKey);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length4) => {
        const obj = {};
        const end = length4 == null ? reader2.len : reader2.pos + length4;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.id = reader2.bytes();
              break;
            case 2:
              obj.pubKey = reader2.bytes();
              break;
            case 3:
              obj.privKey = reader2.bytes();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PeerIdProto2.encode = (obj) => {
    return encodeMessage(obj, PeerIdProto2.codec());
  };
  PeerIdProto2.decode = (buf) => {
    return decodeMessage(buf, PeerIdProto2.codec());
  };
})(PeerIdProto || (PeerIdProto = {}));

// node_modules/@libp2p/peer-id-factory/dist/src/index.js
var createEd25519PeerId = async () => {
  const key = await generateKeyPair4("Ed25519");
  const id = await createFromPrivKey(key);
  if (id.type === "Ed25519") {
    return id;
  }
  throw new Error(`Generated unexpected PeerId type "${id.type}"`);
};
async function createFromPrivKey(privateKey) {
  return peerIdFromKeys(marshalPublicKey(privateKey.public), marshalPrivateKey(privateKey));
}

// node_modules/@libp2p/peer-record/dist/src/errors.js
var codes3 = {
  ERR_SIGNATURE_NOT_VALID: "ERR_SIGNATURE_NOT_VALID"
};

// node_modules/@libp2p/peer-record/dist/src/envelope/envelope.js
var Envelope;
(function(Envelope2) {
  let _codec;
  Envelope2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.publicKey != null && obj.publicKey.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.publicKey);
        }
        if (obj.payloadType != null && obj.payloadType.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.payloadType);
        }
        if (obj.payload != null && obj.payload.byteLength > 0) {
          w.uint32(26);
          w.bytes(obj.payload);
        }
        if (obj.signature != null && obj.signature.byteLength > 0) {
          w.uint32(42);
          w.bytes(obj.signature);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length4) => {
        const obj = {
          publicKey: new Uint8Array(0),
          payloadType: new Uint8Array(0),
          payload: new Uint8Array(0),
          signature: new Uint8Array(0)
        };
        const end = length4 == null ? reader2.len : reader2.pos + length4;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.publicKey = reader2.bytes();
              break;
            case 2:
              obj.payloadType = reader2.bytes();
              break;
            case 3:
              obj.payload = reader2.bytes();
              break;
            case 5:
              obj.signature = reader2.bytes();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Envelope2.encode = (obj) => {
    return encodeMessage(obj, Envelope2.codec());
  };
  Envelope2.decode = (buf) => {
    return decodeMessage(buf, Envelope2.codec());
  };
})(Envelope || (Envelope = {}));

// node_modules/@libp2p/peer-record/dist/src/envelope/index.js
var _RecordEnvelope = class _RecordEnvelope {
  /**
   * The Envelope is responsible for keeping an arbitrary signed record
   * by a libp2p peer.
   */
  constructor(init) {
    __publicField(this, "peerId");
    __publicField(this, "payloadType");
    __publicField(this, "payload");
    __publicField(this, "signature");
    __publicField(this, "marshaled");
    const { peerId: peerId2, payloadType, payload, signature } = init;
    this.peerId = peerId2;
    this.payloadType = payloadType;
    this.payload = payload;
    this.signature = signature;
  }
  /**
   * Marshal the envelope content
   */
  marshal() {
    if (this.peerId.publicKey == null) {
      throw new Error("Missing public key");
    }
    if (this.marshaled == null) {
      this.marshaled = Envelope.encode({
        publicKey: this.peerId.publicKey,
        payloadType: this.payloadType,
        payload: this.payload.subarray(),
        signature: this.signature
      });
    }
    return this.marshaled;
  }
  /**
   * Verifies if the other Envelope is identical to this one
   */
  equals(other) {
    return equals(this.marshal(), other.marshal());
  }
  /**
   * Validate envelope data signature for the given domain
   */
  async validate(domain) {
    const signData = formatSignaturePayload(domain, this.payloadType, this.payload);
    if (this.peerId.publicKey == null) {
      throw new Error("Missing public key");
    }
    const key = unmarshalPublicKey(this.peerId.publicKey);
    return key.verify(signData.subarray(), this.signature);
  }
};
/**
 * Unmarshal a serialized Envelope protobuf message
 */
__publicField(_RecordEnvelope, "createFromProtobuf", async (data) => {
  const envelopeData = Envelope.decode(data);
  const peerId2 = await peerIdFromKeys(envelopeData.publicKey);
  return new _RecordEnvelope({
    peerId: peerId2,
    payloadType: envelopeData.payloadType,
    payload: envelopeData.payload,
    signature: envelopeData.signature
  });
});
/**
 * Seal marshals the given Record, places the marshaled bytes inside an Envelope
 * and signs it with the given peerId's private key
 */
__publicField(_RecordEnvelope, "seal", async (record, peerId2) => {
  if (peerId2.privateKey == null) {
    throw new Error("Missing private key");
  }
  const domain = record.domain;
  const payloadType = record.codec;
  const payload = record.marshal();
  const signData = formatSignaturePayload(domain, payloadType, payload);
  const key = await unmarshalPrivateKey2(peerId2.privateKey);
  const signature = await key.sign(signData.subarray());
  return new _RecordEnvelope({
    peerId: peerId2,
    payloadType,
    payload,
    signature
  });
});
/**
 * Open and certify a given marshalled envelope.
 * Data is unmarshalled and the signature validated for the given domain.
 */
__publicField(_RecordEnvelope, "openAndCertify", async (data, domain) => {
  const envelope = await _RecordEnvelope.createFromProtobuf(data);
  const valid = await envelope.validate(domain);
  if (!valid) {
    throw new CodeError("envelope signature is not valid for the given domain", codes3.ERR_SIGNATURE_NOT_VALID);
  }
  return envelope;
});
var RecordEnvelope = _RecordEnvelope;
var formatSignaturePayload = (domain, payloadType, payload) => {
  const domainUint8Array = fromString(domain);
  const domainLength = encode(domainUint8Array.byteLength);
  const payloadTypeLength = encode(payloadType.length);
  const payloadLength = encode(payload.length);
  return new Uint8ArrayList(domainLength, domainUint8Array, payloadTypeLength, payloadType, payloadLength, payload);
};

// node_modules/@libp2p/utils/dist/src/array-equals.js
function arrayEquals(a, b) {
  const sort2 = (a2, b2) => a2.toString().localeCompare(b2.toString());
  if (a.length !== b.length) {
    return false;
  }
  b.sort(sort2);
  return a.sort(sort2).every((item, index) => b[index].equals(item));
}

// node_modules/@libp2p/peer-record/dist/src/peer-record/consts.js
var ENVELOPE_DOMAIN_PEER_RECORD = "libp2p-peer-record";
var ENVELOPE_PAYLOAD_TYPE_PEER_RECORD = Uint8Array.from([3, 1]);

// node_modules/@libp2p/peer-record/dist/src/peer-record/peer-record.js
var PeerRecord;
(function(PeerRecord3) {
  let AddressInfo;
  (function(AddressInfo2) {
    let _codec2;
    AddressInfo2.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.multiaddr != null && obj.multiaddr.byteLength > 0) {
            w.uint32(10);
            w.bytes(obj.multiaddr);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length4) => {
          const obj = {
            multiaddr: new Uint8Array(0)
          };
          const end = length4 == null ? reader2.len : reader2.pos + length4;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.multiaddr = reader2.bytes();
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    AddressInfo2.encode = (obj) => {
      return encodeMessage(obj, AddressInfo2.codec());
    };
    AddressInfo2.decode = (buf) => {
      return decodeMessage(buf, AddressInfo2.codec());
    };
  })(AddressInfo = PeerRecord3.AddressInfo || (PeerRecord3.AddressInfo = {}));
  let _codec;
  PeerRecord3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.peerId != null && obj.peerId.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.peerId);
        }
        if (obj.seq != null && obj.seq !== 0n) {
          w.uint32(16);
          w.uint64(obj.seq);
        }
        if (obj.addresses != null) {
          for (const value of obj.addresses) {
            w.uint32(26);
            PeerRecord3.AddressInfo.codec().encode(value, w);
          }
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length4) => {
        const obj = {
          peerId: new Uint8Array(0),
          seq: 0n,
          addresses: []
        };
        const end = length4 == null ? reader2.len : reader2.pos + length4;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.peerId = reader2.bytes();
              break;
            case 2:
              obj.seq = reader2.uint64();
              break;
            case 3:
              obj.addresses.push(PeerRecord3.AddressInfo.codec().decode(reader2, reader2.uint32()));
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PeerRecord3.encode = (obj) => {
    return encodeMessage(obj, PeerRecord3.codec());
  };
  PeerRecord3.decode = (buf) => {
    return decodeMessage(buf, PeerRecord3.codec());
  };
})(PeerRecord || (PeerRecord = {}));

// node_modules/@libp2p/peer-record/dist/src/peer-record/index.js
var _PeerRecord = class _PeerRecord {
  constructor(init) {
    __publicField(this, "peerId");
    __publicField(this, "multiaddrs");
    __publicField(this, "seqNumber");
    __publicField(this, "domain", _PeerRecord.DOMAIN);
    __publicField(this, "codec", _PeerRecord.CODEC);
    __publicField(this, "marshaled");
    const { peerId: peerId2, multiaddrs, seqNumber } = init;
    this.peerId = peerId2;
    this.multiaddrs = multiaddrs ?? [];
    this.seqNumber = seqNumber ?? BigInt(Date.now());
  }
  /**
   * Marshal a record to be used in an envelope
   */
  marshal() {
    if (this.marshaled == null) {
      this.marshaled = PeerRecord.encode({
        peerId: this.peerId.toBytes(),
        seq: BigInt(this.seqNumber),
        addresses: this.multiaddrs.map((m) => ({
          multiaddr: m.bytes
        }))
      });
    }
    return this.marshaled;
  }
  /**
   * Returns true if `this` record equals the `other`
   */
  equals(other) {
    if (!(other instanceof _PeerRecord)) {
      return false;
    }
    if (!this.peerId.equals(other.peerId)) {
      return false;
    }
    if (this.seqNumber !== other.seqNumber) {
      return false;
    }
    if (!arrayEquals(this.multiaddrs, other.multiaddrs)) {
      return false;
    }
    return true;
  }
};
/**
 * Unmarshal Peer Record Protobuf
 */
__publicField(_PeerRecord, "createFromProtobuf", (buf) => {
  const peerRecord = PeerRecord.decode(buf);
  const peerId2 = peerIdFromBytes(peerRecord.peerId);
  const multiaddrs = (peerRecord.addresses ?? []).map((a) => multiaddr(a.multiaddr));
  const seqNumber = peerRecord.seq;
  return new _PeerRecord({ peerId: peerId2, multiaddrs, seqNumber });
});
__publicField(_PeerRecord, "DOMAIN", ENVELOPE_DOMAIN_PEER_RECORD);
__publicField(_PeerRecord, "CODEC", ENVELOPE_PAYLOAD_TYPE_PEER_RECORD);
var PeerRecord2 = _PeerRecord;

// node_modules/p-queue/node_modules/eventemitter3/index.mjs
var import_index3 = __toESM(require_eventemitter3(), 1);

// node_modules/p-queue/node_modules/p-timeout/index.js
var TimeoutError2 = class extends Error {
  constructor(message2) {
    super(message2);
    this.name = "TimeoutError";
  }
};
var AbortError7 = class extends Error {
  constructor(message2) {
    super();
    this.name = "AbortError";
    this.message = message2;
  }
};
var getDOMException2 = (errorMessage) => globalThis.DOMException === void 0 ? new AbortError7(errorMessage) : new DOMException(errorMessage);
var getAbortedReason2 = (signal) => {
  const reason = signal.reason === void 0 ? getDOMException2("This operation was aborted.") : signal.reason;
  return reason instanceof Error ? reason : getDOMException2(reason);
};
function pTimeout2(promise, milliseconds, fallback, options) {
  let timer;
  const cancelablePromise = new Promise((resolve, reject) => {
    if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
      throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
    }
    if (milliseconds === Number.POSITIVE_INFINITY) {
      resolve(promise);
      return;
    }
    options = {
      customTimers: { setTimeout, clearTimeout },
      ...options
    };
    if (options.signal) {
      const { signal } = options;
      if (signal.aborted) {
        reject(getAbortedReason2(signal));
      }
      signal.addEventListener("abort", () => {
        reject(getAbortedReason2(signal));
      });
    }
    timer = options.customTimers.setTimeout.call(void 0, () => {
      if (typeof fallback === "function") {
        try {
          resolve(fallback());
        } catch (error) {
          reject(error);
        }
        return;
      }
      const message2 = typeof fallback === "string" ? fallback : `Promise timed out after ${milliseconds} milliseconds`;
      const timeoutError = fallback instanceof Error ? fallback : new TimeoutError2(message2);
      if (typeof promise.cancel === "function") {
        promise.cancel();
      }
      reject(timeoutError);
    }, milliseconds);
    (async () => {
      try {
        resolve(await promise);
      } catch (error) {
        reject(error);
      } finally {
        options.customTimers.clearTimeout.call(void 0, timer);
      }
    })();
  });
  cancelablePromise.clear = () => {
    clearTimeout(timer);
    timer = void 0;
  };
  return cancelablePromise;
}

// node_modules/p-queue/dist/lower-bound.js
function lowerBound(array, value, comparator) {
  let first2 = 0;
  let count = array.length;
  while (count > 0) {
    const step = Math.trunc(count / 2);
    let it = first2 + step;
    if (comparator(array[it], value) <= 0) {
      first2 = ++it;
      count -= step + 1;
    } else {
      count = step;
    }
  }
  return first2;
}

// node_modules/p-queue/dist/priority-queue.js
var __classPrivateFieldGet = function(receiver, state, kind, f2) {
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var _PriorityQueue_queue;
var PriorityQueue = class {
  constructor() {
    _PriorityQueue_queue.set(this, []);
  }
  enqueue(run, options) {
    options = {
      priority: 0,
      ...options
    };
    const element = {
      priority: options.priority,
      run
    };
    if (this.size && __classPrivateFieldGet(this, _PriorityQueue_queue, "f")[this.size - 1].priority >= options.priority) {
      __classPrivateFieldGet(this, _PriorityQueue_queue, "f").push(element);
      return;
    }
    const index = lowerBound(__classPrivateFieldGet(this, _PriorityQueue_queue, "f"), element, (a, b) => b.priority - a.priority);
    __classPrivateFieldGet(this, _PriorityQueue_queue, "f").splice(index, 0, element);
  }
  dequeue() {
    const item = __classPrivateFieldGet(this, _PriorityQueue_queue, "f").shift();
    return item === null || item === void 0 ? void 0 : item.run;
  }
  filter(options) {
    return __classPrivateFieldGet(this, _PriorityQueue_queue, "f").filter((element) => element.priority === options.priority).map((element) => element.run);
  }
  get size() {
    return __classPrivateFieldGet(this, _PriorityQueue_queue, "f").length;
  }
};
_PriorityQueue_queue = /* @__PURE__ */ new WeakMap();
var priority_queue_default = PriorityQueue;

// node_modules/p-queue/dist/index.js
var __classPrivateFieldSet = function(receiver, state, value, kind, f2) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet2 = function(receiver, state, kind, f2) {
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var _PQueue_instances;
var _PQueue_carryoverConcurrencyCount;
var _PQueue_isIntervalIgnored;
var _PQueue_intervalCount;
var _PQueue_intervalCap;
var _PQueue_interval;
var _PQueue_intervalEnd;
var _PQueue_intervalId;
var _PQueue_timeoutId;
var _PQueue_queue;
var _PQueue_queueClass;
var _PQueue_pending;
var _PQueue_concurrency;
var _PQueue_isPaused;
var _PQueue_throwOnTimeout;
var _PQueue_doesIntervalAllowAnother_get;
var _PQueue_doesConcurrentAllowAnother_get;
var _PQueue_next;
var _PQueue_onResumeInterval;
var _PQueue_isIntervalPaused_get;
var _PQueue_tryToStartAnother;
var _PQueue_initializeIntervalIfNeeded;
var _PQueue_onInterval;
var _PQueue_processQueue;
var _PQueue_throwOnAbort;
var _PQueue_onEvent;
var AbortError8 = class extends Error {
};
var PQueue = class extends import_index3.default {
  // TODO: The `throwOnTimeout` option should affect the return types of `add()` and `addAll()`
  constructor(options) {
    var _a4, _b4, _c, _d;
    super();
    _PQueue_instances.add(this);
    _PQueue_carryoverConcurrencyCount.set(this, void 0);
    _PQueue_isIntervalIgnored.set(this, void 0);
    _PQueue_intervalCount.set(this, 0);
    _PQueue_intervalCap.set(this, void 0);
    _PQueue_interval.set(this, void 0);
    _PQueue_intervalEnd.set(this, 0);
    _PQueue_intervalId.set(this, void 0);
    _PQueue_timeoutId.set(this, void 0);
    _PQueue_queue.set(this, void 0);
    _PQueue_queueClass.set(this, void 0);
    _PQueue_pending.set(this, 0);
    _PQueue_concurrency.set(this, void 0);
    _PQueue_isPaused.set(this, void 0);
    _PQueue_throwOnTimeout.set(this, void 0);
    Object.defineProperty(this, "timeout", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    options = {
      carryoverConcurrencyCount: false,
      intervalCap: Number.POSITIVE_INFINITY,
      interval: 0,
      concurrency: Number.POSITIVE_INFINITY,
      autoStart: true,
      queueClass: priority_queue_default,
      ...options
    };
    if (!(typeof options.intervalCap === "number" && options.intervalCap >= 1)) {
      throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(_b4 = (_a4 = options.intervalCap) === null || _a4 === void 0 ? void 0 : _a4.toString()) !== null && _b4 !== void 0 ? _b4 : ""}\` (${typeof options.intervalCap})`);
    }
    if (options.interval === void 0 || !(Number.isFinite(options.interval) && options.interval >= 0)) {
      throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(_d = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ""}\` (${typeof options.interval})`);
    }
    __classPrivateFieldSet(this, _PQueue_carryoverConcurrencyCount, options.carryoverConcurrencyCount, "f");
    __classPrivateFieldSet(this, _PQueue_isIntervalIgnored, options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0, "f");
    __classPrivateFieldSet(this, _PQueue_intervalCap, options.intervalCap, "f");
    __classPrivateFieldSet(this, _PQueue_interval, options.interval, "f");
    __classPrivateFieldSet(this, _PQueue_queue, new options.queueClass(), "f");
    __classPrivateFieldSet(this, _PQueue_queueClass, options.queueClass, "f");
    this.concurrency = options.concurrency;
    this.timeout = options.timeout;
    __classPrivateFieldSet(this, _PQueue_throwOnTimeout, options.throwOnTimeout === true, "f");
    __classPrivateFieldSet(this, _PQueue_isPaused, options.autoStart === false, "f");
  }
  get concurrency() {
    return __classPrivateFieldGet2(this, _PQueue_concurrency, "f");
  }
  set concurrency(newConcurrency) {
    if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
      throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
    }
    __classPrivateFieldSet(this, _PQueue_concurrency, newConcurrency, "f");
    __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_processQueue).call(this);
  }
  async add(function_, options = {}) {
    options = {
      timeout: this.timeout,
      throwOnTimeout: __classPrivateFieldGet2(this, _PQueue_throwOnTimeout, "f"),
      ...options
    };
    return new Promise((resolve, reject) => {
      __classPrivateFieldGet2(this, _PQueue_queue, "f").enqueue(async () => {
        var _a4;
        var _b4, _c;
        __classPrivateFieldSet(this, _PQueue_pending, (_b4 = __classPrivateFieldGet2(this, _PQueue_pending, "f"), _b4++, _b4), "f");
        __classPrivateFieldSet(this, _PQueue_intervalCount, (_c = __classPrivateFieldGet2(this, _PQueue_intervalCount, "f"), _c++, _c), "f");
        try {
          if ((_a4 = options.signal) === null || _a4 === void 0 ? void 0 : _a4.aborted) {
            throw new AbortError8("The task was aborted.");
          }
          let operation = function_({ signal: options.signal });
          if (options.timeout) {
            operation = pTimeout2(Promise.resolve(operation), options.timeout);
          }
          if (options.signal) {
            operation = Promise.race([operation, __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_throwOnAbort).call(this, options.signal)]);
          }
          const result = await operation;
          resolve(result);
          this.emit("completed", result);
        } catch (error) {
          if (error instanceof TimeoutError2 && !options.throwOnTimeout) {
            resolve();
            return;
          }
          reject(error);
          this.emit("error", error);
        } finally {
          __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_next).call(this);
        }
      }, options);
      this.emit("add");
      __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this);
    });
  }
  async addAll(functions, options) {
    return Promise.all(functions.map(async (function_) => this.add(function_, options)));
  }
  /**
  Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
  */
  start() {
    if (!__classPrivateFieldGet2(this, _PQueue_isPaused, "f")) {
      return this;
    }
    __classPrivateFieldSet(this, _PQueue_isPaused, false, "f");
    __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_processQueue).call(this);
    return this;
  }
  /**
  Put queue execution on hold.
  */
  pause() {
    __classPrivateFieldSet(this, _PQueue_isPaused, true, "f");
  }
  /**
  Clear the queue.
  */
  clear() {
    __classPrivateFieldSet(this, _PQueue_queue, new (__classPrivateFieldGet2(this, _PQueue_queueClass, "f"))(), "f");
  }
  /**
      Can be called multiple times. Useful if you for example add additional items at a later time.
  
      @returns A promise that settles when the queue becomes empty.
      */
  async onEmpty() {
    if (__classPrivateFieldGet2(this, _PQueue_queue, "f").size === 0) {
      return;
    }
    await __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "empty");
  }
  /**
      @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.
  
      If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.
  
      Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.
      */
  async onSizeLessThan(limit) {
    if (__classPrivateFieldGet2(this, _PQueue_queue, "f").size < limit) {
      return;
    }
    await __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "next", () => __classPrivateFieldGet2(this, _PQueue_queue, "f").size < limit);
  }
  /**
      The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
  
      @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
      */
  async onIdle() {
    if (__classPrivateFieldGet2(this, _PQueue_pending, "f") === 0 && __classPrivateFieldGet2(this, _PQueue_queue, "f").size === 0) {
      return;
    }
    await __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "idle");
  }
  /**
  Size of the queue, the number of queued items waiting to run.
  */
  get size() {
    return __classPrivateFieldGet2(this, _PQueue_queue, "f").size;
  }
  /**
      Size of the queue, filtered by the given options.
  
      For example, this can be used to find the number of items remaining in the queue with a specific priority level.
      */
  sizeBy(options) {
    return __classPrivateFieldGet2(this, _PQueue_queue, "f").filter(options).length;
  }
  /**
  Number of running items (no longer in the queue).
  */
  get pending() {
    return __classPrivateFieldGet2(this, _PQueue_pending, "f");
  }
  /**
  Whether the queue is currently paused.
  */
  get isPaused() {
    return __classPrivateFieldGet2(this, _PQueue_isPaused, "f");
  }
};
_PQueue_carryoverConcurrencyCount = /* @__PURE__ */ new WeakMap(), _PQueue_isIntervalIgnored = /* @__PURE__ */ new WeakMap(), _PQueue_intervalCount = /* @__PURE__ */ new WeakMap(), _PQueue_intervalCap = /* @__PURE__ */ new WeakMap(), _PQueue_interval = /* @__PURE__ */ new WeakMap(), _PQueue_intervalEnd = /* @__PURE__ */ new WeakMap(), _PQueue_intervalId = /* @__PURE__ */ new WeakMap(), _PQueue_timeoutId = /* @__PURE__ */ new WeakMap(), _PQueue_queue = /* @__PURE__ */ new WeakMap(), _PQueue_queueClass = /* @__PURE__ */ new WeakMap(), _PQueue_pending = /* @__PURE__ */ new WeakMap(), _PQueue_concurrency = /* @__PURE__ */ new WeakMap(), _PQueue_isPaused = /* @__PURE__ */ new WeakMap(), _PQueue_throwOnTimeout = /* @__PURE__ */ new WeakMap(), _PQueue_instances = /* @__PURE__ */ new WeakSet(), _PQueue_doesIntervalAllowAnother_get = function _PQueue_doesIntervalAllowAnother_get2() {
  return __classPrivateFieldGet2(this, _PQueue_isIntervalIgnored, "f") || __classPrivateFieldGet2(this, _PQueue_intervalCount, "f") < __classPrivateFieldGet2(this, _PQueue_intervalCap, "f");
}, _PQueue_doesConcurrentAllowAnother_get = function _PQueue_doesConcurrentAllowAnother_get2() {
  return __classPrivateFieldGet2(this, _PQueue_pending, "f") < __classPrivateFieldGet2(this, _PQueue_concurrency, "f");
}, _PQueue_next = function _PQueue_next2() {
  var _a4;
  __classPrivateFieldSet(this, _PQueue_pending, (_a4 = __classPrivateFieldGet2(this, _PQueue_pending, "f"), _a4--, _a4), "f");
  __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this);
  this.emit("next");
}, _PQueue_onResumeInterval = function _PQueue_onResumeInterval2() {
  __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_onInterval).call(this);
  __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_initializeIntervalIfNeeded).call(this);
  __classPrivateFieldSet(this, _PQueue_timeoutId, void 0, "f");
}, _PQueue_isIntervalPaused_get = function _PQueue_isIntervalPaused_get2() {
  const now = Date.now();
  if (__classPrivateFieldGet2(this, _PQueue_intervalId, "f") === void 0) {
    const delay = __classPrivateFieldGet2(this, _PQueue_intervalEnd, "f") - now;
    if (delay < 0) {
      __classPrivateFieldSet(this, _PQueue_intervalCount, __classPrivateFieldGet2(this, _PQueue_carryoverConcurrencyCount, "f") ? __classPrivateFieldGet2(this, _PQueue_pending, "f") : 0, "f");
    } else {
      if (__classPrivateFieldGet2(this, _PQueue_timeoutId, "f") === void 0) {
        __classPrivateFieldSet(this, _PQueue_timeoutId, setTimeout(() => {
          __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_onResumeInterval).call(this);
        }, delay), "f");
      }
      return true;
    }
  }
  return false;
}, _PQueue_tryToStartAnother = function _PQueue_tryToStartAnother2() {
  if (__classPrivateFieldGet2(this, _PQueue_queue, "f").size === 0) {
    if (__classPrivateFieldGet2(this, _PQueue_intervalId, "f")) {
      clearInterval(__classPrivateFieldGet2(this, _PQueue_intervalId, "f"));
    }
    __classPrivateFieldSet(this, _PQueue_intervalId, void 0, "f");
    this.emit("empty");
    if (__classPrivateFieldGet2(this, _PQueue_pending, "f") === 0) {
      this.emit("idle");
    }
    return false;
  }
  if (!__classPrivateFieldGet2(this, _PQueue_isPaused, "f")) {
    const canInitializeInterval = !__classPrivateFieldGet2(this, _PQueue_instances, "a", _PQueue_isIntervalPaused_get);
    if (__classPrivateFieldGet2(this, _PQueue_instances, "a", _PQueue_doesIntervalAllowAnother_get) && __classPrivateFieldGet2(this, _PQueue_instances, "a", _PQueue_doesConcurrentAllowAnother_get)) {
      const job = __classPrivateFieldGet2(this, _PQueue_queue, "f").dequeue();
      if (!job) {
        return false;
      }
      this.emit("active");
      job();
      if (canInitializeInterval) {
        __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_initializeIntervalIfNeeded).call(this);
      }
      return true;
    }
  }
  return false;
}, _PQueue_initializeIntervalIfNeeded = function _PQueue_initializeIntervalIfNeeded2() {
  if (__classPrivateFieldGet2(this, _PQueue_isIntervalIgnored, "f") || __classPrivateFieldGet2(this, _PQueue_intervalId, "f") !== void 0) {
    return;
  }
  __classPrivateFieldSet(this, _PQueue_intervalId, setInterval(() => {
    __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_onInterval).call(this);
  }, __classPrivateFieldGet2(this, _PQueue_interval, "f")), "f");
  __classPrivateFieldSet(this, _PQueue_intervalEnd, Date.now() + __classPrivateFieldGet2(this, _PQueue_interval, "f"), "f");
}, _PQueue_onInterval = function _PQueue_onInterval2() {
  if (__classPrivateFieldGet2(this, _PQueue_intervalCount, "f") === 0 && __classPrivateFieldGet2(this, _PQueue_pending, "f") === 0 && __classPrivateFieldGet2(this, _PQueue_intervalId, "f")) {
    clearInterval(__classPrivateFieldGet2(this, _PQueue_intervalId, "f"));
    __classPrivateFieldSet(this, _PQueue_intervalId, void 0, "f");
  }
  __classPrivateFieldSet(this, _PQueue_intervalCount, __classPrivateFieldGet2(this, _PQueue_carryoverConcurrencyCount, "f") ? __classPrivateFieldGet2(this, _PQueue_pending, "f") : 0, "f");
  __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_processQueue).call(this);
}, _PQueue_processQueue = function _PQueue_processQueue2() {
  while (__classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this)) {
  }
}, _PQueue_throwOnAbort = async function _PQueue_throwOnAbort2(signal) {
  return new Promise((_resolve, reject) => {
    signal.addEventListener("abort", () => {
      reject(new AbortError8("The task was aborted."));
    }, { once: true });
  });
}, _PQueue_onEvent = async function _PQueue_onEvent2(event, filter2) {
  return new Promise((resolve) => {
    const listener = () => {
      if (filter2 && !filter2()) {
        return;
      }
      this.off(event, listener);
      resolve();
    };
    this.on(event, listener);
  });
};
var dist_default = PQueue;

// node_modules/mortice/node_modules/nanoid/index.browser.js
var nanoid2 = (size = 21) => crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {
  byte &= 63;
  if (byte < 36) {
    id += byte.toString(36);
  } else if (byte < 62) {
    id += (byte - 26).toString(36).toUpperCase();
  } else if (byte > 62) {
    id += "-";
  } else {
    id += "_";
  }
  return id;
}, "");

// node_modules/mortice/dist/src/constants.js
var WORKER_REQUEST_READ_LOCK = "lock:worker:request-read";
var WORKER_RELEASE_READ_LOCK = "lock:worker:release-read";
var MASTER_GRANT_READ_LOCK = "lock:master:grant-read";
var WORKER_REQUEST_WRITE_LOCK = "lock:worker:request-write";
var WORKER_RELEASE_WRITE_LOCK = "lock:worker:release-write";
var MASTER_GRANT_WRITE_LOCK = "lock:master:grant-write";

// node_modules/observable-webworkers/dist/src/index.js
var events = {};
var observable = (worker) => {
  worker.addEventListener("message", (event) => {
    observable.dispatchEvent("message", worker, event);
  });
  if (worker.port != null) {
    worker.port.addEventListener("message", (event) => {
      observable.dispatchEvent("message", worker, event);
    });
  }
};
observable.addEventListener = (type, fn) => {
  if (events[type] == null) {
    events[type] = [];
  }
  events[type].push(fn);
};
observable.removeEventListener = (type, fn) => {
  if (events[type] == null) {
    return;
  }
  events[type] = events[type].filter((listener) => listener === fn);
};
observable.dispatchEvent = function(type, worker, event) {
  if (events[type] == null) {
    return;
  }
  events[type].forEach((fn) => fn(worker, event));
};
var src_default4 = observable;

// node_modules/mortice/dist/src/browser.js
var handleWorkerLockRequest = (emitter, masterEvent, requestType, releaseType, grantType) => {
  return (worker, event) => {
    if (event.data.type !== requestType) {
      return;
    }
    const requestEvent = {
      type: event.data.type,
      name: event.data.name,
      identifier: event.data.identifier
    };
    emitter.dispatchEvent(new MessageEvent(masterEvent, {
      data: {
        name: requestEvent.name,
        handler: async () => {
          worker.postMessage({
            type: grantType,
            name: requestEvent.name,
            identifier: requestEvent.identifier
          });
          return await new Promise((resolve) => {
            const releaseEventListener = (event2) => {
              if (event2 == null || event2.data == null) {
                return;
              }
              const releaseEvent = {
                type: event2.data.type,
                name: event2.data.name,
                identifier: event2.data.identifier
              };
              if (releaseEvent.type === releaseType && releaseEvent.identifier === requestEvent.identifier) {
                worker.removeEventListener("message", releaseEventListener);
                resolve();
              }
            };
            worker.addEventListener("message", releaseEventListener);
          });
        }
      }
    }));
  };
};
var makeWorkerLockRequest = (name2, requestType, grantType, releaseType) => {
  return async () => {
    const id = nanoid2();
    globalThis.postMessage({
      type: requestType,
      identifier: id,
      name: name2
    });
    return await new Promise((resolve) => {
      const listener = (event) => {
        if (event == null || event.data == null) {
          return;
        }
        const responseEvent = {
          type: event.data.type,
          identifier: event.data.identifier
        };
        if (responseEvent.type === grantType && responseEvent.identifier === id) {
          globalThis.removeEventListener("message", listener);
          resolve(() => {
            globalThis.postMessage({
              type: releaseType,
              identifier: id,
              name: name2
            });
          });
        }
      };
      globalThis.addEventListener("message", listener);
    });
  };
};
var defaultOptions2 = {
  singleProcess: false
};
var browser_default = (options) => {
  options = Object.assign({}, defaultOptions2, options);
  const isPrimary = Boolean(globalThis.document) || options.singleProcess;
  if (isPrimary) {
    const emitter = new EventTarget();
    src_default4.addEventListener("message", handleWorkerLockRequest(emitter, "requestReadLock", WORKER_REQUEST_READ_LOCK, WORKER_RELEASE_READ_LOCK, MASTER_GRANT_READ_LOCK));
    src_default4.addEventListener("message", handleWorkerLockRequest(emitter, "requestWriteLock", WORKER_REQUEST_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK));
    return emitter;
  }
  return {
    isWorker: true,
    readLock: (name2) => makeWorkerLockRequest(name2, WORKER_REQUEST_READ_LOCK, MASTER_GRANT_READ_LOCK, WORKER_RELEASE_READ_LOCK),
    writeLock: (name2) => makeWorkerLockRequest(name2, WORKER_REQUEST_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK)
  };
};

// node_modules/mortice/dist/src/index.js
var mutexes = {};
var implementation;
async function createReleaseable(queue, options) {
  let res;
  const p = new Promise((resolve) => {
    res = resolve;
  });
  void queue.add(async () => await pTimeout((async () => {
    return await new Promise((resolve) => {
      res(() => {
        resolve();
      });
    });
  })(), {
    milliseconds: options.timeout
  }));
  return await p;
}
var createMutex = (name2, options) => {
  if (implementation.isWorker === true) {
    return {
      readLock: implementation.readLock(name2, options),
      writeLock: implementation.writeLock(name2, options)
    };
  }
  const masterQueue = new dist_default({ concurrency: 1 });
  let readQueue;
  return {
    async readLock() {
      if (readQueue != null) {
        return await createReleaseable(readQueue, options);
      }
      readQueue = new dist_default({
        concurrency: options.concurrency,
        autoStart: false
      });
      const localReadQueue = readQueue;
      const readPromise = createReleaseable(readQueue, options);
      void masterQueue.add(async () => {
        localReadQueue.start();
        return await localReadQueue.onIdle().then(() => {
          if (readQueue === localReadQueue) {
            readQueue = null;
          }
        });
      });
      return await readPromise;
    },
    async writeLock() {
      readQueue = null;
      return await createReleaseable(masterQueue, options);
    }
  };
};
var defaultOptions3 = {
  name: "lock",
  concurrency: Infinity,
  timeout: 846e5,
  singleProcess: false
};
function createMortice(options) {
  const opts = Object.assign({}, defaultOptions3, options);
  if (implementation == null) {
    implementation = browser_default(opts);
    if (implementation.isWorker !== true) {
      implementation.addEventListener("requestReadLock", (event) => {
        if (mutexes[event.data.name] == null) {
          return;
        }
        void mutexes[event.data.name].readLock().then(async (release) => await event.data.handler().finally(() => release()));
      });
      implementation.addEventListener("requestWriteLock", async (event) => {
        if (mutexes[event.data.name] == null) {
          return;
        }
        void mutexes[event.data.name].writeLock().then(async (release) => await event.data.handler().finally(() => release()));
      });
    }
  }
  if (mutexes[opts.name] == null) {
    mutexes[opts.name] = createMutex(opts.name, opts);
  }
  return mutexes[opts.name];
}

// node_modules/@libp2p/peer-store/node_modules/multiformats/src/bytes.js
var empty4 = new Uint8Array(0);

// node_modules/@libp2p/peer-store/node_modules/multiformats/src/bases/base.js
var Encoder4 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor(name2, prefix, baseEncode) {
    this.name = name2;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode(bytes2) {
    if (bytes2 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes2)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder4 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name2, prefix, baseDecode) {
    this.name = name2;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = /** @type {number} */
    prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  /**
   * @param {string} text
   */
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or2(this, decoder);
  }
};
var ComposedDecoder2 = class {
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor(decoders) {
    this.decoders = decoders;
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or2(this, decoder);
  }
  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode(input) {
    const prefix = (
      /** @type {Prefix} */
      input[0]
    );
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or2 = (left, right) => new ComposedDecoder2(
  /** @type {Decoders<L|R>} */
  {
    ...left.decoders || { [
      /** @type API.UnibaseDecoder<L> */
      left.prefix
    ]: left },
    ...right.decoders || { [
      /** @type API.UnibaseDecoder<R> */
      right.prefix
    ]: right }
  }
);
var Codec2 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name2, prefix, baseEncode, baseDecode) {
    this.name = name2;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder4(name2, prefix, baseEncode);
    this.decoder = new Decoder4(name2, prefix, baseDecode);
  }
  /**
   * @param {Uint8Array} input
   */
  encode(input) {
    return this.encoder.encode(input);
  }
  /**
   * @param {string} input
   */
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from5 = ({ name: name2, prefix, encode: encode12, decode: decode12 }) => new Codec2(name2, prefix, encode12, decode12);
var decode10 = (string2, alphabet, bitsPerChar, name2) => {
  const codes6 = {};
  for (let i = 0; i < alphabet.length; ++i) {
    codes6[alphabet[i]] = i;
  }
  let end = string2.length;
  while (string2[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes6[string2[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name2} character`);
    }
    buffer = buffer << bitsPerChar | value;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || 255 & buffer << 8 - bits2) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode9 = (data, alphabet, bitsPerChar) => {
  const pad = alphabet[alphabet.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer = buffer << 8 | data[i];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet[mask & buffer >> bits2];
    }
  }
  if (bits2) {
    out += alphabet[mask & buffer << bitsPerChar - bits2];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc46482 = ({ name: name2, prefix, bitsPerChar, alphabet }) => {
  return from5({
    prefix,
    name: name2,
    encode(input) {
      return encode9(input, alphabet, bitsPerChar);
    },
    decode(input) {
      return decode10(input, alphabet, bitsPerChar, name2);
    }
  });
};

// node_modules/@libp2p/peer-store/node_modules/multiformats/src/bases/base32.js
var base32 = rfc46482({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper = rfc46482({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad = rfc46482({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper = rfc46482({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex = rfc46482({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper = rfc46482({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad = rfc46482({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper = rfc46482({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z = rfc46482({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@libp2p/peer-store/dist/src/errors.js
var codes4 = {
  ERR_INVALID_PARAMETERS: "ERR_INVALID_PARAMETERS"
};

// node_modules/@libp2p/peer-store/dist/src/pb/peer.js
var Peer;
(function(Peer2) {
  let Peer$metadataEntry;
  (function(Peer$metadataEntry2) {
    let _codec2;
    Peer$metadataEntry2.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.key != null && obj.key !== "") {
            w.uint32(10);
            w.string(obj.key);
          }
          if (obj.value != null && obj.value.byteLength > 0) {
            w.uint32(18);
            w.bytes(obj.value);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length4) => {
          const obj = {
            key: "",
            value: new Uint8Array(0)
          };
          const end = length4 == null ? reader2.len : reader2.pos + length4;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.key = reader2.string();
                break;
              case 2:
                obj.value = reader2.bytes();
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    Peer$metadataEntry2.encode = (obj) => {
      return encodeMessage(obj, Peer$metadataEntry2.codec());
    };
    Peer$metadataEntry2.decode = (buf) => {
      return decodeMessage(buf, Peer$metadataEntry2.codec());
    };
  })(Peer$metadataEntry = Peer2.Peer$metadataEntry || (Peer2.Peer$metadataEntry = {}));
  let Peer$tagsEntry;
  (function(Peer$tagsEntry2) {
    let _codec2;
    Peer$tagsEntry2.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.key != null && obj.key !== "") {
            w.uint32(10);
            w.string(obj.key);
          }
          if (obj.value != null) {
            w.uint32(18);
            Tag.codec().encode(obj.value, w);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length4) => {
          const obj = {
            key: ""
          };
          const end = length4 == null ? reader2.len : reader2.pos + length4;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.key = reader2.string();
                break;
              case 2:
                obj.value = Tag.codec().decode(reader2, reader2.uint32());
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    Peer$tagsEntry2.encode = (obj) => {
      return encodeMessage(obj, Peer$tagsEntry2.codec());
    };
    Peer$tagsEntry2.decode = (buf) => {
      return decodeMessage(buf, Peer$tagsEntry2.codec());
    };
  })(Peer$tagsEntry = Peer2.Peer$tagsEntry || (Peer2.Peer$tagsEntry = {}));
  let _codec;
  Peer2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.addresses != null) {
          for (const value of obj.addresses) {
            w.uint32(10);
            Address.codec().encode(value, w);
          }
        }
        if (obj.protocols != null) {
          for (const value of obj.protocols) {
            w.uint32(18);
            w.string(value);
          }
        }
        if (obj.publicKey != null) {
          w.uint32(34);
          w.bytes(obj.publicKey);
        }
        if (obj.peerRecordEnvelope != null) {
          w.uint32(42);
          w.bytes(obj.peerRecordEnvelope);
        }
        if (obj.metadata != null && obj.metadata.size !== 0) {
          for (const [key, value] of obj.metadata.entries()) {
            w.uint32(50);
            Peer2.Peer$metadataEntry.codec().encode({ key, value }, w);
          }
        }
        if (obj.tags != null && obj.tags.size !== 0) {
          for (const [key, value] of obj.tags.entries()) {
            w.uint32(58);
            Peer2.Peer$tagsEntry.codec().encode({ key, value }, w);
          }
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length4) => {
        const obj = {
          addresses: [],
          protocols: [],
          metadata: /* @__PURE__ */ new Map(),
          tags: /* @__PURE__ */ new Map()
        };
        const end = length4 == null ? reader2.len : reader2.pos + length4;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.addresses.push(Address.codec().decode(reader2, reader2.uint32()));
              break;
            case 2:
              obj.protocols.push(reader2.string());
              break;
            case 4:
              obj.publicKey = reader2.bytes();
              break;
            case 5:
              obj.peerRecordEnvelope = reader2.bytes();
              break;
            case 6: {
              const entry = Peer2.Peer$metadataEntry.codec().decode(reader2, reader2.uint32());
              obj.metadata.set(entry.key, entry.value);
              break;
            }
            case 7: {
              const entry = Peer2.Peer$tagsEntry.codec().decode(reader2, reader2.uint32());
              obj.tags.set(entry.key, entry.value);
              break;
            }
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Peer2.encode = (obj) => {
    return encodeMessage(obj, Peer2.codec());
  };
  Peer2.decode = (buf) => {
    return decodeMessage(buf, Peer2.codec());
  };
})(Peer || (Peer = {}));
var Address;
(function(Address2) {
  let _codec;
  Address2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.multiaddr != null && obj.multiaddr.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.multiaddr);
        }
        if (obj.isCertified != null) {
          w.uint32(16);
          w.bool(obj.isCertified);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length4) => {
        const obj = {
          multiaddr: new Uint8Array(0)
        };
        const end = length4 == null ? reader2.len : reader2.pos + length4;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.multiaddr = reader2.bytes();
              break;
            case 2:
              obj.isCertified = reader2.bool();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Address2.encode = (obj) => {
    return encodeMessage(obj, Address2.codec());
  };
  Address2.decode = (buf) => {
    return decodeMessage(buf, Address2.codec());
  };
})(Address || (Address = {}));
var Tag;
(function(Tag2) {
  let _codec;
  Tag2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.value != null && obj.value !== 0) {
          w.uint32(8);
          w.uint32(obj.value);
        }
        if (obj.expiry != null) {
          w.uint32(16);
          w.uint64(obj.expiry);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length4) => {
        const obj = {
          value: 0
        };
        const end = length4 == null ? reader2.len : reader2.pos + length4;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.value = reader2.uint32();
              break;
            case 2:
              obj.expiry = reader2.uint64();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Tag2.encode = (obj) => {
    return encodeMessage(obj, Tag2.codec());
  };
  Tag2.decode = (buf) => {
    return decodeMessage(buf, Tag2.codec());
  };
})(Tag || (Tag = {}));

// node_modules/@libp2p/peer-store/dist/src/utils/bytes-to-peer.js
function bytesToPeer(peerId2, buf) {
  const peer = Peer.decode(buf);
  if (peer.publicKey != null && peerId2.publicKey == null) {
    peerId2 = peerIdFromPeerId({
      ...peerId2,
      publicKey: peerId2.publicKey
    });
  }
  const tags = /* @__PURE__ */ new Map();
  const now = BigInt(Date.now());
  for (const [key, tag] of peer.tags.entries()) {
    if (tag.expiry != null && tag.expiry < now) {
      continue;
    }
    tags.set(key, tag);
  }
  return {
    ...peer,
    id: peerId2,
    addresses: peer.addresses.map(({ multiaddr: ma, isCertified }) => {
      return {
        multiaddr: multiaddr(ma),
        isCertified: isCertified ?? false
      };
    }),
    metadata: peer.metadata,
    peerRecordEnvelope: peer.peerRecordEnvelope ?? void 0,
    tags
  };
}

// node_modules/@libp2p/peer-store/dist/src/utils/peer-id-to-datastore-key.js
var NAMESPACE_COMMON = "/peers/";
function peerIdToDatastoreKey(peerId2) {
  if (!isPeerId(peerId2) || peerId2.type == null) {
    throw new CodeError("Invalid PeerId", codes4.ERR_INVALID_PARAMETERS);
  }
  const b32key = peerId2.toCID().toString();
  return new Key(`${NAMESPACE_COMMON}${b32key}`);
}

// node_modules/@libp2p/peer-store/dist/src/utils/dedupe-addresses.js
async function dedupeFilterAndSortAddresses(peerId2, filter2, addresses) {
  const addressMap = /* @__PURE__ */ new Map();
  for (const addr of addresses) {
    if (addr == null) {
      continue;
    }
    if (addr.multiaddr instanceof Uint8Array) {
      addr.multiaddr = multiaddr(addr.multiaddr);
    }
    if (!isMultiaddr(addr.multiaddr)) {
      throw new CodeError("Multiaddr was invalid", codes4.ERR_INVALID_PARAMETERS);
    }
    if (!await filter2(peerId2, addr.multiaddr)) {
      continue;
    }
    const isCertified = addr.isCertified ?? false;
    const maStr = addr.multiaddr.toString();
    const existingAddr = addressMap.get(maStr);
    if (existingAddr != null) {
      addr.isCertified = existingAddr.isCertified || isCertified;
    } else {
      addressMap.set(maStr, {
        multiaddr: addr.multiaddr,
        isCertified
      });
    }
  }
  return [...addressMap.values()].sort((a, b) => {
    return a.multiaddr.toString().localeCompare(b.multiaddr.toString());
  }).map(({ isCertified, multiaddr: multiaddr2 }) => ({
    isCertified,
    multiaddr: multiaddr2.bytes
  }));
}

// node_modules/@libp2p/peer-store/dist/src/utils/to-peer-pb.js
async function toPeerPB(peerId2, data, strategy, options) {
  if (data == null) {
    throw new CodeError("Invalid PeerData", codes4.ERR_INVALID_PARAMETERS);
  }
  if (data.publicKey != null && peerId2.publicKey != null && !equals(data.publicKey, peerId2.publicKey)) {
    throw new CodeError("publicKey bytes do not match peer id publicKey bytes", codes4.ERR_INVALID_PARAMETERS);
  }
  const existingPeer = options.existingPeer;
  if (existingPeer != null && !peerId2.equals(existingPeer.id)) {
    throw new CodeError("peer id did not match existing peer id", codes4.ERR_INVALID_PARAMETERS);
  }
  let addresses = (existingPeer == null ? void 0 : existingPeer.addresses) ?? [];
  let protocols = new Set((existingPeer == null ? void 0 : existingPeer.protocols) ?? []);
  let metadata = (existingPeer == null ? void 0 : existingPeer.metadata) ?? /* @__PURE__ */ new Map();
  let tags = (existingPeer == null ? void 0 : existingPeer.tags) ?? /* @__PURE__ */ new Map();
  let peerRecordEnvelope = existingPeer == null ? void 0 : existingPeer.peerRecordEnvelope;
  if (strategy === "patch") {
    if (data.multiaddrs != null || data.addresses != null) {
      addresses = [];
      if (data.multiaddrs != null) {
        addresses.push(...data.multiaddrs.map((multiaddr2) => ({
          isCertified: false,
          multiaddr: multiaddr2
        })));
      }
      if (data.addresses != null) {
        addresses.push(...data.addresses);
      }
    }
    if (data.protocols != null) {
      protocols = new Set(data.protocols);
    }
    if (data.metadata != null) {
      const metadataEntries = data.metadata instanceof Map ? [...data.metadata.entries()] : Object.entries(data.metadata);
      metadata = createSortedMap(metadataEntries, {
        validate: validateMetadata
      });
    }
    if (data.tags != null) {
      const tagsEntries = data.tags instanceof Map ? [...data.tags.entries()] : Object.entries(data.tags);
      tags = createSortedMap(tagsEntries, {
        validate: validateTag,
        map: mapTag
      });
    }
    if (data.peerRecordEnvelope != null) {
      peerRecordEnvelope = data.peerRecordEnvelope;
    }
  }
  if (strategy === "merge") {
    if (data.multiaddrs != null) {
      addresses.push(...data.multiaddrs.map((multiaddr2) => ({
        isCertified: false,
        multiaddr: multiaddr2
      })));
    }
    if (data.addresses != null) {
      addresses.push(...data.addresses);
    }
    if (data.protocols != null) {
      protocols = /* @__PURE__ */ new Set([...protocols, ...data.protocols]);
    }
    if (data.metadata != null) {
      const metadataEntries = data.metadata instanceof Map ? [...data.metadata.entries()] : Object.entries(data.metadata);
      for (const [key, value] of metadataEntries) {
        if (value == null) {
          metadata.delete(key);
        } else {
          metadata.set(key, value);
        }
      }
      metadata = createSortedMap([...metadata.entries()], {
        validate: validateMetadata
      });
    }
    if (data.tags != null) {
      const tagsEntries = data.tags instanceof Map ? [...data.tags.entries()] : Object.entries(data.tags);
      const mergedTags = new Map(tags);
      for (const [key, value] of tagsEntries) {
        if (value == null) {
          mergedTags.delete(key);
        } else {
          mergedTags.set(key, value);
        }
      }
      tags = createSortedMap([...mergedTags.entries()], {
        validate: validateTag,
        map: mapTag
      });
    }
    if (data.peerRecordEnvelope != null) {
      peerRecordEnvelope = data.peerRecordEnvelope;
    }
  }
  const output2 = {
    addresses: await dedupeFilterAndSortAddresses(peerId2, options.addressFilter ?? (async () => true), addresses),
    protocols: [...protocols.values()].sort((a, b) => {
      return a.localeCompare(b);
    }),
    metadata,
    tags,
    publicKey: (existingPeer == null ? void 0 : existingPeer.id.publicKey) ?? data.publicKey ?? peerId2.publicKey,
    peerRecordEnvelope
  };
  if (peerId2.type !== "RSA") {
    delete output2.publicKey;
  }
  return output2;
}
function createSortedMap(entries, options) {
  var _a4;
  const output2 = /* @__PURE__ */ new Map();
  for (const [key, value] of entries) {
    if (value == null) {
      continue;
    }
    options.validate(key, value);
  }
  for (const [key, value] of entries.sort(([a], [b]) => {
    return a.localeCompare(b);
  })) {
    if (value != null) {
      output2.set(key, ((_a4 = options.map) == null ? void 0 : _a4.call(options, key, value)) ?? value);
    }
  }
  return output2;
}
function validateMetadata(key, value) {
  if (typeof key !== "string") {
    throw new CodeError("Metadata key must be a string", codes4.ERR_INVALID_PARAMETERS);
  }
  if (!(value instanceof Uint8Array)) {
    throw new CodeError("Metadata value must be a Uint8Array", codes4.ERR_INVALID_PARAMETERS);
  }
}
function validateTag(key, tag) {
  if (typeof key !== "string") {
    throw new CodeError("Tag name must be a string", codes4.ERR_INVALID_PARAMETERS);
  }
  if (tag.value != null) {
    if (parseInt(`${tag.value}`, 10) !== tag.value) {
      throw new CodeError("Tag value must be an integer", codes4.ERR_INVALID_PARAMETERS);
    }
    if (tag.value < 0 || tag.value > 100) {
      throw new CodeError("Tag value must be between 0-100", codes4.ERR_INVALID_PARAMETERS);
    }
  }
  if (tag.ttl != null) {
    if (parseInt(`${tag.ttl}`, 10) !== tag.ttl) {
      throw new CodeError("Tag ttl must be an integer", codes4.ERR_INVALID_PARAMETERS);
    }
    if (tag.ttl < 0) {
      throw new CodeError("Tag ttl must be between greater than 0", codes4.ERR_INVALID_PARAMETERS);
    }
  }
}
function mapTag(key, tag) {
  let expiry;
  if (tag.expiry != null) {
    expiry = tag.expiry;
  }
  if (tag.ttl != null) {
    expiry = BigInt(Date.now() + Number(tag.ttl));
  }
  return {
    value: tag.value ?? 0,
    expiry
  };
}

// node_modules/@libp2p/peer-store/dist/src/store.js
function decodePeer(key, value, cache) {
  const base32Str = key.toString().split("/")[2];
  const buf = base32.decode(base32Str);
  const peerId2 = peerIdFromBytes(buf);
  const cached = cache.get(peerId2);
  if (cached != null) {
    return cached;
  }
  const peer = bytesToPeer(peerId2, value);
  cache.set(peerId2, peer);
  return peer;
}
function mapQuery(query, cache) {
  if (query == null) {
    return {};
  }
  return {
    prefix: NAMESPACE_COMMON,
    filters: (query.filters ?? []).map((fn) => ({ key, value }) => {
      return fn(decodePeer(key, value, cache));
    }),
    orders: (query.orders ?? []).map((fn) => (a, b) => {
      return fn(decodePeer(a.key, a.value, cache), decodePeer(b.key, b.value, cache));
    })
  };
}
var _findExistingPeer, findExistingPeer_fn, _saveIfDifferent, saveIfDifferent_fn;
var PersistentStore = class {
  constructor(components, init = {}) {
    __privateAdd(this, _findExistingPeer);
    __privateAdd(this, _saveIfDifferent);
    __publicField(this, "peerId");
    __publicField(this, "datastore");
    __publicField(this, "lock");
    __publicField(this, "addressFilter");
    this.peerId = components.peerId;
    this.datastore = components.datastore;
    this.addressFilter = init.addressFilter;
    this.lock = createMortice({
      name: "peer-store",
      singleProcess: true
    });
  }
  async has(peerId2) {
    return this.datastore.has(peerIdToDatastoreKey(peerId2));
  }
  async delete(peerId2) {
    if (this.peerId.equals(peerId2)) {
      throw new CodeError("Cannot delete self peer", codes4.ERR_INVALID_PARAMETERS);
    }
    await this.datastore.delete(peerIdToDatastoreKey(peerId2));
  }
  async load(peerId2) {
    const buf = await this.datastore.get(peerIdToDatastoreKey(peerId2));
    return bytesToPeer(peerId2, buf);
  }
  async save(peerId2, data) {
    const { existingBuf, existingPeer } = await __privateMethod(this, _findExistingPeer, findExistingPeer_fn).call(this, peerId2);
    const peerPb = await toPeerPB(peerId2, data, "patch", {
      addressFilter: this.addressFilter
    });
    return __privateMethod(this, _saveIfDifferent, saveIfDifferent_fn).call(this, peerId2, peerPb, existingBuf, existingPeer);
  }
  async patch(peerId2, data) {
    const { existingBuf, existingPeer } = await __privateMethod(this, _findExistingPeer, findExistingPeer_fn).call(this, peerId2);
    const peerPb = await toPeerPB(peerId2, data, "patch", {
      addressFilter: this.addressFilter,
      existingPeer
    });
    return __privateMethod(this, _saveIfDifferent, saveIfDifferent_fn).call(this, peerId2, peerPb, existingBuf, existingPeer);
  }
  async merge(peerId2, data) {
    const { existingBuf, existingPeer } = await __privateMethod(this, _findExistingPeer, findExistingPeer_fn).call(this, peerId2);
    const peerPb = await toPeerPB(peerId2, data, "merge", {
      addressFilter: this.addressFilter,
      existingPeer
    });
    return __privateMethod(this, _saveIfDifferent, saveIfDifferent_fn).call(this, peerId2, peerPb, existingBuf, existingPeer);
  }
  async *all(query) {
    const peerCache = new PeerMap();
    for await (const { key, value } of this.datastore.query(mapQuery(query ?? {}, peerCache))) {
      const peer = decodePeer(key, value, peerCache);
      if (peer.id.equals(this.peerId)) {
        continue;
      }
      yield peer;
    }
  }
};
_findExistingPeer = new WeakSet();
findExistingPeer_fn = async function(peerId2) {
  try {
    const existingBuf = await this.datastore.get(peerIdToDatastoreKey(peerId2));
    const existingPeer = bytesToPeer(peerId2, existingBuf);
    return {
      existingBuf,
      existingPeer
    };
  } catch (err) {
    if (err.code !== "ERR_NOT_FOUND") {
      throw err;
    }
  }
  return {};
};
_saveIfDifferent = new WeakSet();
saveIfDifferent_fn = async function(peerId2, peer, existingBuf, existingPeer) {
  const buf = Peer.encode(peer);
  if (existingBuf != null && equals(buf, existingBuf)) {
    return {
      peer: bytesToPeer(peerId2, buf),
      previous: existingPeer,
      updated: false
    };
  }
  await this.datastore.put(peerIdToDatastoreKey(peerId2), buf);
  return {
    peer: bytesToPeer(peerId2, buf),
    previous: existingPeer,
    updated: true
  };
};

// node_modules/@libp2p/peer-store/dist/src/index.js
var log19 = logger("libp2p:peer-store");
var _emitIfUpdated, emitIfUpdated_fn;
var PersistentPeerStore = class {
  constructor(components, init = {}) {
    __privateAdd(this, _emitIfUpdated);
    __publicField(this, "store");
    __publicField(this, "events");
    __publicField(this, "peerId");
    this.events = components.events;
    this.peerId = components.peerId;
    this.store = new PersistentStore(components, init);
  }
  async forEach(fn, query) {
    log19.trace("forEach await read lock");
    const release = await this.store.lock.readLock();
    log19.trace("forEach got read lock");
    try {
      for await (const peer of this.store.all(query)) {
        fn(peer);
      }
    } finally {
      log19.trace("forEach release read lock");
      release();
    }
  }
  async all(query) {
    log19.trace("all await read lock");
    const release = await this.store.lock.readLock();
    log19.trace("all got read lock");
    try {
      return await src_default(this.store.all(query));
    } finally {
      log19.trace("all release read lock");
      release();
    }
  }
  async delete(peerId2) {
    log19.trace("delete await write lock");
    const release = await this.store.lock.writeLock();
    log19.trace("delete got write lock");
    try {
      await this.store.delete(peerId2);
    } finally {
      log19.trace("delete release write lock");
      release();
    }
  }
  async has(peerId2) {
    log19.trace("has await read lock");
    const release = await this.store.lock.readLock();
    log19.trace("has got read lock");
    try {
      return await this.store.has(peerId2);
    } finally {
      log19.trace("has release read lock");
      release();
    }
  }
  async get(peerId2) {
    log19.trace("get await read lock");
    const release = await this.store.lock.readLock();
    log19.trace("get got read lock");
    try {
      return await this.store.load(peerId2);
    } finally {
      log19.trace("get release read lock");
      release();
    }
  }
  async save(id, data) {
    log19.trace("save await write lock");
    const release = await this.store.lock.writeLock();
    log19.trace("save got write lock");
    try {
      const result = await this.store.save(id, data);
      __privateMethod(this, _emitIfUpdated, emitIfUpdated_fn).call(this, id, result);
      return result.peer;
    } finally {
      log19.trace("save release write lock");
      release();
    }
  }
  async patch(id, data) {
    log19.trace("patch await write lock");
    const release = await this.store.lock.writeLock();
    log19.trace("patch got write lock");
    try {
      const result = await this.store.patch(id, data);
      __privateMethod(this, _emitIfUpdated, emitIfUpdated_fn).call(this, id, result);
      return result.peer;
    } finally {
      log19.trace("patch release write lock");
      release();
    }
  }
  async merge(id, data) {
    log19.trace("merge await write lock");
    const release = await this.store.lock.writeLock();
    log19.trace("merge got write lock");
    try {
      const result = await this.store.merge(id, data);
      __privateMethod(this, _emitIfUpdated, emitIfUpdated_fn).call(this, id, result);
      return result.peer;
    } finally {
      log19.trace("merge release write lock");
      release();
    }
  }
  async consumePeerRecord(buf, expectedPeer) {
    const envelope = await RecordEnvelope.openAndCertify(buf, PeerRecord2.DOMAIN);
    if ((expectedPeer == null ? void 0 : expectedPeer.equals(envelope.peerId)) === false) {
      log19("envelope peer id was not the expected peer id - expected: %p received: %p", expectedPeer, envelope.peerId);
      return false;
    }
    const peerRecord = PeerRecord2.createFromProtobuf(envelope.payload);
    let peer;
    try {
      peer = await this.get(envelope.peerId);
    } catch (err) {
      if (err.code !== "ERR_NOT_FOUND") {
        throw err;
      }
    }
    if ((peer == null ? void 0 : peer.peerRecordEnvelope) != null) {
      const storedEnvelope = await RecordEnvelope.createFromProtobuf(peer.peerRecordEnvelope);
      const storedRecord = PeerRecord2.createFromProtobuf(storedEnvelope.payload);
      if (storedRecord.seqNumber >= peerRecord.seqNumber) {
        log19("sequence number was lower or equal to existing sequence number - stored: %d received: %d", storedRecord.seqNumber, peerRecord.seqNumber);
        return false;
      }
    }
    await this.patch(peerRecord.peerId, {
      peerRecordEnvelope: buf,
      addresses: peerRecord.multiaddrs.map((multiaddr2) => ({
        isCertified: true,
        multiaddr: multiaddr2
      }))
    });
    return true;
  }
};
_emitIfUpdated = new WeakSet();
emitIfUpdated_fn = function(id, result) {
  if (!result.updated) {
    return;
  }
  if (this.peerId.equals(id)) {
    this.events.safeDispatchEvent("self:peer:update", { detail: result });
  } else {
    this.events.safeDispatchEvent("peer:update", { detail: result });
  }
};

// node_modules/it-drain/dist/src/index.js
function isAsyncIterable6(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function drain(source) {
  if (isAsyncIterable6(source)) {
    return (async () => {
      for await (const _ of source) {
      }
    })();
  } else {
    for (const _ of source) {
    }
  }
}
var src_default5 = drain;

// node_modules/it-peekable/dist/src/index.js
function peekable(iterable) {
  const [iterator, symbol4] = iterable[Symbol.asyncIterator] != null ? [iterable[Symbol.asyncIterator](), Symbol.asyncIterator] : [iterable[Symbol.iterator](), Symbol.iterator];
  const queue = [];
  return {
    peek: () => {
      return iterator.next();
    },
    push: (value) => {
      queue.push(value);
    },
    next: () => {
      if (queue.length > 0) {
        return {
          done: false,
          value: queue.shift()
        };
      }
      return iterator.next();
    },
    [symbol4]() {
      return this;
    }
  };
}
var src_default6 = peekable;

// node_modules/it-filter/dist/src/index.js
function isAsyncIterable7(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function filter(source, fn) {
  if (isAsyncIterable7(source)) {
    return async function* () {
      for await (const entry of source) {
        if (await fn(entry)) {
          yield entry;
        }
      }
    }();
  }
  const peekable2 = src_default6(source);
  const { value, done } = peekable2.next();
  if (done === true) {
    return /* @__PURE__ */ function* () {
    }();
  }
  const res = fn(value);
  if (typeof res.then === "function") {
    return async function* () {
      if (await res) {
        yield value;
      }
      for await (const entry of peekable2) {
        if (await fn(entry)) {
          yield entry;
        }
      }
    }();
  }
  const func2 = fn;
  return function* () {
    if (res === true) {
      yield value;
    }
    for (const entry of peekable2) {
      if (func2(entry)) {
        yield entry;
      }
    }
  }();
}
var src_default7 = filter;

// node_modules/it-sort/dist/src/index.js
function isAsyncIterable8(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function sort(source, sorter) {
  if (isAsyncIterable8(source)) {
    return async function* () {
      const arr = await src_default(source);
      yield* arr.sort(sorter);
    }();
  }
  return function* () {
    const arr = src_default(source);
    yield* arr.sort(sorter);
  }();
}
var src_default8 = sort;

// node_modules/datastore-core/node_modules/it-take/dist/src/index.js
function isAsyncIterable9(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function take(source, limit) {
  if (isAsyncIterable9(source)) {
    return async function* () {
      let items = 0;
      if (limit < 1) {
        return;
      }
      for await (const entry of source) {
        yield entry;
        items++;
        if (items === limit) {
          return;
        }
      }
    }();
  }
  return function* () {
    let items = 0;
    if (limit < 1) {
      return;
    }
    for (const entry of source) {
      yield entry;
      items++;
      if (items === limit) {
        return;
      }
    }
  }();
}
var src_default9 = take;

// node_modules/datastore-core/dist/src/base.js
var BaseDatastore = class {
  put(key, val, options) {
    return Promise.reject(new Error(".put is not implemented"));
  }
  get(key, options) {
    return Promise.reject(new Error(".get is not implemented"));
  }
  has(key, options) {
    return Promise.reject(new Error(".has is not implemented"));
  }
  delete(key, options) {
    return Promise.reject(new Error(".delete is not implemented"));
  }
  async *putMany(source, options = {}) {
    for await (const { key, value } of source) {
      await this.put(key, value, options);
      yield key;
    }
  }
  async *getMany(source, options = {}) {
    for await (const key of source) {
      yield {
        key,
        value: await this.get(key, options)
      };
    }
  }
  async *deleteMany(source, options = {}) {
    for await (const key of source) {
      await this.delete(key, options);
      yield key;
    }
  }
  batch() {
    let puts = [];
    let dels = [];
    return {
      put(key, value) {
        puts.push({ key, value });
      },
      delete(key) {
        dels.push(key);
      },
      commit: async (options) => {
        await src_default5(this.putMany(puts, options));
        puts = [];
        await src_default5(this.deleteMany(dels, options));
        dels = [];
      }
    };
  }
  /**
   * Extending classes should override `query` or implement this method
   */
  // eslint-disable-next-line require-yield
  async *_all(q, options) {
    throw new Error("._all is not implemented");
  }
  /**
   * Extending classes should override `queryKeys` or implement this method
   */
  // eslint-disable-next-line require-yield
  async *_allKeys(q, options) {
    throw new Error("._allKeys is not implemented");
  }
  query(q, options) {
    let it = this._all(q, options);
    if (q.prefix != null) {
      const prefix = q.prefix;
      it = src_default7(it, (e) => e.key.toString().startsWith(prefix));
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f2) => src_default7(it2, f2), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f2) => src_default8(it2, f2), it);
    }
    if (q.offset != null) {
      let i = 0;
      const offset = q.offset;
      it = src_default7(it, () => i++ >= offset);
    }
    if (q.limit != null) {
      it = src_default9(it, q.limit);
    }
    return it;
  }
  queryKeys(q, options) {
    let it = this._allKeys(q, options);
    if (q.prefix != null) {
      const prefix = q.prefix;
      it = src_default7(it, (key) => key.toString().startsWith(prefix));
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f2) => src_default7(it2, f2), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f2) => src_default8(it2, f2), it);
    }
    if (q.offset != null) {
      const offset = q.offset;
      let i = 0;
      it = src_default7(it, () => i++ >= offset);
    }
    if (q.limit != null) {
      it = src_default9(it, q.limit);
    }
    return it;
  }
};

// node_modules/datastore-core/dist/src/errors.js
var import_err_code2 = __toESM(require_err_code(), 1);
function notFoundError(err) {
  err = err ?? new Error("Not Found");
  return (0, import_err_code2.default)(err, "ERR_NOT_FOUND");
}

// node_modules/datastore-core/dist/src/memory.js
var MemoryDatastore = class extends BaseDatastore {
  constructor() {
    super();
    __publicField(this, "data");
    this.data = /* @__PURE__ */ new Map();
  }
  put(key, val) {
    this.data.set(key.toString(), val);
    return key;
  }
  get(key) {
    const result = this.data.get(key.toString());
    if (result == null) {
      throw notFoundError();
    }
    return result;
  }
  has(key) {
    return this.data.has(key.toString());
  }
  delete(key) {
    this.data.delete(key.toString());
  }
  *_all() {
    for (const [key, value] of this.data.entries()) {
      yield { key: new Key(key), value };
    }
  }
  *_allKeys() {
    for (const key of this.data.keys()) {
      yield new Key(key);
    }
  }
};

// node_modules/libp2p/dist/src/address-manager/utils.js
function debounce(func2, wait) {
  let timeout;
  return function() {
    const later = function() {
      timeout = void 0;
      func2();
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

// node_modules/libp2p/dist/src/address-manager/index.js
var log20 = logger("libp2p:address-manager");
var defaultAddressFilter = (addrs) => addrs;
function stripPeerId(ma, peerId2) {
  const observedPeerIdStr = ma.getPeerId();
  if (observedPeerIdStr != null) {
    const observedPeerId = peerIdFromString(observedPeerIdStr);
    if (observedPeerId.equals(peerId2)) {
      ma = ma.decapsulate(multiaddr(`/p2p/${peerId2.toString()}`));
    }
  }
  return ma;
}
var DefaultAddressManager = class {
  /**
   * Responsible for managing the peer addresses.
   * Peers can specify their listen and announce addresses.
   * The listen addresses will be used by the libp2p transports to listen for new connections,
   * while the announce addresses will be used for the peer addresses' to other peers in the network.
   */
  constructor(components, init = {}) {
    __publicField(this, "components");
    // this is an array to allow for duplicates, e.g. multiples of `/ip4/0.0.0.0/tcp/0`
    __publicField(this, "listen");
    __publicField(this, "announce");
    __publicField(this, "observed");
    __publicField(this, "announceFilter");
    const { listen = [], announce = [] } = init;
    this.components = components;
    this.listen = listen.map((ma) => ma.toString());
    this.announce = new Set(announce.map((ma) => ma.toString()));
    this.observed = /* @__PURE__ */ new Map();
    this.announceFilter = init.announceFilter ?? defaultAddressFilter;
    this._updatePeerStoreAddresses = debounce(this._updatePeerStoreAddresses.bind(this), 1e3);
    components.events.addEventListener("transport:listening", () => {
      this._updatePeerStoreAddresses();
    });
    components.events.addEventListener("transport:close", () => {
      this._updatePeerStoreAddresses();
    });
  }
  _updatePeerStoreAddresses() {
    const addrs = this.getAnnounceAddrs().concat(this.components.transportManager.getAddrs()).concat([...this.observed.entries()].filter(([_, metadata]) => metadata.confident).map(([str]) => multiaddr(str))).map((ma) => {
      if (ma.getPeerId() === this.components.peerId.toString()) {
        return ma.decapsulate(`/p2p/${this.components.peerId.toString()}`);
      }
      return ma;
    });
    this.components.peerStore.patch(this.components.peerId, {
      multiaddrs: addrs
    }).catch((err) => {
      log20.error("error updating addresses", err);
    });
  }
  /**
   * Get peer listen multiaddrs
   */
  getListenAddrs() {
    return Array.from(this.listen).map((a) => multiaddr(a));
  }
  /**
   * Get peer announcing multiaddrs
   */
  getAnnounceAddrs() {
    return Array.from(this.announce).map((a) => multiaddr(a));
  }
  /**
   * Get observed multiaddrs
   */
  getObservedAddrs() {
    return Array.from(this.observed).map(([a]) => multiaddr(a));
  }
  /**
   * Add peer observed addresses
   */
  addObservedAddr(addr) {
    addr = stripPeerId(addr, this.components.peerId);
    const addrString = addr.toString();
    if (this.observed.has(addrString)) {
      return;
    }
    this.observed.set(addrString, {
      confident: false
    });
  }
  confirmObservedAddr(addr) {
    addr = stripPeerId(addr, this.components.peerId);
    const addrString = addr.toString();
    const metadata = this.observed.get(addrString) ?? {
      confident: false
    };
    const startingConfidence = metadata.confident;
    this.observed.set(addrString, {
      confident: true
    });
    if (!startingConfidence) {
      this._updatePeerStoreAddresses();
    }
  }
  removeObservedAddr(addr) {
    addr = stripPeerId(addr, this.components.peerId);
    const addrString = addr.toString();
    this.observed.delete(addrString);
  }
  getAddresses() {
    let addrs = this.getAnnounceAddrs().map((ma) => ma.toString());
    if (addrs.length === 0) {
      addrs = this.components.transportManager.getAddrs().map((ma) => ma.toString());
    }
    addrs = addrs.concat(Array.from(this.observed).filter(([ma, metadata]) => metadata.confident).map(([ma]) => ma));
    const addrSet = new Set(addrs);
    return this.announceFilter(Array.from(addrSet).map((str) => multiaddr(str))).map((ma) => {
      var _a4;
      if (((_a4 = ma.protos().pop()) == null ? void 0 : _a4.path) === true) {
        return ma;
      }
      if (ma.getPeerId() === this.components.peerId.toString()) {
        return ma;
      }
      return ma.encapsulate(`/p2p/${this.components.peerId.toString()}`);
    });
  }
};

// node_modules/@libp2p/interface/dist/src/startable.js
function isStartable(obj) {
  return obj != null && typeof obj.start === "function" && typeof obj.stop === "function";
}

// node_modules/libp2p/dist/src/components.js
var DefaultComponents = class {
  constructor(init = {}) {
    __publicField(this, "components", {});
    __publicField(this, "_started", false);
    this.components = {};
    for (const [key, value] of Object.entries(init)) {
      this.components[key] = value;
    }
    if (this.components.logger == null) {
      this.components.logger = defaultLogger();
    }
  }
  isStarted() {
    return this._started;
  }
  async _invokeStartableMethod(methodName) {
    await Promise.all(Object.values(this.components).filter((obj) => isStartable(obj)).map(async (startable) => {
      var _a4;
      await ((_a4 = startable[methodName]) == null ? void 0 : _a4.call(startable));
    }));
  }
  async beforeStart() {
    await this._invokeStartableMethod("beforeStart");
  }
  async start() {
    await this._invokeStartableMethod("start");
    this._started = true;
  }
  async afterStart() {
    await this._invokeStartableMethod("afterStart");
  }
  async beforeStop() {
    await this._invokeStartableMethod("beforeStop");
  }
  async stop() {
    await this._invokeStartableMethod("stop");
    this._started = false;
  }
  async afterStop() {
    await this._invokeStartableMethod("afterStop");
  }
};
var OPTIONAL_SERVICES = [
  "metrics",
  "connectionProtector"
];
var NON_SERVICE_PROPERTIES = [
  "components",
  "isStarted",
  "beforeStart",
  "start",
  "afterStart",
  "beforeStop",
  "stop",
  "afterStop",
  "then",
  "_invokeStartableMethod"
];
function defaultComponents(init = {}) {
  const components = new DefaultComponents(init);
  const proxy = new Proxy(components, {
    get(target, prop, receiver) {
      if (typeof prop === "string" && !NON_SERVICE_PROPERTIES.includes(prop)) {
        const service = components.components[prop];
        if (service == null && !OPTIONAL_SERVICES.includes(prop)) {
          throw new CodeError(`${prop} not set`, "ERR_SERVICE_MISSING");
        }
        return service;
      }
      return Reflect.get(target, prop, receiver);
    },
    set(target, prop, value) {
      if (typeof prop === "string") {
        components.components[prop] = value;
      } else {
        Reflect.set(target, prop, value);
      }
      return true;
    }
  });
  return proxy;
}

// node_modules/private-ip/lib/index.js
var import_netmask = __toESM(require_netmask(), 1);

// node_modules/ip-regex/index.js
var word = "[a-fA-F\\d:]";
var boundry = (options) => options && options.includeBoundaries ? `(?:(?<=\\s|^)(?=${word})|(?<=${word})(?=\\s|$))` : "";
var v42 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
var v6segment = "[a-fA-F\\d]{1,4}";
var v6 = `
(?:
(?:${v6segment}:){7}(?:${v6segment}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${v6segment}:){6}(?:${v42}|:${v6segment}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${v6segment}:){5}(?::${v42}|(?::${v6segment}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${v6segment}:){4}(?:(?::${v6segment}){0,1}:${v42}|(?::${v6segment}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${v6segment}:){3}(?:(?::${v6segment}){0,2}:${v42}|(?::${v6segment}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${v6segment}:){2}(?:(?::${v6segment}){0,3}:${v42}|(?::${v6segment}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${v6segment}:){1}(?:(?::${v6segment}){0,4}:${v42}|(?::${v6segment}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${v6segment}){0,5}:${v42}|(?::${v6segment}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
var v46Exact = new RegExp(`(?:^${v42}$)|(?:^${v6}$)`);
var v4exact = new RegExp(`^${v42}$`);
var v6exact = new RegExp(`^${v6}$`);
var ipRegex = (options) => options && options.exact ? v46Exact : new RegExp(`(?:${boundry(options)}${v42}${boundry(options)})|(?:${boundry(options)}${v6}${boundry(options)})`, "g");
ipRegex.v4 = (options) => options && options.exact ? v4exact : new RegExp(`${boundry(options)}${v42}${boundry(options)}`, "g");
ipRegex.v6 = (options) => options && options.exact ? v6exact : new RegExp(`${boundry(options)}${v6}${boundry(options)}`, "g");
var ip_regex_default = ipRegex;

// node_modules/private-ip/lib/index.js
var import_ipaddr = __toESM(require_ipaddr(), 1);
var { isValid: is_valid, parse: parse2 } = import_ipaddr.default;
var PRIVATE_IP_RANGES = [
  "0.0.0.0/8",
  "10.0.0.0/8",
  "100.64.0.0/10",
  "127.0.0.0/8",
  "169.254.0.0/16",
  "172.16.0.0/12",
  "192.0.0.0/24",
  "192.0.0.0/29",
  "192.0.0.8/32",
  "192.0.0.9/32",
  "192.0.0.10/32",
  "192.0.0.170/32",
  "192.0.0.171/32",
  "192.0.2.0/24",
  "192.31.196.0/24",
  "192.52.193.0/24",
  "192.88.99.0/24",
  "192.168.0.0/16",
  "192.175.48.0/24",
  "198.18.0.0/15",
  "198.51.100.0/24",
  "203.0.113.0/24",
  "240.0.0.0/4",
  "255.255.255.255/32"
];
var NETMASK_RANGES = PRIVATE_IP_RANGES.map((ip_range) => new import_netmask.Netmask(ip_range));
function ipv4_check(ip_addr) {
  for (let r of NETMASK_RANGES) {
    if (r.contains(ip_addr))
      return true;
  }
  return false;
}
function ipv6_check(ip_addr) {
  return /^::$/.test(ip_addr) || /^::1$/.test(ip_addr) || /^::f{4}:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ip_addr) || /^::f{4}:0.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ip_addr) || /^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ip_addr) || /^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^f[c-d]([0-9a-fA-F]{2,2}):/i.test(ip_addr) || /^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(ip_addr) || /^ff([0-9a-fA-F]{2,2}):/i.test(ip_addr);
}
var lib_default = (ip) => {
  if (is_valid(ip)) {
    const parsed = parse2(ip);
    if (parsed.kind() === "ipv4")
      return ipv4_check(parsed.toNormalizedString());
    else if (parsed.kind() === "ipv6")
      return ipv6_check(ip);
  } else if (isIP(ip) && ip_regex_default.v6().test(ip))
    return ipv6_check(ip);
  return void 0;
};

// node_modules/private-ip/index.js
var private_ip_default = lib_default;

// node_modules/libp2p/dist/src/config/connection-gater.browser.js
function connectionGater(gater = {}) {
  return {
    denyDialPeer: async () => false,
    denyDialMultiaddr: async (multiaddr2) => {
      const tuples = multiaddr2.stringTuples();
      if (tuples[0][0] === 4 || tuples[0][0] === 41) {
        return Boolean(private_ip_default(`${tuples[0][1]}`));
      }
      return false;
    },
    denyInboundConnection: async () => false,
    denyOutboundConnection: async () => false,
    denyInboundEncryptedConnection: async () => false,
    denyOutboundEncryptedConnection: async () => false,
    denyInboundUpgradedConnection: async () => false,
    denyOutboundUpgradedConnection: async () => false,
    filterMultiaddrForPeer: async () => true,
    ...gater
  };
}

// node_modules/@multiformats/multiaddr-matcher/node_modules/multiformats/vendor/base-x.js
function base2(ALPHABET, name2) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode12(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length4 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length4) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length4 = i2;
      pbegin++;
    }
    var it2 = size - length4;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length4 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length4) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length4 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length4;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode12(string2) {
    var buffer = decodeUnsafe(string2);
    if (buffer) {
      return buffer;
    }
    throw new Error(`Non-${name2} character`);
  }
  return {
    encode: encode12,
    decodeUnsafe,
    decode: decode12
  };
}
var src2 = base2;
var _brrp__multiformats_scope_baseX2 = src2;
var base_x_default3 = _brrp__multiformats_scope_baseX2;

// node_modules/@multiformats/multiaddr-matcher/node_modules/multiformats/src/bytes.js
var empty5 = new Uint8Array(0);
var coerce5 = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};

// node_modules/@multiformats/multiaddr-matcher/node_modules/multiformats/src/bases/base.js
var Encoder5 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor(name2, prefix, baseEncode) {
    this.name = name2;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode(bytes2) {
    if (bytes2 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes2)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder5 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name2, prefix, baseDecode) {
    this.name = name2;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = /** @type {number} */
    prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  /**
   * @param {string} text
   */
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or3(this, decoder);
  }
};
var ComposedDecoder3 = class {
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor(decoders) {
    this.decoders = decoders;
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or3(this, decoder);
  }
  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode(input) {
    const prefix = (
      /** @type {Prefix} */
      input[0]
    );
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or3 = (left, right) => new ComposedDecoder3(
  /** @type {Decoders<L|R>} */
  {
    ...left.decoders || { [
      /** @type API.UnibaseDecoder<L> */
      left.prefix
    ]: left },
    ...right.decoders || { [
      /** @type API.UnibaseDecoder<R> */
      right.prefix
    ]: right }
  }
);
var Codec3 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name2, prefix, baseEncode, baseDecode) {
    this.name = name2;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder5(name2, prefix, baseEncode);
    this.decoder = new Decoder5(name2, prefix, baseDecode);
  }
  /**
   * @param {Uint8Array} input
   */
  encode(input) {
    return this.encoder.encode(input);
  }
  /**
   * @param {string} input
   */
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from6 = ({ name: name2, prefix, encode: encode12, decode: decode12 }) => new Codec3(name2, prefix, encode12, decode12);
var baseX2 = ({ prefix, name: name2, alphabet }) => {
  const { encode: encode12, decode: decode12 } = base_x_default3(alphabet, name2);
  return from6({
    prefix,
    name: name2,
    encode: encode12,
    /**
     * @param {string} text
     */
    decode: (text) => coerce5(decode12(text))
  });
};
var decode11 = (string2, alphabet, bitsPerChar, name2) => {
  const codes6 = {};
  for (let i = 0; i < alphabet.length; ++i) {
    codes6[alphabet[i]] = i;
  }
  let end = string2.length;
  while (string2[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits2 = 0;
  let buffer = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes6[string2[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name2} character`);
    }
    buffer = buffer << bitsPerChar | value;
    bits2 += bitsPerChar;
    if (bits2 >= 8) {
      bits2 -= 8;
      out[written++] = 255 & buffer >> bits2;
    }
  }
  if (bits2 >= bitsPerChar || 255 & buffer << 8 - bits2) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode10 = (data, alphabet, bitsPerChar) => {
  const pad = alphabet[alphabet.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits2 = 0;
  let buffer = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer = buffer << 8 | data[i];
    bits2 += 8;
    while (bits2 > bitsPerChar) {
      bits2 -= bitsPerChar;
      out += alphabet[mask & buffer >> bits2];
    }
  }
  if (bits2) {
    out += alphabet[mask & buffer << bitsPerChar - bits2];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc46483 = ({ name: name2, prefix, bitsPerChar, alphabet }) => {
  return from6({
    prefix,
    name: name2,
    encode(input) {
      return encode10(input, alphabet, bitsPerChar);
    },
    decode(input) {
      return decode11(input, alphabet, bitsPerChar, name2);
    }
  });
};

// node_modules/@multiformats/multiaddr-matcher/node_modules/multiformats/src/bases/base58.js
var base58btc2 = baseX2({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr2 = baseX2({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@multiformats/multiaddr-matcher/node_modules/multiformats/src/bases/base64.js
var base642 = rfc46483({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad2 = rfc46483({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url2 = rfc46483({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad2 = rfc46483({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@multiformats/multiaddr-matcher/dist/src/index.js
var toParts = (ma) => {
  return ma.toString().split("/").slice(1);
};
var func = (fn) => {
  return {
    match: (vals) => {
      if (vals.length < 1) {
        return false;
      }
      if (fn(vals[0])) {
        return vals.slice(1);
      }
      return false;
    },
    pattern: "fn"
  };
};
var literal = (str) => {
  return {
    match: (vals) => func((val) => val === str).match(vals),
    pattern: str
  };
};
var string = () => {
  return {
    match: (vals) => func((val) => typeof val === "string").match(vals),
    pattern: "{string}"
  };
};
var number3 = () => {
  return {
    match: (vals) => func((val) => !isNaN(parseInt(val))).match(vals),
    pattern: "{number}"
  };
};
var peerId = () => {
  return {
    match: (vals) => {
      if (vals.length < 2) {
        return false;
      }
      if (vals[0] !== "p2p" && vals[0] !== "ipfs") {
        return false;
      }
      if (vals[1].startsWith("Q") || vals[1].startsWith("1")) {
        try {
          base58btc2.decode(`z${vals[1]}`);
        } catch (err) {
          return false;
        }
      } else {
        return false;
      }
      return vals.slice(2);
    },
    pattern: "/p2p/{peerid}"
  };
};
var certhash = () => {
  return {
    match: (vals) => {
      if (vals.length < 2) {
        return false;
      }
      if (vals[0] !== "certhash") {
        return false;
      }
      try {
        base64url2.decode(vals[1]);
      } catch {
        return false;
      }
      return vals.slice(2);
    },
    pattern: "/certhash/{certhash}"
  };
};
var optional = (matcher) => {
  return {
    match: (vals) => {
      const result = matcher.match(vals);
      if (result === false) {
        return vals;
      }
      return result;
    },
    pattern: `optional(${matcher.pattern})`
  };
};
var or4 = (...matchers) => {
  return {
    match: (vals) => {
      let matches;
      for (const matcher of matchers) {
        const result = matcher.match(vals);
        if (result === false) {
          continue;
        }
        if (matches == null || result.length < matches.length) {
          matches = result;
        }
      }
      if (matches == null) {
        return false;
      }
      return matches;
    },
    pattern: `or(${matchers.map((m) => m.pattern).join(", ")})`
  };
};
var and = (...matchers) => {
  return {
    match: (vals) => {
      for (const matcher of matchers) {
        const result = matcher.match(vals);
        if (result === false) {
          return false;
        }
        vals = result;
      }
      return vals;
    },
    pattern: `and(${matchers.map((m) => m.pattern).join(", ")})`
  };
};
function fmt(...matchers) {
  function match(ma) {
    let parts = toParts(ma);
    for (const matcher of matchers) {
      const result = matcher.match(parts);
      if (result === false) {
        return false;
      }
      parts = result;
    }
    return parts;
  }
  function matches(ma) {
    const result = match(ma);
    return result !== false;
  }
  function exactMatch(ma) {
    const result = match(ma);
    if (result === false) {
      return false;
    }
    return result.length === 0;
  }
  return {
    matches,
    exactMatch
  };
}
var _DNS4 = and(literal("dns4"), string());
var _DNS6 = and(literal("dns6"), string());
var _DNSADDR = and(literal("dnsaddr"), string());
var _DNS = and(literal("dns"), string());
var DNS4 = fmt(_DNS4);
var DNS6 = fmt(_DNS6);
var DNSADDR = fmt(_DNSADDR);
var DNS3 = fmt(or4(_DNS, _DNSADDR, _DNS4, _DNS6));
var _IP4 = and(literal("ip4"), func(isIPv4));
var _IP6 = and(literal("ip6"), func(isIPv6));
var _IP = or4(_IP4, _IP6);
var _IP_OR_DOMAIN = or4(_IP, _DNS, _DNS4, _DNS6, _DNSADDR);
var IP_OR_DOMAIN = fmt(_IP_OR_DOMAIN);
var IP4 = fmt(_IP4);
var IP6 = fmt(_IP6);
var IP = fmt(_IP);
var _TCP = and(_IP_OR_DOMAIN, literal("tcp"), number3());
var _UDP = and(_IP_OR_DOMAIN, literal("udp"), number3());
var TCP_OR_UDP = or4(_TCP, _UDP);
var TCP = fmt(_TCP);
var UDP = fmt(_UDP);
var _QUIC = and(_UDP, literal("quic"));
var _QUICV1 = and(_UDP, literal("quic-v1"));
var QUIC_V0_OR_V1 = or4(_QUIC, _QUICV1);
var QUIC = fmt(_QUIC);
var QUICV1 = fmt(_QUICV1);
var _WEB = or4(_IP_OR_DOMAIN, _TCP, _UDP, _QUIC, _QUICV1);
var _WebSockets = or4(and(_WEB, literal("ws"), optional(peerId())));
var WebSockets3 = fmt(_WebSockets);
var _WebSocketsSecure = or4(and(_WEB, literal("wss"), optional(peerId())), and(_WEB, literal("tls"), literal("ws"), optional(peerId())));
var WebSocketsSecure2 = fmt(_WebSocketsSecure);
var _WebRTCDirect = and(TCP_OR_UDP, literal("webrtc-direct"), certhash(), optional(certhash()), optional(peerId()));
var WebRTCDirect = fmt(_WebRTCDirect);
var _WebTransport = and(_QUICV1, literal("webtransport"), certhash(), certhash(), optional(peerId()));
var WebTransport = fmt(_WebTransport);
var _P2P = or4(_WebSockets, _WebSocketsSecure, and(_TCP, optional(peerId())), and(QUIC_V0_OR_V1, optional(peerId())), and(_IP_OR_DOMAIN, optional(peerId())), _WebRTCDirect, _WebTransport, peerId());
var P2P = fmt(_P2P);
var _Circuit = and(_P2P, literal("p2p-circuit"), peerId());
var Circuit = fmt(_Circuit);
var _WebRTC = or4(and(_P2P, literal("p2p-circuit"), literal("webrtc"), peerId()), and(_P2P, literal("webrtc"), optional(peerId())), literal("webrtc"));
var WebRTC = fmt(_WebRTC);

// node_modules/@libp2p/utils/dist/src/multiaddr/is-private.js
function isPrivate(ma) {
  try {
    const { address } = ma.nodeAddress();
    return Boolean(private_ip_default(address));
  } catch {
    return true;
  }
}

// node_modules/@libp2p/utils/dist/src/address-sort.js
function publicAddressesFirst(a, b) {
  const isAPrivate = isPrivate(a.multiaddr);
  const isBPrivate = isPrivate(b.multiaddr);
  if (isAPrivate && !isBPrivate) {
    return 1;
  } else if (!isAPrivate && isBPrivate) {
    return -1;
  }
  return 0;
}
function certifiedAddressesFirst(a, b) {
  if (a.isCertified && !b.isCertified) {
    return -1;
  } else if (!a.isCertified && b.isCertified) {
    return 1;
  }
  return 0;
}
function circuitRelayAddressesLast(a, b) {
  const isACircuit = Circuit.exactMatch(a.multiaddr);
  const isBCircuit = Circuit.exactMatch(b.multiaddr);
  if (isACircuit && !isBCircuit) {
    return 1;
  } else if (!isACircuit && isBCircuit) {
    return -1;
  }
  return 0;
}
function defaultAddressSort(a, b) {
  const publicResult = publicAddressesFirst(a, b);
  if (publicResult !== 0) {
    return publicResult;
  }
  const relayResult = circuitRelayAddressesLast(a, b);
  if (relayResult !== 0) {
    return relayResult;
  }
  const certifiedResult = certifiedAddressesFirst(a, b);
  return certifiedResult;
}

// node_modules/dns-over-http-resolver/dist/src/index.js
var import_debug = __toESM(require_browser());
var import_receptacle = __toESM(require_receptacle());

// node_modules/dns-over-http-resolver/dist/src/utils.js
function buildResource(serverResolver, hostname, recordType) {
  return `${serverResolver}?name=${hostname}&type=${recordType}`;
}
async function request(resource, signal) {
  const req = await fetch(resource, {
    headers: new Headers({
      accept: "application/dns-json"
    }),
    signal
  });
  const res = await req.json();
  return res;
}
function getCacheKey(hostname, recordType) {
  return `${recordType}_${hostname}`;
}

// node_modules/dns-over-http-resolver/dist/src/index.js
var log21 = Object.assign((0, import_debug.default)("dns-over-http-resolver"), {
  error: (0, import_debug.default)("dns-over-http-resolver:error")
});
var Resolver = class {
  /**
   * @class
   * @param {object} [options]
   * @param {number} [options.maxCache = 100] - maximum number of cached dns records
   * @param {Request} [options.request] - function to return DNSJSON
   */
  constructor(options = {}) {
    __publicField(this, "_cache");
    __publicField(this, "_TXTcache");
    __publicField(this, "_servers");
    __publicField(this, "_request");
    __publicField(this, "_abortControllers");
    this._cache = new import_receptacle.default({ max: (options == null ? void 0 : options.maxCache) ?? 100 });
    this._TXTcache = new import_receptacle.default({ max: (options == null ? void 0 : options.maxCache) ?? 100 });
    this._servers = [
      "https://cloudflare-dns.com/dns-query",
      "https://dns.google/resolve"
    ];
    this._request = options.request ?? request;
    this._abortControllers = [];
  }
  /**
   * Cancel all outstanding DNS queries made by this resolver. Any outstanding
   * requests will be aborted and promises rejected.
   */
  cancel() {
    this._abortControllers.forEach((controller) => {
      controller.abort();
    });
  }
  /**
   * Get an array of the IP addresses currently configured for DNS resolution.
   * These addresses are formatted according to RFC 5952. It can include a custom port.
   */
  getServers() {
    return this._servers;
  }
  /**
   * Get a shuffled array of the IP addresses currently configured for DNS resolution.
   * These addresses are formatted according to RFC 5952. It can include a custom port.
   */
  _getShuffledServers() {
    const newServers = [...this._servers];
    for (let i = newServers.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * i);
      const temp = newServers[i];
      newServers[i] = newServers[j];
      newServers[j] = temp;
    }
    return newServers;
  }
  /**
   * Sets the IP address and port of servers to be used when performing DNS resolution.
   *
   * @param {string[]} servers - array of RFC 5952 formatted addresses.
   */
  setServers(servers) {
    this._servers = servers;
  }
  async resolve(hostname, rrType = "A") {
    switch (rrType) {
      case "A":
        return this.resolve4(hostname);
      case "AAAA":
        return this.resolve6(hostname);
      case "TXT":
        return this.resolveTxt(hostname);
      default:
        throw new Error(`${rrType} is not supported`);
    }
  }
  /**
   * Uses the DNS protocol to resolve the given host name into IPv4 addresses
   *
   * @param {string} hostname - host name to resolve
   */
  async resolve4(hostname) {
    const recordType = "A";
    const cached = this._cache.get(getCacheKey(hostname, recordType));
    if (cached != null) {
      return cached;
    }
    let aborted = false;
    for (const server of this._getShuffledServers()) {
      const controller = new AbortController();
      this._abortControllers.push(controller);
      try {
        const response = await this._request(buildResource(server, hostname, recordType), controller.signal);
        const data = response.Answer.map((a) => a.data);
        const ttl = Math.min(...response.Answer.map((a) => a.TTL));
        this._cache.set(getCacheKey(hostname, recordType), data, { ttl });
        return data;
      } catch (err) {
        if (controller.signal.aborted) {
          aborted = true;
        }
        log21.error(`${server} could not resolve ${hostname} record ${recordType}`);
      } finally {
        this._abortControllers = this._abortControllers.filter((c) => c !== controller);
      }
    }
    if (aborted) {
      throw Object.assign(new Error("queryA ECANCELLED"), {
        code: "ECANCELLED"
      });
    }
    throw new Error(`Could not resolve ${hostname} record ${recordType}`);
  }
  /**
   * Uses the DNS protocol to resolve the given host name into IPv6 addresses
   *
   * @param {string} hostname - host name to resolve
   */
  async resolve6(hostname) {
    const recordType = "AAAA";
    const cached = this._cache.get(getCacheKey(hostname, recordType));
    if (cached != null) {
      return cached;
    }
    let aborted = false;
    for (const server of this._getShuffledServers()) {
      const controller = new AbortController();
      this._abortControllers.push(controller);
      try {
        const response = await this._request(buildResource(server, hostname, recordType), controller.signal);
        const data = response.Answer.map((a) => a.data);
        const ttl = Math.min(...response.Answer.map((a) => a.TTL));
        this._cache.set(getCacheKey(hostname, recordType), data, { ttl });
        return data;
      } catch (err) {
        if (controller.signal.aborted) {
          aborted = true;
        }
        log21.error(`${server} could not resolve ${hostname} record ${recordType}`);
      } finally {
        this._abortControllers = this._abortControllers.filter((c) => c !== controller);
      }
    }
    if (aborted) {
      throw Object.assign(new Error("queryAaaa ECANCELLED"), {
        code: "ECANCELLED"
      });
    }
    throw new Error(`Could not resolve ${hostname} record ${recordType}`);
  }
  /**
   * Uses the DNS protocol to resolve the given host name into a Text record
   *
   * @param {string} hostname - host name to resolve
   */
  async resolveTxt(hostname) {
    const recordType = "TXT";
    const cached = this._TXTcache.get(getCacheKey(hostname, recordType));
    if (cached != null) {
      return cached;
    }
    let aborted = false;
    for (const server of this._getShuffledServers()) {
      const controller = new AbortController();
      this._abortControllers.push(controller);
      try {
        const response = await this._request(buildResource(server, hostname, recordType), controller.signal);
        const data = response.Answer.map((a) => [a.data.replace(/['"]+/g, "")]);
        const ttl = Math.min(...response.Answer.map((a) => a.TTL));
        this._TXTcache.set(getCacheKey(hostname, recordType), data, { ttl });
        return data;
      } catch (err) {
        if (controller.signal.aborted) {
          aborted = true;
        }
        log21.error(`${server} could not resolve ${hostname} record ${recordType}`);
      } finally {
        this._abortControllers = this._abortControllers.filter((c) => c !== controller);
      }
    }
    if (aborted) {
      throw Object.assign(new Error("queryTxt ECANCELLED"), {
        code: "ECANCELLED"
      });
    }
    throw new Error(`Could not resolve ${hostname} record ${recordType}`);
  }
  clearCache() {
    this._cache.clear();
    this._TXTcache.clear();
  }
};
var src_default10 = Resolver;

// node_modules/@multiformats/multiaddr/dist/src/resolvers/dns.browser.js
var dns_browser_default = src_default10;

// node_modules/@multiformats/multiaddr/dist/src/resolvers/index.js
var { code: dnsaddrCode } = getProtocol("dnsaddr");
async function dnsaddrResolver(addr, options = {}) {
  const resolver = new dns_browser_default();
  if (options.signal != null) {
    options.signal.addEventListener("abort", () => {
      resolver.cancel();
    });
  }
  const peerId2 = addr.getPeerId();
  const [, hostname] = addr.stringTuples().find(([proto]) => proto === dnsaddrCode) ?? [];
  if (hostname == null) {
    throw new Error("No hostname found in multiaddr");
  }
  const records = await resolver.resolveTxt(`_dnsaddr.${hostname}`);
  let addresses = records.flat().map((a) => a.split("=")[1]).filter(Boolean);
  if (peerId2 != null) {
    addresses = addresses.filter((entry) => entry.includes(peerId2));
  }
  return addresses;
}

// node_modules/libp2p/dist/src/errors.js
var messages;
(function(messages2) {
  messages2["NOT_STARTED_YET"] = "The libp2p node is not started yet";
  messages2["DHT_DISABLED"] = "DHT is not available";
  messages2["PUBSUB_DISABLED"] = "PubSub is not available";
  messages2["CONN_ENCRYPTION_REQUIRED"] = "At least one connection encryption module is required";
  messages2["ERR_TRANSPORTS_REQUIRED"] = "At least one transport module is required";
  messages2["ERR_PROTECTOR_REQUIRED"] = "Private network is enforced, but no protector was provided";
  messages2["NOT_FOUND"] = "Not found";
})(messages || (messages = {}));
var codes5;
(function(codes6) {
  codes6["DHT_DISABLED"] = "ERR_DHT_DISABLED";
  codes6["ERR_PUBSUB_DISABLED"] = "ERR_PUBSUB_DISABLED";
  codes6["PUBSUB_NOT_STARTED"] = "ERR_PUBSUB_NOT_STARTED";
  codes6["DHT_NOT_STARTED"] = "ERR_DHT_NOT_STARTED";
  codes6["CONN_ENCRYPTION_REQUIRED"] = "ERR_CONN_ENCRYPTION_REQUIRED";
  codes6["ERR_TRANSPORTS_REQUIRED"] = "ERR_TRANSPORTS_REQUIRED";
  codes6["ERR_PROTECTOR_REQUIRED"] = "ERR_PROTECTOR_REQUIRED";
  codes6["ERR_PEER_DIAL_INTERCEPTED"] = "ERR_PEER_DIAL_INTERCEPTED";
  codes6["ERR_CONNECTION_INTERCEPTED"] = "ERR_CONNECTION_INTERCEPTED";
  codes6["ERR_INVALID_PROTOCOLS_FOR_STREAM"] = "ERR_INVALID_PROTOCOLS_FOR_STREAM";
  codes6["ERR_CONNECTION_ENDED"] = "ERR_CONNECTION_ENDED";
  codes6["ERR_CONNECTION_FAILED"] = "ERR_CONNECTION_FAILED";
  codes6["ERR_NODE_NOT_STARTED"] = "ERR_NODE_NOT_STARTED";
  codes6["ERR_ALREADY_ABORTED"] = "ERR_ALREADY_ABORTED";
  codes6["ERR_TOO_MANY_ADDRESSES"] = "ERR_TOO_MANY_ADDRESSES";
  codes6["ERR_NO_VALID_ADDRESSES"] = "ERR_NO_VALID_ADDRESSES";
  codes6["ERR_RELAYED_DIAL"] = "ERR_RELAYED_DIAL";
  codes6["ERR_DIALED_SELF"] = "ERR_DIALED_SELF";
  codes6["ERR_DISCOVERED_SELF"] = "ERR_DISCOVERED_SELF";
  codes6["ERR_DUPLICATE_TRANSPORT"] = "ERR_DUPLICATE_TRANSPORT";
  codes6["ERR_ENCRYPTION_FAILED"] = "ERR_ENCRYPTION_FAILED";
  codes6["ERR_HOP_REQUEST_FAILED"] = "ERR_HOP_REQUEST_FAILED";
  codes6["ERR_INVALID_KEY"] = "ERR_INVALID_KEY";
  codes6["ERR_INVALID_MESSAGE"] = "ERR_INVALID_MESSAGE";
  codes6["ERR_INVALID_PARAMETERS"] = "ERR_INVALID_PARAMETERS";
  codes6["ERR_INVALID_PEER"] = "ERR_INVALID_PEER";
  codes6["ERR_MUXER_UNAVAILABLE"] = "ERR_MUXER_UNAVAILABLE";
  codes6["ERR_NOT_FOUND"] = "ERR_NOT_FOUND";
  codes6["ERR_TIMEOUT"] = "ERR_TIMEOUT";
  codes6["ERR_TRANSPORT_UNAVAILABLE"] = "ERR_TRANSPORT_UNAVAILABLE";
  codes6["ERR_TRANSPORT_DIAL_FAILED"] = "ERR_TRANSPORT_DIAL_FAILED";
  codes6["ERR_UNSUPPORTED_PROTOCOL"] = "ERR_UNSUPPORTED_PROTOCOL";
  codes6["ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED"] = "ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED";
  codes6["ERR_INVALID_MULTIADDR"] = "ERR_INVALID_MULTIADDR";
  codes6["ERR_SIGNATURE_NOT_VALID"] = "ERR_SIGNATURE_NOT_VALID";
  codes6["ERR_FIND_SELF"] = "ERR_FIND_SELF";
  codes6["ERR_NO_ROUTERS_AVAILABLE"] = "ERR_NO_ROUTERS_AVAILABLE";
  codes6["ERR_CONNECTION_NOT_MULTIPLEXED"] = "ERR_CONNECTION_NOT_MULTIPLEXED";
  codes6["ERR_NO_DIAL_TOKENS"] = "ERR_NO_DIAL_TOKENS";
  codes6["ERR_KEYCHAIN_REQUIRED"] = "ERR_KEYCHAIN_REQUIRED";
  codes6["ERR_INVALID_CMS"] = "ERR_INVALID_CMS";
  codes6["ERR_MISSING_KEYS"] = "ERR_MISSING_KEYS";
  codes6["ERR_NO_KEY"] = "ERR_NO_KEY";
  codes6["ERR_INVALID_KEY_NAME"] = "ERR_INVALID_KEY_NAME";
  codes6["ERR_INVALID_KEY_TYPE"] = "ERR_INVALID_KEY_TYPE";
  codes6["ERR_KEY_ALREADY_EXISTS"] = "ERR_KEY_ALREADY_EXISTS";
  codes6["ERR_INVALID_KEY_SIZE"] = "ERR_INVALID_KEY_SIZE";
  codes6["ERR_KEY_NOT_FOUND"] = "ERR_KEY_NOT_FOUND";
  codes6["ERR_OLD_KEY_NAME_INVALID"] = "ERR_OLD_KEY_NAME_INVALID";
  codes6["ERR_NEW_KEY_NAME_INVALID"] = "ERR_NEW_KEY_NAME_INVALID";
  codes6["ERR_PASSWORD_REQUIRED"] = "ERR_PASSWORD_REQUIRED";
  codes6["ERR_PEM_REQUIRED"] = "ERR_PEM_REQUIRED";
  codes6["ERR_CANNOT_READ_KEY"] = "ERR_CANNOT_READ_KEY";
  codes6["ERR_MISSING_PRIVATE_KEY"] = "ERR_MISSING_PRIVATE_KEY";
  codes6["ERR_MISSING_PUBLIC_KEY"] = "ERR_MISSING_PUBLIC_KEY";
  codes6["ERR_INVALID_OLD_PASS_TYPE"] = "ERR_INVALID_OLD_PASS_TYPE";
  codes6["ERR_INVALID_NEW_PASS_TYPE"] = "ERR_INVALID_NEW_PASS_TYPE";
  codes6["ERR_INVALID_PASS_LENGTH"] = "ERR_INVALID_PASS_LENGTH";
  codes6["ERR_NOT_IMPLEMENTED"] = "ERR_NOT_IMPLEMENTED";
  codes6["ERR_WRONG_PING_ACK"] = "ERR_WRONG_PING_ACK";
  codes6["ERR_INVALID_RECORD"] = "ERR_INVALID_RECORD";
  codes6["ERR_ALREADY_SUCCEEDED"] = "ERR_ALREADY_SUCCEEDED";
  codes6["ERR_NO_HANDLER_FOR_PROTOCOL"] = "ERR_NO_HANDLER_FOR_PROTOCOL";
  codes6["ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS"] = "ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS";
  codes6["ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS"] = "ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS";
  codes6["ERR_CONNECTION_DENIED"] = "ERR_CONNECTION_DENIED";
  codes6["ERR_TRANSFER_LIMIT_EXCEEDED"] = "ERR_TRANSFER_LIMIT_EXCEEDED";
})(codes5 || (codes5 = {}));

// node_modules/libp2p/dist/src/config.js
var DefaultConfig = {
  addresses: {
    listen: [],
    announce: [],
    noAnnounce: [],
    announceFilter: (multiaddrs) => multiaddrs
  },
  connectionManager: {
    resolvers: {
      dnsaddr: dnsaddrResolver
    },
    addressSorter: defaultAddressSort
  },
  transportManager: {
    faultTolerance: FaultTolerance.FATAL_ALL
  }
};
function validateConfig(opts) {
  var _a4, _b4;
  const resultingOptions = merge_options_default(DefaultConfig, opts);
  if (resultingOptions.transports == null || resultingOptions.transports.length < 1) {
    throw new CodeError(messages.ERR_TRANSPORTS_REQUIRED, codes5.ERR_TRANSPORTS_REQUIRED);
  }
  if (resultingOptions.connectionProtector === null && ((_b4 = (_a4 = globalThis.process) == null ? void 0 : _a4.env) == null ? void 0 : _b4.LIBP2P_FORCE_PNET) != null) {
    throw new CodeError(messages.ERR_PROTECTOR_REQUIRED, codes5.ERR_PROTECTOR_REQUIRED);
  }
  return resultingOptions;
}

// node_modules/@libp2p/interface/dist/src/peer-store/tags.js
var KEEP_ALIVE = "keep-alive";

// node_modules/libp2p/dist/src/connection-manager/index.js
var import_rate_limiter_flexible2 = __toESM(require_rate_limiter_flexible(), 1);

// node_modules/libp2p/dist/src/get-peer.js
var log22 = logger("libp2p:get-peer");
function getPeerAddress(peer) {
  if (isPeerId(peer)) {
    return { peerId: peer, multiaddrs: [] };
  }
  if (!Array.isArray(peer)) {
    peer = [peer];
  }
  let peerId2;
  if (peer.length > 0) {
    const peerIdStr = peer[0].getPeerId();
    peerId2 = peerIdStr == null ? void 0 : peerIdFromString(peerIdStr);
    peer.forEach((ma) => {
      if (!isMultiaddr(ma)) {
        log22.error("multiaddr %s was invalid", ma);
        throw new CodeError("Invalid Multiaddr", codes5.ERR_INVALID_MULTIADDR);
      }
      const maPeerIdStr = ma.getPeerId();
      if (maPeerIdStr == null) {
        if (peerId2 != null) {
          throw new CodeError("Multiaddrs must all have the same peer id or have no peer id", codes5.ERR_INVALID_PARAMETERS);
        }
      } else {
        const maPeerId = peerIdFromString(maPeerIdStr);
        if (peerId2 == null || !peerId2.equals(maPeerId)) {
          throw new CodeError("Multiaddrs must all have the same peer id or have no peer id", codes5.ERR_INVALID_PARAMETERS);
        }
      }
    });
  }
  return {
    peerId: peerId2,
    multiaddrs: peer
  };
}

// node_modules/libp2p/dist/src/utils/peer-job-queue.js
function lowerBound2(array, value, comparator) {
  let first2 = 0;
  let count = array.length;
  while (count > 0) {
    const step = Math.trunc(count / 2);
    let it = first2 + step;
    if (comparator(array[it], value) <= 0) {
      first2 = ++it;
      count -= step + 1;
    } else {
      count = step;
    }
  }
  return first2;
}
var _queue;
var PeerPriorityQueue = class {
  constructor() {
    __privateAdd(this, _queue, []);
  }
  enqueue(run, options) {
    const peerId2 = options == null ? void 0 : options.peerId;
    const priority = (options == null ? void 0 : options.priority) ?? 0;
    if (peerId2 == null) {
      throw new CodeError("missing peer id", codes5.ERR_INVALID_PARAMETERS);
    }
    const element = {
      priority,
      peerId: peerId2,
      run
    };
    if (this.size > 0 && __privateGet(this, _queue)[this.size - 1].priority >= priority) {
      __privateGet(this, _queue).push(element);
      return;
    }
    const index = lowerBound2(__privateGet(this, _queue), element, (a, b) => b.priority - a.priority);
    __privateGet(this, _queue).splice(index, 0, element);
  }
  dequeue() {
    const item = __privateGet(this, _queue).shift();
    return item == null ? void 0 : item.run;
  }
  filter(options) {
    if (options.peerId != null) {
      const peerId2 = options.peerId;
      return __privateGet(this, _queue).filter((element) => peerId2.equals(element.peerId)).map((element) => element.run);
    }
    return __privateGet(this, _queue).filter((element) => element.priority === options.priority).map((element) => element.run);
  }
  get size() {
    return __privateGet(this, _queue).length;
  }
};
_queue = new WeakMap();
var PeerJobQueue = class extends dist_default {
  constructor(options = {}) {
    super({
      ...options,
      queueClass: PeerPriorityQueue
    });
  }
  /**
   * Returns true if this queue has a job for the passed peer id that has not yet
   * started to run
   */
  hasJob(peerId2) {
    return this.sizeBy({
      peerId: peerId2
    }) > 0;
  }
};

// node_modules/libp2p/dist/src/connection-manager/constants.defaults.js
var DIAL_TIMEOUT = 3e4;
var INBOUND_UPGRADE_TIMEOUT = 3e4;
var MAX_PEER_ADDRS_TO_DIAL = 25;
var MAX_PARALLEL_DIALS_PER_PEER = 1;
var AUTO_DIAL_INTERVAL = 5e3;
var AUTO_DIAL_CONCURRENCY = 25;
var AUTO_DIAL_PRIORITY = 0;
var AUTO_DIAL_MAX_QUEUE_LENGTH = 100;
var AUTO_DIAL_DISCOVERED_PEERS_DEBOUNCE = 10;
var INBOUND_CONNECTION_THRESHOLD = 5;
var MAX_INCOMING_PENDING_CONNECTIONS = 10;
var LAST_DIAL_FAILURE_KEY = "last-dial-failure";

// node_modules/libp2p/dist/src/connection-manager/constants.browser.js
var MIN_CONNECTIONS = 5;
var MAX_CONNECTIONS = 100;
var MAX_PARALLEL_DIALS = 50;
var AUTO_DIAL_PEER_RETRY_THRESHOLD = 1e3 * 60 * 7;

// node_modules/libp2p/dist/src/connection-manager/auto-dial.js
var defaultOptions4 = {
  minConnections: MIN_CONNECTIONS,
  maxQueueLength: AUTO_DIAL_MAX_QUEUE_LENGTH,
  autoDialConcurrency: AUTO_DIAL_CONCURRENCY,
  autoDialPriority: AUTO_DIAL_PRIORITY,
  autoDialInterval: AUTO_DIAL_INTERVAL,
  autoDialPeerRetryThreshold: AUTO_DIAL_PEER_RETRY_THRESHOLD,
  autoDialDiscoveredPeersDebounce: AUTO_DIAL_DISCOVERED_PEERS_DEBOUNCE
};
var _log;
var AutoDial = class {
  /**
   * Proactively tries to connect to known peers stored in the PeerStore.
   * It will keep the number of connections below the upper limit and sort
   * the peers to connect based on whether we know their keys and protocols.
   */
  constructor(components, init) {
    __publicField(this, "connectionManager");
    __publicField(this, "peerStore");
    __publicField(this, "queue");
    __publicField(this, "minConnections");
    __publicField(this, "autoDialPriority");
    __publicField(this, "autoDialIntervalMs");
    __publicField(this, "autoDialMaxQueueLength");
    __publicField(this, "autoDialPeerRetryThresholdMs");
    __publicField(this, "autoDialDiscoveredPeersDebounce");
    __publicField(this, "autoDialInterval");
    __publicField(this, "started");
    __publicField(this, "running");
    __privateAdd(this, _log, void 0);
    this.connectionManager = components.connectionManager;
    this.peerStore = components.peerStore;
    this.minConnections = init.minConnections ?? defaultOptions4.minConnections;
    this.autoDialPriority = init.autoDialPriority ?? defaultOptions4.autoDialPriority;
    this.autoDialIntervalMs = init.autoDialInterval ?? defaultOptions4.autoDialInterval;
    this.autoDialMaxQueueLength = init.maxQueueLength ?? defaultOptions4.maxQueueLength;
    this.autoDialPeerRetryThresholdMs = init.autoDialPeerRetryThreshold ?? defaultOptions4.autoDialPeerRetryThreshold;
    this.autoDialDiscoveredPeersDebounce = init.autoDialDiscoveredPeersDebounce ?? defaultOptions4.autoDialDiscoveredPeersDebounce;
    __privateSet(this, _log, components.logger.forComponent("libp2p:connection-manager:auto-dial"));
    this.started = false;
    this.running = false;
    this.queue = new PeerJobQueue({
      concurrency: init.autoDialConcurrency ?? defaultOptions4.autoDialConcurrency
    });
    this.queue.addListener("error", (err) => {
      __privateGet(this, _log).error("error during auto-dial", err);
    });
    components.events.addEventListener("connection:close", () => {
      this.autoDial().catch((err) => {
        __privateGet(this, _log).error(err);
      });
    });
    let debounce2;
    components.events.addEventListener("peer:discovery", () => {
      clearTimeout(debounce2);
      debounce2 = setTimeout(() => {
        this.autoDial().catch((err) => {
          __privateGet(this, _log).error(err);
        });
      }, this.autoDialDiscoveredPeersDebounce);
    });
  }
  isStarted() {
    return this.started;
  }
  start() {
    this.autoDialInterval = setTimeout(() => {
      this.autoDial().catch((err) => {
        __privateGet(this, _log).error("error while autodialing", err);
      });
    }, this.autoDialIntervalMs);
    this.started = true;
  }
  afterStart() {
    this.autoDial().catch((err) => {
      __privateGet(this, _log).error("error while autodialing", err);
    });
  }
  stop() {
    this.queue.clear();
    clearTimeout(this.autoDialInterval);
    this.started = false;
    this.running = false;
  }
  async autoDial() {
    if (!this.started) {
      return;
    }
    const connections = this.connectionManager.getConnectionsMap();
    const numConnections = connections.size;
    if (numConnections >= this.minConnections) {
      if (this.minConnections > 0) {
        __privateGet(this, _log).trace("have enough connections %d/%d", numConnections, this.minConnections);
      }
      return;
    }
    if (this.queue.size > this.autoDialMaxQueueLength) {
      __privateGet(this, _log).call(this, "not enough connections %d/%d but auto dial queue is full", numConnections, this.minConnections);
      return;
    }
    if (this.running) {
      __privateGet(this, _log).call(this, "not enough connections %d/%d - but skipping autodial as it is already running", numConnections, this.minConnections);
      return;
    }
    this.running = true;
    __privateGet(this, _log).call(this, "not enough connections %d/%d - will dial peers to increase the number of connections", numConnections, this.minConnections);
    const dialQueue = new PeerSet(
      // @ts-expect-error boolean filter removes falsy peer IDs
      this.connectionManager.getDialQueue().map((queue) => queue.peerId).filter(Boolean)
    );
    const peers = await this.peerStore.all({
      filters: [
        // Remove some peers
        (peer) => {
          if (peer.addresses.length === 0) {
            __privateGet(this, _log).trace("not autodialing %p because they have no addresses", peer.id);
            return false;
          }
          if (connections.has(peer.id)) {
            __privateGet(this, _log).trace("not autodialing %p because they are already connected", peer.id);
            return false;
          }
          if (dialQueue.has(peer.id)) {
            __privateGet(this, _log).trace("not autodialing %p because they are already being dialed", peer.id);
            return false;
          }
          if (this.queue.hasJob(peer.id)) {
            __privateGet(this, _log).trace("not autodialing %p because they are already being autodialed", peer.id);
            return false;
          }
          return true;
        }
      ]
    });
    const shuffledPeers = peers.sort(() => Math.random() > 0.5 ? 1 : -1);
    const peerValues = new PeerMap();
    for (const peer of shuffledPeers) {
      if (peerValues.has(peer.id)) {
        continue;
      }
      peerValues.set(peer.id, [...peer.tags.values()].reduce((acc, curr) => {
        return acc + curr.value;
      }, 0));
    }
    const sortedPeers = shuffledPeers.sort((a, b) => {
      const peerAValue = peerValues.get(a.id) ?? 0;
      const peerBValue = peerValues.get(b.id) ?? 0;
      if (peerAValue > peerBValue) {
        return -1;
      }
      if (peerAValue < peerBValue) {
        return 1;
      }
      return 0;
    });
    const peersThatHaveNotFailed = sortedPeers.filter((peer) => {
      const lastDialFailure = peer.metadata.get(LAST_DIAL_FAILURE_KEY);
      if (lastDialFailure == null) {
        return true;
      }
      const lastDialFailureTimestamp = parseInt(toString(lastDialFailure));
      if (isNaN(lastDialFailureTimestamp)) {
        return true;
      }
      return Date.now() - lastDialFailureTimestamp > this.autoDialPeerRetryThresholdMs;
    });
    __privateGet(this, _log).call(this, "selected %d/%d peers to dial", peersThatHaveNotFailed.length, peers.length);
    for (const peer of peersThatHaveNotFailed) {
      this.queue.add(async () => {
        const numConnections2 = this.connectionManager.getConnectionsMap().size;
        if (numConnections2 >= this.minConnections) {
          __privateGet(this, _log).call(this, "got enough connections now %d/%d", numConnections2, this.minConnections);
          this.queue.clear();
          return;
        }
        __privateGet(this, _log).call(this, "connecting to a peerStore stored peer %p", peer.id);
        await this.connectionManager.openConnection(peer.id, {
          priority: this.autoDialPriority
        });
      }, {
        peerId: peer.id
      }).catch((err) => {
        __privateGet(this, _log).error("could not connect to peerStore stored peer", err);
      });
    }
    this.running = false;
    if (this.started) {
      this.autoDialInterval = setTimeout(() => {
        this.autoDial().catch((err) => {
          __privateGet(this, _log).error("error while autodialing", err);
        });
      }, this.autoDialIntervalMs);
    }
  }
};
_log = new WeakMap();

// node_modules/libp2p/dist/src/connection-manager/connection-pruner.js
var defaultOptions5 = {
  maxConnections: MAX_CONNECTIONS,
  allow: []
};
var _log2;
var ConnectionPruner = class {
  constructor(components, init = {}) {
    __publicField(this, "maxConnections");
    __publicField(this, "connectionManager");
    __publicField(this, "peerStore");
    __publicField(this, "allow");
    __publicField(this, "events");
    __privateAdd(this, _log2, void 0);
    this.maxConnections = init.maxConnections ?? defaultOptions5.maxConnections;
    this.allow = init.allow ?? defaultOptions5.allow;
    this.connectionManager = components.connectionManager;
    this.peerStore = components.peerStore;
    this.events = components.events;
    __privateSet(this, _log2, components.logger.forComponent("libp2p:connection-manager:connection-pruner"));
    components.events.addEventListener("connection:open", () => {
      this.maybePruneConnections().catch((err) => {
        __privateGet(this, _log2).error(err);
      });
    });
  }
  /**
   * If we have more connections than our maximum, select some excess connections
   * to prune based on peer value
   */
  async maybePruneConnections() {
    const connections = this.connectionManager.getConnections();
    const numConnections = connections.length;
    const toPrune = Math.max(numConnections - this.maxConnections, 0);
    __privateGet(this, _log2).call(this, "checking max connections limit %d/%d", numConnections, this.maxConnections);
    if (numConnections <= this.maxConnections) {
      return;
    }
    __privateGet(this, _log2).call(this, "max connections limit exceeded %d/%d, pruning %d connection(s)", numConnections, this.maxConnections, toPrune);
    const peerValues = new PeerMap();
    for (const connection of connections) {
      const remotePeer = connection.remotePeer;
      if (peerValues.has(remotePeer)) {
        continue;
      }
      peerValues.set(remotePeer, 0);
      try {
        const peer = await this.peerStore.get(remotePeer);
        peerValues.set(remotePeer, [...peer.tags.values()].reduce((acc, curr) => {
          return acc + curr.value;
        }, 0));
      } catch (err) {
        if (err.code !== "ERR_NOT_FOUND") {
          __privateGet(this, _log2).error("error loading peer tags", err);
        }
      }
    }
    const sortedConnections = connections.sort((a, b) => {
      const peerAValue = peerValues.get(a.remotePeer) ?? 0;
      const peerBValue = peerValues.get(b.remotePeer) ?? 0;
      if (peerAValue > peerBValue) {
        return 1;
      }
      if (peerAValue < peerBValue) {
        return -1;
      }
      const connectionALifespan = a.timeline.open;
      const connectionBLifespan = b.timeline.open;
      if (connectionALifespan < connectionBLifespan) {
        return 1;
      }
      if (connectionALifespan > connectionBLifespan) {
        return -1;
      }
      return 0;
    });
    const toClose = [];
    for (const connection of sortedConnections) {
      __privateGet(this, _log2).call(this, "too many connections open - closing a connection to %p", connection.remotePeer);
      const connectionInAllowList = this.allow.some((ma) => {
        return connection.remoteAddr.toString().startsWith(ma.toString());
      });
      if (!connectionInAllowList) {
        toClose.push(connection);
      }
      if (toClose.length === toPrune) {
        break;
      }
    }
    await Promise.all(toClose.map(async (connection) => {
      try {
        await connection.close();
      } catch (err) {
        __privateGet(this, _log2).error(err);
      }
    }));
    this.events.safeDispatchEvent("connection:prune", { detail: toClose });
  }
};
_log2 = new WeakMap();

// node_modules/any-signal/dist/src/index.js
function anySignal(signals) {
  const controller = new globalThis.AbortController();
  function onAbort() {
    controller.abort();
    for (const signal2 of signals) {
      if ((signal2 == null ? void 0 : signal2.removeEventListener) != null) {
        signal2.removeEventListener("abort", onAbort);
      }
    }
  }
  for (const signal2 of signals) {
    if ((signal2 == null ? void 0 : signal2.aborted) === true) {
      onAbort();
      break;
    }
    if ((signal2 == null ? void 0 : signal2.addEventListener) != null) {
      signal2.addEventListener("abort", onAbort);
    }
  }
  function clear() {
    for (const signal2 of signals) {
      if ((signal2 == null ? void 0 : signal2.removeEventListener) != null) {
        signal2.removeEventListener("abort", onAbort);
      }
    }
  }
  const signal = controller.signal;
  signal.clear = clear;
  return signal;
}

// node_modules/libp2p/dist/src/connection-manager/utils.js
async function resolveMultiaddrs(ma, options) {
  const resolvableProto = ma.protoNames().includes("dnsaddr");
  if (!resolvableProto) {
    return [ma];
  }
  const resolvedMultiaddrs = await resolveRecord(ma, options);
  const recursiveMultiaddrs = await Promise.all(resolvedMultiaddrs.map(async (nm) => {
    return resolveMultiaddrs(nm, options);
  }));
  const addrs = recursiveMultiaddrs.flat();
  const output2 = addrs.reduce((array, newM) => {
    if (array.find((m) => m.equals(newM)) == null) {
      array.push(newM);
    }
    return array;
  }, []);
  options.log("resolved %s to", ma, output2.map((ma2) => ma2.toString()));
  return output2;
}
async function resolveRecord(ma, options) {
  try {
    ma = multiaddr(ma.toString());
    const multiaddrs = await ma.resolve(options);
    return multiaddrs;
  } catch (err) {
    options.log.error(`multiaddr ${ma.toString()} could not be resolved`, err);
    return [];
  }
}
function combineSignals(...signals) {
  const sigs = [];
  for (const sig of signals) {
    if (sig != null) {
      setMaxListeners(Infinity, sig);
      sigs.push(sig);
    }
  }
  const signal = anySignal(sigs);
  setMaxListeners(Infinity, signal);
  return signal;
}

// node_modules/libp2p/dist/src/connection-manager/dial-queue.js
var defaultOptions6 = {
  addressSorter: defaultAddressSort,
  maxParallelDials: MAX_PARALLEL_DIALS,
  maxPeerAddrsToDial: MAX_PEER_ADDRS_TO_DIAL,
  maxParallelDialsPerPeer: MAX_PARALLEL_DIALS_PER_PEER,
  dialTimeout: DIAL_TIMEOUT,
  resolvers: {
    dnsaddr: dnsaddrResolver
  }
};
var _log3;
var DialQueue = class {
  constructor(components, init = {}) {
    __publicField(this, "pendingDials");
    __publicField(this, "queue");
    __publicField(this, "peerId");
    __publicField(this, "peerStore");
    __publicField(this, "connectionGater");
    __publicField(this, "transportManager");
    __publicField(this, "addressSorter");
    __publicField(this, "maxPeerAddrsToDial");
    __publicField(this, "maxParallelDialsPerPeer");
    __publicField(this, "dialTimeout");
    __publicField(this, "inProgressDialCount");
    __publicField(this, "pendingDialCount");
    __publicField(this, "shutDownController");
    __publicField(this, "connections");
    __privateAdd(this, _log3, void 0);
    var _a4, _b4;
    this.addressSorter = init.addressSorter ?? defaultOptions6.addressSorter;
    this.maxPeerAddrsToDial = init.maxPeerAddrsToDial ?? defaultOptions6.maxPeerAddrsToDial;
    this.maxParallelDialsPerPeer = init.maxParallelDialsPerPeer ?? defaultOptions6.maxParallelDialsPerPeer;
    this.dialTimeout = init.dialTimeout ?? defaultOptions6.dialTimeout;
    this.connections = init.connections ?? new PeerMap();
    __privateSet(this, _log3, components.logger.forComponent("libp2p:connection-manager:dial-queue"));
    this.peerId = components.peerId;
    this.peerStore = components.peerStore;
    this.connectionGater = components.connectionGater;
    this.transportManager = components.transportManager;
    this.shutDownController = new AbortController();
    setMaxListeners(Infinity, this.shutDownController.signal);
    this.pendingDialCount = (_a4 = components.metrics) == null ? void 0 : _a4.registerMetric("libp2p_dialler_pending_dials");
    this.inProgressDialCount = (_b4 = components.metrics) == null ? void 0 : _b4.registerMetric("libp2p_dialler_in_progress_dials");
    this.pendingDials = [];
    for (const [key, value] of Object.entries(init.resolvers ?? {})) {
      resolvers.set(key, value);
    }
    this.queue = new dist_default({
      concurrency: init.maxParallelDials ?? defaultOptions6.maxParallelDials
    });
    this.queue.on("add", () => {
      var _a5, _b5;
      (_a5 = this.pendingDialCount) == null ? void 0 : _a5.update(this.queue.size);
      (_b5 = this.inProgressDialCount) == null ? void 0 : _b5.update(this.queue.pending);
    });
    this.queue.on("active", () => {
      var _a5, _b5;
      (_a5 = this.pendingDialCount) == null ? void 0 : _a5.update(this.queue.size);
      (_b5 = this.inProgressDialCount) == null ? void 0 : _b5.update(this.queue.pending);
    });
    this.queue.on("completed", () => {
      var _a5, _b5;
      (_a5 = this.pendingDialCount) == null ? void 0 : _a5.update(this.queue.size);
      (_b5 = this.inProgressDialCount) == null ? void 0 : _b5.update(this.queue.pending);
    });
    this.queue.on("error", (err) => {
      var _a5, _b5;
      __privateGet(this, _log3).error("error in dial queue", err);
      (_a5 = this.pendingDialCount) == null ? void 0 : _a5.update(this.queue.size);
      (_b5 = this.inProgressDialCount) == null ? void 0 : _b5.update(this.queue.pending);
    });
    this.queue.on("empty", () => {
      var _a5, _b5;
      (_a5 = this.pendingDialCount) == null ? void 0 : _a5.update(this.queue.size);
      (_b5 = this.inProgressDialCount) == null ? void 0 : _b5.update(this.queue.pending);
    });
    this.queue.on("idle", () => {
      var _a5, _b5;
      (_a5 = this.pendingDialCount) == null ? void 0 : _a5.update(this.queue.size);
      (_b5 = this.inProgressDialCount) == null ? void 0 : _b5.update(this.queue.pending);
    });
  }
  /**
   * Clears any pending dials
   */
  stop() {
    this.shutDownController.abort();
  }
  /**
   * Connects to a given peer, multiaddr or list of multiaddrs.
   *
   * If a peer is passed, all known multiaddrs will be tried. If a multiaddr or
   * multiaddrs are passed only those will be dialled.
   *
   * Where a list of multiaddrs is passed, if any contain a peer id then all
   * multiaddrs in the list must contain the same peer id.
   *
   * The dial to the first address that is successfully able to upgrade a connection
   * will be used, all other dials will be aborted when that happens.
   */
  async dial(peerIdOrMultiaddr, options = {}) {
    const { peerId: peerId2, multiaddrs } = getPeerAddress(peerIdOrMultiaddr);
    const addrs = multiaddrs.map((multiaddr2) => ({
      multiaddr: multiaddr2,
      isCertified: false
    }));
    const signal = this.createDialAbortControllers(options.signal);
    let addrsToDial;
    try {
      addrsToDial = await this.calculateMultiaddrs(peerId2, addrs, {
        ...options,
        signal
      });
    } catch (err) {
      signal.clear();
      throw err;
    }
    let existingConnection = Array.from(this.connections.values()).flat().find((conn) => {
      if (options.force === true) {
        return false;
      }
      return addrsToDial.find((addr) => {
        return addr.multiaddr.equals(conn.remoteAddr);
      });
    });
    if (existingConnection != null) {
      __privateGet(this, _log3).call(this, "already connected to %a", existingConnection.remoteAddr);
      return existingConnection;
    }
    const existingDial = this.pendingDials.find((dial) => {
      if (dial.peerId != null && peerId2 != null && dial.peerId.equals(peerId2)) {
        return true;
      }
      if (addrsToDial.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()).join() === dial.multiaddrs.map((multiaddr2) => multiaddr2.toString()).join()) {
        return true;
      }
      return false;
    });
    if (existingDial != null) {
      __privateGet(this, _log3).call(this, "joining existing dial target for %p", peerId2);
      signal.clear();
      return existingDial.promise;
    }
    __privateGet(this, _log3).call(this, "creating dial target for", addrsToDial.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
    const pendingDial = {
      id: randomId(),
      status: "queued",
      peerId: peerId2,
      multiaddrs: addrsToDial.map(({ multiaddr: multiaddr2 }) => multiaddr2)
    };
    pendingDial.promise = this.performDial(pendingDial, {
      ...options,
      signal
    }).finally(() => {
      this.pendingDials = this.pendingDials.filter((p) => p.id !== pendingDial.id);
      signal.clear();
    }).catch(async (err) => {
      __privateGet(this, _log3).error("dial failed to %s", pendingDial.multiaddrs.map((ma) => ma.toString()).join(", "), err);
      if (peerId2 != null) {
        try {
          await this.peerStore.patch(peerId2, {
            metadata: {
              [LAST_DIAL_FAILURE_KEY]: fromString(Date.now().toString())
            }
          });
        } catch (err2) {
          __privateGet(this, _log3).error("could not update last dial failure key for %p", peerId2, err2);
        }
      }
      if (signal.aborted) {
        const error = new CodeError(err.message, codes5.ERR_TIMEOUT);
        throw error;
      }
      throw err;
    });
    this.pendingDials.push(pendingDial);
    const connection = await pendingDial.promise;
    existingConnection = Array.from(this.connections.values()).flat().find((conn) => {
      if (options.force === true) {
        return false;
      }
      return conn.id !== connection.id && conn.remoteAddr.equals(connection.remoteAddr);
    });
    if (existingConnection != null) {
      __privateGet(this, _log3).call(this, "already connected to %a", existingConnection.remoteAddr);
      await connection.close();
      return existingConnection;
    }
    __privateGet(this, _log3).call(this, "connection opened to %a", connection.remoteAddr);
    return connection;
  }
  createDialAbortControllers(userSignal) {
    var _a4;
    const signal = anySignal([
      AbortSignal.timeout(this.dialTimeout),
      this.shutDownController.signal,
      userSignal
    ]);
    try {
      (_a4 = setMaxListeners) == null ? void 0 : _a4(Infinity, signal);
    } catch {
    }
    return signal;
  }
  // eslint-disable-next-line complexity
  async calculateMultiaddrs(peerId2, addrs = [], options = {}) {
    var _a4, _b4;
    if (peerId2 != null) {
      if (this.peerId.equals(peerId2)) {
        throw new CodeError("Tried to dial self", codes5.ERR_DIALED_SELF);
      }
      if (await ((_b4 = (_a4 = this.connectionGater).denyDialPeer) == null ? void 0 : _b4.call(_a4, peerId2)) === true) {
        throw new CodeError("The dial request is blocked by gater.allowDialPeer", codes5.ERR_PEER_DIAL_INTERCEPTED);
      }
      if (addrs.length === 0) {
        __privateGet(this, _log3).call(this, "loading multiaddrs for %p", peerId2);
        try {
          const peer = await this.peerStore.get(peerId2);
          addrs.push(...peer.addresses);
          __privateGet(this, _log3).call(this, "loaded multiaddrs for %p", peerId2, addrs.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
        } catch (err) {
          if (err.code !== codes5.ERR_NOT_FOUND) {
            throw err;
          }
        }
      }
    }
    let resolvedAddresses = (await Promise.all(addrs.map(async (addr) => {
      const result = await resolveMultiaddrs(addr.multiaddr, {
        ...options,
        log: __privateGet(this, _log3)
      });
      if (result.length === 1 && result[0].equals(addr.multiaddr)) {
        return addr;
      }
      return result.map((multiaddr2) => ({
        multiaddr: multiaddr2,
        isCertified: false
      }));
    }))).flat();
    if (peerId2 != null) {
      const peerIdMultiaddr = `/p2p/${peerId2.toString()}`;
      resolvedAddresses = resolvedAddresses.map((addr) => {
        const lastProto = addr.multiaddr.protos().pop();
        if ((lastProto == null ? void 0 : lastProto.path) === true) {
          return addr;
        }
        if (addr.multiaddr.getPeerId() == null) {
          return {
            multiaddr: addr.multiaddr.encapsulate(peerIdMultiaddr),
            isCertified: addr.isCertified
          };
        }
        return addr;
      });
    }
    const filteredAddrs = resolvedAddresses.filter((addr) => {
      if (this.transportManager.transportForMultiaddr(addr.multiaddr) == null) {
        return false;
      }
      const addrPeerId = addr.multiaddr.getPeerId();
      if (peerId2 != null && addrPeerId != null) {
        return peerId2.equals(addrPeerId);
      }
      return true;
    });
    const dedupedAddrs = /* @__PURE__ */ new Map();
    for (const addr of filteredAddrs) {
      const maStr = addr.multiaddr.toString();
      const existing = dedupedAddrs.get(maStr);
      if (existing != null) {
        existing.isCertified = existing.isCertified || addr.isCertified || false;
        continue;
      }
      dedupedAddrs.set(maStr, addr);
    }
    const dedupedMultiaddrs = [...dedupedAddrs.values()];
    if (dedupedMultiaddrs.length === 0 || dedupedMultiaddrs.length > this.maxPeerAddrsToDial) {
      __privateGet(this, _log3).call(this, "addresses for %p before filtering", peerId2 ?? "unknown peer", resolvedAddresses.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
      __privateGet(this, _log3).call(this, "addresses for %p after filtering", peerId2 ?? "unknown peer", dedupedMultiaddrs.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
    }
    if (dedupedMultiaddrs.length === 0) {
      throw new CodeError("The dial request has no valid addresses", codes5.ERR_NO_VALID_ADDRESSES);
    }
    if (dedupedMultiaddrs.length > this.maxPeerAddrsToDial) {
      throw new CodeError("dial with more addresses than allowed", codes5.ERR_TOO_MANY_ADDRESSES);
    }
    const gatedAdrs = [];
    for (const addr of dedupedMultiaddrs) {
      if (this.connectionGater.denyDialMultiaddr != null && await this.connectionGater.denyDialMultiaddr(addr.multiaddr)) {
        continue;
      }
      gatedAdrs.push(addr);
    }
    const sortedGatedAddrs = gatedAdrs.sort(this.addressSorter);
    if (sortedGatedAddrs.length === 0) {
      throw new CodeError("The connection gater denied all addresses in the dial request", codes5.ERR_NO_VALID_ADDRESSES);
    }
    return sortedGatedAddrs;
  }
  async performDial(pendingDial, options = {}) {
    const dialAbortControllers = pendingDial.multiaddrs.map(() => new AbortController());
    try {
      const peerDialQueue = new dist_default({
        concurrency: this.maxParallelDialsPerPeer
      });
      peerDialQueue.on("error", (err) => {
        __privateGet(this, _log3).error("error dialling", err);
      });
      const conn = await Promise.any(pendingDial.multiaddrs.map(async (addr, i) => {
        const controller = dialAbortControllers[i];
        if (controller == null) {
          throw new CodeError("dialAction did not come with an AbortController", codes5.ERR_INVALID_PARAMETERS);
        }
        const signal = combineSignals(controller.signal, options.signal);
        signal.addEventListener("abort", () => {
          __privateGet(this, _log3).call(this, "dial to %a aborted", addr);
        });
        const deferred = pDefer();
        await peerDialQueue.add(async () => {
          if (signal.aborted) {
            __privateGet(this, _log3).call(this, "dial to %a was aborted before reaching the head of the peer dial queue", addr);
            deferred.reject(new AbortError());
            return;
          }
          await this.queue.add(async () => {
            try {
              if (signal.aborted) {
                __privateGet(this, _log3).call(this, "dial to %a was aborted before reaching the head of the dial queue", addr);
                deferred.reject(new AbortError());
                return;
              }
              pendingDial.status = "active";
              const conn2 = await this.transportManager.dial(addr, {
                ...options,
                signal
              });
              if (controller.signal.aborted) {
                __privateGet(this, _log3).call(this, "multiple dials succeeded, closing superfluous connection");
                conn2.close().catch((err) => {
                  __privateGet(this, _log3).error("error closing superfluous connection", err);
                });
                deferred.reject(new AbortError());
                return;
              }
              dialAbortControllers[i] = void 0;
              dialAbortControllers.forEach((c) => {
                if (c !== void 0) {
                  c.abort();
                }
              });
              __privateGet(this, _log3).call(this, "dial to %a succeeded", addr);
              deferred.resolve(conn2);
            } catch (err) {
              __privateGet(this, _log3).error("error during dial of %a", addr, err);
              deferred.reject(err);
            }
          }, {
            ...options,
            signal
          }).catch((err) => {
            deferred.reject(err);
          });
        }, {
          signal
        }).catch((err) => {
          deferred.reject(err);
        }).finally(() => {
          signal.clear();
        });
        return deferred.promise;
      }));
      if (conn == null) {
        throw new CodeError("successful dial led to empty object returned from peer dial queue", codes5.ERR_TRANSPORT_DIAL_FAILED);
      }
      pendingDial.status = "success";
      return conn;
    } catch (err) {
      pendingDial.status = "error";
      if (pendingDial.multiaddrs.length === 1 && err.name === "AggregateError") {
        throw err.errors[0];
      }
      throw err;
    }
  }
};
_log3 = new WeakMap();
function randomId() {
  return `${parseInt(String(Math.random() * 1e9), 10).toString()}${Date.now()}`;
}

// node_modules/libp2p/dist/src/connection-manager/index.js
var DEFAULT_DIAL_PRIORITY = 50;
var defaultOptions7 = {
  minConnections: MIN_CONNECTIONS,
  maxConnections: MAX_CONNECTIONS,
  inboundConnectionThreshold: INBOUND_CONNECTION_THRESHOLD,
  maxIncomingPendingConnections: MAX_INCOMING_PENDING_CONNECTIONS,
  autoDialConcurrency: AUTO_DIAL_CONCURRENCY,
  autoDialPriority: AUTO_DIAL_PRIORITY,
  autoDialMaxQueueLength: AUTO_DIAL_MAX_QUEUE_LENGTH
};
var _log4;
var DefaultConnectionManager = class {
  constructor(components, init = {}) {
    __publicField(this, "started");
    __publicField(this, "connections");
    __publicField(this, "allow");
    __publicField(this, "deny");
    __publicField(this, "maxIncomingPendingConnections");
    __publicField(this, "incomingPendingConnections");
    __publicField(this, "maxConnections");
    __publicField(this, "dialQueue");
    __publicField(this, "autoDial");
    __publicField(this, "connectionPruner");
    __publicField(this, "inboundConnectionRateLimiter");
    __publicField(this, "peerStore");
    __publicField(this, "metrics");
    __publicField(this, "events");
    __privateAdd(this, _log4, void 0);
    this.maxConnections = init.maxConnections ?? defaultOptions7.maxConnections;
    const minConnections = init.minConnections ?? defaultOptions7.minConnections;
    if (this.maxConnections < minConnections) {
      throw new CodeError("Connection Manager maxConnections must be greater than minConnections", codes5.ERR_INVALID_PARAMETERS);
    }
    this.connections = new PeerMap();
    this.started = false;
    this.peerStore = components.peerStore;
    this.metrics = components.metrics;
    this.events = components.events;
    __privateSet(this, _log4, components.logger.forComponent("libp2p:connection-manager"));
    this.onConnect = this.onConnect.bind(this);
    this.onDisconnect = this.onDisconnect.bind(this);
    this.events.addEventListener("connection:open", this.onConnect);
    this.events.addEventListener("connection:close", this.onDisconnect);
    this.allow = (init.allow ?? []).map((ma) => multiaddr(ma));
    this.deny = (init.deny ?? []).map((ma) => multiaddr(ma));
    this.incomingPendingConnections = 0;
    this.maxIncomingPendingConnections = init.maxIncomingPendingConnections ?? defaultOptions7.maxIncomingPendingConnections;
    this.inboundConnectionRateLimiter = new import_rate_limiter_flexible2.RateLimiterMemory({
      points: init.inboundConnectionThreshold ?? defaultOptions7.inboundConnectionThreshold,
      duration: 1
    });
    this.autoDial = new AutoDial({
      connectionManager: this,
      peerStore: components.peerStore,
      events: components.events,
      logger: components.logger
    }, {
      minConnections,
      autoDialConcurrency: init.autoDialConcurrency ?? defaultOptions7.autoDialConcurrency,
      autoDialPriority: init.autoDialPriority ?? defaultOptions7.autoDialPriority,
      maxQueueLength: init.autoDialMaxQueueLength ?? defaultOptions7.autoDialMaxQueueLength
    });
    this.connectionPruner = new ConnectionPruner({
      connectionManager: this,
      peerStore: components.peerStore,
      events: components.events,
      logger: components.logger
    }, {
      maxConnections: this.maxConnections,
      allow: this.allow
    });
    this.dialQueue = new DialQueue({
      peerId: components.peerId,
      metrics: components.metrics,
      peerStore: components.peerStore,
      transportManager: components.transportManager,
      connectionGater: components.connectionGater,
      logger: components.logger
    }, {
      addressSorter: init.addressSorter ?? defaultAddressSort,
      maxParallelDials: init.maxParallelDials ?? MAX_PARALLEL_DIALS,
      maxPeerAddrsToDial: init.maxPeerAddrsToDial ?? MAX_PEER_ADDRS_TO_DIAL,
      maxParallelDialsPerPeer: init.maxParallelDialsPerPeer ?? MAX_PARALLEL_DIALS_PER_PEER,
      dialTimeout: init.dialTimeout ?? DIAL_TIMEOUT,
      resolvers: init.resolvers ?? {
        dnsaddr: dnsaddrResolver
      },
      connections: this.connections
    });
  }
  isStarted() {
    return this.started;
  }
  /**
   * Starts the Connection Manager. If Metrics are not enabled on libp2p
   * only event loop and connection limits will be monitored.
   */
  async start() {
    var _a4, _b4, _c;
    (_a4 = this.metrics) == null ? void 0 : _a4.registerMetricGroup("libp2p_connection_manager_connections", {
      calculate: () => {
        const metric = {
          inbound: 0,
          outbound: 0
        };
        for (const conns of this.connections.values()) {
          for (const conn of conns) {
            if (conn.direction === "inbound") {
              metric.inbound++;
            } else {
              metric.outbound++;
            }
          }
        }
        return metric;
      }
    });
    (_b4 = this.metrics) == null ? void 0 : _b4.registerMetricGroup("libp2p_protocol_streams_total", {
      label: "protocol",
      calculate: () => {
        const metric = {};
        for (const conns of this.connections.values()) {
          for (const conn of conns) {
            for (const stream of conn.streams) {
              const key = `${stream.direction} ${stream.protocol ?? "unnegotiated"}`;
              metric[key] = (metric[key] ?? 0) + 1;
            }
          }
        }
        return metric;
      }
    });
    (_c = this.metrics) == null ? void 0 : _c.registerMetricGroup("libp2p_connection_manager_protocol_streams_per_connection_90th_percentile", {
      label: "protocol",
      calculate: () => {
        const allStreams = {};
        for (const conns of this.connections.values()) {
          for (const conn of conns) {
            const streams = {};
            for (const stream of conn.streams) {
              const key = `${stream.direction} ${stream.protocol ?? "unnegotiated"}`;
              streams[key] = (streams[key] ?? 0) + 1;
            }
            for (const [protocol, count] of Object.entries(streams)) {
              allStreams[protocol] = allStreams[protocol] ?? [];
              allStreams[protocol].push(count);
            }
          }
        }
        const metric = {};
        for (let [protocol, counts] of Object.entries(allStreams)) {
          counts = counts.sort((a, b) => a - b);
          const index = Math.floor(counts.length * 0.9);
          metric[protocol] = counts[index];
        }
        return metric;
      }
    });
    this.autoDial.start();
    this.started = true;
    __privateGet(this, _log4).call(this, "started");
  }
  async afterStart() {
    void Promise.resolve().then(async () => {
      const keepAlivePeers = await this.peerStore.all({
        filters: [(peer) => {
          return peer.tags.has(KEEP_ALIVE);
        }]
      });
      await Promise.all(keepAlivePeers.map(async (peer) => {
        await this.openConnection(peer.id).catch((err) => {
          __privateGet(this, _log4).error(err);
        });
      }));
    }).catch((err) => {
      __privateGet(this, _log4).error(err);
    });
    this.autoDial.afterStart();
  }
  /**
   * Stops the Connection Manager
   */
  async stop() {
    this.dialQueue.stop();
    this.autoDial.stop();
    const tasks = [];
    for (const connectionList of this.connections.values()) {
      for (const connection of connectionList) {
        tasks.push((async () => {
          try {
            await connection.close();
          } catch (err) {
            __privateGet(this, _log4).error(err);
          }
        })());
      }
    }
    __privateGet(this, _log4).call(this, "closing %d connections", tasks.length);
    await Promise.all(tasks);
    this.connections.clear();
    __privateGet(this, _log4).call(this, "stopped");
  }
  onConnect(evt) {
    void this._onConnect(evt).catch((err) => {
      __privateGet(this, _log4).error(err);
    });
  }
  /**
   * Tracks the incoming connection and check the connection limit
   */
  async _onConnect(evt) {
    const { detail: connection } = evt;
    if (!this.started) {
      await connection.close();
      return;
    }
    const peerId2 = connection.remotePeer;
    const storedConns = this.connections.get(peerId2);
    let isNewPeer = false;
    if (storedConns != null) {
      storedConns.push(connection);
    } else {
      isNewPeer = true;
      this.connections.set(peerId2, [connection]);
    }
    if (peerId2.publicKey != null && peerId2.type === "RSA") {
      await this.peerStore.patch(peerId2, {
        publicKey: peerId2.publicKey
      });
    }
    if (isNewPeer) {
      this.events.safeDispatchEvent("peer:connect", { detail: connection.remotePeer });
    }
  }
  /**
   * Removes the connection from tracking
   */
  onDisconnect(evt) {
    const { detail: connection } = evt;
    if (!this.started) {
      return;
    }
    const peerId2 = connection.remotePeer;
    let storedConn = this.connections.get(peerId2);
    if (storedConn != null && storedConn.length > 1) {
      storedConn = storedConn.filter((conn) => conn.id !== connection.id);
      this.connections.set(peerId2, storedConn);
    } else if (storedConn != null) {
      this.connections.delete(peerId2);
      this.events.safeDispatchEvent("peer:disconnect", { detail: connection.remotePeer });
    }
  }
  getConnections(peerId2) {
    if (peerId2 != null) {
      return this.connections.get(peerId2) ?? [];
    }
    let conns = [];
    for (const c of this.connections.values()) {
      conns = conns.concat(c);
    }
    return conns;
  }
  getConnectionsMap() {
    return this.connections;
  }
  async openConnection(peerIdOrMultiaddr, options = {}) {
    var _a4;
    if (!this.isStarted()) {
      throw new CodeError("Not started", codes5.ERR_NODE_NOT_STARTED);
    }
    (_a4 = options.signal) == null ? void 0 : _a4.throwIfAborted();
    const { peerId: peerId2 } = getPeerAddress(peerIdOrMultiaddr);
    if (peerId2 != null && options.force !== true) {
      __privateGet(this, _log4).call(this, "dial %p", peerId2);
      const existingConnection = this.getConnections(peerId2).find((conn) => !conn.transient);
      if (existingConnection != null) {
        __privateGet(this, _log4).call(this, "had an existing non-transient connection to %p", peerId2);
        return existingConnection;
      }
    }
    const connection = await this.dialQueue.dial(peerIdOrMultiaddr, {
      ...options,
      priority: options.priority ?? DEFAULT_DIAL_PRIORITY
    });
    let peerConnections = this.connections.get(connection.remotePeer);
    if (peerConnections == null) {
      peerConnections = [];
      this.connections.set(connection.remotePeer, peerConnections);
    }
    let trackedConnection = false;
    for (const conn of peerConnections) {
      if (conn.id === connection.id) {
        trackedConnection = true;
      }
    }
    if (!trackedConnection) {
      peerConnections.push(connection);
    }
    return connection;
  }
  async closeConnections(peerId2, options = {}) {
    const connections = this.connections.get(peerId2) ?? [];
    await Promise.all(connections.map(async (connection) => {
      try {
        await connection.close(options);
      } catch (err) {
        connection.abort(err);
      }
    }));
  }
  async acceptIncomingConnection(maConn) {
    const denyConnection = this.deny.some((ma) => {
      return maConn.remoteAddr.toString().startsWith(ma.toString());
    });
    if (denyConnection) {
      __privateGet(this, _log4).call(this, "connection from %a refused - connection remote address was in deny list", maConn.remoteAddr);
      return false;
    }
    const allowConnection = this.allow.some((ma) => {
      return maConn.remoteAddr.toString().startsWith(ma.toString());
    });
    if (allowConnection) {
      this.incomingPendingConnections++;
      return true;
    }
    if (this.incomingPendingConnections === this.maxIncomingPendingConnections) {
      __privateGet(this, _log4).call(this, "connection from %a refused - incomingPendingConnections exceeded by host", maConn.remoteAddr);
      return false;
    }
    if (maConn.remoteAddr.isThinWaistAddress()) {
      const host = maConn.remoteAddr.nodeAddress().address;
      try {
        await this.inboundConnectionRateLimiter.consume(host, 1);
      } catch {
        __privateGet(this, _log4).call(this, "connection from %a refused - inboundConnectionThreshold exceeded by host %s", maConn.remoteAddr, host);
        return false;
      }
    }
    if (this.getConnections().length < this.maxConnections) {
      this.incomingPendingConnections++;
      return true;
    }
    __privateGet(this, _log4).call(this, "connection from %a refused - maxConnections exceeded", maConn.remoteAddr);
    return false;
  }
  afterUpgradeInbound() {
    this.incomingPendingConnections--;
  }
  getDialQueue() {
    return this.dialQueue.pendingDials;
  }
};
_log4 = new WeakMap();

// node_modules/it-map/dist/src/index.js
function isAsyncIterable10(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function map2(source, func2) {
  if (isAsyncIterable10(source)) {
    return async function* () {
      for await (const val of source) {
        yield func2(val);
      }
    }();
  }
  const peekable2 = src_default6(source);
  const { value, done } = peekable2.next();
  if (done === true) {
    return /* @__PURE__ */ function* () {
    }();
  }
  const res = func2(value);
  if (typeof res.then === "function") {
    return async function* () {
      yield await res;
      for await (const val of peekable2) {
        yield func2(val);
      }
    }();
  }
  const fn = func2;
  return function* () {
    yield res;
    for (const val of peekable2) {
      yield fn(val);
    }
  }();
}
var src_default11 = map2;

// node_modules/libp2p/dist/src/content-routing/utils.js
async function* storeAddresses(source, peerStore) {
  yield* src_default11(source, async (peer) => {
    await peerStore.merge(peer.id, {
      multiaddrs: peer.multiaddrs
    });
    return peer;
  });
}
function uniquePeers(source) {
  const seen = /* @__PURE__ */ new Set();
  return src_default7(source, (peer) => {
    if (seen.has(peer.id.toString())) {
      return false;
    }
    seen.add(peer.id.toString());
    return true;
  });
}
async function* requirePeers(source, min = 1) {
  let seen = 0;
  for await (const peer of source) {
    seen++;
    yield peer;
  }
  if (seen < min) {
    throw new CodeError(`more peers required, seen: ${seen}  min: ${min}`, "NOT_FOUND");
  }
}

// node_modules/libp2p/dist/src/content-routing/index.js
var CompoundContentRouting = class {
  constructor(components, init) {
    __publicField(this, "routers");
    __publicField(this, "started");
    __publicField(this, "components");
    this.routers = init.routers ?? [];
    this.started = false;
    this.components = components;
  }
  isStarted() {
    return this.started;
  }
  async start() {
    this.started = true;
  }
  async stop() {
    this.started = false;
  }
  /**
   * Iterates over all content routers in parallel to find providers of the given key
   */
  async *findProviders(key, options = {}) {
    if (this.routers.length === 0) {
      throw new CodeError("No content routers available", codes5.ERR_NO_ROUTERS_AVAILABLE);
    }
    yield* pipe(src_default2(...this.routers.map((router) => router.findProviders(key, options))), (source) => storeAddresses(source, this.components.peerStore), (source) => uniquePeers(source), (source) => requirePeers(source));
  }
  /**
   * Iterates over all content routers in parallel to notify it is
   * a provider of the given key
   */
  async provide(key, options = {}) {
    if (this.routers.length === 0) {
      throw new CodeError("No content routers available", codes5.ERR_NO_ROUTERS_AVAILABLE);
    }
    await Promise.all(this.routers.map(async (router) => {
      await router.provide(key, options);
    }));
  }
  /**
   * Store the given key/value pair in the available content routings
   */
  async put(key, value, options) {
    if (!this.isStarted()) {
      throw new CodeError(messages.NOT_STARTED_YET, codes5.DHT_NOT_STARTED);
    }
    await Promise.all(this.routers.map(async (router) => {
      await router.put(key, value, options);
    }));
  }
  /**
   * Get the value to the given key.
   * Times out after 1 minute by default.
   */
  async get(key, options) {
    if (!this.isStarted()) {
      throw new CodeError(messages.NOT_STARTED_YET, codes5.DHT_NOT_STARTED);
    }
    return Promise.any(this.routers.map(async (router) => {
      return router.get(key, options);
    }));
  }
};

// node_modules/it-first/dist/src/index.js
function isAsyncIterable11(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function first(source) {
  if (isAsyncIterable11(source)) {
    return (async () => {
      for await (const entry of source) {
        return entry;
      }
      return void 0;
    })();
  }
  for (const entry of source) {
    return entry;
  }
  return void 0;
}
var src_default12 = first;

// node_modules/libp2p/dist/src/peer-routing.js
var log23 = logger("libp2p:peer-routing");
var DefaultPeerRouting = class {
  constructor(components, init) {
    __publicField(this, "components");
    __publicField(this, "routers");
    this.components = components;
    this.routers = init.routers ?? [];
  }
  /**
   * Iterates over all peer routers in parallel to find the given peer
   */
  async findPeer(id, options) {
    if (this.routers.length === 0) {
      throw new CodeError("No peer routers available", codes5.ERR_NO_ROUTERS_AVAILABLE);
    }
    if (id.toString() === this.components.peerId.toString()) {
      throw new CodeError("Should not try to find self", codes5.ERR_FIND_SELF);
    }
    const output2 = await pipe(src_default2(...this.routers.map((router) => async function* () {
      try {
        yield await router.findPeer(id, options);
      } catch (err) {
        log23.error(err);
      }
    }())), (source) => src_default7(source, Boolean), (source) => storeAddresses(source, this.components.peerStore), async (source) => src_default12(source));
    if (output2 != null) {
      return output2;
    }
    throw new CodeError(messages.NOT_FOUND, codes5.ERR_NOT_FOUND);
  }
  /**
   * Attempt to find the closest peers on the network to the given key
   */
  async *getClosestPeers(key, options) {
    if (this.routers.length === 0) {
      throw new CodeError("No peer routers available", codes5.ERR_NO_ROUTERS_AVAILABLE);
    }
    yield* pipe(src_default2(...this.routers.map((router) => router.getClosestPeers(key, options))), (source) => storeAddresses(source, this.components.peerStore), (source) => uniquePeers(source), (source) => requirePeers(source));
  }
};

// node_modules/libp2p/dist/src/registrar.js
var log24 = logger("libp2p:registrar");
var DEFAULT_MAX_INBOUND_STREAMS = 32;
var DEFAULT_MAX_OUTBOUND_STREAMS = 64;
var DefaultRegistrar = class {
  constructor(components) {
    __publicField(this, "topologies");
    __publicField(this, "handlers");
    __publicField(this, "components");
    this.topologies = /* @__PURE__ */ new Map();
    this.handlers = /* @__PURE__ */ new Map();
    this.components = components;
    this._onDisconnect = this._onDisconnect.bind(this);
    this._onPeerUpdate = this._onPeerUpdate.bind(this);
    this._onPeerIdentify = this._onPeerIdentify.bind(this);
    this.components.events.addEventListener("peer:disconnect", this._onDisconnect);
    this.components.events.addEventListener("peer:update", this._onPeerUpdate);
    this.components.events.addEventListener("peer:identify", this._onPeerIdentify);
  }
  getProtocols() {
    return Array.from(/* @__PURE__ */ new Set([
      ...this.handlers.keys()
    ])).sort();
  }
  getHandler(protocol) {
    const handler = this.handlers.get(protocol);
    if (handler == null) {
      throw new CodeError(`No handler registered for protocol ${protocol}`, codes5.ERR_NO_HANDLER_FOR_PROTOCOL);
    }
    return handler;
  }
  getTopologies(protocol) {
    const topologies = this.topologies.get(protocol);
    if (topologies == null) {
      return [];
    }
    return [
      ...topologies.values()
    ];
  }
  /**
   * Registers the `handler` for each protocol
   */
  async handle(protocol, handler, opts) {
    if (this.handlers.has(protocol)) {
      throw new CodeError(`Handler already registered for protocol ${protocol}`, codes5.ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED);
    }
    const options = merge_options_default.bind({ ignoreUndefined: true })({
      maxInboundStreams: DEFAULT_MAX_INBOUND_STREAMS,
      maxOutboundStreams: DEFAULT_MAX_OUTBOUND_STREAMS
    }, opts);
    this.handlers.set(protocol, {
      handler,
      options
    });
    await this.components.peerStore.merge(this.components.peerId, {
      protocols: [protocol]
    });
  }
  /**
   * Removes the handler for each protocol. The protocol
   * will no longer be supported on streams.
   */
  async unhandle(protocols) {
    const protocolList = Array.isArray(protocols) ? protocols : [protocols];
    protocolList.forEach((protocol) => {
      this.handlers.delete(protocol);
    });
    await this.components.peerStore.patch(this.components.peerId, {
      protocols: this.getProtocols()
    });
  }
  /**
   * Register handlers for a set of multicodecs given
   */
  async register(protocol, topology) {
    if (topology == null) {
      throw new CodeError("invalid topology", codes5.ERR_INVALID_PARAMETERS);
    }
    const id = `${(Math.random() * 1e9).toString(36)}${Date.now()}`;
    let topologies = this.topologies.get(protocol);
    if (topologies == null) {
      topologies = /* @__PURE__ */ new Map();
      this.topologies.set(protocol, topologies);
    }
    topologies.set(id, topology);
    return id;
  }
  /**
   * Unregister topology
   */
  unregister(id) {
    for (const [protocol, topologies] of this.topologies.entries()) {
      if (topologies.has(id)) {
        topologies.delete(id);
        if (topologies.size === 0) {
          this.topologies.delete(protocol);
        }
      }
    }
  }
  /**
   * Remove a disconnected peer from the record
   */
  _onDisconnect(evt) {
    const remotePeer = evt.detail;
    void this.components.peerStore.get(remotePeer).then((peer) => {
      var _a4;
      for (const protocol of peer.protocols) {
        const topologies = this.topologies.get(protocol);
        if (topologies == null) {
          continue;
        }
        for (const topology of topologies.values()) {
          (_a4 = topology.onDisconnect) == null ? void 0 : _a4.call(topology, remotePeer);
        }
      }
    }).catch((err) => {
      if (err.code === codes5.ERR_NOT_FOUND) {
        return;
      }
      log24.error("could not inform topologies of disconnecting peer %p", remotePeer, err);
    });
  }
  /**
   * When a peer is updated, if they have removed supported protocols notify any
   * topologies interested in the removed protocols.
   */
  _onPeerUpdate(evt) {
    var _a4;
    const { peer, previous } = evt.detail;
    const removed = ((previous == null ? void 0 : previous.protocols) ?? []).filter((protocol) => !peer.protocols.includes(protocol));
    for (const protocol of removed) {
      const topologies = this.topologies.get(protocol);
      if (topologies == null) {
        continue;
      }
      for (const topology of topologies.values()) {
        (_a4 = topology.onDisconnect) == null ? void 0 : _a4.call(topology, peer.id);
      }
    }
  }
  /**
   * After identify has completed and we have received the list of supported
   * protocols, notify any topologies interested in those protocols.
   */
  _onPeerIdentify(evt) {
    var _a4;
    const protocols = evt.detail.protocols;
    const connection = evt.detail.connection;
    const peerId2 = evt.detail.peerId;
    for (const protocol of protocols) {
      const topologies = this.topologies.get(protocol);
      if (topologies == null) {
        continue;
      }
      for (const topology of topologies.values()) {
        if (connection.transient && topology.notifyOnTransient !== true) {
          continue;
        }
        (_a4 = topology.onConnect) == null ? void 0 : _a4.call(topology, peerId2, connection);
      }
    }
  }
};

// node_modules/@libp2p/interface/dist/src/metrics/tracked-map.js
var TrackedMap = class extends Map {
  constructor(init) {
    super();
    __publicField(this, "metric");
    const { name: name2, metrics } = init;
    this.metric = metrics.registerMetric(name2);
    this.updateComponentMetric();
  }
  set(key, value) {
    super.set(key, value);
    this.updateComponentMetric();
    return this;
  }
  delete(key) {
    const deleted = super.delete(key);
    this.updateComponentMetric();
    return deleted;
  }
  clear() {
    super.clear();
    this.updateComponentMetric();
  }
  updateComponentMetric() {
    this.metric.update(this.size);
  }
};
function trackedMap(config) {
  const { name: name2, metrics } = config;
  let map3;
  if (metrics != null) {
    map3 = new TrackedMap({ name: name2, metrics });
  } else {
    map3 = /* @__PURE__ */ new Map();
  }
  return map3;
}

// node_modules/libp2p/dist/src/transport-manager.js
var log25 = logger("libp2p:transports");
var DefaultTransportManager = class {
  constructor(components, init = {}) {
    __publicField(this, "components");
    __publicField(this, "transports");
    __publicField(this, "listeners");
    __publicField(this, "faultTolerance");
    __publicField(this, "started");
    this.components = components;
    this.started = false;
    this.transports = /* @__PURE__ */ new Map();
    this.listeners = trackedMap({
      name: "libp2p_transport_manager_listeners",
      metrics: this.components.metrics
    });
    this.faultTolerance = init.faultTolerance ?? FaultTolerance.FATAL_ALL;
  }
  /**
   * Adds a `Transport` to the manager
   */
  add(transport) {
    const tag = transport[Symbol.toStringTag];
    if (tag == null) {
      throw new CodeError("Transport must have a valid tag", codes5.ERR_INVALID_KEY);
    }
    if (this.transports.has(tag)) {
      throw new CodeError(`There is already a transport with the tag ${tag}`, codes5.ERR_DUPLICATE_TRANSPORT);
    }
    log25("adding transport %s", tag);
    this.transports.set(tag, transport);
    if (!this.listeners.has(tag)) {
      this.listeners.set(tag, []);
    }
  }
  isStarted() {
    return this.started;
  }
  start() {
    this.started = true;
  }
  async afterStart() {
    const addrs = this.components.addressManager.getListenAddrs();
    await this.listen(addrs);
  }
  /**
   * Stops all listeners
   */
  async stop() {
    const tasks = [];
    for (const [key, listeners] of this.listeners) {
      log25("closing listeners for %s", key);
      while (listeners.length > 0) {
        const listener = listeners.pop();
        if (listener == null) {
          continue;
        }
        tasks.push(listener.close());
      }
    }
    await Promise.all(tasks);
    log25("all listeners closed");
    for (const key of this.listeners.keys()) {
      this.listeners.set(key, []);
    }
    this.started = false;
  }
  /**
   * Dials the given Multiaddr over it's supported transport
   */
  async dial(ma, options) {
    const transport = this.transportForMultiaddr(ma);
    if (transport == null) {
      throw new CodeError(`No transport available for address ${String(ma)}`, codes5.ERR_TRANSPORT_UNAVAILABLE);
    }
    try {
      return await transport.dial(ma, {
        ...options,
        upgrader: this.components.upgrader
      });
    } catch (err) {
      if (err.code == null) {
        err.code = codes5.ERR_TRANSPORT_DIAL_FAILED;
      }
      throw err;
    }
  }
  /**
   * Returns all Multiaddr's the listeners are using
   */
  getAddrs() {
    let addrs = [];
    for (const listeners of this.listeners.values()) {
      for (const listener of listeners) {
        addrs = [...addrs, ...listener.getAddrs()];
      }
    }
    return addrs;
  }
  /**
   * Returns all the transports instances
   */
  getTransports() {
    return Array.of(...this.transports.values());
  }
  /**
   * Returns all the listener instances
   */
  getListeners() {
    return Array.of(...this.listeners.values()).flat();
  }
  /**
   * Finds a transport that matches the given Multiaddr
   */
  transportForMultiaddr(ma) {
    for (const transport of this.transports.values()) {
      const addrs = transport.filter([ma]);
      if (addrs.length > 0) {
        return transport;
      }
    }
  }
  /**
   * Starts listeners for each listen Multiaddr
   */
  async listen(addrs) {
    if (!this.isStarted()) {
      throw new CodeError("Not started", codes5.ERR_NODE_NOT_STARTED);
    }
    if (addrs == null || addrs.length === 0) {
      log25("no addresses were provided for listening, this node is dial only");
      return;
    }
    const couldNotListen = [];
    for (const [key, transport] of this.transports.entries()) {
      const supportedAddrs = transport.filter(addrs);
      const tasks = [];
      for (const addr of supportedAddrs) {
        log25("creating listener for %s on %a", key, addr);
        const listener = transport.createListener({
          upgrader: this.components.upgrader
        });
        let listeners = this.listeners.get(key) ?? [];
        if (listeners == null) {
          listeners = [];
          this.listeners.set(key, listeners);
        }
        listeners.push(listener);
        listener.addEventListener("listening", () => {
          this.components.events.safeDispatchEvent("transport:listening", {
            detail: listener
          });
        });
        listener.addEventListener("close", () => {
          const index = listeners.findIndex((l) => l === listener);
          listeners.splice(index, 1);
          this.components.events.safeDispatchEvent("transport:close", {
            detail: listener
          });
        });
        tasks.push(listener.listen(addr));
      }
      if (tasks.length === 0) {
        couldNotListen.push(key);
        continue;
      }
      const results = await Promise.allSettled(tasks);
      const isListening = results.find((r) => r.status === "fulfilled");
      if (isListening == null && this.faultTolerance !== FaultTolerance.NO_FATAL) {
        throw new CodeError(`Transport (${key}) could not listen on any available address`, codes5.ERR_NO_VALID_ADDRESSES);
      }
    }
    if (couldNotListen.length === this.transports.size) {
      const message2 = `no valid addresses were provided for transports [${couldNotListen.join(", ")}]`;
      if (this.faultTolerance === FaultTolerance.FATAL_ALL) {
        throw new CodeError(message2, codes5.ERR_NO_VALID_ADDRESSES);
      }
      log25(`libp2p in dial mode only: ${message2}`);
    }
  }
  /**
   * Removes the given transport from the manager.
   * If a transport has any running listeners, they will be closed.
   */
  async remove(key) {
    const listeners = this.listeners.get(key) ?? [];
    log25.trace("removing transport %s", key);
    const tasks = [];
    log25.trace("closing listeners for %s", key);
    while (listeners.length > 0) {
      const listener = listeners.pop();
      if (listener == null) {
        continue;
      }
      tasks.push(listener.close());
    }
    await Promise.all(tasks);
    this.transports.delete(key);
    this.listeners.delete(key);
  }
  /**
   * Removes all transports from the manager.
   * If any listeners are running, they will be closed.
   *
   * @async
   */
  async removeAll() {
    const tasks = [];
    for (const key of this.transports.keys()) {
      tasks.push(this.remove(key));
    }
    await Promise.all(tasks);
  }
};

// node_modules/@libp2p/multistream-select/dist/src/constants.js
var PROTOCOL_ID = "/multistream/1.0.0";
var MAX_PROTOCOL_LENGTH = 1024;

// node_modules/it-reader/dist/src/index.js
function reader(source) {
  const reader2 = async function* () {
    let bytes2 = yield;
    let bl = new Uint8ArrayList();
    for await (const chunk of source) {
      if (bytes2 == null) {
        bl.append(chunk);
        bytes2 = yield bl;
        bl = new Uint8ArrayList();
        continue;
      }
      bl.append(chunk);
      while (bl.length >= bytes2) {
        const data = bl.sublist(0, bytes2);
        bl.consume(bytes2);
        bytes2 = yield data;
        if (bytes2 == null) {
          if (bl.length > 0) {
            bytes2 = yield bl;
            bl = new Uint8ArrayList();
          }
          break;
        }
      }
    }
    if (bytes2 != null) {
      throw Object.assign(new Error(`stream ended before ${bytes2} bytes became available`), { code: "ERR_UNDER_READ", buffer: bl });
    }
  }();
  void reader2.next();
  return reader2;
}

// node_modules/it-handshake/dist/src/index.js
function handshake(stream) {
  const writer = pushable();
  const source = reader(stream.source);
  const sourcePromise = pDefer();
  let sinkErr;
  const sinkPromise = stream.sink(async function* () {
    yield* writer;
    const source2 = await sourcePromise.promise;
    yield* source2;
  }());
  sinkPromise.catch((err) => {
    sinkErr = err;
  });
  const rest = {
    sink: async (source2) => {
      if (sinkErr != null) {
        await Promise.reject(sinkErr);
        return;
      }
      sourcePromise.resolve(source2);
      await sinkPromise;
    },
    source
  };
  return {
    reader: source,
    writer,
    stream: rest,
    rest: () => writer.end(),
    write: writer.push,
    read: async () => {
      const res = await source.next();
      if (res.value != null) {
        return res.value;
      }
    }
  };
}

// node_modules/@libp2p/multistream-select/dist/src/multistream.js
var log26 = logger("libp2p:mss");
var NewLine = fromString("\n");
function encode11(buffer) {
  const list = new Uint8ArrayList(buffer, NewLine);
  return encode2.single(list);
}
function write(writer, buffer, options = {}) {
  const encoded = encode11(buffer);
  if (options.writeBytes === true) {
    writer.push(encoded.subarray());
  } else {
    writer.push(encoded);
  }
}
function writeAll(writer, buffers, options = {}) {
  const list = new Uint8ArrayList();
  for (const buf of buffers) {
    list.append(encode11(buf));
  }
  if (options.writeBytes === true) {
    writer.push(list.subarray());
  } else {
    writer.push(list);
  }
}
async function read4(reader2, options) {
  let byteLength = 1;
  const varByteSource = {
    [Symbol.asyncIterator]: () => varByteSource,
    next: async () => reader2.next(byteLength)
  };
  let input = varByteSource;
  if ((options == null ? void 0 : options.signal) != null) {
    input = abortableSource(varByteSource, options.signal);
  }
  const onLength = (l) => {
    byteLength = l;
  };
  const buf = await pipe(input, (source) => decode2(source, { onLength, maxDataLength: MAX_PROTOCOL_LENGTH }), async (source) => src_default12(source));
  if (buf == null || buf.length === 0) {
    throw new CodeError("no buffer returned", "ERR_INVALID_MULTISTREAM_SELECT_MESSAGE");
  }
  if (buf.get(buf.byteLength - 1) !== NewLine[0]) {
    log26.error("Invalid mss message - missing newline - %s", buf.subarray());
    throw new CodeError("missing newline", "ERR_INVALID_MULTISTREAM_SELECT_MESSAGE");
  }
  return buf.sublist(0, -1);
}
async function readString(reader2, options) {
  const buf = await read4(reader2, options);
  return toString(buf.subarray());
}

// node_modules/@libp2p/multistream-select/dist/src/select.js
var log27 = logger("libp2p:mss:select");
async function select(stream, protocols, options = {}) {
  protocols = Array.isArray(protocols) ? [...protocols] : [protocols];
  const { reader: reader2, writer, rest, stream: shakeStream } = handshake(stream);
  const protocol = protocols.shift();
  if (protocol == null) {
    throw new Error("At least one protocol must be specified");
  }
  log27.trace('select: write ["%s", "%s"]', PROTOCOL_ID, protocol);
  const p1 = fromString(PROTOCOL_ID);
  const p2 = fromString(protocol);
  writeAll(writer, [p1, p2], options);
  let response = await readString(reader2, options);
  log27.trace('select: read "%s"', response);
  if (response === PROTOCOL_ID) {
    response = await readString(reader2, options);
    log27.trace('select: read "%s"', response);
  }
  if (response === protocol) {
    rest();
    return { stream: shakeStream, protocol };
  }
  for (const protocol2 of protocols) {
    log27.trace('select: write "%s"', protocol2);
    write(writer, fromString(protocol2), options);
    const response2 = await readString(reader2, options);
    log27.trace('select: read "%s" for "%s"', response2, protocol2);
    if (response2 === protocol2) {
      rest();
      return { stream: shakeStream, protocol: protocol2 };
    }
  }
  rest();
  throw new CodeError("protocol selection failed", "ERR_UNSUPPORTED_PROTOCOL");
}

// node_modules/@libp2p/multistream-select/dist/src/handle.js
var log28 = logger("libp2p:mss:handle");
async function handle(stream, protocols, options) {
  protocols = Array.isArray(protocols) ? protocols : [protocols];
  const { writer, reader: reader2, rest, stream: shakeStream } = handshake(stream);
  while (true) {
    const protocol = await readString(reader2, options);
    log28.trace('read "%s"', protocol);
    if (protocol === PROTOCOL_ID) {
      log28.trace('respond with "%s" for "%s"', PROTOCOL_ID, protocol);
      write(writer, fromString(PROTOCOL_ID), options);
      continue;
    }
    if (protocols.includes(protocol)) {
      write(writer, fromString(protocol), options);
      log28.trace('respond with "%s" for "%s"', protocol, protocol);
      rest();
      return { stream: shakeStream, protocol };
    }
    if (protocol === "ls") {
      write(writer, new Uint8ArrayList(...protocols.map((p) => encode11(fromString(p)))), options);
      log28.trace('respond with "%s" for %s', protocols, protocol);
      continue;
    }
    write(writer, fromString("na"), options);
    log28('respond with "na" for "%s"', protocol);
  }
}

// node_modules/@libp2p/interface/dist/src/connection/index.js
var symbol3 = Symbol.for("@libp2p/connection");

// node_modules/libp2p/dist/src/connection/index.js
var CLOSE_TIMEOUT3 = 500;
var _log5, _a3, _b3;
var ConnectionImpl = class {
  /**
   * An implementation of the js-libp2p connection.
   * Any libp2p transport should use an upgrader to return this connection.
   */
  constructor(init) {
    /**
     * Connection identifier.
     */
    __publicField(this, "id");
    /**
     * Observed multiaddr of the remote peer
     */
    __publicField(this, "remoteAddr");
    /**
     * Remote peer id
     */
    __publicField(this, "remotePeer");
    __publicField(this, "direction");
    __publicField(this, "timeline");
    __publicField(this, "multiplexer");
    __publicField(this, "encryption");
    __publicField(this, "status");
    __publicField(this, "transient");
    /**
     * User provided tags
     *
     */
    __publicField(this, "tags");
    /**
     * Reference to the new stream function of the multiplexer
     */
    __publicField(this, "_newStream");
    /**
     * Reference to the close function of the raw connection
     */
    __publicField(this, "_close");
    __publicField(this, "_abort");
    /**
     * Reference to the getStreams function of the muxer
     */
    __publicField(this, "_getStreams");
    __privateAdd(this, _log5, void 0);
    __publicField(this, _a3, "Connection");
    __publicField(this, _b3, true);
    const { remoteAddr, remotePeer, newStream, close, abort, getStreams } = init;
    this.id = `${parseInt(String(Math.random() * 1e9)).toString(36)}${Date.now()}`;
    this.remoteAddr = remoteAddr;
    this.remotePeer = remotePeer;
    this.direction = init.direction;
    this.status = "open";
    this.timeline = init.timeline;
    this.multiplexer = init.multiplexer;
    this.encryption = init.encryption;
    this.transient = init.transient ?? false;
    __privateSet(this, _log5, init.logger.forComponent("libp2p:connection"));
    if (this.remoteAddr.getPeerId() == null) {
      this.remoteAddr = this.remoteAddr.encapsulate(`/p2p/${this.remotePeer}`);
    }
    this._newStream = newStream;
    this._close = close;
    this._abort = abort;
    this._getStreams = getStreams;
    this.tags = [];
  }
  /**
   * Get all the streams of the muxer
   */
  get streams() {
    return this._getStreams();
  }
  /**
   * Create a new stream from this connection
   */
  async newStream(protocols, options) {
    if (this.status === "closing") {
      throw new CodeError("the connection is being closed", "ERR_CONNECTION_BEING_CLOSED");
    }
    if (this.status === "closed") {
      throw new CodeError("the connection is closed", "ERR_CONNECTION_CLOSED");
    }
    if (!Array.isArray(protocols)) {
      protocols = [protocols];
    }
    if (this.transient && (options == null ? void 0 : options.runOnTransientConnection) !== true) {
      throw new CodeError("Cannot open protocol stream on transient connection", "ERR_TRANSIENT_CONNECTION");
    }
    const stream = await this._newStream(protocols, options);
    stream.direction = "outbound";
    return stream;
  }
  /**
   * Close the connection
   */
  async close(options = {}) {
    if (this.status === "closed" || this.status === "closing") {
      return;
    }
    __privateGet(this, _log5).call(this, "closing connection to %a", this.remoteAddr);
    this.status = "closing";
    if (options.signal == null) {
      const signal = AbortSignal.timeout(CLOSE_TIMEOUT3);
      setMaxListeners(Infinity, signal);
      options = {
        ...options,
        signal
      };
    }
    try {
      __privateGet(this, _log5).trace("closing all streams");
      await Promise.all(this.streams.map(async (s) => s.close(options)));
      __privateGet(this, _log5).trace("closing underlying transport");
      await this._close(options);
      __privateGet(this, _log5).trace("updating timeline with close time");
      this.status = "closed";
      this.timeline.close = Date.now();
    } catch (err) {
      __privateGet(this, _log5).error("error encountered during graceful close of connection to %a", this.remoteAddr, err);
      this.abort(err);
    }
  }
  abort(err) {
    __privateGet(this, _log5).error("aborting connection to %a due to error", this.remoteAddr, err);
    this.status = "closing";
    this.streams.forEach((s) => {
      s.abort(err);
    });
    __privateGet(this, _log5).error("all streams aborted", this.streams.length);
    this._abort(err);
    this.timeline.close = Date.now();
    this.status = "closed";
  }
};
_a3 = Symbol.toStringTag, _b3 = symbol3;
_log5 = new WeakMap();
function createConnection(init) {
  return new ConnectionImpl(init);
}

// node_modules/libp2p/dist/src/upgrader.js
var DEFAULT_PROTOCOL_SELECT_TIMEOUT = 3e4;
function findIncomingStreamLimit(protocol, registrar) {
  try {
    const { options } = registrar.getHandler(protocol);
    return options.maxInboundStreams;
  } catch (err) {
    if (err.code !== codes5.ERR_NO_HANDLER_FOR_PROTOCOL) {
      throw err;
    }
  }
  return DEFAULT_MAX_INBOUND_STREAMS;
}
function findOutgoingStreamLimit(protocol, registrar, options = {}) {
  try {
    const { options: options2 } = registrar.getHandler(protocol);
    if (options2.maxOutboundStreams != null) {
      return options2.maxOutboundStreams;
    }
  } catch (err) {
    if (err.code !== codes5.ERR_NO_HANDLER_FOR_PROTOCOL) {
      throw err;
    }
  }
  return options.maxOutboundStreams ?? DEFAULT_MAX_OUTBOUND_STREAMS;
}
function countStreams(protocol, direction, connection) {
  let streamCount = 0;
  connection.streams.forEach((stream) => {
    if (stream.direction === direction && stream.protocol === protocol) {
      streamCount++;
    }
  });
  return streamCount;
}
var _log6;
var DefaultUpgrader = class {
  constructor(components, init) {
    __publicField(this, "components");
    __publicField(this, "connectionEncryption");
    __publicField(this, "muxers");
    __publicField(this, "inboundUpgradeTimeout");
    __publicField(this, "events");
    __privateAdd(this, _log6, void 0);
    this.components = components;
    this.connectionEncryption = /* @__PURE__ */ new Map();
    __privateSet(this, _log6, components.logger.forComponent("libp2p:upgrader"));
    init.connectionEncryption.forEach((encrypter) => {
      this.connectionEncryption.set(encrypter.protocol, encrypter);
    });
    this.muxers = /* @__PURE__ */ new Map();
    init.muxers.forEach((muxer) => {
      this.muxers.set(muxer.protocol, muxer);
    });
    this.inboundUpgradeTimeout = init.inboundUpgradeTimeout ?? INBOUND_UPGRADE_TIMEOUT;
    this.events = components.events;
  }
  async shouldBlockConnection(remotePeer, maConn, connectionType) {
    const connectionGater2 = this.components.connectionGater[connectionType];
    if (connectionGater2 !== void 0) {
      if (await connectionGater2(remotePeer, maConn)) {
        throw new CodeError(`The multiaddr connection is blocked by gater.${connectionType}`, codes5.ERR_CONNECTION_INTERCEPTED);
      }
    }
  }
  /**
   * Upgrades an inbound connection
   */
  async upgradeInbound(maConn, opts) {
    var _a4, _b4, _c;
    const accept = await this.components.connectionManager.acceptIncomingConnection(maConn);
    if (!accept) {
      throw new CodeError("connection denied", codes5.ERR_CONNECTION_DENIED);
    }
    let encryptedConn;
    let remotePeer;
    let upgradedConn;
    let muxerFactory;
    let cryptoProtocol;
    const signal = AbortSignal.timeout(this.inboundUpgradeTimeout);
    const onAbort = () => {
      maConn.abort(new CodeError("inbound upgrade timeout", codes5.ERR_TIMEOUT));
    };
    signal.addEventListener("abort", onAbort, { once: true });
    setMaxListeners(Infinity, signal);
    try {
      if (await ((_b4 = (_a4 = this.components.connectionGater).denyInboundConnection) == null ? void 0 : _b4.call(_a4, maConn)) === true) {
        throw new CodeError("The multiaddr connection is blocked by gater.acceptConnection", codes5.ERR_CONNECTION_INTERCEPTED);
      }
      (_c = this.components.metrics) == null ? void 0 : _c.trackMultiaddrConnection(maConn);
      __privateGet(this, _log6).call(this, "starting the inbound connection upgrade");
      let protectedConn = maConn;
      if ((opts == null ? void 0 : opts.skipProtection) !== true) {
        const protector = this.components.connectionProtector;
        if (protector != null) {
          __privateGet(this, _log6).call(this, "protecting the inbound connection");
          protectedConn = await protector.protect(maConn);
        }
      }
      try {
        encryptedConn = protectedConn;
        if ((opts == null ? void 0 : opts.skipEncryption) !== true) {
          ({
            conn: encryptedConn,
            remotePeer,
            protocol: cryptoProtocol
          } = await this._encryptInbound(protectedConn));
          const maConn2 = {
            ...protectedConn,
            ...encryptedConn
          };
          await this.shouldBlockConnection(remotePeer, maConn2, "denyInboundEncryptedConnection");
        } else {
          const idStr = maConn.remoteAddr.getPeerId();
          if (idStr == null) {
            throw new CodeError("inbound connection that skipped encryption must have a peer id", codes5.ERR_INVALID_MULTIADDR);
          }
          const remotePeerId = peerIdFromString(idStr);
          cryptoProtocol = "native";
          remotePeer = remotePeerId;
        }
        upgradedConn = encryptedConn;
        if ((opts == null ? void 0 : opts.muxerFactory) != null) {
          muxerFactory = opts.muxerFactory;
        } else if (this.muxers.size > 0) {
          const multiplexed = await this._multiplexInbound({
            ...protectedConn,
            ...encryptedConn
          }, this.muxers);
          muxerFactory = multiplexed.muxerFactory;
          upgradedConn = multiplexed.stream;
        }
      } catch (err) {
        __privateGet(this, _log6).error("Failed to upgrade inbound connection", err);
        throw err;
      }
      await this.shouldBlockConnection(remotePeer, maConn, "denyInboundUpgradedConnection");
      __privateGet(this, _log6).call(this, "Successfully upgraded inbound connection");
      return this._createConnection({
        cryptoProtocol,
        direction: "inbound",
        maConn,
        upgradedConn,
        muxerFactory,
        remotePeer,
        transient: opts == null ? void 0 : opts.transient
      });
    } finally {
      signal.removeEventListener("abort", onAbort);
      this.components.connectionManager.afterUpgradeInbound();
    }
  }
  /**
   * Upgrades an outbound connection
   */
  async upgradeOutbound(maConn, opts) {
    var _a4;
    const idStr = maConn.remoteAddr.getPeerId();
    let remotePeerId;
    if (idStr != null) {
      remotePeerId = peerIdFromString(idStr);
      await this.shouldBlockConnection(remotePeerId, maConn, "denyOutboundConnection");
    }
    let encryptedConn;
    let remotePeer;
    let upgradedConn;
    let cryptoProtocol;
    let muxerFactory;
    (_a4 = this.components.metrics) == null ? void 0 : _a4.trackMultiaddrConnection(maConn);
    __privateGet(this, _log6).call(this, "Starting the outbound connection upgrade");
    let protectedConn = maConn;
    if ((opts == null ? void 0 : opts.skipProtection) !== true) {
      const protector = this.components.connectionProtector;
      if (protector != null) {
        protectedConn = await protector.protect(maConn);
      }
    }
    try {
      encryptedConn = protectedConn;
      if ((opts == null ? void 0 : opts.skipEncryption) !== true) {
        ({
          conn: encryptedConn,
          remotePeer,
          protocol: cryptoProtocol
        } = await this._encryptOutbound(protectedConn, remotePeerId));
        const maConn2 = {
          ...protectedConn,
          ...encryptedConn
        };
        await this.shouldBlockConnection(remotePeer, maConn2, "denyOutboundEncryptedConnection");
      } else {
        if (remotePeerId == null) {
          throw new CodeError("Encryption was skipped but no peer id was passed", codes5.ERR_INVALID_PEER);
        }
        cryptoProtocol = "native";
        remotePeer = remotePeerId;
      }
      upgradedConn = encryptedConn;
      if ((opts == null ? void 0 : opts.muxerFactory) != null) {
        muxerFactory = opts.muxerFactory;
      } else if (this.muxers.size > 0) {
        const multiplexed = await this._multiplexOutbound({
          ...protectedConn,
          ...encryptedConn
        }, this.muxers);
        muxerFactory = multiplexed.muxerFactory;
        upgradedConn = multiplexed.stream;
      }
    } catch (err) {
      __privateGet(this, _log6).error("Failed to upgrade outbound connection", err);
      await maConn.close(err);
      throw err;
    }
    await this.shouldBlockConnection(remotePeer, maConn, "denyOutboundUpgradedConnection");
    __privateGet(this, _log6).call(this, "Successfully upgraded outbound connection");
    return this._createConnection({
      cryptoProtocol,
      direction: "outbound",
      maConn,
      upgradedConn,
      muxerFactory,
      remotePeer,
      transient: opts == null ? void 0 : opts.transient
    });
  }
  /**
   * A convenience method for generating a new `Connection`
   */
  _createConnection(opts) {
    const { cryptoProtocol, direction, maConn, upgradedConn, remotePeer, muxerFactory, transient } = opts;
    let muxer;
    let newStream;
    let connection;
    if (muxerFactory != null) {
      muxer = muxerFactory.createStreamMuxer({
        direction,
        // Run anytime a remote stream is created
        onIncomingStream: (muxedStream) => {
          if (connection == null) {
            return;
          }
          void Promise.resolve().then(async () => {
            var _a4;
            const protocols = this.components.registrar.getProtocols();
            const { stream, protocol } = await handle(muxedStream, protocols);
            __privateGet(this, _log6).call(this, "%s: incoming stream opened on %s", direction, protocol);
            if (connection == null) {
              return;
            }
            const incomingLimit = findIncomingStreamLimit(protocol, this.components.registrar);
            const streamCount = countStreams(protocol, "inbound", connection);
            if (streamCount === incomingLimit) {
              const err = new CodeError(`Too many inbound protocol streams for protocol "${protocol}" - limit ${incomingLimit}`, codes5.ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS);
              muxedStream.abort(err);
              throw err;
            }
            muxedStream.source = stream.source;
            muxedStream.sink = stream.sink;
            muxedStream.protocol = protocol;
            await this.components.peerStore.merge(remotePeer, {
              protocols: [protocol]
            });
            (_a4 = this.components.metrics) == null ? void 0 : _a4.trackProtocolStream(muxedStream, connection);
            this._onStream({ connection, stream: muxedStream, protocol });
          }).catch(async (err) => {
            __privateGet(this, _log6).error(err);
            if (muxedStream.timeline.close == null) {
              await muxedStream.close();
            }
          });
        }
      });
      newStream = async (protocols, options = {}) => {
        var _a4;
        if (muxer == null) {
          throw new CodeError("Stream is not multiplexed", codes5.ERR_MUXER_UNAVAILABLE);
        }
        __privateGet(this, _log6).call(this, "%s-%s: starting new stream on %s", connection.id, direction, protocols);
        const muxedStream = await muxer.newStream();
        try {
          if (options.signal == null) {
            __privateGet(this, _log6).call(this, "No abort signal was passed while trying to negotiate protocols %s falling back to default timeout", protocols);
            const signal = AbortSignal.timeout(DEFAULT_PROTOCOL_SELECT_TIMEOUT);
            setMaxListeners(Infinity, signal);
            options = {
              ...options,
              signal
            };
          }
          const { stream, protocol } = await select(muxedStream, protocols, options);
          const outgoingLimit = findOutgoingStreamLimit(protocol, this.components.registrar, options);
          const streamCount = countStreams(protocol, "outbound", connection);
          if (streamCount >= outgoingLimit) {
            const err = new CodeError(`Too many outbound protocol streams for protocol "${protocol}" - limit ${outgoingLimit}`, codes5.ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS);
            muxedStream.abort(err);
            throw err;
          }
          await this.components.peerStore.merge(remotePeer, {
            protocols: [protocol]
          });
          muxedStream.source = stream.source;
          muxedStream.sink = stream.sink;
          muxedStream.protocol = protocol;
          (_a4 = this.components.metrics) == null ? void 0 : _a4.trackProtocolStream(muxedStream, connection);
          return muxedStream;
        } catch (err) {
          __privateGet(this, _log6).error("could not create new stream for protocols %s on connection with address %a", protocols, connection.remoteAddr, err);
          if (muxedStream.timeline.close == null) {
            muxedStream.abort(err);
          }
          if (err.code != null) {
            throw err;
          }
          throw new CodeError(String(err), codes5.ERR_UNSUPPORTED_PROTOCOL);
        }
      };
      void Promise.all([
        muxer.sink(upgradedConn.source),
        upgradedConn.sink(muxer.source)
      ]).catch((err) => {
        __privateGet(this, _log6).error(err);
      });
    }
    const _timeline = maConn.timeline;
    maConn.timeline = new Proxy(_timeline, {
      set: (...args) => {
        if (connection != null && args[1] === "close" && args[2] != null && _timeline.close == null) {
          (async () => {
            try {
              if (connection.status === "open") {
                await connection.close();
              }
            } catch (err) {
              __privateGet(this, _log6).error(err);
            } finally {
              this.events.safeDispatchEvent("connection:close", {
                detail: connection
              });
            }
          })().catch((err) => {
            __privateGet(this, _log6).error(err);
          });
        }
        return Reflect.set(...args);
      }
    });
    maConn.timeline.upgraded = Date.now();
    const errConnectionNotMultiplexed = () => {
      throw new CodeError("connection is not multiplexed", codes5.ERR_CONNECTION_NOT_MULTIPLEXED);
    };
    connection = createConnection({
      remoteAddr: maConn.remoteAddr,
      remotePeer,
      status: "open",
      direction,
      timeline: maConn.timeline,
      multiplexer: muxer == null ? void 0 : muxer.protocol,
      encryption: cryptoProtocol,
      transient,
      logger: this.components.logger,
      newStream: newStream ?? errConnectionNotMultiplexed,
      getStreams: () => {
        if (muxer != null) {
          return muxer.streams;
        } else {
          return [];
        }
      },
      close: async (options) => {
        if (muxer != null) {
          __privateGet(this, _log6).trace("close muxer");
          await muxer.close(options);
        }
        __privateGet(this, _log6).trace("close maconn");
        await maConn.close(options);
        __privateGet(this, _log6).trace("closed maconn");
      },
      abort: (err) => {
        maConn.abort(err);
        if (muxer != null) {
          muxer.abort(err);
        }
      }
    });
    this.events.safeDispatchEvent("connection:open", {
      detail: connection
    });
    return connection;
  }
  /**
   * Routes incoming streams to the correct handler
   */
  _onStream(opts) {
    const { connection, stream, protocol } = opts;
    const { handler, options } = this.components.registrar.getHandler(protocol);
    if (connection.transient && options.runOnTransientConnection !== true) {
      throw new CodeError("Cannot open protocol stream on transient connection", "ERR_TRANSIENT_CONNECTION");
    }
    handler({ connection, stream });
  }
  /**
   * Attempts to encrypt the incoming `connection` with the provided `cryptos`
   */
  async _encryptInbound(connection) {
    const protocols = Array.from(this.connectionEncryption.keys());
    __privateGet(this, _log6).call(this, "handling inbound crypto protocol selection", protocols);
    try {
      const { stream, protocol } = await handle(connection, protocols, {
        writeBytes: true
      });
      const encrypter = this.connectionEncryption.get(protocol);
      if (encrypter == null) {
        throw new Error(`no crypto module found for ${protocol}`);
      }
      __privateGet(this, _log6).call(this, "encrypting inbound connection...");
      return {
        ...await encrypter.secureInbound(this.components.peerId, stream),
        protocol
      };
    } catch (err) {
      throw new CodeError(String(err), codes5.ERR_ENCRYPTION_FAILED);
    }
  }
  /**
   * Attempts to encrypt the given `connection` with the provided connection encrypters.
   * The first `ConnectionEncrypter` module to succeed will be used
   */
  async _encryptOutbound(connection, remotePeerId) {
    const protocols = Array.from(this.connectionEncryption.keys());
    __privateGet(this, _log6).call(this, "selecting outbound crypto protocol", protocols);
    try {
      const { stream, protocol } = await select(connection, protocols, {
        writeBytes: true
      });
      const encrypter = this.connectionEncryption.get(protocol);
      if (encrypter == null) {
        throw new Error(`no crypto module found for ${protocol}`);
      }
      __privateGet(this, _log6).call(this, "encrypting outbound connection to %p", remotePeerId);
      return {
        ...await encrypter.secureOutbound(this.components.peerId, stream, remotePeerId),
        protocol
      };
    } catch (err) {
      throw new CodeError(String(err), codes5.ERR_ENCRYPTION_FAILED);
    }
  }
  /**
   * Selects one of the given muxers via multistream-select. That
   * muxer will be used for all future streams on the connection.
   */
  async _multiplexOutbound(connection, muxers) {
    const protocols = Array.from(muxers.keys());
    __privateGet(this, _log6).call(this, "outbound selecting muxer %s", protocols);
    try {
      const { stream, protocol } = await select(connection, protocols, {
        writeBytes: true
      });
      __privateGet(this, _log6).call(this, "%s selected as muxer protocol", protocol);
      const muxerFactory = muxers.get(protocol);
      return { stream, muxerFactory };
    } catch (err) {
      __privateGet(this, _log6).error("error multiplexing outbound stream", err);
      throw new CodeError(String(err), codes5.ERR_MUXER_UNAVAILABLE);
    }
  }
  /**
   * Registers support for one of the given muxers via multistream-select. The
   * selected muxer will be used for all future streams on the connection.
   */
  async _multiplexInbound(connection, muxers) {
    const protocols = Array.from(muxers.keys());
    __privateGet(this, _log6).call(this, "inbound handling muxers %s", protocols);
    try {
      const { stream, protocol } = await handle(connection, protocols, {
        writeBytes: true
      });
      const muxerFactory = muxers.get(protocol);
      return { stream, muxerFactory };
    } catch (err) {
      __privateGet(this, _log6).error("error multiplexing inbound stream", err);
      throw new CodeError(String(err), codes5.ERR_MUXER_UNAVAILABLE);
    }
  }
};
_log6 = new WeakMap();

// node_modules/libp2p/dist/src/libp2p.js
var _started, _log7, _onDiscoveryPeer, onDiscoveryPeer_fn;
var Libp2pNode = class extends TypedEventEmitter {
  constructor(init) {
    super();
    /**
     * Called whenever peer discovery services emit `peer` events and adds peers
     * to the peer store.
     */
    __privateAdd(this, _onDiscoveryPeer);
    __publicField(this, "peerId");
    __publicField(this, "peerStore");
    __publicField(this, "contentRouting");
    __publicField(this, "peerRouting");
    __publicField(this, "keychain");
    __publicField(this, "metrics");
    __publicField(this, "services");
    __publicField(this, "logger");
    __publicField(this, "components");
    __privateAdd(this, _started, void 0);
    __privateAdd(this, _log7, void 0);
    const events2 = new TypedEventEmitter();
    const originalDispatch = events2.dispatchEvent.bind(events2);
    events2.dispatchEvent = (evt) => {
      const internalResult = originalDispatch(evt);
      const externalResult = this.dispatchEvent(new CustomEvent(evt.type, { detail: evt.detail }));
      return internalResult || externalResult;
    };
    setMaxListeners(Infinity, events2);
    __privateSet(this, _started, false);
    this.peerId = init.peerId;
    this.logger = init.logger ?? defaultLogger();
    __privateSet(this, _log7, this.logger.forComponent("libp2p"));
    this.services = {};
    const components = this.components = defaultComponents({
      peerId: init.peerId,
      logger: this.logger,
      events: events2,
      datastore: init.datastore ?? new MemoryDatastore(),
      connectionGater: connectionGater(init.connectionGater)
    });
    this.peerStore = this.configureComponent("peerStore", new PersistentPeerStore(components, {
      addressFilter: this.components.connectionGater.filterMultiaddrForPeer,
      ...init.peerStore
    }));
    if (init.metrics != null) {
      this.metrics = this.configureComponent("metrics", init.metrics(this.components));
    }
    components.events.addEventListener("peer:update", (evt) => {
      if (evt.detail.previous == null) {
        const peerInfo = {
          id: evt.detail.peer.id,
          multiaddrs: evt.detail.peer.addresses.map((a) => a.multiaddr),
          protocols: evt.detail.peer.protocols
        };
        components.events.safeDispatchEvent("peer:discovery", { detail: peerInfo });
      }
    });
    if (init.connectionProtector != null) {
      this.configureComponent("connectionProtector", init.connectionProtector(components));
    }
    this.components.upgrader = new DefaultUpgrader(this.components, {
      connectionEncryption: (init.connectionEncryption ?? []).map((fn, index) => this.configureComponent(`connection-encryption-${index}`, fn(this.components))),
      muxers: (init.streamMuxers ?? []).map((fn, index) => this.configureComponent(`stream-muxers-${index}`, fn(this.components))),
      inboundUpgradeTimeout: init.connectionManager.inboundUpgradeTimeout
    });
    this.configureComponent("transportManager", new DefaultTransportManager(this.components, init.transportManager));
    this.configureComponent("connectionManager", new DefaultConnectionManager(this.components, init.connectionManager));
    this.configureComponent("registrar", new DefaultRegistrar(this.components));
    this.configureComponent("addressManager", new DefaultAddressManager(this.components, init.addresses));
    const keychainOpts = DefaultKeyChain.generateOptions();
    this.keychain = this.configureComponent("keyChain", new DefaultKeyChain(this.components, {
      ...keychainOpts,
      ...init.keychain
    }));
    const peerRouters = (init.peerRouters ?? []).map((fn, index) => this.configureComponent(`peer-router-${index}`, fn(this.components)));
    this.peerRouting = this.components.peerRouting = this.configureComponent("peerRouting", new DefaultPeerRouting(this.components, {
      routers: peerRouters
    }));
    const contentRouters = (init.contentRouters ?? []).map((fn, index) => this.configureComponent(`content-router-${index}`, fn(this.components)));
    this.contentRouting = this.components.contentRouting = this.configureComponent("contentRouting", new CompoundContentRouting(this.components, {
      routers: contentRouters
    }));
    (init.peerDiscovery ?? []).forEach((fn, index) => {
      const service = this.configureComponent(`peer-discovery-${index}`, fn(this.components));
      service.addEventListener("peer", (evt) => {
        __privateMethod(this, _onDiscoveryPeer, onDiscoveryPeer_fn).call(this, evt);
      });
    });
    init.transports.forEach((fn, index) => {
      this.components.transportManager.add(this.configureComponent(`transport-${index}`, fn(this.components)));
    });
    if (init.services != null) {
      for (const name2 of Object.keys(init.services)) {
        const createService = init.services[name2];
        const service = createService(this.components);
        if (service == null) {
          __privateGet(this, _log7).error("service factory %s returned null or undefined instance", name2);
          continue;
        }
        this.services[name2] = service;
        this.configureComponent(name2, service);
        if (service[contentRouting] != null) {
          __privateGet(this, _log7).call(this, "registering service %s for content routing", name2);
          contentRouters.push(service[contentRouting]);
        }
        if (service[peerRouting] != null) {
          __privateGet(this, _log7).call(this, "registering service %s for peer routing", name2);
          peerRouters.push(service[peerRouting]);
        }
        if (service[peerDiscovery] != null) {
          __privateGet(this, _log7).call(this, "registering service %s for peer discovery", name2);
          service[peerDiscovery].addEventListener("peer", (evt) => {
            __privateMethod(this, _onDiscoveryPeer, onDiscoveryPeer_fn).call(this, evt);
          });
        }
      }
    }
  }
  configureComponent(name2, component) {
    if (component == null) {
      __privateGet(this, _log7).error("component %s was null or undefined", name2);
    }
    this.components[name2] = component;
    return component;
  }
  /**
   * Starts the libp2p node and all its subsystems
   */
  async start() {
    var _a4, _b4, _c, _d;
    if (__privateGet(this, _started)) {
      return;
    }
    __privateSet(this, _started, true);
    __privateGet(this, _log7).call(this, "libp2p is starting");
    const keys = await this.keychain.listKeys();
    if (keys.find((key) => key.name === "self") == null) {
      __privateGet(this, _log7).call(this, "importing self key into keychain");
      await this.keychain.importPeer("self", this.components.peerId);
    }
    try {
      await ((_b4 = (_a4 = this.components).beforeStart) == null ? void 0 : _b4.call(_a4));
      await this.components.start();
      await ((_d = (_c = this.components).afterStart) == null ? void 0 : _d.call(_c));
      this.safeDispatchEvent("start", { detail: this });
      __privateGet(this, _log7).call(this, "libp2p has started");
    } catch (err) {
      __privateGet(this, _log7).error("An error occurred starting libp2p", err);
      await this.stop();
      throw err;
    }
  }
  /**
   * Stop the libp2p node by closing its listeners and open connections
   */
  async stop() {
    var _a4, _b4, _c, _d;
    if (!__privateGet(this, _started)) {
      return;
    }
    __privateGet(this, _log7).call(this, "libp2p is stopping");
    __privateSet(this, _started, false);
    await ((_b4 = (_a4 = this.components).beforeStop) == null ? void 0 : _b4.call(_a4));
    await this.components.stop();
    await ((_d = (_c = this.components).afterStop) == null ? void 0 : _d.call(_c));
    this.safeDispatchEvent("stop", { detail: this });
    __privateGet(this, _log7).call(this, "libp2p has stopped");
  }
  isStarted() {
    return __privateGet(this, _started);
  }
  getConnections(peerId2) {
    return this.components.connectionManager.getConnections(peerId2);
  }
  getDialQueue() {
    return this.components.connectionManager.getDialQueue();
  }
  getPeers() {
    const peerSet = new PeerSet();
    for (const conn of this.components.connectionManager.getConnections()) {
      peerSet.add(conn.remotePeer);
    }
    return Array.from(peerSet);
  }
  async dial(peer, options = {}) {
    return this.components.connectionManager.openConnection(peer, options);
  }
  async dialProtocol(peer, protocols, options = {}) {
    if (protocols == null) {
      throw new CodeError("no protocols were provided to open a stream", codes5.ERR_INVALID_PROTOCOLS_FOR_STREAM);
    }
    protocols = Array.isArray(protocols) ? protocols : [protocols];
    if (protocols.length === 0) {
      throw new CodeError("no protocols were provided to open a stream", codes5.ERR_INVALID_PROTOCOLS_FOR_STREAM);
    }
    const connection = await this.dial(peer, options);
    return connection.newStream(protocols, options);
  }
  getMultiaddrs() {
    return this.components.addressManager.getAddresses();
  }
  getProtocols() {
    return this.components.registrar.getProtocols();
  }
  async hangUp(peer, options = {}) {
    if (isMultiaddr(peer)) {
      peer = peerIdFromString(peer.getPeerId() ?? "");
    }
    await this.components.connectionManager.closeConnections(peer, options);
  }
  /**
   * Get the public key for the given peer id
   */
  async getPublicKey(peer, options = {}) {
    __privateGet(this, _log7).call(this, "getPublicKey %p", peer);
    if (peer.publicKey != null) {
      return peer.publicKey;
    }
    const peerInfo = await this.peerStore.get(peer);
    if (peerInfo.id.publicKey != null) {
      return peerInfo.id.publicKey;
    }
    const peerKey = concat([
      fromString("/pk/"),
      peer.multihash.digest
    ]);
    const bytes2 = await this.contentRouting.get(peerKey, options);
    unmarshalPublicKey(bytes2);
    await this.peerStore.patch(peer, {
      publicKey: bytes2
    });
    return bytes2;
  }
  async handle(protocols, handler, options) {
    if (!Array.isArray(protocols)) {
      protocols = [protocols];
    }
    await Promise.all(protocols.map(async (protocol) => {
      await this.components.registrar.handle(protocol, handler, options);
    }));
  }
  async unhandle(protocols) {
    if (!Array.isArray(protocols)) {
      protocols = [protocols];
    }
    await Promise.all(protocols.map(async (protocol) => {
      await this.components.registrar.unhandle(protocol);
    }));
  }
  async register(protocol, topology) {
    return this.components.registrar.register(protocol, topology);
  }
  unregister(id) {
    this.components.registrar.unregister(id);
  }
};
_started = new WeakMap();
_log7 = new WeakMap();
_onDiscoveryPeer = new WeakSet();
onDiscoveryPeer_fn = function(evt) {
  const { detail: peer } = evt;
  if (peer.id.toString() === this.peerId.toString()) {
    __privateGet(this, _log7).error(new Error(codes5.ERR_DISCOVERED_SELF));
    return;
  }
  void this.components.peerStore.merge(peer.id, {
    multiaddrs: peer.multiaddrs,
    protocols: peer.protocols
  }).catch((err) => {
    __privateGet(this, _log7).error(err);
  });
};
async function createLibp2pNode(options) {
  if (options.peerId == null) {
    const datastore = options.datastore;
    if (datastore != null) {
      try {
        const keyChain = new DefaultKeyChain({
          datastore
        }, merge_options_default(DefaultKeyChain.generateOptions(), options.keychain));
        options.peerId = await keyChain.exportPeerId("self");
      } catch (err) {
        if (err.code !== "ERR_NOT_FOUND") {
          throw err;
        }
      }
    }
  }
  if (options.peerId == null) {
    options.peerId = await createEd25519PeerId();
  }
  return new Libp2pNode(validateConfig(options));
}

// node_modules/libp2p/dist/src/index.js
async function createLibp2p(options) {
  const node = await createLibp2pNode(options);
  if (options.start !== false) {
    await node.start();
  }
  return node;
}

// node_modules/libp2p/dist/src/version.js
var version = "0.46.21";

// node_modules/libp2p/dist/src/identify/consts.js
var AGENT_VERSION = `js-libp2p/${version}`;
var IDENTIFY_PROTOCOL_VERSION = "0.1.0";
var MULTICODEC_IDENTIFY_PROTOCOL_NAME = "id";
var MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME = "id/push";
var MULTICODEC_IDENTIFY_PROTOCOL_VERSION = "1.0.0";
var MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION = "1.0.0";

// node_modules/it-protobuf-stream/dist/src/index.js
function pbStream(duplex, opts) {
  const lp = lpStream(duplex, opts);
  const W = {
    read: async (proto, options) => {
      const value = await lp.read(options);
      return proto.decode(value);
    },
    write: async (message2, proto, options) => {
      await lp.write(proto.encode(message2), options);
    },
    writeV: async (messages2, proto, options) => {
      await lp.writeV(messages2.map((message2) => proto.encode(message2)), options);
    },
    pb: (proto) => {
      return {
        read: async (options) => W.read(proto, options),
        write: async (d, options) => W.write(d, proto, options),
        writeV: async (d, options) => W.writeV(d, proto, options),
        unwrap: () => W
      };
    },
    unwrap: () => {
      return lp.unwrap();
    }
  };
  return W;
}

// node_modules/libp2p/dist/src/identify/pb/message.js
var Identify;
(function(Identify2) {
  let _codec;
  Identify2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.protocolVersion != null) {
          w.uint32(42);
          w.string(obj.protocolVersion);
        }
        if (obj.agentVersion != null) {
          w.uint32(50);
          w.string(obj.agentVersion);
        }
        if (obj.publicKey != null) {
          w.uint32(10);
          w.bytes(obj.publicKey);
        }
        if (obj.listenAddrs != null) {
          for (const value of obj.listenAddrs) {
            w.uint32(18);
            w.bytes(value);
          }
        }
        if (obj.observedAddr != null) {
          w.uint32(34);
          w.bytes(obj.observedAddr);
        }
        if (obj.protocols != null) {
          for (const value of obj.protocols) {
            w.uint32(26);
            w.string(value);
          }
        }
        if (obj.signedPeerRecord != null) {
          w.uint32(66);
          w.bytes(obj.signedPeerRecord);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader2, length4) => {
        const obj = {
          listenAddrs: [],
          protocols: []
        };
        const end = length4 == null ? reader2.len : reader2.pos + length4;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 5:
              obj.protocolVersion = reader2.string();
              break;
            case 6:
              obj.agentVersion = reader2.string();
              break;
            case 1:
              obj.publicKey = reader2.bytes();
              break;
            case 2:
              obj.listenAddrs.push(reader2.bytes());
              break;
            case 4:
              obj.observedAddr = reader2.bytes();
              break;
            case 3:
              obj.protocols.push(reader2.string());
              break;
            case 8:
              obj.signedPeerRecord = reader2.bytes();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Identify2.encode = (obj) => {
    return encodeMessage(obj, Identify2.codec());
  };
  Identify2.decode = (buf) => {
    return decodeMessage(buf, Identify2.codec());
  };
})(Identify || (Identify = {}));

// node_modules/libp2p/dist/src/identify/identify.js
var MAX_IDENTIFY_MESSAGE_SIZE = 1024 * 8;
var defaultValues = {
  protocolPrefix: "ipfs",
  agentVersion: AGENT_VERSION,
  // https://github.com/libp2p/go-libp2p/blob/8d2e54e1637041d5cf4fac1e531287560bd1f4ac/p2p/protocol/identify/id.go#L48
  timeout: 6e4,
  maxInboundStreams: 1,
  maxOutboundStreams: 1,
  maxPushIncomingStreams: 1,
  maxPushOutgoingStreams: 1,
  maxObservedAddresses: 10,
  maxIdentifyMessageSize: 8192,
  runOnConnectionOpen: true,
  runOnTransientConnection: true
};
var _log8, _consumeIdentifyMessage, consumeIdentifyMessage_fn;
var DefaultIdentifyService = class {
  constructor(components, init) {
    __privateAdd(this, _consumeIdentifyMessage);
    __publicField(this, "identifyProtocolStr");
    __publicField(this, "identifyPushProtocolStr");
    __publicField(this, "host");
    __publicField(this, "started");
    __publicField(this, "timeout");
    __publicField(this, "peerId");
    __publicField(this, "peerStore");
    __publicField(this, "registrar");
    __publicField(this, "connectionManager");
    __publicField(this, "addressManager");
    __publicField(this, "maxInboundStreams");
    __publicField(this, "maxOutboundStreams");
    __publicField(this, "maxPushIncomingStreams");
    __publicField(this, "maxPushOutgoingStreams");
    __publicField(this, "maxIdentifyMessageSize");
    __publicField(this, "maxObservedAddresses");
    __publicField(this, "events");
    __publicField(this, "runOnTransientConnection");
    __privateAdd(this, _log8, void 0);
    this.started = false;
    this.peerId = components.peerId;
    this.peerStore = components.peerStore;
    this.registrar = components.registrar;
    this.addressManager = components.addressManager;
    this.connectionManager = components.connectionManager;
    this.events = components.events;
    __privateSet(this, _log8, components.logger.forComponent("libp2p:identify"));
    this.identifyProtocolStr = `/${init.protocolPrefix ?? defaultValues.protocolPrefix}/${MULTICODEC_IDENTIFY_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PROTOCOL_VERSION}`;
    this.identifyPushProtocolStr = `/${init.protocolPrefix ?? defaultValues.protocolPrefix}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION}`;
    this.timeout = init.timeout ?? defaultValues.timeout;
    this.maxInboundStreams = init.maxInboundStreams ?? defaultValues.maxInboundStreams;
    this.maxOutboundStreams = init.maxOutboundStreams ?? defaultValues.maxOutboundStreams;
    this.maxPushIncomingStreams = init.maxPushIncomingStreams ?? defaultValues.maxPushIncomingStreams;
    this.maxPushOutgoingStreams = init.maxPushOutgoingStreams ?? defaultValues.maxPushOutgoingStreams;
    this.maxIdentifyMessageSize = init.maxIdentifyMessageSize ?? defaultValues.maxIdentifyMessageSize;
    this.maxObservedAddresses = init.maxObservedAddresses ?? defaultValues.maxObservedAddresses;
    this.runOnTransientConnection = init.runOnTransientConnection ?? defaultValues.runOnTransientConnection;
    this.host = {
      protocolVersion: `${init.protocolPrefix ?? defaultValues.protocolPrefix}/${IDENTIFY_PROTOCOL_VERSION}`,
      agentVersion: init.agentVersion ?? defaultValues.agentVersion
    };
    if (init.runOnConnectionOpen ?? defaultValues.runOnConnectionOpen) {
      components.events.addEventListener("connection:open", (evt) => {
        const connection = evt.detail;
        this.identify(connection).catch((err) => {
          __privateGet(this, _log8).error("error during identify trigged by connection:open", err);
        });
      });
    }
    components.events.addEventListener("self:peer:update", (evt) => {
      void this.push().catch((err) => {
        __privateGet(this, _log8).error(err);
      });
    });
    if (this.host.agentVersion === AGENT_VERSION) {
      if (isNode || isElectronMain) {
        this.host.agentVersion += ` UserAgent=${globalThis.process.version}`;
      } else if (isBrowser || isWebWorker || isElectronRenderer || isReactNative) {
        this.host.agentVersion += ` UserAgent=${globalThis.navigator.userAgent}`;
      }
    }
  }
  isStarted() {
    return this.started;
  }
  async start() {
    if (this.started) {
      return;
    }
    await this.peerStore.merge(this.peerId, {
      metadata: {
        AgentVersion: fromString(this.host.agentVersion),
        ProtocolVersion: fromString(this.host.protocolVersion)
      }
    });
    await this.registrar.handle(this.identifyProtocolStr, (data) => {
      void this._handleIdentify(data).catch((err) => {
        __privateGet(this, _log8).error(err);
      });
    }, {
      maxInboundStreams: this.maxInboundStreams,
      maxOutboundStreams: this.maxOutboundStreams,
      runOnTransientConnection: this.runOnTransientConnection
    });
    await this.registrar.handle(this.identifyPushProtocolStr, (data) => {
      void this._handlePush(data).catch((err) => {
        __privateGet(this, _log8).error(err);
      });
    }, {
      maxInboundStreams: this.maxPushIncomingStreams,
      maxOutboundStreams: this.maxPushOutgoingStreams,
      runOnTransientConnection: this.runOnTransientConnection
    });
    this.started = true;
  }
  async stop() {
    await this.registrar.unhandle(this.identifyProtocolStr);
    await this.registrar.unhandle(this.identifyPushProtocolStr);
    this.started = false;
  }
  /**
   * Send an Identify Push update to the list of connections
   */
  async pushToConnections(connections) {
    const listenAddresses = this.addressManager.getAddresses().map((ma) => ma.decapsulateCode(getProtocol("p2p").code));
    const peerRecord = new PeerRecord2({
      peerId: this.peerId,
      multiaddrs: listenAddresses
    });
    const signedPeerRecord = await RecordEnvelope.seal(peerRecord, this.peerId);
    const supportedProtocols = this.registrar.getProtocols();
    const peer = await this.peerStore.get(this.peerId);
    const agentVersion = toString(peer.metadata.get("AgentVersion") ?? fromString(this.host.agentVersion));
    const protocolVersion = toString(peer.metadata.get("ProtocolVersion") ?? fromString(this.host.protocolVersion));
    const pushes = connections.map(async (connection) => {
      let stream;
      const signal = AbortSignal.timeout(this.timeout);
      setMaxListeners(Infinity, signal);
      try {
        stream = await connection.newStream([this.identifyPushProtocolStr], {
          signal,
          runOnTransientConnection: this.runOnTransientConnection
        });
        const pb = pbStream(stream, {
          maxDataLength: this.maxIdentifyMessageSize ?? MAX_IDENTIFY_MESSAGE_SIZE
        }).pb(Identify);
        await pb.write({
          listenAddrs: listenAddresses.map((ma) => ma.bytes),
          signedPeerRecord: signedPeerRecord.marshal(),
          protocols: supportedProtocols,
          agentVersion,
          protocolVersion
        }, {
          signal
        });
        await stream.close({
          signal
        });
      } catch (err) {
        __privateGet(this, _log8).error("could not push identify update to peer", err);
        stream == null ? void 0 : stream.abort(err);
      }
    });
    await Promise.all(pushes);
  }
  /**
   * Calls `push` on all peer connections
   */
  async push() {
    if (!this.isStarted()) {
      return;
    }
    const connections = [];
    await Promise.all(this.connectionManager.getConnections().map(async (conn) => {
      try {
        const peer = await this.peerStore.get(conn.remotePeer);
        if (!peer.protocols.includes(this.identifyPushProtocolStr)) {
          return;
        }
        connections.push(conn);
      } catch (err) {
        if (err.code !== codes5.ERR_NOT_FOUND) {
          throw err;
        }
      }
    }));
    await this.pushToConnections(connections);
  }
  async _identify(connection, options = {}) {
    let stream;
    if (options.signal == null) {
      const signal = AbortSignal.timeout(this.timeout);
      setMaxListeners(Infinity, signal);
      options = {
        ...options,
        signal
      };
    }
    try {
      stream = await connection.newStream([this.identifyProtocolStr], {
        ...options,
        runOnTransientConnection: this.runOnTransientConnection
      });
      const pb = pbStream(stream, {
        maxDataLength: this.maxIdentifyMessageSize ?? MAX_IDENTIFY_MESSAGE_SIZE
      }).pb(Identify);
      const message2 = await pb.read(options);
      await stream.close(options);
      return message2;
    } catch (err) {
      __privateGet(this, _log8).error("error while reading identify message", err);
      stream == null ? void 0 : stream.abort(err);
      throw err;
    }
  }
  async identify(connection, options = {}) {
    const message2 = await this._identify(connection, options);
    const { publicKey, protocols, observedAddr } = message2;
    if (publicKey == null) {
      throw new CodeError("public key was missing from identify message", codes5.ERR_MISSING_PUBLIC_KEY);
    }
    const id = await peerIdFromKeys(publicKey);
    if (!connection.remotePeer.equals(id)) {
      throw new CodeError("identified peer does not match the expected peer", codes5.ERR_INVALID_PEER);
    }
    if (this.peerId.equals(id)) {
      throw new CodeError("identified peer is our own peer id?", codes5.ERR_INVALID_PEER);
    }
    const cleanObservedAddr = getCleanMultiaddr(observedAddr);
    __privateGet(this, _log8).call(this, "identify completed for peer %p and protocols %o", id, protocols);
    __privateGet(this, _log8).call(this, "our observed address is %a", cleanObservedAddr);
    if (cleanObservedAddr != null && this.addressManager.getObservedAddrs().length < (this.maxObservedAddresses ?? Infinity)) {
      __privateGet(this, _log8).call(this, "storing our observed address %a", cleanObservedAddr);
      this.addressManager.addObservedAddr(cleanObservedAddr);
    }
    return __privateMethod(this, _consumeIdentifyMessage, consumeIdentifyMessage_fn).call(this, connection, message2);
  }
  /**
   * Sends the `Identify` response with the Signed Peer Record
   * to the requesting peer over the given `connection`
   */
  async _handleIdentify(data) {
    const { connection, stream } = data;
    const signal = AbortSignal.timeout(this.timeout);
    setMaxListeners(Infinity, signal);
    try {
      const publicKey = this.peerId.publicKey ?? new Uint8Array(0);
      const peerData = await this.peerStore.get(this.peerId);
      const multiaddrs = this.addressManager.getAddresses().map((ma) => ma.decapsulateCode(getProtocol("p2p").code));
      let signedPeerRecord = peerData.peerRecordEnvelope;
      if (multiaddrs.length > 0 && signedPeerRecord == null) {
        const peerRecord = new PeerRecord2({
          peerId: this.peerId,
          multiaddrs
        });
        const envelope = await RecordEnvelope.seal(peerRecord, this.peerId);
        signedPeerRecord = envelope.marshal().subarray();
      }
      let observedAddr = connection.remoteAddr.bytes;
      if (!IP_OR_DOMAIN.matches(connection.remoteAddr)) {
        observedAddr = void 0;
      }
      const pb = pbStream(stream).pb(Identify);
      await pb.write({
        protocolVersion: this.host.protocolVersion,
        agentVersion: this.host.agentVersion,
        publicKey,
        listenAddrs: multiaddrs.map((addr) => addr.bytes),
        signedPeerRecord,
        observedAddr,
        protocols: peerData.protocols
      }, {
        signal
      });
      await stream.close({
        signal
      });
    } catch (err) {
      __privateGet(this, _log8).error("could not respond to identify request", err);
      stream.abort(err);
    }
  }
  /**
   * Reads the Identify Push message from the given `connection`
   */
  async _handlePush(data) {
    const { connection, stream } = data;
    try {
      if (this.peerId.equals(connection.remotePeer)) {
        throw new Error("received push from ourselves?");
      }
      const options = {
        signal: AbortSignal.timeout(this.timeout)
      };
      const pb = pbStream(stream, {
        maxDataLength: this.maxIdentifyMessageSize ?? MAX_IDENTIFY_MESSAGE_SIZE
      }).pb(Identify);
      const message2 = await pb.read(options);
      await stream.close(options);
      await __privateMethod(this, _consumeIdentifyMessage, consumeIdentifyMessage_fn).call(this, connection, message2);
    } catch (err) {
      __privateGet(this, _log8).error("received invalid message", err);
      stream.abort(err);
      return;
    }
    __privateGet(this, _log8).call(this, "handled push from %p", connection.remotePeer);
  }
};
_log8 = new WeakMap();
_consumeIdentifyMessage = new WeakSet();
consumeIdentifyMessage_fn = async function(connection, message2) {
  __privateGet(this, _log8).call(this, "received identify from %p", connection.remotePeer);
  if (message2 == null) {
    throw new CodeError("message was null or undefined", "ERR_INVALID_MESSAGE");
  }
  const peer = {};
  if (message2.listenAddrs.length > 0) {
    peer.addresses = message2.listenAddrs.map((buf) => ({
      isCertified: false,
      multiaddr: multiaddr(buf)
    }));
  }
  if (message2.protocols.length > 0) {
    peer.protocols = message2.protocols;
  }
  if (message2.publicKey != null) {
    peer.publicKey = message2.publicKey;
    const peerId2 = await peerIdFromKeys(message2.publicKey);
    if (!peerId2.equals(connection.remotePeer)) {
      throw new CodeError("public key did not match remote PeerId", "ERR_INVALID_PUBLIC_KEY");
    }
  }
  let output2;
  if (message2.signedPeerRecord != null) {
    __privateGet(this, _log8).call(this, "received signedPeerRecord in push from %p", connection.remotePeer);
    let peerRecordEnvelope = message2.signedPeerRecord;
    const envelope = await RecordEnvelope.openAndCertify(peerRecordEnvelope, PeerRecord2.DOMAIN);
    let peerRecord = PeerRecord2.createFromProtobuf(envelope.payload);
    if (!peerRecord.peerId.equals(envelope.peerId)) {
      throw new CodeError("signing key does not match PeerId in the PeerRecord", "ERR_INVALID_SIGNING_KEY");
    }
    if (!connection.remotePeer.equals(peerRecord.peerId)) {
      throw new CodeError("signing key does not match remote PeerId", "ERR_INVALID_PEER_RECORD_KEY");
    }
    let existingPeer;
    try {
      existingPeer = await this.peerStore.get(peerRecord.peerId);
    } catch (err) {
      if (err.code !== "ERR_NOT_FOUND") {
        throw err;
      }
    }
    if (existingPeer != null) {
      peer.metadata = existingPeer.metadata;
      if (existingPeer.peerRecordEnvelope != null) {
        const storedEnvelope = await RecordEnvelope.createFromProtobuf(existingPeer.peerRecordEnvelope);
        const storedRecord = PeerRecord2.createFromProtobuf(storedEnvelope.payload);
        if (storedRecord.seqNumber >= peerRecord.seqNumber) {
          __privateGet(this, _log8).call(this, "sequence number was lower or equal to existing sequence number - stored: %d received: %d", storedRecord.seqNumber, peerRecord.seqNumber);
          peerRecord = storedRecord;
          peerRecordEnvelope = existingPeer.peerRecordEnvelope;
        }
      }
    }
    peer.peerRecordEnvelope = peerRecordEnvelope;
    peer.addresses = peerRecord.multiaddrs.map((multiaddr2) => ({
      isCertified: true,
      multiaddr: multiaddr2
    }));
    output2 = {
      seq: peerRecord.seqNumber,
      addresses: peerRecord.multiaddrs
    };
  } else {
    __privateGet(this, _log8).call(this, "%p did not send a signed peer record", connection.remotePeer);
  }
  __privateGet(this, _log8).call(this, "patching %p with", connection.remotePeer, peer);
  await this.peerStore.patch(connection.remotePeer, peer);
  if (message2.agentVersion != null || message2.protocolVersion != null) {
    const metadata = {};
    if (message2.agentVersion != null) {
      metadata.AgentVersion = fromString(message2.agentVersion);
    }
    if (message2.protocolVersion != null) {
      metadata.ProtocolVersion = fromString(message2.protocolVersion);
    }
    __privateGet(this, _log8).call(this, "merging %p metadata", connection.remotePeer, metadata);
    await this.peerStore.merge(connection.remotePeer, {
      metadata
    });
  }
  const result = {
    peerId: connection.remotePeer,
    protocolVersion: message2.protocolVersion,
    agentVersion: message2.agentVersion,
    publicKey: message2.publicKey,
    listenAddrs: message2.listenAddrs.map((buf) => multiaddr(buf)),
    observedAddr: message2.observedAddr == null ? void 0 : multiaddr(message2.observedAddr),
    protocols: message2.protocols,
    signedPeerRecord: output2,
    connection
  };
  this.events.safeDispatchEvent("peer:identify", { detail: result });
  return result;
};
function getCleanMultiaddr(addr) {
  if (addr != null && addr.length > 0) {
    try {
      return multiaddr(addr);
    } catch {
    }
  }
}

// node_modules/libp2p/dist/src/identify/index.js
function identifyService(init = {}) {
  return (components) => new DefaultIdentifyService(components, init);
}

// node_modules/libp2p/dist/src/ping/constants.js
var PING_LENGTH = 32;
var PROTOCOL_VERSION = "1.0.0";
var PROTOCOL_NAME = "ping";
var PROTOCOL_PREFIX = "ipfs";
var TIMEOUT = 1e4;
var MAX_INBOUND_STREAMS = 2;
var MAX_OUTBOUND_STREAMS = 1;

// node_modules/libp2p/dist/src/ping/index.js
var log29 = logger("libp2p:ping");
var DefaultPingService = class {
  constructor(components, init) {
    __publicField(this, "protocol");
    __publicField(this, "components");
    __publicField(this, "started");
    __publicField(this, "timeout");
    __publicField(this, "maxInboundStreams");
    __publicField(this, "maxOutboundStreams");
    __publicField(this, "runOnTransientConnection");
    this.components = components;
    this.started = false;
    this.protocol = `/${init.protocolPrefix ?? PROTOCOL_PREFIX}/${PROTOCOL_NAME}/${PROTOCOL_VERSION}`;
    this.timeout = init.timeout ?? TIMEOUT;
    this.maxInboundStreams = init.maxInboundStreams ?? MAX_INBOUND_STREAMS;
    this.maxOutboundStreams = init.maxOutboundStreams ?? MAX_OUTBOUND_STREAMS;
    this.runOnTransientConnection = init.runOnTransientConnection ?? true;
  }
  async start() {
    await this.components.registrar.handle(this.protocol, this.handleMessage, {
      maxInboundStreams: this.maxInboundStreams,
      maxOutboundStreams: this.maxOutboundStreams,
      runOnTransientConnection: this.runOnTransientConnection
    });
    this.started = true;
  }
  async stop() {
    await this.components.registrar.unhandle(this.protocol);
    this.started = false;
  }
  isStarted() {
    return this.started;
  }
  /**
   * A handler to register with Libp2p to process ping messages
   */
  handleMessage(data) {
    log29("incoming ping from %p", data.connection.remotePeer);
    const { stream } = data;
    const start = Date.now();
    void pipe(stream, stream).catch((err) => {
      log29.error("incoming ping from %p failed with error", data.connection.remotePeer, err);
    }).finally(() => {
      const ms = Date.now() - start;
      log29("incoming ping from %p complete in %dms", data.connection.remotePeer, ms);
    });
  }
  /**
   * Ping a given peer and wait for its response, getting the operation latency.
   *
   * @param {PeerId|Multiaddr} peer
   * @returns {Promise<number>}
   */
  async ping(peer, options = {}) {
    var _a4, _b4;
    log29("pinging %p", peer);
    const start = Date.now();
    const data = randomBytes2(PING_LENGTH);
    const connection = await this.components.connectionManager.openConnection(peer, options);
    let stream;
    let onAbort = () => {
    };
    if (options.signal == null) {
      const signal = AbortSignal.timeout(this.timeout);
      options = {
        ...options,
        signal
      };
    }
    try {
      stream = await connection.newStream(this.protocol, {
        ...options,
        runOnTransientConnection: this.runOnTransientConnection
      });
      onAbort = () => {
        stream == null ? void 0 : stream.abort(new CodeError("ping timeout", codes5.ERR_TIMEOUT));
      };
      (_a4 = options.signal) == null ? void 0 : _a4.addEventListener("abort", onAbort, { once: true });
      const result = await pipe([data], stream, async (source) => src_default12(source));
      const ms = Date.now() - start;
      if (result == null) {
        throw new CodeError(`Did not receive a ping ack after ${ms}ms`, codes5.ERR_WRONG_PING_ACK);
      }
      if (!equals(data, result.subarray())) {
        throw new CodeError(`Received wrong ping ack after ${ms}ms`, codes5.ERR_WRONG_PING_ACK);
      }
      log29("ping %p complete in %dms", connection.remotePeer, ms);
      return ms;
    } catch (err) {
      log29.error("error while pinging %p", connection.remotePeer, err);
      stream == null ? void 0 : stream.abort(err);
      throw err;
    } finally {
      (_b4 = options.signal) == null ? void 0 : _b4.removeEventListener("abort", onAbort);
      if (stream != null) {
        await stream.close();
      }
    }
  }
};
function pingService(init = {}) {
  return (components) => new DefaultPingService(components, init);
}

// node_modules/@waku/sdk/dist/create.js
var DEFAULT_NODE_REQUIREMENTS = {
  lightPush: 1,
  filter: 1,
  store: 1
};
async function createLightNode(options) {
  options = options ?? {};
  if (!options.pubsubTopics) {
    options.pubsubTopics = [DefaultPubSubTopic];
  }
  const libp2pOptions = (options == null ? void 0 : options.libp2p) ?? {};
  const peerDiscovery2 = libp2pOptions.peerDiscovery ?? [];
  if (options == null ? void 0 : options.defaultBootstrap) {
    peerDiscovery2.push(...defaultPeerDiscoveries());
    Object.assign(libp2pOptions, { peerDiscovery: peerDiscovery2 });
  }
  const libp2p = await defaultLibp2p(void 0, libp2pOptions, options == null ? void 0 : options.userAgent);
  const store = wakuStore(options);
  const lightPush = wakuLightPush(options);
  const filter2 = wakuFilter(options);
  return new WakuNode(options ?? {}, options.pubsubTopics, libp2p, store, lightPush, filter2);
}
async function createRelayNode(options) {
  options = options ?? {};
  if (!options.pubsubTopics) {
    options.pubsubTopics = [DefaultPubSubTopic];
  }
  const libp2pOptions = (options == null ? void 0 : options.libp2p) ?? {};
  const peerDiscovery2 = libp2pOptions.peerDiscovery ?? [];
  if (options == null ? void 0 : options.defaultBootstrap) {
    peerDiscovery2.push(...defaultPeerDiscoveries());
    Object.assign(libp2pOptions, { peerDiscovery: peerDiscovery2 });
  }
  const libp2p = await defaultLibp2p(wakuGossipSub(options), libp2pOptions, options == null ? void 0 : options.userAgent);
  const relay = wakuRelay(options);
  return new WakuNode(options, options.pubsubTopics, libp2p, void 0, void 0, void 0, relay);
}
async function createFullNode(options) {
  options = options ?? {};
  if (!options.pubsubTopics) {
    options.pubsubTopics = [DefaultPubSubTopic];
  }
  const libp2pOptions = (options == null ? void 0 : options.libp2p) ?? {};
  const peerDiscovery2 = libp2pOptions.peerDiscovery ?? [];
  if (options == null ? void 0 : options.defaultBootstrap) {
    peerDiscovery2.push(...defaultPeerDiscoveries());
    Object.assign(libp2pOptions, { peerDiscovery: peerDiscovery2 });
  }
  const libp2p = await defaultLibp2p(wakuGossipSub(options), libp2pOptions, options == null ? void 0 : options.userAgent);
  const store = wakuStore(options);
  const lightPush = wakuLightPush(options);
  const filter2 = wakuFilter(options);
  const relay = wakuRelay(options);
  return new WakuNode(options ?? {}, options.pubsubTopics, libp2p, store, lightPush, filter2, relay);
}
function defaultPeerDiscoveries() {
  const discoveries = [
    wakuDnsDiscovery([enrTree["PROD"]], DEFAULT_NODE_REQUIREMENTS),
    wakuPeerExchangeDiscovery()
  ];
  return discoveries;
}
async function defaultLibp2p(wakuGossipSub2, options, userAgent) {
  const pubsubService = wakuGossipSub2 ? { pubsub: wakuGossipSub2 } : {};
  return createLibp2p({
    connectionManager: {
      minConnections: 1
    },
    transports: [webSockets({ filter: all2 })],
    streamMuxers: [mplex()],
    connectionEncryption: [noise()],
    ...options,
    services: {
      identify: identifyService({
        agentVersion: userAgent ?? DefaultUserAgent
      }),
      ping: pingService(),
      ...pubsubService,
      ...options == null ? void 0 : options.services
    }
  });
}
export {
  DecodedMessage,
  Decoder,
  EPeersByDiscoveryEvents,
  Encoder,
  PageDirection,
  Protocols,
  SendError,
  Tags,
  WakuNode,
  bytesToUtf8,
  createDecoder,
  createEncoder,
  createFullNode,
  createLightNode,
  createRelayNode,
  defaultLibp2p,
  defaultPeerDiscoveries,
  dist_exports3 as relay,
  utf8ToBytes,
  dist_exports as utils,
  waitForRemotePeer,
  dist_exports2 as waku
};
/*! Bundled license information:

@noble/ciphers/esm/utils.js:
  (*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/edwards.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/montgomery.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/ed25519.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=@waku_sdk.js.map
