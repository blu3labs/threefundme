{
  "version": 3,
  "sources": ["../../@libp2p/interface/src/events.browser.ts", "../../@libp2p/interface/src/events.ts", "../../@libp2p/interface/src/peer-discovery/index.ts", "../../@libp2p/interface/src/errors.ts", "../../@libp2p/interface/src/peer-id/index.ts", "../../@libp2p/peer-id/node_modules/multiformats/src/bases/base58.js", "../../@libp2p/peer-id/node_modules/multiformats/vendor/base-x.js", "../../@libp2p/peer-id/node_modules/multiformats/src/bytes.js", "../../@libp2p/peer-id/node_modules/multiformats/src/bases/base.js", "../../@libp2p/peer-id/node_modules/multiformats/src/bases/base10.js", "../../@libp2p/peer-id/node_modules/multiformats/src/bases/base16.js", "../../@libp2p/peer-id/node_modules/multiformats/src/bases/base2.js", "../../@libp2p/peer-id/node_modules/multiformats/src/bases/base256emoji.js", "../../@libp2p/peer-id/node_modules/multiformats/src/bases/base32.js", "../../@libp2p/peer-id/node_modules/multiformats/src/bases/base36.js", "../../@libp2p/peer-id/node_modules/multiformats/src/bases/base64.js", "../../@libp2p/peer-id/node_modules/multiformats/src/bases/base8.js", "../../@libp2p/peer-id/node_modules/multiformats/src/bases/identity.js", "../../@libp2p/peer-id/node_modules/multiformats/src/codecs/json.js", "../../@libp2p/peer-id/node_modules/multiformats/src/hashes/identity.js", "../../@libp2p/peer-id/node_modules/multiformats/vendor/varint.js", "../../@libp2p/peer-id/node_modules/multiformats/src/varint.js", "../../@libp2p/peer-id/node_modules/multiformats/src/hashes/digest.js", "../../@libp2p/peer-id/node_modules/multiformats/src/hashes/sha2-browser.js", "../../@libp2p/peer-id/node_modules/multiformats/src/hashes/hasher.js", "../../@libp2p/peer-id/node_modules/multiformats/src/cid.js", "../../@libp2p/peer-id/node_modules/multiformats/src/basics.js", "../../uint8arrays/src/equals.ts", "../../@libp2p/peer-id/src/index.ts", "../../@multiformats/multiaddr/node_modules/multiformats/src/bases/base58.js", "../../@multiformats/multiaddr/node_modules/multiformats/vendor/base-x.js", "../../@multiformats/multiaddr/node_modules/multiformats/src/bytes.js", "../../@multiformats/multiaddr/node_modules/multiformats/src/bases/base.js", "../../@multiformats/multiaddr/node_modules/multiformats/src/bases/base32.js", "../../@multiformats/multiaddr/node_modules/multiformats/vendor/varint.js", "../../@multiformats/multiaddr/node_modules/multiformats/src/varint.js", "../../@multiformats/multiaddr/node_modules/multiformats/src/hashes/digest.js", "../../@multiformats/multiaddr/node_modules/multiformats/src/cid.js", "../../uint8arrays/node_modules/multiformats/src/bases/base10.js", "../../uint8arrays/node_modules/multiformats/vendor/base-x.js", "../../uint8arrays/node_modules/multiformats/src/bytes.js", "../../uint8arrays/node_modules/multiformats/src/bases/base.js", "../../uint8arrays/node_modules/multiformats/src/bases/base16.js", "../../uint8arrays/node_modules/multiformats/src/bases/base2.js", "../../uint8arrays/node_modules/multiformats/src/bases/base256emoji.js", "../../uint8arrays/node_modules/multiformats/src/bases/base32.js", "../../uint8arrays/node_modules/multiformats/src/bases/base36.js", "../../uint8arrays/node_modules/multiformats/src/bases/base58.js", "../../uint8arrays/node_modules/multiformats/src/bases/base64.js", "../../uint8arrays/node_modules/multiformats/src/bases/base8.js", "../../uint8arrays/node_modules/multiformats/src/bases/identity.js", "../../uint8arrays/node_modules/multiformats/src/codecs/json.js", "../../uint8arrays/node_modules/multiformats/src/hashes/identity.js", "../../uint8arrays/node_modules/multiformats/vendor/varint.js", "../../uint8arrays/node_modules/multiformats/src/varint.js", "../../uint8arrays/node_modules/multiformats/src/hashes/digest.js", "../../uint8arrays/node_modules/multiformats/src/hashes/sha2-browser.js", "../../uint8arrays/node_modules/multiformats/src/hashes/hasher.js", "../../uint8arrays/node_modules/multiformats/src/cid.js", "../../uint8arrays/node_modules/multiformats/src/basics.js", "../../uint8arrays/src/util/as-uint8array.ts", "../../uint8arrays/src/alloc.ts", "../../uint8arrays/src/util/bases.ts", "../../uint8arrays/src/to-string.ts", "../../uint8-varint/src/index.ts", "../../uint8arrays/src/concat.ts", "../../@chainsafe/is-ip/src/parser.ts", "../../@chainsafe/is-ip/src/parse.ts", "../../@chainsafe/netmask/src/ip.ts", "../../@multiformats/multiaddr/node_modules/multiformats/src/bases/base10.js", "../../@multiformats/multiaddr/node_modules/multiformats/src/bases/base16.js", "../../@multiformats/multiaddr/node_modules/multiformats/src/bases/base2.js", "../../@multiformats/multiaddr/node_modules/multiformats/src/bases/base256emoji.js", "../../@multiformats/multiaddr/node_modules/multiformats/src/bases/base36.js", "../../@multiformats/multiaddr/node_modules/multiformats/src/bases/base64.js", "../../@multiformats/multiaddr/node_modules/multiformats/src/bases/base8.js", "../../@multiformats/multiaddr/node_modules/multiformats/src/bases/identity.js", "../../@multiformats/multiaddr/node_modules/multiformats/src/codecs/json.js", "../../@multiformats/multiaddr/node_modules/multiformats/src/hashes/identity.js", "../../@multiformats/multiaddr/node_modules/multiformats/src/hashes/sha2-browser.js", "../../@multiformats/multiaddr/node_modules/multiformats/src/hashes/hasher.js", "../../@multiformats/multiaddr/node_modules/multiformats/src/basics.js", "../../uint8arrays/src/from-string.ts", "../../@chainsafe/is-ip/src/is-ip.ts", "../../@multiformats/multiaddr/src/ip.ts", "../../@multiformats/multiaddr/src/protocols-table.ts", "../../@multiformats/multiaddr/src/convert.ts", "../../@multiformats/multiaddr/src/codec.ts", "../../@multiformats/multiaddr/src/multiaddr.ts", "../../@multiformats/multiaddr/src/index.ts"],
  "sourcesContent": ["/** Noop for browser compatibility */\nexport function setMaxListeners (): void {}\n", "import { setMaxListeners as nodeSetMaxListeners } from 'events'\n\nexport interface EventCallback<EventType> { (evt: EventType): void }\nexport interface EventObject<EventType> { handleEvent: EventCallback<EventType> }\nexport type EventHandler<EventType> = EventCallback<EventType> | EventObject<EventType>\n\ninterface Listener {\n  once: boolean\n  callback: any\n}\n\n/**\n * Adds types to the EventTarget class. Hopefully this won't be necessary forever.\n *\n * https://github.com/microsoft/TypeScript/issues/28357\n * https://github.com/microsoft/TypeScript/issues/43477\n * https://github.com/microsoft/TypeScript/issues/299\n * etc\n */\nexport interface TypedEventTarget <EventMap extends Record<string, any>> extends EventTarget {\n  addEventListener<K extends keyof EventMap>(type: K, listener: EventHandler<EventMap[K]> | null, options?: boolean | AddEventListenerOptions): void\n\n  listenerCount (type: string): number\n\n  removeEventListener<K extends keyof EventMap>(type: K, listener?: EventHandler<EventMap[K]> | null, options?: boolean | EventListenerOptions): void\n\n  removeEventListener (type: string, listener?: EventHandler<Event>, options?: boolean | EventListenerOptions): void\n\n  safeDispatchEvent<Detail>(type: keyof EventMap, detail: CustomEventInit<Detail>): boolean\n}\n\n/**\n * An implementation of a typed event target\n * etc\n */\nexport class TypedEventEmitter<EventMap extends Record<string, any>> extends EventTarget implements TypedEventTarget<EventMap> {\n  #listeners = new Map<any, Listener[]>()\n\n  listenerCount (type: string): number {\n    const listeners = this.#listeners.get(type)\n\n    if (listeners == null) {\n      return 0\n    }\n\n    return listeners.length\n  }\n\n  addEventListener<K extends keyof EventMap>(type: K, listener: EventHandler<EventMap[K]> | null, options?: boolean | AddEventListenerOptions): void\n  addEventListener (type: string, listener: EventHandler<Event>, options?: boolean | AddEventListenerOptions): void {\n    super.addEventListener(type, listener, options)\n\n    let list = this.#listeners.get(type)\n\n    if (list == null) {\n      list = []\n      this.#listeners.set(type, list)\n    }\n\n    list.push({\n      callback: listener,\n      once: (options !== true && options !== false && options?.once) ?? false\n    })\n  }\n\n  removeEventListener<K extends keyof EventMap>(type: K, listener?: EventHandler<EventMap[K]> | null, options?: boolean | EventListenerOptions): void\n  removeEventListener (type: string, listener?: EventHandler<Event>, options?: boolean | EventListenerOptions): void {\n    super.removeEventListener(type.toString(), listener ?? null, options)\n\n    let list = this.#listeners.get(type)\n\n    if (list == null) {\n      return\n    }\n\n    list = list.filter(({ callback }) => callback !== listener)\n    this.#listeners.set(type, list)\n  }\n\n  dispatchEvent (event: Event): boolean {\n    const result = super.dispatchEvent(event)\n\n    let list = this.#listeners.get(event.type)\n\n    if (list == null) {\n      return result\n    }\n\n    list = list.filter(({ once }) => !once)\n    this.#listeners.set(event.type, list)\n\n    return result\n  }\n\n  safeDispatchEvent<Detail>(type: keyof EventMap, detail: CustomEventInit<Detail>): boolean {\n    return this.dispatchEvent(new CustomEvent<Detail>(type as string, detail))\n  }\n}\n\n/**\n * CustomEvent is a standard event but it's not supported by node.\n *\n * Remove this when https://github.com/nodejs/node/issues/40678 is closed.\n *\n * Ref: https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent\n */\nclass CustomEventPolyfill<T = any> extends Event {\n  /** Returns any custom data event was created with. Typically used for synthetic events. */\n  public detail: T\n\n  constructor (message: string, data?: EventInit & { detail: T }) {\n    super(message, data)\n    // @ts-expect-error could be undefined\n    this.detail = data?.detail\n  }\n}\n\nexport const CustomEvent = globalThis.CustomEvent ?? CustomEventPolyfill\n\n// TODO: remove this in v1\nexport { TypedEventEmitter as EventEmitter }\n\n// create a setMaxListeners that doesn't break browser usage\nexport const setMaxListeners: typeof nodeSetMaxListeners = (n, ...eventTargets) => {\n  try {\n    nodeSetMaxListeners(n, ...eventTargets)\n  } catch {\n    // swallow error, gulp\n  }\n}\n", "import type { TypedEventTarget } from '../events.js'\nimport type { PeerInfo } from '../peer-info/index.js'\n\n/**\n * Any object that implements this Symbol as a property should return a\n * PeerDiscovery instance as the property value, similar to how\n * `Symbol.Iterable` can be used to return an `Iterable` from an `Iterator`.\n *\n * @example\n *\n * ```js\n * import { peerDiscovery, PeerDiscovery } from '@libp2p/peer-discovery'\n *\n * class MyPeerDiscoverer implements PeerDiscovery {\n *   get [peerDiscovery] () {\n *     return this\n *   }\n *\n *   // ...other methods\n * }\n * ```\n */\nexport const peerDiscovery = Symbol.for('@libp2p/peer-discovery')\n\nexport interface PeerDiscoveryEvents {\n  'peer': CustomEvent<PeerInfo>\n}\n\nexport interface PeerDiscovery extends TypedEventTarget<PeerDiscoveryEvents> {}\n", "/**\n * When this error is thrown it means an operation was aborted,\n * usually in response to the `abort` event being emitted by an\n * AbortSignal.\n */\nexport class AbortError extends Error {\n  public readonly code: string\n  public readonly type: string\n\n  constructor (message: string = 'The operation was aborted') {\n    super(message)\n    this.code = AbortError.code\n    this.type = AbortError.type\n  }\n\n  static readonly code = 'ABORT_ERR'\n\n  static readonly type = 'aborted'\n}\n\nexport class CodeError<T extends Record<string, any> = Record<string, never>> extends Error {\n  public readonly props: T\n\n  constructor (\n    message: string,\n    public readonly code: string,\n    props?: T\n  ) {\n    super(message)\n\n    this.name = props?.name ?? 'CodeError'\n    this.props = props ?? {} as T // eslint-disable-line @typescript-eslint/consistent-type-assertions\n  }\n}\n\nexport class UnexpectedPeerError extends Error {\n  public code: string\n\n  constructor (message = 'Unexpected Peer') {\n    super(message)\n    this.code = UnexpectedPeerError.code\n  }\n\n  static readonly code = 'ERR_UNEXPECTED_PEER'\n}\n\nexport class InvalidCryptoExchangeError extends Error {\n  public code: string\n\n  constructor (message = 'Invalid crypto exchange') {\n    super(message)\n    this.code = InvalidCryptoExchangeError.code\n  }\n\n  static readonly code = 'ERR_INVALID_CRYPTO_EXCHANGE'\n}\n\nexport class InvalidCryptoTransmissionError extends Error {\n  public code: string\n\n  constructor (message = 'Invalid crypto transmission') {\n    super(message)\n    this.code = InvalidCryptoTransmissionError.code\n  }\n\n  static readonly code = 'ERR_INVALID_CRYPTO_TRANSMISSION'\n}\n", "import type { CID } from 'multiformats/cid'\nimport type { MultihashDigest } from 'multiformats/hashes/interface'\n\nexport type PeerIdType = 'RSA' | 'Ed25519' | 'secp256k1'\n\ninterface BasePeerId {\n  readonly type: PeerIdType\n  readonly multihash: MultihashDigest\n  readonly privateKey?: Uint8Array\n  readonly publicKey?: Uint8Array\n\n  toString(): string\n  toCID(): CID\n  toBytes(): Uint8Array\n  equals(other: PeerId | Uint8Array | string): boolean\n}\n\nexport interface RSAPeerId extends BasePeerId {\n  readonly type: 'RSA'\n  readonly publicKey?: Uint8Array\n}\n\nexport interface Ed25519PeerId extends BasePeerId {\n  readonly type: 'Ed25519'\n  readonly publicKey: Uint8Array\n}\n\nexport interface Secp256k1PeerId extends BasePeerId {\n  readonly type: 'secp256k1'\n  readonly publicKey: Uint8Array\n}\n\nexport type PeerId = RSAPeerId | Ed25519PeerId | Secp256k1PeerId\n\nexport const symbol = Symbol.for('@libp2p/peer-id')\n\nexport function isPeerId (other: any): other is PeerId {\n  return other != null && Boolean(other[symbol])\n}\n", "import { baseX } from './base.js'\n\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n})\n\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n})\n", "// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET, name) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256);\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255;\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i);\n    var xc = x.charCodeAt(0);\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i;\n  }\n  var BASE = ALPHABET.length;\n  var LEADER = ALPHABET.charAt(0);\n  var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (source instanceof Uint8Array) ; else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source);\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0;\n    var length = 0;\n    var pbegin = 0;\n    var pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++;\n      zeroes++;\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n    var b58 = new Uint8Array(size);\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0;\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0;\n        b58[it1] = (carry % BASE) >>> 0;\n        carry = (carry / BASE) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      pbegin++;\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length;\n    while (it2 !== size && b58[it2] === 0) {\n      it2++;\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes);\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0;\n        // Skip leading spaces.\n    if (source[psz] === ' ') { return }\n        // Skip and count leading '1's.\n    var zeroes = 0;\n    var length = 0;\n    while (source[psz] === LEADER) {\n      zeroes++;\n      psz++;\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size);\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0;\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0;\n        b256[it3] = (carry % 256) >>> 0;\n        carry = (carry / 256) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      psz++;\n    }\n        // Skip trailing spaces.\n    if (source[psz] === ' ') { return }\n        // Skip leading zeroes in b256.\n    var it4 = size - length;\n    while (it4 !== size && b256[it4] === 0) {\n      it4++;\n    }\n    var vch = new Uint8Array(zeroes + (size - it4));\n    var j = zeroes;\n    while (it4 !== size) {\n      vch[j++] = b256[it4++];\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string);\n    if (buffer) { return buffer }\n    throw new Error(`Non-${name} character`)\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nvar src = base;\n\nvar _brrp__multiformats_scope_baseX = src;\n\nexport default _brrp__multiformats_scope_baseX;\n", "const empty = new Uint8Array(0)\n\n/**\n * @param {Uint8Array} d\n */\nconst toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')\n\n/**\n * @param {string} hex\n */\nconst fromHex = hex => {\n  const hexes = hex.match(/../g)\n  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty\n}\n\n/**\n * @param {Uint8Array} aa\n * @param {Uint8Array} bb\n */\nconst equals = (aa, bb) => {\n  if (aa === bb) return true\n  if (aa.byteLength !== bb.byteLength) {\n    return false\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @param {ArrayBufferView|ArrayBuffer|Uint8Array} o\n * @returns {Uint8Array}\n */\nconst coerce = o => {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o\n  if (o instanceof ArrayBuffer) return new Uint8Array(o)\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)\n  }\n  throw new Error('Unknown type, must be binary type')\n}\n\n/**\n * @param {any} o\n * @returns {o is ArrayBuffer|ArrayBufferView}\n */\nconst isBinary = o =>\n  o instanceof ArrayBuffer || ArrayBuffer.isView(o)\n\n/**\n * @param {string} str\n * @returns {Uint8Array}\n */\nconst fromString = str => (new TextEncoder()).encode(str)\n\n/**\n * @param {Uint8Array} b\n * @returns {string}\n */\nconst toString = b => (new TextDecoder()).decode(b)\n\nexport { equals, coerce, isBinary, fromHex, toHex, fromString, toString, empty }\n", "import basex from '../../vendor/base-x.js'\nimport { coerce } from '../bytes.js'\n// Linter can't see that API is used in types.\n// eslint-disable-next-line\nimport * as API from './interface.js'\n\n/**\n * Class represents both BaseEncoder and MultibaseEncoder meaning it\n * can be used to encode to multibase or base encode without multibase\n * prefix.\n *\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseEncoder<Prefix>}\n * @implements {API.BaseEncoder}\n */\nclass Encoder {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(bytes:Uint8Array) => string} baseEncode\n   */\n  constructor (name, prefix, baseEncode) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n  }\n\n  /**\n   * @param {Uint8Array} bytes\n   * @returns {API.Multibase<Prefix>}\n   */\n  encode (bytes) {\n    if (bytes instanceof Uint8Array) {\n      return `${this.prefix}${this.baseEncode(bytes)}`\n    } else {\n      throw Error('Unknown type, must be binary type')\n    }\n  }\n}\n\n/**\n * @template {string} Prefix\n */\n/**\n * Class represents both BaseDecoder and MultibaseDecoder so it could be used\n * to decode multibases (with matching prefix) or just base decode strings\n * with corresponding base encoding.\n *\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.UnibaseDecoder<Prefix>}\n * @implements {API.BaseDecoder}\n */\nclass Decoder {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(text:string) => Uint8Array} baseDecode\n   */\n  constructor (name, prefix, baseDecode) {\n    this.name = name\n    this.prefix = prefix\n    /* c8 ignore next 3 */\n    if (prefix.codePointAt(0) === undefined) {\n      throw new Error('Invalid prefix character')\n    }\n    /** @private */\n    this.prefixCodePoint = /** @type {number} */ (prefix.codePointAt(0))\n    this.baseDecode = baseDecode\n  }\n\n  /**\n   * @param {string} text\n   */\n  decode (text) {\n    if (typeof text === 'string') {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`)\n      }\n      return this.baseDecode(text.slice(this.prefix.length))\n    } else {\n      throw Error('Can only multibase decode strings')\n    }\n  }\n\n  /**\n   * @template {string} OtherPrefix\n   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder\n   * @returns {ComposedDecoder<Prefix|OtherPrefix>}\n   */\n  or (decoder) {\n    return or(this, decoder)\n  }\n}\n\n/**\n * @template {string} Prefix\n * @typedef {Record<Prefix, API.UnibaseDecoder<Prefix>>} Decoders\n */\n\n/**\n * @template {string} Prefix\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.CombobaseDecoder<Prefix>}\n */\nclass ComposedDecoder {\n  /**\n   * @param {Decoders<Prefix>} decoders\n   */\n  constructor (decoders) {\n    this.decoders = decoders\n  }\n\n  /**\n   * @template {string} OtherPrefix\n   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder\n   * @returns {ComposedDecoder<Prefix|OtherPrefix>}\n   */\n  or (decoder) {\n    return or(this, decoder)\n  }\n\n  /**\n   * @param {string} input\n   * @returns {Uint8Array}\n   */\n  decode (input) {\n    const prefix = /** @type {Prefix} */ (input[0])\n    const decoder = this.decoders[prefix]\n    if (decoder) {\n      return decoder.decode(input)\n    } else {\n      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)\n    }\n  }\n}\n\n/**\n * @template {string} L\n * @template {string} R\n * @param {API.UnibaseDecoder<L>|API.CombobaseDecoder<L>} left\n * @param {API.UnibaseDecoder<R>|API.CombobaseDecoder<R>} right\n * @returns {ComposedDecoder<L|R>}\n */\nexport const or = (left, right) => new ComposedDecoder(/** @type {Decoders<L|R>} */({\n  ...(left.decoders || { [/** @type API.UnibaseDecoder<L> */(left).prefix]: left }),\n  ...(right.decoders || { [/** @type API.UnibaseDecoder<R> */(right).prefix]: right })\n}))\n\n/**\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseCodec<Prefix>}\n * @implements {API.MultibaseEncoder<Prefix>}\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.BaseCodec}\n * @implements {API.BaseEncoder}\n * @implements {API.BaseDecoder}\n */\nexport class Codec {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(bytes:Uint8Array) => string} baseEncode\n   * @param {(text:string) => Uint8Array} baseDecode\n   */\n  constructor (name, prefix, baseEncode, baseDecode) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n    this.baseDecode = baseDecode\n    this.encoder = new Encoder(name, prefix, baseEncode)\n    this.decoder = new Decoder(name, prefix, baseDecode)\n  }\n\n  /**\n   * @param {Uint8Array} input\n   */\n  encode (input) {\n    return this.encoder.encode(input)\n  }\n\n  /**\n   * @param {string} input\n   */\n  decode (input) {\n    return this.decoder.decode(input)\n  }\n}\n\n/**\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {(bytes:Uint8Array) => string} options.encode\n * @param {(input:string) => Uint8Array} options.decode\n * @returns {Codec<Base, Prefix>}\n */\nexport const from = ({ name, prefix, encode, decode }) =>\n  new Codec(name, prefix, encode, decode)\n\n/**\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {string} options.alphabet\n * @returns {Codec<Base, Prefix>}\n */\nexport const baseX = ({ prefix, name, alphabet }) => {\n  const { encode, decode } = basex(alphabet, name)\n  return from({\n    prefix,\n    name,\n    encode,\n    /**\n     * @param {string} text\n     */\n    decode: text => coerce(decode(text))\n  })\n}\n\n/**\n * @param {string} string\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @param {string} name\n * @returns {Uint8Array}\n */\nconst decode = (string, alphabet, bitsPerChar, name) => {\n  // Build the character lookup table:\n  /** @type {Record<string, number>} */\n  const codes = {}\n  for (let i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i\n  }\n\n  // Count the padding bytes:\n  let end = string.length\n  while (string[end - 1] === '=') {\n    --end\n  }\n\n  // Allocate the output:\n  const out = new Uint8Array((end * bitsPerChar / 8) | 0)\n\n  // Parse the data:\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  let written = 0 // Next byte to write\n  for (let i = 0; i < end; ++i) {\n    // Read one character from the string:\n    const value = codes[string[i]]\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${name} character`)\n    }\n\n    // Append the bits to the buffer:\n    buffer = (buffer << bitsPerChar) | value\n    bits += bitsPerChar\n\n    // Write out some bits if the buffer has a byte's worth:\n    if (bits >= 8) {\n      bits -= 8\n      out[written++] = 0xff & (buffer >> bits)\n    }\n  }\n\n  // Verify that we have received just enough bits:\n  if (bits >= bitsPerChar || 0xff & (buffer << (8 - bits))) {\n    throw new SyntaxError('Unexpected end of data')\n  }\n\n  return out\n}\n\n/**\n * @param {Uint8Array} data\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @returns {string}\n */\nconst encode = (data, alphabet, bitsPerChar) => {\n  const pad = alphabet[alphabet.length - 1] === '='\n  const mask = (1 << bitsPerChar) - 1\n  let out = ''\n\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  for (let i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = (buffer << 8) | data[i]\n    bits += 8\n\n    // Write out as much as we can:\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar\n      out += alphabet[mask & (buffer >> bits)]\n    }\n  }\n\n  // Partial character:\n  if (bits) {\n    out += alphabet[mask & (buffer << (bitsPerChar - bits))]\n  }\n\n  // Add padding characters until we hit a byte boundary:\n  if (pad) {\n    while ((out.length * bitsPerChar) & 7) {\n      out += '='\n    }\n  }\n\n  return out\n}\n\n/**\n * RFC4648 Factory\n *\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {string} options.alphabet\n * @param {number} options.bitsPerChar\n */\nexport const rfc4648 = ({ name, prefix, bitsPerChar, alphabet }) => {\n  return from({\n    prefix,\n    name,\n    encode (input) {\n      return encode(input, alphabet, bitsPerChar)\n    },\n    decode (input) {\n      return decode(input, alphabet, bitsPerChar, name)\n    }\n  })\n}\n", "import { baseX } from './base.js'\n\nexport const base10 = baseX({\n  prefix: '9',\n  name: 'base10',\n  alphabet: '0123456789'\n})\n", "// @ts-check\n\nimport { rfc4648 } from './base.js'\n\nexport const base16 = rfc4648({\n  prefix: 'f',\n  name: 'base16',\n  alphabet: '0123456789abcdef',\n  bitsPerChar: 4\n})\n\nexport const base16upper = rfc4648({\n  prefix: 'F',\n  name: 'base16upper',\n  alphabet: '0123456789ABCDEF',\n  bitsPerChar: 4\n})\n", "// @ts-check\n\nimport { rfc4648 } from './base.js'\n\nexport const base2 = rfc4648({\n  prefix: '0',\n  name: 'base2',\n  alphabet: '01',\n  bitsPerChar: 1\n})\n", "import { from } from './base.js'\n\nconst alphabet = Array.from('🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂')\nconst alphabetBytesToChars = /** @type {string[]} */ (alphabet.reduce((p, c, i) => { p[i] = c; return p }, /** @type {string[]} */([])))\nconst alphabetCharsToBytes = /** @type {number[]} */ (alphabet.reduce((p, c, i) => { p[/** @type {number} */ (c.codePointAt(0))] = i; return p }, /** @type {number[]} */([])))\n\n/**\n * @param {Uint8Array} data\n * @returns {string}\n */\nfunction encode (data) {\n  return data.reduce((p, c) => {\n    p += alphabetBytesToChars[c]\n    return p\n  }, '')\n}\n\n/**\n * @param {string} str\n * @returns {Uint8Array}\n */\nfunction decode (str) {\n  const byts = []\n  for (const char of str) {\n    const byt = alphabetCharsToBytes[/** @type {number} */ (char.codePointAt(0))]\n    if (byt === undefined) {\n      throw new Error(`Non-base256emoji character: ${char}`)\n    }\n    byts.push(byt)\n  }\n  return new Uint8Array(byts)\n}\n\nexport const base256emoji = from({\n  prefix: '🚀',\n  name: 'base256emoji',\n  encode,\n  decode\n})\n", "import { rfc4648 } from './base.js'\n\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n})\n\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n})\n\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n})\n\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n})\n\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n})\n\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n})\n\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n})\n\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n})\n\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n})\n", "import { baseX } from './base.js'\n\nexport const base36 = baseX({\n  prefix: 'k',\n  name: 'base36',\n  alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'\n})\n\nexport const base36upper = baseX({\n  prefix: 'K',\n  name: 'base36upper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n})\n", "// @ts-check\n\nimport { rfc4648 } from './base.js'\n\nexport const base64 = rfc4648({\n  prefix: 'm',\n  name: 'base64',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n  bitsPerChar: 6\n})\n\nexport const base64pad = rfc4648({\n  prefix: 'M',\n  name: 'base64pad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n  bitsPerChar: 6\n})\n\nexport const base64url = rfc4648({\n  prefix: 'u',\n  name: 'base64url',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n  bitsPerChar: 6\n})\n\nexport const base64urlpad = rfc4648({\n  prefix: 'U',\n  name: 'base64urlpad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',\n  bitsPerChar: 6\n})\n", "// @ts-check\n\nimport { rfc4648 } from './base.js'\n\nexport const base8 = rfc4648({\n  prefix: '7',\n  name: 'base8',\n  alphabet: '01234567',\n  bitsPerChar: 3\n})\n", "// @ts-check\n\nimport { fromString, toString } from '../bytes.js'\nimport { from } from './base.js'\n\nexport const identity = from({\n  prefix: '\\x00',\n  name: 'identity',\n  encode: (buf) => toString(buf),\n  decode: (str) => fromString(str)\n})\n", "// @ts-check\n\n/**\n * @template T\n * @typedef {import('./interface.js').ByteView<T>} ByteView\n */\n\nconst textEncoder = new TextEncoder()\nconst textDecoder = new TextDecoder()\n\nexport const name = 'json'\nexport const code = 0x0200\n\n/**\n * @template T\n * @param {T} node\n * @returns {ByteView<T>}\n */\nexport const encode = (node) => textEncoder.encode(JSON.stringify(node))\n\n/**\n * @template T\n * @param {ByteView<T>} data\n * @returns {T}\n */\nexport const decode = (data) => JSON.parse(textDecoder.decode(data))\n", "import { coerce } from '../bytes.js'\nimport * as Digest from './digest.js'\n\nconst code = 0x0\nconst name = 'identity'\n\n/** @type {(input:Uint8Array) => Uint8Array} */\nconst encode = coerce\n\n/**\n * @param {Uint8Array} input\n * @returns {Digest.Digest<typeof code, number>}\n */\nconst digest = (input) => Digest.create(code, encode(input))\n\nexport const identity = { code, name, encode, digest }\n", "var encode_1 = encode;\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31);\n\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num /= 128;\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  \n  encode.bytes = offset - oldOffset + 1;\n  \n  return out\n}\n\nvar decode = read;\n\nvar MSB$1 = 0x80\n  , REST$1 = 0x7F;\n\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length;\n\n  do {\n    if (counter >= l) {\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++];\n    res += shift < 28\n      ? (b & REST$1) << shift\n      : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1)\n\n  read.bytes = counter - offset;\n\n  return res\n}\n\nvar N1 = Math.pow(2,  7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\n\nvar length = function (value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n};\n\nvar varint = {\n    encode: encode_1\n  , decode: decode\n  , encodingLength: length\n};\n\nvar _brrp_varint = varint;\n\nexport default _brrp_varint;\n", "import varint from '../vendor/varint.js'\n\n/**\n * @param {Uint8Array} data\n * @param {number} [offset=0]\n * @returns {[number, number]}\n */\nexport const decode = (data, offset = 0) => {\n  const code = varint.decode(data, offset)\n  return [code, varint.decode.bytes]\n}\n\n/**\n * @param {number} int\n * @param {Uint8Array} target\n * @param {number} [offset=0]\n */\nexport const encodeTo = (int, target, offset = 0) => {\n  varint.encode(int, target, offset)\n  return target\n}\n\n/**\n * @param {number} int\n * @returns {number}\n */\nexport const encodingLength = (int) => {\n  return varint.encodingLength(int)\n}\n", "import { coerce, equals as equalBytes } from '../bytes.js'\nimport * as varint from '../varint.js'\n\n/**\n * Creates a multihash digest.\n *\n * @template {number} Code\n * @param {Code} code\n * @param {Uint8Array} digest\n */\nexport const create = (code, digest) => {\n  const size = digest.byteLength\n  const sizeOffset = varint.encodingLength(code)\n  const digestOffset = sizeOffset + varint.encodingLength(size)\n\n  const bytes = new Uint8Array(digestOffset + size)\n  varint.encodeTo(code, bytes, 0)\n  varint.encodeTo(size, bytes, sizeOffset)\n  bytes.set(digest, digestOffset)\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * Turns bytes representation of multihash digest into an instance.\n *\n * @param {Uint8Array} multihash\n * @returns {MultihashDigest}\n */\nexport const decode = (multihash) => {\n  const bytes = coerce(multihash)\n  const [code, sizeOffset] = varint.decode(bytes)\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset))\n  const digest = bytes.subarray(sizeOffset + digestOffset)\n\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length')\n  }\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * @param {MultihashDigest} a\n * @param {unknown} b\n * @returns {b is MultihashDigest}\n */\nexport const equals = (a, b) => {\n  if (a === b) {\n    return true\n  } else {\n    const data = /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */(b)\n\n    return (\n      a.code === data.code &&\n      a.size === data.size &&\n      data.bytes instanceof Uint8Array &&\n      equalBytes(a.bytes, data.bytes)\n    )\n  }\n}\n\n/**\n * @typedef {import('./interface.js').MultihashDigest} MultihashDigest\n */\n\n/**\n * Represents a multihash digest which carries information about the\n * hashing algorithm and an actual hash digest.\n *\n * @template {number} Code\n * @template {number} Size\n * @class\n * @implements {MultihashDigest}\n */\nexport class Digest {\n  /**\n   * Creates a multihash digest.\n   *\n   * @param {Code} code\n   * @param {Size} size\n   * @param {Uint8Array} digest\n   * @param {Uint8Array} bytes\n   */\n  constructor (code, size, digest, bytes) {\n    this.code = code\n    this.size = size\n    this.digest = digest\n    this.bytes = bytes\n  }\n}\n", "/* global crypto */\n\nimport { from } from './hasher.js'\n\n/**\n * @param {AlgorithmIdentifier} name\n */\nconst sha = name =>\n  /**\n   * @param {Uint8Array} data\n   */\n  async data => new Uint8Array(await crypto.subtle.digest(name, data))\n\nexport const sha256 = from({\n  name: 'sha2-256',\n  code: 0x12,\n  encode: sha('SHA-256')\n})\n\nexport const sha512 = from({\n  name: 'sha2-512',\n  code: 0x13,\n  encode: sha('SHA-512')\n})\n", "import * as Digest from './digest.js'\n\n/**\n * @template {string} Name\n * @template {number} Code\n * @param {object} options\n * @param {Name} options.name\n * @param {Code} options.code\n * @param {(input: Uint8Array) => Await<Uint8Array>} options.encode\n */\nexport const from = ({ name, code, encode }) => new Hasher(name, code, encode)\n\n/**\n * Hasher represents a hashing algorithm implementation that produces as\n * `MultihashDigest`.\n *\n * @template {string} Name\n * @template {number} Code\n * @class\n * @implements {MultihashHasher<Code>}\n */\nexport class Hasher {\n  /**\n   *\n   * @param {Name} name\n   * @param {Code} code\n   * @param {(input: Uint8Array) => Await<Uint8Array>} encode\n   */\n  constructor (name, code, encode) {\n    this.name = name\n    this.code = code\n    this.encode = encode\n  }\n\n  /**\n   * @param {Uint8Array} input\n   * @returns {Await<Digest.Digest<Code, number>>}\n   */\n  digest (input) {\n    if (input instanceof Uint8Array) {\n      const result = this.encode(input)\n      return result instanceof Uint8Array\n        ? Digest.create(this.code, result)\n        /* c8 ignore next 1 */\n        : result.then(digest => Digest.create(this.code, digest))\n    } else {\n      throw Error('Unknown type, must be binary type')\n      /* c8 ignore next 1 */\n    }\n  }\n}\n\n/**\n * @template {number} Alg\n * @typedef {import('./interface.js').MultihashHasher} MultihashHasher\n */\n\n/**\n * @template T\n * @typedef {Promise<T>|T} Await\n */\n", "import { base32 } from './bases/base32.js'\nimport { base58btc } from './bases/base58.js'\nimport { coerce } from './bytes.js'\nimport * as Digest from './hashes/digest.js'\n// Linter can see that API is used in types.\n// eslint-disable-next-line\nimport * as API from \"./link/interface.js\"\nimport * as varint from './varint.js'\n\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\n/**\n * @template {API.Link<unknown, number, number, API.Version>} T\n * @template {string} Prefix\n * @param {T} link\n * @param {API.MultibaseEncoder<Prefix>} [base]\n * @returns {API.ToString<T, Prefix>}\n */\nexport const format = (link, base) => {\n  const { bytes, version } = link\n  switch (version) {\n    case 0:\n      return toStringV0(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<\"z\">} */ (base) || base58btc.encoder\n      )\n    default:\n      return toStringV1(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<Prefix>} */ (base || base32.encoder)\n      )\n  }\n}\n\n/**\n * @template {API.UnknownLink} Link\n * @param {Link} link\n * @returns {API.LinkJSON<Link>}\n */\nexport const toJSON = (link) => ({\n  '/': format(link)\n})\n\n/**\n * @template {API.UnknownLink} Link\n * @param {API.LinkJSON<Link>} json\n */\nexport const fromJSON = (json) =>\n  CID.parse(json['/'])\n\n/** @type {WeakMap<API.UnknownLink, Map<string, string>>} */\nconst cache = new WeakMap()\n\n/**\n * @param {API.UnknownLink} cid\n * @returns {Map<string, string>}\n */\nconst baseCache = cid => {\n  const baseCache = cache.get(cid)\n  if (baseCache == null) {\n    const baseCache = new Map()\n    cache.set(cid, baseCache)\n    return baseCache\n  }\n  return baseCache\n}\n\n/**\n * @template {unknown} [Data=unknown]\n * @template {number} [Format=number]\n * @template {number} [Alg=number]\n * @template {API.Version} [Version=API.Version]\n * @implements {API.Link<Data, Format, Alg, Version>}\n */\n\nexport class CID {\n  /**\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.\n   * @param {Uint8Array} bytes\n   */\n  constructor (version, code, multihash, bytes) {\n    /** @readonly */\n    this.code = code\n    /** @readonly */\n    this.version = version\n    /** @readonly */\n    this.multihash = multihash\n    /** @readonly */\n    this.bytes = bytes\n\n    // flag to serializers that this is a CID and\n    // should be treated specially\n    /** @readonly */\n    this['/'] = bytes\n  }\n\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n  get asCID () {\n    return this\n  }\n\n  // ArrayBufferView\n  get byteOffset () {\n    return this.bytes.byteOffset\n  }\n\n  // ArrayBufferView\n  get byteLength () {\n    return this.bytes.byteLength\n  }\n\n  /**\n   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}\n   */\n  toV0 () {\n    switch (this.version) {\n      case 0: {\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (this)\n      }\n      case 1: {\n        const { code, multihash } = this\n\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n        }\n\n        // sha2-256\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n        }\n\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (\n          CID.createV0(\n            /** @type {API.MultihashDigest<API.SHA_256>} */ (multihash)\n          )\n        )\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 0. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @returns {CID<Data, Format, Alg, 1>}\n   */\n  toV1 () {\n    switch (this.version) {\n      case 0: {\n        const { code, digest } = this.multihash\n        const multihash = Digest.create(code, digest)\n        return /** @type {CID<Data, Format, Alg, 1>} */ (\n          CID.createV1(this.code, multihash)\n        )\n      }\n      case 1: {\n        return /** @type {CID<Data, Format, Alg, 1>} */ (this)\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 1. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @param {unknown} other\n   * @returns {other is CID<Data, Format, Alg, Version>}\n   */\n  equals (other) {\n    return CID.equals(this, other)\n  }\n\n  /**\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {API.Link<Data, Format, Alg, Version>} self\n   * @param {unknown} other\n   * @returns {other is CID}\n   */\n  static equals (self, other) {\n    const unknown =\n      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */ (\n        other\n      )\n    return (\n      unknown &&\n      self.code === unknown.code &&\n      self.version === unknown.version &&\n      Digest.equals(self.multihash, unknown.multihash)\n    )\n  }\n\n  /**\n   * @param {API.MultibaseEncoder<string>} [base]\n   * @returns {string}\n   */\n  toString (base) {\n    return format(this, base)\n  }\n\n  /**\n   * @returns {API.LinkJSON<this>}\n   */\n  toJSON () {\n    return { '/': format(this) }\n  }\n\n  link () {\n    return this\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'CID'\n  }\n\n  // Legacy\n\n  [Symbol.for('nodejs.util.inspect.custom')] () {\n    return `CID(${this.toString()})`\n  }\n\n  /**\n   * Takes any input `value` and returns a `CID` instance if it was\n   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n   * it will return value back. If `value` is not instance of this CID\n   * class, but is compatible CID it will return new instance of this\n   * `CID` class. Otherwise returns null.\n   *\n   * This allows two different incompatible versions of CID library to\n   * co-exist and interop as long as binary interface is compatible.\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @template {unknown} U\n   * @param {API.Link<Data, Format, Alg, Version>|U} input\n   * @returns {CID<Data, Format, Alg, Version>|null}\n   */\n  static asCID (input) {\n    if (input == null) {\n      return null\n    }\n\n    const value = /** @type {any} */ (input)\n    if (value instanceof CID) {\n      // If value is instance of CID then we're all set.\n      return value\n    } else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n      // If value isn't instance of this CID class but `this.asCID === this` or\n      // `value['/'] === value.bytes` is true it is CID instance coming from a\n      // different implementation (diff version or duplicate). In that case we\n      // rebase it to this `CID` implementation so caller is guaranteed to get\n      // instance with expected API.\n      const { version, code, multihash, bytes } = value\n      return new CID(\n        version,\n        code,\n        /** @type {API.MultihashDigest<Alg>} */ (multihash),\n        bytes || encodeCID(version, code, multihash.bytes)\n      )\n    } else if (value[cidSymbol] === true) {\n      // If value is a CID from older implementation that used to be tagged via\n      // symbol we still rebase it to the this `CID` implementation by\n      // delegating that to a constructor.\n      const { version, multihash, code } = value\n      const digest =\n        /** @type {API.MultihashDigest<Alg>} */\n        (Digest.decode(multihash))\n      return CID.create(version, code, digest)\n    } else {\n      // Otherwise value is not a CID (or an incompatible version of it) in\n      // which case we return `null`.\n      return null\n    }\n  }\n\n  /**\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.\n   * @returns {CID<Data, Format, Alg, Version>}\n   */\n  static create (version, code, digest) {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported')\n    }\n\n    if (!(digest.bytes instanceof Uint8Array)) {\n      throw new Error('Invalid digest')\n    }\n\n    switch (version) {\n      case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(\n            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`\n          )\n        } else {\n          return new CID(version, code, digest, digest.bytes)\n        }\n      }\n      case 1: {\n        const bytes = encodeCID(version, code, digest.bytes)\n        return new CID(version, code, digest, bytes)\n      }\n      default: {\n        throw new Error('Invalid version')\n      }\n    }\n  }\n\n  /**\n   * Simplified version of `create` for CIDv0.\n   *\n   * @template {unknown} [T=unknown]\n   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.\n   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}\n   */\n  static createV0 (digest) {\n    return CID.create(0, DAG_PB_CODE, digest)\n  }\n\n  /**\n   * Simplified version of `create` for CIDv1.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @param {Code} code - Content encoding format code.\n   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.\n   * @returns {CID<Data, Code, Alg, 1>}\n   */\n  static createV1 (code, digest) {\n    return CID.create(1, code, digest)\n  }\n\n  /**\n   * Decoded a CID from its binary representation. The byte array must contain\n   * only the CID with no additional bytes.\n   *\n   * An error will be thrown if the bytes provided do not contain a valid\n   * binary representation of a CID.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static decode (bytes) {\n    const [cid, remainder] = CID.decodeFirst(bytes)\n    if (remainder.length) {\n      throw new Error('Incorrect length')\n    }\n    return cid\n  }\n\n  /**\n   * Decoded a CID from its binary representation at the beginning of a byte\n   * array.\n   *\n   * Returns an array with the first element containing the CID and the second\n   * element containing the remainder of the original byte array. The remainder\n   * will be a zero-length byte array if the provided bytes only contained a\n   * binary CID representation.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes\n   * @returns {[CID<T, C, A, V>, Uint8Array]}\n   */\n  static decodeFirst (bytes) {\n    const specs = CID.inspectBytes(bytes)\n    const prefixSize = specs.size - specs.multihashSize\n    const multihashBytes = coerce(\n      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)\n    )\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length')\n    }\n    const digestBytes = multihashBytes.subarray(\n      specs.multihashSize - specs.digestSize\n    )\n    const digest = new Digest.Digest(\n      specs.multihashCode,\n      specs.digestSize,\n      digestBytes,\n      multihashBytes\n    )\n    const cid =\n      specs.version === 0\n        ? CID.createV0(/** @type {API.MultihashDigest<API.SHA_256>} */ (digest))\n        : CID.createV1(specs.codec, digest)\n    return [/** @type {CID<T, C, A, V>} */(cid), bytes.subarray(specs.size)]\n  }\n\n  /**\n   * Inspect the initial bytes of a CID to determine its properties.\n   *\n   * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n   * bytes but for larger multicodec code values and larger multihash digest\n   * lengths these varints can be quite large. It is recommended that at least\n   * 10 bytes be made available in the `initialBytes` argument for a complete\n   * inspection.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes\n   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}\n   */\n  static inspectBytes (initialBytes) {\n    let offset = 0\n    const next = () => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset))\n      offset += length\n      return i\n    }\n\n    let version = /** @type {V} */ (next())\n    let codec = /** @type {C} */ (DAG_PB_CODE)\n    if (/** @type {number} */(version) === 18) {\n      // CIDv0\n      version = /** @type {V} */ (0)\n      offset = 0\n    } else {\n      codec = /** @type {C} */ (next())\n    }\n\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`)\n    }\n\n    const prefixSize = offset\n    const multihashCode = /** @type {A} */ (next()) // multihash code\n    const digestSize = next() // multihash length\n    const size = offset + digestSize\n    const multihashSize = size - prefixSize\n\n    return { version, codec, multihashCode, digestSize, multihashSize, size }\n  }\n\n  /**\n   * Takes cid in a string representation and creates an instance. If `base`\n   * decoder is not provided will use a default from the configuration. It will\n   * throw an error if encoding of the CID is not compatible with supplied (or\n   * a default decoder).\n   *\n   * @template {string} Prefix\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n   * @param {API.MultibaseDecoder<Prefix>} [base]\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static parse (source, base) {\n    const [prefix, bytes] = parseCIDtoBytes(source, base)\n\n    const cid = CID.decode(bytes)\n\n    if (cid.version === 0 && source[0] !== 'Q') {\n      throw Error('Version 0 CID string must not include multibase prefix')\n    }\n\n    // Cache string representation to avoid computing it on `this.toString()`\n    baseCache(cid).set(prefix, source)\n\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @template {unknown} Data\n * @template {number} Code\n * @template {number} Alg\n * @template {API.Version} Ver\n * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n * @param {API.MultibaseDecoder<Prefix>} [base]\n * @returns {[Prefix, API.ByteView<API.Link<Data, Code, Alg, Ver>>]}\n */\nconst parseCIDtoBytes = (source, base) => {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q': {\n      const decoder = base || base58btc\n      return [\n        /** @type {Prefix} */ (base58btc.prefix),\n        decoder.decode(`${base58btc.prefix}${source}`)\n      ]\n    }\n    case base58btc.prefix: {\n      const decoder = base || base58btc\n      return [/** @type {Prefix} */(base58btc.prefix), decoder.decode(source)]\n    }\n    case base32.prefix: {\n      const decoder = base || base32\n      return [/** @type {Prefix} */(base32.prefix), decoder.decode(source)]\n    }\n    default: {\n      if (base == null) {\n        throw Error(\n          'To parse non base32 or base58btc encoded CID multibase decoder must be provided'\n        )\n      }\n      return [/** @type {Prefix} */(source[0]), base.decode(source)]\n    }\n  }\n}\n\n/**\n *\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<'z'>} base\n */\nconst toStringV0 = (bytes, cache, base) => {\n  const { prefix } = base\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`)\n  }\n\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<Prefix>} base\n */\nconst toStringV1 = (bytes, cache, base) => {\n  const { prefix } = base\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nconst DAG_PB_CODE = 0x70\nconst SHA_256_CODE = 0x12\n\n/**\n * @param {API.Version} version\n * @param {number} code\n * @param {Uint8Array} multihash\n * @returns {Uint8Array}\n */\nconst encodeCID = (version, code, multihash) => {\n  const codeOffset = varint.encodingLength(version)\n  const hashOffset = codeOffset + varint.encodingLength(code)\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength)\n  varint.encodeTo(version, bytes, 0)\n  varint.encodeTo(code, bytes, codeOffset)\n  bytes.set(multihash, hashOffset)\n  return bytes\n}\n\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID')\n", "// @ts-check\n\nimport * as base10 from './bases/base10.js'\nimport * as base16 from './bases/base16.js'\nimport * as base2 from './bases/base2.js'\nimport * as base256emoji from './bases/base256emoji.js'\nimport * as base32 from './bases/base32.js'\nimport * as base36 from './bases/base36.js'\nimport * as base58 from './bases/base58.js'\nimport * as base64 from './bases/base64.js'\nimport * as base8 from './bases/base8.js'\nimport * as identityBase from './bases/identity.js'\nimport * as json from './codecs/json.js'\nimport * as raw from './codecs/raw.js'\nimport * as identity from './hashes/identity.js'\nimport * as sha2 from './hashes/sha2.js'\nimport { CID, hasher, digest, varint, bytes } from './index.js'\n\nconst bases = { ...identityBase, ...base2, ...base8, ...base10, ...base16, ...base32, ...base36, ...base58, ...base64, ...base256emoji }\nconst hashes = { ...sha2, ...identity }\nconst codecs = { raw, json }\n\nexport { CID, hasher, digest, varint, bytes, hashes, bases, codecs }\n", "/**\n * Returns true if the two passed Uint8Arrays have the same content\n */\nexport function equals (a: Uint8Array, b: Uint8Array): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (a.byteLength !== b.byteLength) {\n    return false\n  }\n\n  for (let i = 0; i < a.byteLength; i++) {\n    if (a[i] !== b[i]) {\n      return false\n    }\n  }\n\n  return true\n}\n", "/**\n * @packageDocumentation\n *\n * An implementation of a peer id\n *\n * @example\n *\n * ```JavaScript\n * import { peerIdFromString } from '@libp2p/peer-id'\n * const peer = peerIdFromString('k51qzi5uqu5dkwkqm42v9j9kqcam2jiuvloi16g72i4i4amoo2m8u3ol3mqu6s')\n *\n * console.log(peer.toCid()) // CID(bafzaa...)\n * console.log(peer.toString()) // \"12D3K...\"\n * ```\n */\n\nimport { CodeError } from '@libp2p/interface/errors'\nimport { type Ed25519PeerId, type PeerIdType, type RSAPeerId, type Secp256k1PeerId, symbol, type PeerId } from '@libp2p/interface/peer-id'\nimport { base58btc } from 'multiformats/bases/base58'\nimport { bases } from 'multiformats/basics'\nimport { CID } from 'multiformats/cid'\nimport * as Digest from 'multiformats/hashes/digest'\nimport { identity } from 'multiformats/hashes/identity'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport type { MultibaseDecoder } from 'multiformats/bases/interface'\nimport type { MultihashDigest } from 'multiformats/hashes/interface'\n\nconst inspect = Symbol.for('nodejs.util.inspect.custom')\n\nconst baseDecoder = Object\n  .values(bases)\n  .map(codec => codec.decoder)\n  // @ts-expect-error https://github.com/multiformats/js-multiformats/issues/141\n  .reduce((acc, curr) => acc.or(curr), bases.identity.decoder)\n\n// these values are from https://github.com/multiformats/multicodec/blob/master/table.csv\nconst LIBP2P_KEY_CODE = 0x72\n\nconst MARSHALLED_ED225519_PUBLIC_KEY_LENGTH = 36\nconst MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH = 37\n\ninterface PeerIdInit {\n  type: PeerIdType\n  multihash: MultihashDigest\n  privateKey?: Uint8Array\n}\n\ninterface RSAPeerIdInit {\n  multihash: MultihashDigest\n  privateKey?: Uint8Array\n  publicKey?: Uint8Array\n}\n\ninterface Ed25519PeerIdInit {\n  multihash: MultihashDigest\n  privateKey?: Uint8Array\n}\n\ninterface Secp256k1PeerIdInit {\n  multihash: MultihashDigest\n  privateKey?: Uint8Array\n}\n\nclass PeerIdImpl {\n  public type: PeerIdType\n  public readonly multihash: MultihashDigest\n  public readonly privateKey?: Uint8Array\n  public readonly publicKey?: Uint8Array\n  private string?: string\n\n  constructor (init: PeerIdInit) {\n    this.type = init.type\n    this.multihash = init.multihash\n    this.privateKey = init.privateKey\n\n    // mark string cache as non-enumerable\n    Object.defineProperty(this, 'string', {\n      enumerable: false,\n      writable: true\n    })\n  }\n\n  get [Symbol.toStringTag] (): string {\n    return `PeerId(${this.toString()})`\n  }\n\n  readonly [symbol] = true\n\n  toString (): string {\n    if (this.string == null) {\n      this.string = base58btc.encode(this.multihash.bytes).slice(1)\n    }\n\n    return this.string\n  }\n\n  // return self-describing String representation\n  // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209\n  toCID (): CID {\n    return CID.createV1(LIBP2P_KEY_CODE, this.multihash)\n  }\n\n  toBytes (): Uint8Array {\n    return this.multihash.bytes\n  }\n\n  /**\n   * Returns Multiaddr as a JSON string\n   */\n  toJSON (): string {\n    return this.toString()\n  }\n\n  /**\n   * Checks the equality of `this` peer against a given PeerId\n   */\n  equals (id: PeerId | Uint8Array | string): boolean {\n    if (id instanceof Uint8Array) {\n      return uint8ArrayEquals(this.multihash.bytes, id)\n    } else if (typeof id === 'string') {\n      return peerIdFromString(id).equals(this as PeerId)\n    } else if (id?.multihash?.bytes != null) {\n      return uint8ArrayEquals(this.multihash.bytes, id.multihash.bytes)\n    } else {\n      throw new Error('not valid Id')\n    }\n  }\n\n  /**\n   * Returns PeerId as a human-readable string\n   * https://nodejs.org/api/util.html#utilinspectcustom\n   *\n   * @example\n   * ```js\n   * import { peerIdFromString } from '@libp2p/peer-id'\n   *\n   * console.info(peerIdFromString('QmFoo'))\n   * // 'PeerId(QmFoo)'\n   * ```\n   */\n  [inspect] (): string {\n    return `PeerId(${this.toString()})`\n  }\n}\n\nclass RSAPeerIdImpl extends PeerIdImpl implements RSAPeerId {\n  public readonly type = 'RSA'\n  public readonly publicKey?: Uint8Array\n\n  constructor (init: RSAPeerIdInit) {\n    super({ ...init, type: 'RSA' })\n\n    this.publicKey = init.publicKey\n  }\n}\n\nclass Ed25519PeerIdImpl extends PeerIdImpl implements Ed25519PeerId {\n  public readonly type = 'Ed25519'\n  public readonly publicKey: Uint8Array\n\n  constructor (init: Ed25519PeerIdInit) {\n    super({ ...init, type: 'Ed25519' })\n\n    this.publicKey = init.multihash.digest\n  }\n}\n\nclass Secp256k1PeerIdImpl extends PeerIdImpl implements Secp256k1PeerId {\n  public readonly type = 'secp256k1'\n  public readonly publicKey: Uint8Array\n\n  constructor (init: Secp256k1PeerIdInit) {\n    super({ ...init, type: 'secp256k1' })\n\n    this.publicKey = init.multihash.digest\n  }\n}\n\nexport function createPeerId (init: PeerIdInit): PeerId {\n  if (init.type === 'RSA') {\n    return new RSAPeerIdImpl(init)\n  }\n\n  if (init.type === 'Ed25519') {\n    return new Ed25519PeerIdImpl(init)\n  }\n\n  if (init.type === 'secp256k1') {\n    return new Secp256k1PeerIdImpl(init)\n  }\n\n  throw new CodeError('Type must be \"RSA\", \"Ed25519\" or \"secp256k1\"', 'ERR_INVALID_PARAMETERS')\n}\n\nexport function peerIdFromPeerId (other: any): PeerId {\n  if (other.type === 'RSA') {\n    return new RSAPeerIdImpl(other)\n  }\n\n  if (other.type === 'Ed25519') {\n    return new Ed25519PeerIdImpl(other)\n  }\n\n  if (other.type === 'secp256k1') {\n    return new Secp256k1PeerIdImpl(other)\n  }\n\n  throw new CodeError('Not a PeerId', 'ERR_INVALID_PARAMETERS')\n}\n\nexport function peerIdFromString (str: string, decoder?: MultibaseDecoder<any>): PeerId {\n  decoder = decoder ?? baseDecoder\n\n  if (str.charAt(0) === '1' || str.charAt(0) === 'Q') {\n    // identity hash ed25519/secp256k1 key or sha2-256 hash of\n    // rsa public key - base58btc encoded either way\n    const multihash = Digest.decode(base58btc.decode(`z${str}`))\n\n    if (str.startsWith('12D')) {\n      return new Ed25519PeerIdImpl({ multihash })\n    } else if (str.startsWith('16U')) {\n      return new Secp256k1PeerIdImpl({ multihash })\n    } else {\n      return new RSAPeerIdImpl({ multihash })\n    }\n  }\n\n  return peerIdFromBytes(baseDecoder.decode(str))\n}\n\nexport function peerIdFromBytes (buf: Uint8Array): PeerId {\n  try {\n    const multihash = Digest.decode(buf)\n\n    if (multihash.code === identity.code) {\n      if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n        return new Ed25519PeerIdImpl({ multihash })\n      } else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n        return new Secp256k1PeerIdImpl({ multihash })\n      }\n    }\n\n    if (multihash.code === sha256.code) {\n      return new RSAPeerIdImpl({ multihash })\n    }\n  } catch {\n    return peerIdFromCID(CID.decode(buf))\n  }\n\n  throw new Error('Supplied PeerID CID is invalid')\n}\n\nexport function peerIdFromCID (cid: CID): PeerId {\n  if (cid == null || cid.multihash == null || cid.version == null || (cid.version === 1 && cid.code !== LIBP2P_KEY_CODE)) {\n    throw new Error('Supplied PeerID CID is invalid')\n  }\n\n  const multihash = cid.multihash\n\n  if (multihash.code === sha256.code) {\n    return new RSAPeerIdImpl({ multihash: cid.multihash })\n  } else if (multihash.code === identity.code) {\n    if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n      return new Ed25519PeerIdImpl({ multihash: cid.multihash })\n    } else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n      return new Secp256k1PeerIdImpl({ multihash: cid.multihash })\n    }\n  }\n\n  throw new Error('Supplied PeerID CID is invalid')\n}\n\n/**\n * @param publicKey - A marshalled public key\n * @param privateKey - A marshalled private key\n */\nexport async function peerIdFromKeys (publicKey: Uint8Array, privateKey?: Uint8Array): Promise<PeerId> {\n  if (publicKey.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n    return new Ed25519PeerIdImpl({ multihash: Digest.create(identity.code, publicKey), privateKey })\n  }\n\n  if (publicKey.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n    return new Secp256k1PeerIdImpl({ multihash: Digest.create(identity.code, publicKey), privateKey })\n  }\n\n  return new RSAPeerIdImpl({ multihash: await sha256.digest(publicKey), publicKey, privateKey })\n}\n", "import { baseX } from './base.js'\n\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n})\n\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n})\n", "// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET, name) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256);\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255;\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i);\n    var xc = x.charCodeAt(0);\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i;\n  }\n  var BASE = ALPHABET.length;\n  var LEADER = ALPHABET.charAt(0);\n  var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (source instanceof Uint8Array) ; else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source);\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0;\n    var length = 0;\n    var pbegin = 0;\n    var pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++;\n      zeroes++;\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n    var b58 = new Uint8Array(size);\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0;\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0;\n        b58[it1] = (carry % BASE) >>> 0;\n        carry = (carry / BASE) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      pbegin++;\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length;\n    while (it2 !== size && b58[it2] === 0) {\n      it2++;\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes);\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0;\n        // Skip leading spaces.\n    if (source[psz] === ' ') { return }\n        // Skip and count leading '1's.\n    var zeroes = 0;\n    var length = 0;\n    while (source[psz] === LEADER) {\n      zeroes++;\n      psz++;\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size);\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0;\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0;\n        b256[it3] = (carry % 256) >>> 0;\n        carry = (carry / 256) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      psz++;\n    }\n        // Skip trailing spaces.\n    if (source[psz] === ' ') { return }\n        // Skip leading zeroes in b256.\n    var it4 = size - length;\n    while (it4 !== size && b256[it4] === 0) {\n      it4++;\n    }\n    var vch = new Uint8Array(zeroes + (size - it4));\n    var j = zeroes;\n    while (it4 !== size) {\n      vch[j++] = b256[it4++];\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string);\n    if (buffer) { return buffer }\n    throw new Error(`Non-${name} character`)\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nvar src = base;\n\nvar _brrp__multiformats_scope_baseX = src;\n\nexport default _brrp__multiformats_scope_baseX;\n", "const empty = new Uint8Array(0)\n\n/**\n * @param {Uint8Array} d\n */\nconst toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')\n\n/**\n * @param {string} hex\n */\nconst fromHex = hex => {\n  const hexes = hex.match(/../g)\n  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty\n}\n\n/**\n * @param {Uint8Array} aa\n * @param {Uint8Array} bb\n */\nconst equals = (aa, bb) => {\n  if (aa === bb) return true\n  if (aa.byteLength !== bb.byteLength) {\n    return false\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @param {ArrayBufferView|ArrayBuffer|Uint8Array} o\n * @returns {Uint8Array}\n */\nconst coerce = o => {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o\n  if (o instanceof ArrayBuffer) return new Uint8Array(o)\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)\n  }\n  throw new Error('Unknown type, must be binary type')\n}\n\n/**\n * @param {any} o\n * @returns {o is ArrayBuffer|ArrayBufferView}\n */\nconst isBinary = o =>\n  o instanceof ArrayBuffer || ArrayBuffer.isView(o)\n\n/**\n * @param {string} str\n * @returns {Uint8Array}\n */\nconst fromString = str => (new TextEncoder()).encode(str)\n\n/**\n * @param {Uint8Array} b\n * @returns {string}\n */\nconst toString = b => (new TextDecoder()).decode(b)\n\nexport { equals, coerce, isBinary, fromHex, toHex, fromString, toString, empty }\n", "import basex from '../../vendor/base-x.js'\nimport { coerce } from '../bytes.js'\n// Linter can't see that API is used in types.\n// eslint-disable-next-line\nimport * as API from './interface.js'\n\n/**\n * Class represents both BaseEncoder and MultibaseEncoder meaning it\n * can be used to encode to multibase or base encode without multibase\n * prefix.\n *\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseEncoder<Prefix>}\n * @implements {API.BaseEncoder}\n */\nclass Encoder {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(bytes:Uint8Array) => string} baseEncode\n   */\n  constructor (name, prefix, baseEncode) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n  }\n\n  /**\n   * @param {Uint8Array} bytes\n   * @returns {API.Multibase<Prefix>}\n   */\n  encode (bytes) {\n    if (bytes instanceof Uint8Array) {\n      return `${this.prefix}${this.baseEncode(bytes)}`\n    } else {\n      throw Error('Unknown type, must be binary type')\n    }\n  }\n}\n\n/**\n * @template {string} Prefix\n */\n/**\n * Class represents both BaseDecoder and MultibaseDecoder so it could be used\n * to decode multibases (with matching prefix) or just base decode strings\n * with corresponding base encoding.\n *\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.UnibaseDecoder<Prefix>}\n * @implements {API.BaseDecoder}\n */\nclass Decoder {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(text:string) => Uint8Array} baseDecode\n   */\n  constructor (name, prefix, baseDecode) {\n    this.name = name\n    this.prefix = prefix\n    /* c8 ignore next 3 */\n    if (prefix.codePointAt(0) === undefined) {\n      throw new Error('Invalid prefix character')\n    }\n    /** @private */\n    this.prefixCodePoint = /** @type {number} */ (prefix.codePointAt(0))\n    this.baseDecode = baseDecode\n  }\n\n  /**\n   * @param {string} text\n   */\n  decode (text) {\n    if (typeof text === 'string') {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`)\n      }\n      return this.baseDecode(text.slice(this.prefix.length))\n    } else {\n      throw Error('Can only multibase decode strings')\n    }\n  }\n\n  /**\n   * @template {string} OtherPrefix\n   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder\n   * @returns {ComposedDecoder<Prefix|OtherPrefix>}\n   */\n  or (decoder) {\n    return or(this, decoder)\n  }\n}\n\n/**\n * @template {string} Prefix\n * @typedef {Record<Prefix, API.UnibaseDecoder<Prefix>>} Decoders\n */\n\n/**\n * @template {string} Prefix\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.CombobaseDecoder<Prefix>}\n */\nclass ComposedDecoder {\n  /**\n   * @param {Decoders<Prefix>} decoders\n   */\n  constructor (decoders) {\n    this.decoders = decoders\n  }\n\n  /**\n   * @template {string} OtherPrefix\n   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder\n   * @returns {ComposedDecoder<Prefix|OtherPrefix>}\n   */\n  or (decoder) {\n    return or(this, decoder)\n  }\n\n  /**\n   * @param {string} input\n   * @returns {Uint8Array}\n   */\n  decode (input) {\n    const prefix = /** @type {Prefix} */ (input[0])\n    const decoder = this.decoders[prefix]\n    if (decoder) {\n      return decoder.decode(input)\n    } else {\n      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)\n    }\n  }\n}\n\n/**\n * @template {string} L\n * @template {string} R\n * @param {API.UnibaseDecoder<L>|API.CombobaseDecoder<L>} left\n * @param {API.UnibaseDecoder<R>|API.CombobaseDecoder<R>} right\n * @returns {ComposedDecoder<L|R>}\n */\nexport const or = (left, right) => new ComposedDecoder(/** @type {Decoders<L|R>} */({\n  ...(left.decoders || { [/** @type API.UnibaseDecoder<L> */(left).prefix]: left }),\n  ...(right.decoders || { [/** @type API.UnibaseDecoder<R> */(right).prefix]: right })\n}))\n\n/**\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseCodec<Prefix>}\n * @implements {API.MultibaseEncoder<Prefix>}\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.BaseCodec}\n * @implements {API.BaseEncoder}\n * @implements {API.BaseDecoder}\n */\nexport class Codec {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(bytes:Uint8Array) => string} baseEncode\n   * @param {(text:string) => Uint8Array} baseDecode\n   */\n  constructor (name, prefix, baseEncode, baseDecode) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n    this.baseDecode = baseDecode\n    this.encoder = new Encoder(name, prefix, baseEncode)\n    this.decoder = new Decoder(name, prefix, baseDecode)\n  }\n\n  /**\n   * @param {Uint8Array} input\n   */\n  encode (input) {\n    return this.encoder.encode(input)\n  }\n\n  /**\n   * @param {string} input\n   */\n  decode (input) {\n    return this.decoder.decode(input)\n  }\n}\n\n/**\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {(bytes:Uint8Array) => string} options.encode\n * @param {(input:string) => Uint8Array} options.decode\n * @returns {Codec<Base, Prefix>}\n */\nexport const from = ({ name, prefix, encode, decode }) =>\n  new Codec(name, prefix, encode, decode)\n\n/**\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {string} options.alphabet\n * @returns {Codec<Base, Prefix>}\n */\nexport const baseX = ({ prefix, name, alphabet }) => {\n  const { encode, decode } = basex(alphabet, name)\n  return from({\n    prefix,\n    name,\n    encode,\n    /**\n     * @param {string} text\n     */\n    decode: text => coerce(decode(text))\n  })\n}\n\n/**\n * @param {string} string\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @param {string} name\n * @returns {Uint8Array}\n */\nconst decode = (string, alphabet, bitsPerChar, name) => {\n  // Build the character lookup table:\n  /** @type {Record<string, number>} */\n  const codes = {}\n  for (let i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i\n  }\n\n  // Count the padding bytes:\n  let end = string.length\n  while (string[end - 1] === '=') {\n    --end\n  }\n\n  // Allocate the output:\n  const out = new Uint8Array((end * bitsPerChar / 8) | 0)\n\n  // Parse the data:\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  let written = 0 // Next byte to write\n  for (let i = 0; i < end; ++i) {\n    // Read one character from the string:\n    const value = codes[string[i]]\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${name} character`)\n    }\n\n    // Append the bits to the buffer:\n    buffer = (buffer << bitsPerChar) | value\n    bits += bitsPerChar\n\n    // Write out some bits if the buffer has a byte's worth:\n    if (bits >= 8) {\n      bits -= 8\n      out[written++] = 0xff & (buffer >> bits)\n    }\n  }\n\n  // Verify that we have received just enough bits:\n  if (bits >= bitsPerChar || 0xff & (buffer << (8 - bits))) {\n    throw new SyntaxError('Unexpected end of data')\n  }\n\n  return out\n}\n\n/**\n * @param {Uint8Array} data\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @returns {string}\n */\nconst encode = (data, alphabet, bitsPerChar) => {\n  const pad = alphabet[alphabet.length - 1] === '='\n  const mask = (1 << bitsPerChar) - 1\n  let out = ''\n\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  for (let i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = (buffer << 8) | data[i]\n    bits += 8\n\n    // Write out as much as we can:\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar\n      out += alphabet[mask & (buffer >> bits)]\n    }\n  }\n\n  // Partial character:\n  if (bits) {\n    out += alphabet[mask & (buffer << (bitsPerChar - bits))]\n  }\n\n  // Add padding characters until we hit a byte boundary:\n  if (pad) {\n    while ((out.length * bitsPerChar) & 7) {\n      out += '='\n    }\n  }\n\n  return out\n}\n\n/**\n * RFC4648 Factory\n *\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {string} options.alphabet\n * @param {number} options.bitsPerChar\n */\nexport const rfc4648 = ({ name, prefix, bitsPerChar, alphabet }) => {\n  return from({\n    prefix,\n    name,\n    encode (input) {\n      return encode(input, alphabet, bitsPerChar)\n    },\n    decode (input) {\n      return decode(input, alphabet, bitsPerChar, name)\n    }\n  })\n}\n", "import { rfc4648 } from './base.js'\n\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n})\n\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n})\n\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n})\n\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n})\n\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n})\n\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n})\n\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n})\n\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n})\n\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n})\n", "var encode_1 = encode;\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31);\n\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num /= 128;\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  \n  encode.bytes = offset - oldOffset + 1;\n  \n  return out\n}\n\nvar decode = read;\n\nvar MSB$1 = 0x80\n  , REST$1 = 0x7F;\n\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length;\n\n  do {\n    if (counter >= l) {\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++];\n    res += shift < 28\n      ? (b & REST$1) << shift\n      : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1)\n\n  read.bytes = counter - offset;\n\n  return res\n}\n\nvar N1 = Math.pow(2,  7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\n\nvar length = function (value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n};\n\nvar varint = {\n    encode: encode_1\n  , decode: decode\n  , encodingLength: length\n};\n\nvar _brrp_varint = varint;\n\nexport default _brrp_varint;\n", "import varint from '../vendor/varint.js'\n\n/**\n * @param {Uint8Array} data\n * @param {number} [offset=0]\n * @returns {[number, number]}\n */\nexport const decode = (data, offset = 0) => {\n  const code = varint.decode(data, offset)\n  return [code, varint.decode.bytes]\n}\n\n/**\n * @param {number} int\n * @param {Uint8Array} target\n * @param {number} [offset=0]\n */\nexport const encodeTo = (int, target, offset = 0) => {\n  varint.encode(int, target, offset)\n  return target\n}\n\n/**\n * @param {number} int\n * @returns {number}\n */\nexport const encodingLength = (int) => {\n  return varint.encodingLength(int)\n}\n", "import { coerce, equals as equalBytes } from '../bytes.js'\nimport * as varint from '../varint.js'\n\n/**\n * Creates a multihash digest.\n *\n * @template {number} Code\n * @param {Code} code\n * @param {Uint8Array} digest\n */\nexport const create = (code, digest) => {\n  const size = digest.byteLength\n  const sizeOffset = varint.encodingLength(code)\n  const digestOffset = sizeOffset + varint.encodingLength(size)\n\n  const bytes = new Uint8Array(digestOffset + size)\n  varint.encodeTo(code, bytes, 0)\n  varint.encodeTo(size, bytes, sizeOffset)\n  bytes.set(digest, digestOffset)\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * Turns bytes representation of multihash digest into an instance.\n *\n * @param {Uint8Array} multihash\n * @returns {MultihashDigest}\n */\nexport const decode = (multihash) => {\n  const bytes = coerce(multihash)\n  const [code, sizeOffset] = varint.decode(bytes)\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset))\n  const digest = bytes.subarray(sizeOffset + digestOffset)\n\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length')\n  }\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * @param {MultihashDigest} a\n * @param {unknown} b\n * @returns {b is MultihashDigest}\n */\nexport const equals = (a, b) => {\n  if (a === b) {\n    return true\n  } else {\n    const data = /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */(b)\n\n    return (\n      a.code === data.code &&\n      a.size === data.size &&\n      data.bytes instanceof Uint8Array &&\n      equalBytes(a.bytes, data.bytes)\n    )\n  }\n}\n\n/**\n * @typedef {import('./interface.js').MultihashDigest} MultihashDigest\n */\n\n/**\n * Represents a multihash digest which carries information about the\n * hashing algorithm and an actual hash digest.\n *\n * @template {number} Code\n * @template {number} Size\n * @class\n * @implements {MultihashDigest}\n */\nexport class Digest {\n  /**\n   * Creates a multihash digest.\n   *\n   * @param {Code} code\n   * @param {Size} size\n   * @param {Uint8Array} digest\n   * @param {Uint8Array} bytes\n   */\n  constructor (code, size, digest, bytes) {\n    this.code = code\n    this.size = size\n    this.digest = digest\n    this.bytes = bytes\n  }\n}\n", "import { base32 } from './bases/base32.js'\nimport { base58btc } from './bases/base58.js'\nimport { coerce } from './bytes.js'\nimport * as Digest from './hashes/digest.js'\n// Linter can see that API is used in types.\n// eslint-disable-next-line\nimport * as API from \"./link/interface.js\"\nimport * as varint from './varint.js'\n\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\n/**\n * @template {API.Link<unknown, number, number, API.Version>} T\n * @template {string} Prefix\n * @param {T} link\n * @param {API.MultibaseEncoder<Prefix>} [base]\n * @returns {API.ToString<T, Prefix>}\n */\nexport const format = (link, base) => {\n  const { bytes, version } = link\n  switch (version) {\n    case 0:\n      return toStringV0(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<\"z\">} */ (base) || base58btc.encoder\n      )\n    default:\n      return toStringV1(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<Prefix>} */ (base || base32.encoder)\n      )\n  }\n}\n\n/**\n * @template {API.UnknownLink} Link\n * @param {Link} link\n * @returns {API.LinkJSON<Link>}\n */\nexport const toJSON = (link) => ({\n  '/': format(link)\n})\n\n/**\n * @template {API.UnknownLink} Link\n * @param {API.LinkJSON<Link>} json\n */\nexport const fromJSON = (json) =>\n  CID.parse(json['/'])\n\n/** @type {WeakMap<API.UnknownLink, Map<string, string>>} */\nconst cache = new WeakMap()\n\n/**\n * @param {API.UnknownLink} cid\n * @returns {Map<string, string>}\n */\nconst baseCache = cid => {\n  const baseCache = cache.get(cid)\n  if (baseCache == null) {\n    const baseCache = new Map()\n    cache.set(cid, baseCache)\n    return baseCache\n  }\n  return baseCache\n}\n\n/**\n * @template {unknown} [Data=unknown]\n * @template {number} [Format=number]\n * @template {number} [Alg=number]\n * @template {API.Version} [Version=API.Version]\n * @implements {API.Link<Data, Format, Alg, Version>}\n */\n\nexport class CID {\n  /**\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.\n   * @param {Uint8Array} bytes\n   */\n  constructor (version, code, multihash, bytes) {\n    /** @readonly */\n    this.code = code\n    /** @readonly */\n    this.version = version\n    /** @readonly */\n    this.multihash = multihash\n    /** @readonly */\n    this.bytes = bytes\n\n    // flag to serializers that this is a CID and\n    // should be treated specially\n    /** @readonly */\n    this['/'] = bytes\n  }\n\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n  get asCID () {\n    return this\n  }\n\n  // ArrayBufferView\n  get byteOffset () {\n    return this.bytes.byteOffset\n  }\n\n  // ArrayBufferView\n  get byteLength () {\n    return this.bytes.byteLength\n  }\n\n  /**\n   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}\n   */\n  toV0 () {\n    switch (this.version) {\n      case 0: {\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (this)\n      }\n      case 1: {\n        const { code, multihash } = this\n\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n        }\n\n        // sha2-256\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n        }\n\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (\n          CID.createV0(\n            /** @type {API.MultihashDigest<API.SHA_256>} */ (multihash)\n          )\n        )\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 0. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @returns {CID<Data, Format, Alg, 1>}\n   */\n  toV1 () {\n    switch (this.version) {\n      case 0: {\n        const { code, digest } = this.multihash\n        const multihash = Digest.create(code, digest)\n        return /** @type {CID<Data, Format, Alg, 1>} */ (\n          CID.createV1(this.code, multihash)\n        )\n      }\n      case 1: {\n        return /** @type {CID<Data, Format, Alg, 1>} */ (this)\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 1. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @param {unknown} other\n   * @returns {other is CID<Data, Format, Alg, Version>}\n   */\n  equals (other) {\n    return CID.equals(this, other)\n  }\n\n  /**\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {API.Link<Data, Format, Alg, Version>} self\n   * @param {unknown} other\n   * @returns {other is CID}\n   */\n  static equals (self, other) {\n    const unknown =\n      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */ (\n        other\n      )\n    return (\n      unknown &&\n      self.code === unknown.code &&\n      self.version === unknown.version &&\n      Digest.equals(self.multihash, unknown.multihash)\n    )\n  }\n\n  /**\n   * @param {API.MultibaseEncoder<string>} [base]\n   * @returns {string}\n   */\n  toString (base) {\n    return format(this, base)\n  }\n\n  /**\n   * @returns {API.LinkJSON<this>}\n   */\n  toJSON () {\n    return { '/': format(this) }\n  }\n\n  link () {\n    return this\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'CID'\n  }\n\n  // Legacy\n\n  [Symbol.for('nodejs.util.inspect.custom')] () {\n    return `CID(${this.toString()})`\n  }\n\n  /**\n   * Takes any input `value` and returns a `CID` instance if it was\n   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n   * it will return value back. If `value` is not instance of this CID\n   * class, but is compatible CID it will return new instance of this\n   * `CID` class. Otherwise returns null.\n   *\n   * This allows two different incompatible versions of CID library to\n   * co-exist and interop as long as binary interface is compatible.\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @template {unknown} U\n   * @param {API.Link<Data, Format, Alg, Version>|U} input\n   * @returns {CID<Data, Format, Alg, Version>|null}\n   */\n  static asCID (input) {\n    if (input == null) {\n      return null\n    }\n\n    const value = /** @type {any} */ (input)\n    if (value instanceof CID) {\n      // If value is instance of CID then we're all set.\n      return value\n    } else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n      // If value isn't instance of this CID class but `this.asCID === this` or\n      // `value['/'] === value.bytes` is true it is CID instance coming from a\n      // different implementation (diff version or duplicate). In that case we\n      // rebase it to this `CID` implementation so caller is guaranteed to get\n      // instance with expected API.\n      const { version, code, multihash, bytes } = value\n      return new CID(\n        version,\n        code,\n        /** @type {API.MultihashDigest<Alg>} */ (multihash),\n        bytes || encodeCID(version, code, multihash.bytes)\n      )\n    } else if (value[cidSymbol] === true) {\n      // If value is a CID from older implementation that used to be tagged via\n      // symbol we still rebase it to the this `CID` implementation by\n      // delegating that to a constructor.\n      const { version, multihash, code } = value\n      const digest =\n        /** @type {API.MultihashDigest<Alg>} */\n        (Digest.decode(multihash))\n      return CID.create(version, code, digest)\n    } else {\n      // Otherwise value is not a CID (or an incompatible version of it) in\n      // which case we return `null`.\n      return null\n    }\n  }\n\n  /**\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.\n   * @returns {CID<Data, Format, Alg, Version>}\n   */\n  static create (version, code, digest) {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported')\n    }\n\n    if (!(digest.bytes instanceof Uint8Array)) {\n      throw new Error('Invalid digest')\n    }\n\n    switch (version) {\n      case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(\n            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`\n          )\n        } else {\n          return new CID(version, code, digest, digest.bytes)\n        }\n      }\n      case 1: {\n        const bytes = encodeCID(version, code, digest.bytes)\n        return new CID(version, code, digest, bytes)\n      }\n      default: {\n        throw new Error('Invalid version')\n      }\n    }\n  }\n\n  /**\n   * Simplified version of `create` for CIDv0.\n   *\n   * @template {unknown} [T=unknown]\n   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.\n   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}\n   */\n  static createV0 (digest) {\n    return CID.create(0, DAG_PB_CODE, digest)\n  }\n\n  /**\n   * Simplified version of `create` for CIDv1.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @param {Code} code - Content encoding format code.\n   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.\n   * @returns {CID<Data, Code, Alg, 1>}\n   */\n  static createV1 (code, digest) {\n    return CID.create(1, code, digest)\n  }\n\n  /**\n   * Decoded a CID from its binary representation. The byte array must contain\n   * only the CID with no additional bytes.\n   *\n   * An error will be thrown if the bytes provided do not contain a valid\n   * binary representation of a CID.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static decode (bytes) {\n    const [cid, remainder] = CID.decodeFirst(bytes)\n    if (remainder.length) {\n      throw new Error('Incorrect length')\n    }\n    return cid\n  }\n\n  /**\n   * Decoded a CID from its binary representation at the beginning of a byte\n   * array.\n   *\n   * Returns an array with the first element containing the CID and the second\n   * element containing the remainder of the original byte array. The remainder\n   * will be a zero-length byte array if the provided bytes only contained a\n   * binary CID representation.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes\n   * @returns {[CID<T, C, A, V>, Uint8Array]}\n   */\n  static decodeFirst (bytes) {\n    const specs = CID.inspectBytes(bytes)\n    const prefixSize = specs.size - specs.multihashSize\n    const multihashBytes = coerce(\n      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)\n    )\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length')\n    }\n    const digestBytes = multihashBytes.subarray(\n      specs.multihashSize - specs.digestSize\n    )\n    const digest = new Digest.Digest(\n      specs.multihashCode,\n      specs.digestSize,\n      digestBytes,\n      multihashBytes\n    )\n    const cid =\n      specs.version === 0\n        ? CID.createV0(/** @type {API.MultihashDigest<API.SHA_256>} */ (digest))\n        : CID.createV1(specs.codec, digest)\n    return [/** @type {CID<T, C, A, V>} */(cid), bytes.subarray(specs.size)]\n  }\n\n  /**\n   * Inspect the initial bytes of a CID to determine its properties.\n   *\n   * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n   * bytes but for larger multicodec code values and larger multihash digest\n   * lengths these varints can be quite large. It is recommended that at least\n   * 10 bytes be made available in the `initialBytes` argument for a complete\n   * inspection.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes\n   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}\n   */\n  static inspectBytes (initialBytes) {\n    let offset = 0\n    const next = () => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset))\n      offset += length\n      return i\n    }\n\n    let version = /** @type {V} */ (next())\n    let codec = /** @type {C} */ (DAG_PB_CODE)\n    if (/** @type {number} */(version) === 18) {\n      // CIDv0\n      version = /** @type {V} */ (0)\n      offset = 0\n    } else {\n      codec = /** @type {C} */ (next())\n    }\n\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`)\n    }\n\n    const prefixSize = offset\n    const multihashCode = /** @type {A} */ (next()) // multihash code\n    const digestSize = next() // multihash length\n    const size = offset + digestSize\n    const multihashSize = size - prefixSize\n\n    return { version, codec, multihashCode, digestSize, multihashSize, size }\n  }\n\n  /**\n   * Takes cid in a string representation and creates an instance. If `base`\n   * decoder is not provided will use a default from the configuration. It will\n   * throw an error if encoding of the CID is not compatible with supplied (or\n   * a default decoder).\n   *\n   * @template {string} Prefix\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n   * @param {API.MultibaseDecoder<Prefix>} [base]\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static parse (source, base) {\n    const [prefix, bytes] = parseCIDtoBytes(source, base)\n\n    const cid = CID.decode(bytes)\n\n    if (cid.version === 0 && source[0] !== 'Q') {\n      throw Error('Version 0 CID string must not include multibase prefix')\n    }\n\n    // Cache string representation to avoid computing it on `this.toString()`\n    baseCache(cid).set(prefix, source)\n\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @template {unknown} Data\n * @template {number} Code\n * @template {number} Alg\n * @template {API.Version} Ver\n * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n * @param {API.MultibaseDecoder<Prefix>} [base]\n * @returns {[Prefix, API.ByteView<API.Link<Data, Code, Alg, Ver>>]}\n */\nconst parseCIDtoBytes = (source, base) => {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q': {\n      const decoder = base || base58btc\n      return [\n        /** @type {Prefix} */ (base58btc.prefix),\n        decoder.decode(`${base58btc.prefix}${source}`)\n      ]\n    }\n    case base58btc.prefix: {\n      const decoder = base || base58btc\n      return [/** @type {Prefix} */(base58btc.prefix), decoder.decode(source)]\n    }\n    case base32.prefix: {\n      const decoder = base || base32\n      return [/** @type {Prefix} */(base32.prefix), decoder.decode(source)]\n    }\n    default: {\n      if (base == null) {\n        throw Error(\n          'To parse non base32 or base58btc encoded CID multibase decoder must be provided'\n        )\n      }\n      return [/** @type {Prefix} */(source[0]), base.decode(source)]\n    }\n  }\n}\n\n/**\n *\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<'z'>} base\n */\nconst toStringV0 = (bytes, cache, base) => {\n  const { prefix } = base\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`)\n  }\n\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<Prefix>} base\n */\nconst toStringV1 = (bytes, cache, base) => {\n  const { prefix } = base\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nconst DAG_PB_CODE = 0x70\nconst SHA_256_CODE = 0x12\n\n/**\n * @param {API.Version} version\n * @param {number} code\n * @param {Uint8Array} multihash\n * @returns {Uint8Array}\n */\nconst encodeCID = (version, code, multihash) => {\n  const codeOffset = varint.encodingLength(version)\n  const hashOffset = codeOffset + varint.encodingLength(code)\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength)\n  varint.encodeTo(version, bytes, 0)\n  varint.encodeTo(code, bytes, codeOffset)\n  bytes.set(multihash, hashOffset)\n  return bytes\n}\n\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID')\n", "import { baseX } from './base.js'\n\nexport const base10 = baseX({\n  prefix: '9',\n  name: 'base10',\n  alphabet: '0123456789'\n})\n", "// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET, name) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256);\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255;\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i);\n    var xc = x.charCodeAt(0);\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i;\n  }\n  var BASE = ALPHABET.length;\n  var LEADER = ALPHABET.charAt(0);\n  var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (source instanceof Uint8Array) ; else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source);\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0;\n    var length = 0;\n    var pbegin = 0;\n    var pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++;\n      zeroes++;\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n    var b58 = new Uint8Array(size);\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0;\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0;\n        b58[it1] = (carry % BASE) >>> 0;\n        carry = (carry / BASE) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      pbegin++;\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length;\n    while (it2 !== size && b58[it2] === 0) {\n      it2++;\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes);\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0;\n        // Skip leading spaces.\n    if (source[psz] === ' ') { return }\n        // Skip and count leading '1's.\n    var zeroes = 0;\n    var length = 0;\n    while (source[psz] === LEADER) {\n      zeroes++;\n      psz++;\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size);\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0;\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0;\n        b256[it3] = (carry % 256) >>> 0;\n        carry = (carry / 256) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      psz++;\n    }\n        // Skip trailing spaces.\n    if (source[psz] === ' ') { return }\n        // Skip leading zeroes in b256.\n    var it4 = size - length;\n    while (it4 !== size && b256[it4] === 0) {\n      it4++;\n    }\n    var vch = new Uint8Array(zeroes + (size - it4));\n    var j = zeroes;\n    while (it4 !== size) {\n      vch[j++] = b256[it4++];\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string);\n    if (buffer) { return buffer }\n    throw new Error(`Non-${name} character`)\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nvar src = base;\n\nvar _brrp__multiformats_scope_baseX = src;\n\nexport default _brrp__multiformats_scope_baseX;\n", "const empty = new Uint8Array(0)\n\n/**\n * @param {Uint8Array} d\n */\nconst toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')\n\n/**\n * @param {string} hex\n */\nconst fromHex = hex => {\n  const hexes = hex.match(/../g)\n  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty\n}\n\n/**\n * @param {Uint8Array} aa\n * @param {Uint8Array} bb\n */\nconst equals = (aa, bb) => {\n  if (aa === bb) return true\n  if (aa.byteLength !== bb.byteLength) {\n    return false\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @param {ArrayBufferView|ArrayBuffer|Uint8Array} o\n * @returns {Uint8Array}\n */\nconst coerce = o => {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o\n  if (o instanceof ArrayBuffer) return new Uint8Array(o)\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)\n  }\n  throw new Error('Unknown type, must be binary type')\n}\n\n/**\n * @param {any} o\n * @returns {o is ArrayBuffer|ArrayBufferView}\n */\nconst isBinary = o =>\n  o instanceof ArrayBuffer || ArrayBuffer.isView(o)\n\n/**\n * @param {string} str\n * @returns {Uint8Array}\n */\nconst fromString = str => (new TextEncoder()).encode(str)\n\n/**\n * @param {Uint8Array} b\n * @returns {string}\n */\nconst toString = b => (new TextDecoder()).decode(b)\n\nexport { equals, coerce, isBinary, fromHex, toHex, fromString, toString, empty }\n", "import basex from '../../vendor/base-x.js'\nimport { coerce } from '../bytes.js'\n// Linter can't see that API is used in types.\n// eslint-disable-next-line\nimport * as API from './interface.js'\n\n/**\n * Class represents both BaseEncoder and MultibaseEncoder meaning it\n * can be used to encode to multibase or base encode without multibase\n * prefix.\n *\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseEncoder<Prefix>}\n * @implements {API.BaseEncoder}\n */\nclass Encoder {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(bytes:Uint8Array) => string} baseEncode\n   */\n  constructor (name, prefix, baseEncode) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n  }\n\n  /**\n   * @param {Uint8Array} bytes\n   * @returns {API.Multibase<Prefix>}\n   */\n  encode (bytes) {\n    if (bytes instanceof Uint8Array) {\n      return `${this.prefix}${this.baseEncode(bytes)}`\n    } else {\n      throw Error('Unknown type, must be binary type')\n    }\n  }\n}\n\n/**\n * @template {string} Prefix\n */\n/**\n * Class represents both BaseDecoder and MultibaseDecoder so it could be used\n * to decode multibases (with matching prefix) or just base decode strings\n * with corresponding base encoding.\n *\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.UnibaseDecoder<Prefix>}\n * @implements {API.BaseDecoder}\n */\nclass Decoder {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(text:string) => Uint8Array} baseDecode\n   */\n  constructor (name, prefix, baseDecode) {\n    this.name = name\n    this.prefix = prefix\n    /* c8 ignore next 3 */\n    if (prefix.codePointAt(0) === undefined) {\n      throw new Error('Invalid prefix character')\n    }\n    /** @private */\n    this.prefixCodePoint = /** @type {number} */ (prefix.codePointAt(0))\n    this.baseDecode = baseDecode\n  }\n\n  /**\n   * @param {string} text\n   */\n  decode (text) {\n    if (typeof text === 'string') {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`)\n      }\n      return this.baseDecode(text.slice(this.prefix.length))\n    } else {\n      throw Error('Can only multibase decode strings')\n    }\n  }\n\n  /**\n   * @template {string} OtherPrefix\n   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder\n   * @returns {ComposedDecoder<Prefix|OtherPrefix>}\n   */\n  or (decoder) {\n    return or(this, decoder)\n  }\n}\n\n/**\n * @template {string} Prefix\n * @typedef {Record<Prefix, API.UnibaseDecoder<Prefix>>} Decoders\n */\n\n/**\n * @template {string} Prefix\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.CombobaseDecoder<Prefix>}\n */\nclass ComposedDecoder {\n  /**\n   * @param {Decoders<Prefix>} decoders\n   */\n  constructor (decoders) {\n    this.decoders = decoders\n  }\n\n  /**\n   * @template {string} OtherPrefix\n   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder\n   * @returns {ComposedDecoder<Prefix|OtherPrefix>}\n   */\n  or (decoder) {\n    return or(this, decoder)\n  }\n\n  /**\n   * @param {string} input\n   * @returns {Uint8Array}\n   */\n  decode (input) {\n    const prefix = /** @type {Prefix} */ (input[0])\n    const decoder = this.decoders[prefix]\n    if (decoder) {\n      return decoder.decode(input)\n    } else {\n      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)\n    }\n  }\n}\n\n/**\n * @template {string} L\n * @template {string} R\n * @param {API.UnibaseDecoder<L>|API.CombobaseDecoder<L>} left\n * @param {API.UnibaseDecoder<R>|API.CombobaseDecoder<R>} right\n * @returns {ComposedDecoder<L|R>}\n */\nexport const or = (left, right) => new ComposedDecoder(/** @type {Decoders<L|R>} */({\n  ...(left.decoders || { [/** @type API.UnibaseDecoder<L> */(left).prefix]: left }),\n  ...(right.decoders || { [/** @type API.UnibaseDecoder<R> */(right).prefix]: right })\n}))\n\n/**\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseCodec<Prefix>}\n * @implements {API.MultibaseEncoder<Prefix>}\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.BaseCodec}\n * @implements {API.BaseEncoder}\n * @implements {API.BaseDecoder}\n */\nexport class Codec {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(bytes:Uint8Array) => string} baseEncode\n   * @param {(text:string) => Uint8Array} baseDecode\n   */\n  constructor (name, prefix, baseEncode, baseDecode) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n    this.baseDecode = baseDecode\n    this.encoder = new Encoder(name, prefix, baseEncode)\n    this.decoder = new Decoder(name, prefix, baseDecode)\n  }\n\n  /**\n   * @param {Uint8Array} input\n   */\n  encode (input) {\n    return this.encoder.encode(input)\n  }\n\n  /**\n   * @param {string} input\n   */\n  decode (input) {\n    return this.decoder.decode(input)\n  }\n}\n\n/**\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {(bytes:Uint8Array) => string} options.encode\n * @param {(input:string) => Uint8Array} options.decode\n * @returns {Codec<Base, Prefix>}\n */\nexport const from = ({ name, prefix, encode, decode }) =>\n  new Codec(name, prefix, encode, decode)\n\n/**\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {string} options.alphabet\n * @returns {Codec<Base, Prefix>}\n */\nexport const baseX = ({ prefix, name, alphabet }) => {\n  const { encode, decode } = basex(alphabet, name)\n  return from({\n    prefix,\n    name,\n    encode,\n    /**\n     * @param {string} text\n     */\n    decode: text => coerce(decode(text))\n  })\n}\n\n/**\n * @param {string} string\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @param {string} name\n * @returns {Uint8Array}\n */\nconst decode = (string, alphabet, bitsPerChar, name) => {\n  // Build the character lookup table:\n  /** @type {Record<string, number>} */\n  const codes = {}\n  for (let i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i\n  }\n\n  // Count the padding bytes:\n  let end = string.length\n  while (string[end - 1] === '=') {\n    --end\n  }\n\n  // Allocate the output:\n  const out = new Uint8Array((end * bitsPerChar / 8) | 0)\n\n  // Parse the data:\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  let written = 0 // Next byte to write\n  for (let i = 0; i < end; ++i) {\n    // Read one character from the string:\n    const value = codes[string[i]]\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${name} character`)\n    }\n\n    // Append the bits to the buffer:\n    buffer = (buffer << bitsPerChar) | value\n    bits += bitsPerChar\n\n    // Write out some bits if the buffer has a byte's worth:\n    if (bits >= 8) {\n      bits -= 8\n      out[written++] = 0xff & (buffer >> bits)\n    }\n  }\n\n  // Verify that we have received just enough bits:\n  if (bits >= bitsPerChar || 0xff & (buffer << (8 - bits))) {\n    throw new SyntaxError('Unexpected end of data')\n  }\n\n  return out\n}\n\n/**\n * @param {Uint8Array} data\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @returns {string}\n */\nconst encode = (data, alphabet, bitsPerChar) => {\n  const pad = alphabet[alphabet.length - 1] === '='\n  const mask = (1 << bitsPerChar) - 1\n  let out = ''\n\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  for (let i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = (buffer << 8) | data[i]\n    bits += 8\n\n    // Write out as much as we can:\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar\n      out += alphabet[mask & (buffer >> bits)]\n    }\n  }\n\n  // Partial character:\n  if (bits) {\n    out += alphabet[mask & (buffer << (bitsPerChar - bits))]\n  }\n\n  // Add padding characters until we hit a byte boundary:\n  if (pad) {\n    while ((out.length * bitsPerChar) & 7) {\n      out += '='\n    }\n  }\n\n  return out\n}\n\n/**\n * RFC4648 Factory\n *\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {string} options.alphabet\n * @param {number} options.bitsPerChar\n */\nexport const rfc4648 = ({ name, prefix, bitsPerChar, alphabet }) => {\n  return from({\n    prefix,\n    name,\n    encode (input) {\n      return encode(input, alphabet, bitsPerChar)\n    },\n    decode (input) {\n      return decode(input, alphabet, bitsPerChar, name)\n    }\n  })\n}\n", "// @ts-check\n\nimport { rfc4648 } from './base.js'\n\nexport const base16 = rfc4648({\n  prefix: 'f',\n  name: 'base16',\n  alphabet: '0123456789abcdef',\n  bitsPerChar: 4\n})\n\nexport const base16upper = rfc4648({\n  prefix: 'F',\n  name: 'base16upper',\n  alphabet: '0123456789ABCDEF',\n  bitsPerChar: 4\n})\n", "// @ts-check\n\nimport { rfc4648 } from './base.js'\n\nexport const base2 = rfc4648({\n  prefix: '0',\n  name: 'base2',\n  alphabet: '01',\n  bitsPerChar: 1\n})\n", "import { from } from './base.js'\n\nconst alphabet = Array.from('🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂')\nconst alphabetBytesToChars = /** @type {string[]} */ (alphabet.reduce((p, c, i) => { p[i] = c; return p }, /** @type {string[]} */([])))\nconst alphabetCharsToBytes = /** @type {number[]} */ (alphabet.reduce((p, c, i) => { p[/** @type {number} */ (c.codePointAt(0))] = i; return p }, /** @type {number[]} */([])))\n\n/**\n * @param {Uint8Array} data\n * @returns {string}\n */\nfunction encode (data) {\n  return data.reduce((p, c) => {\n    p += alphabetBytesToChars[c]\n    return p\n  }, '')\n}\n\n/**\n * @param {string} str\n * @returns {Uint8Array}\n */\nfunction decode (str) {\n  const byts = []\n  for (const char of str) {\n    const byt = alphabetCharsToBytes[/** @type {number} */ (char.codePointAt(0))]\n    if (byt === undefined) {\n      throw new Error(`Non-base256emoji character: ${char}`)\n    }\n    byts.push(byt)\n  }\n  return new Uint8Array(byts)\n}\n\nexport const base256emoji = from({\n  prefix: '🚀',\n  name: 'base256emoji',\n  encode,\n  decode\n})\n", "import { rfc4648 } from './base.js'\n\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n})\n\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n})\n\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n})\n\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n})\n\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n})\n\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n})\n\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n})\n\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n})\n\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n})\n", "import { baseX } from './base.js'\n\nexport const base36 = baseX({\n  prefix: 'k',\n  name: 'base36',\n  alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'\n})\n\nexport const base36upper = baseX({\n  prefix: 'K',\n  name: 'base36upper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n})\n", "import { baseX } from './base.js'\n\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n})\n\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n})\n", "// @ts-check\n\nimport { rfc4648 } from './base.js'\n\nexport const base64 = rfc4648({\n  prefix: 'm',\n  name: 'base64',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n  bitsPerChar: 6\n})\n\nexport const base64pad = rfc4648({\n  prefix: 'M',\n  name: 'base64pad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n  bitsPerChar: 6\n})\n\nexport const base64url = rfc4648({\n  prefix: 'u',\n  name: 'base64url',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n  bitsPerChar: 6\n})\n\nexport const base64urlpad = rfc4648({\n  prefix: 'U',\n  name: 'base64urlpad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',\n  bitsPerChar: 6\n})\n", "// @ts-check\n\nimport { rfc4648 } from './base.js'\n\nexport const base8 = rfc4648({\n  prefix: '7',\n  name: 'base8',\n  alphabet: '01234567',\n  bitsPerChar: 3\n})\n", "// @ts-check\n\nimport { fromString, toString } from '../bytes.js'\nimport { from } from './base.js'\n\nexport const identity = from({\n  prefix: '\\x00',\n  name: 'identity',\n  encode: (buf) => toString(buf),\n  decode: (str) => fromString(str)\n})\n", "// @ts-check\n\n/**\n * @template T\n * @typedef {import('./interface.js').ByteView<T>} ByteView\n */\n\nconst textEncoder = new TextEncoder()\nconst textDecoder = new TextDecoder()\n\nexport const name = 'json'\nexport const code = 0x0200\n\n/**\n * @template T\n * @param {T} node\n * @returns {ByteView<T>}\n */\nexport const encode = (node) => textEncoder.encode(JSON.stringify(node))\n\n/**\n * @template T\n * @param {ByteView<T>} data\n * @returns {T}\n */\nexport const decode = (data) => JSON.parse(textDecoder.decode(data))\n", "import { coerce } from '../bytes.js'\nimport * as Digest from './digest.js'\n\nconst code = 0x0\nconst name = 'identity'\n\n/** @type {(input:Uint8Array) => Uint8Array} */\nconst encode = coerce\n\n/**\n * @param {Uint8Array} input\n * @returns {Digest.Digest<typeof code, number>}\n */\nconst digest = (input) => Digest.create(code, encode(input))\n\nexport const identity = { code, name, encode, digest }\n", "var encode_1 = encode;\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31);\n\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num /= 128;\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  \n  encode.bytes = offset - oldOffset + 1;\n  \n  return out\n}\n\nvar decode = read;\n\nvar MSB$1 = 0x80\n  , REST$1 = 0x7F;\n\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length;\n\n  do {\n    if (counter >= l) {\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++];\n    res += shift < 28\n      ? (b & REST$1) << shift\n      : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1)\n\n  read.bytes = counter - offset;\n\n  return res\n}\n\nvar N1 = Math.pow(2,  7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\n\nvar length = function (value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n};\n\nvar varint = {\n    encode: encode_1\n  , decode: decode\n  , encodingLength: length\n};\n\nvar _brrp_varint = varint;\n\nexport default _brrp_varint;\n", "import varint from '../vendor/varint.js'\n\n/**\n * @param {Uint8Array} data\n * @param {number} [offset=0]\n * @returns {[number, number]}\n */\nexport const decode = (data, offset = 0) => {\n  const code = varint.decode(data, offset)\n  return [code, varint.decode.bytes]\n}\n\n/**\n * @param {number} int\n * @param {Uint8Array} target\n * @param {number} [offset=0]\n */\nexport const encodeTo = (int, target, offset = 0) => {\n  varint.encode(int, target, offset)\n  return target\n}\n\n/**\n * @param {number} int\n * @returns {number}\n */\nexport const encodingLength = (int) => {\n  return varint.encodingLength(int)\n}\n", "import { coerce, equals as equalBytes } from '../bytes.js'\nimport * as varint from '../varint.js'\n\n/**\n * Creates a multihash digest.\n *\n * @template {number} Code\n * @param {Code} code\n * @param {Uint8Array} digest\n */\nexport const create = (code, digest) => {\n  const size = digest.byteLength\n  const sizeOffset = varint.encodingLength(code)\n  const digestOffset = sizeOffset + varint.encodingLength(size)\n\n  const bytes = new Uint8Array(digestOffset + size)\n  varint.encodeTo(code, bytes, 0)\n  varint.encodeTo(size, bytes, sizeOffset)\n  bytes.set(digest, digestOffset)\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * Turns bytes representation of multihash digest into an instance.\n *\n * @param {Uint8Array} multihash\n * @returns {MultihashDigest}\n */\nexport const decode = (multihash) => {\n  const bytes = coerce(multihash)\n  const [code, sizeOffset] = varint.decode(bytes)\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset))\n  const digest = bytes.subarray(sizeOffset + digestOffset)\n\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length')\n  }\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * @param {MultihashDigest} a\n * @param {unknown} b\n * @returns {b is MultihashDigest}\n */\nexport const equals = (a, b) => {\n  if (a === b) {\n    return true\n  } else {\n    const data = /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */(b)\n\n    return (\n      a.code === data.code &&\n      a.size === data.size &&\n      data.bytes instanceof Uint8Array &&\n      equalBytes(a.bytes, data.bytes)\n    )\n  }\n}\n\n/**\n * @typedef {import('./interface.js').MultihashDigest} MultihashDigest\n */\n\n/**\n * Represents a multihash digest which carries information about the\n * hashing algorithm and an actual hash digest.\n *\n * @template {number} Code\n * @template {number} Size\n * @class\n * @implements {MultihashDigest}\n */\nexport class Digest {\n  /**\n   * Creates a multihash digest.\n   *\n   * @param {Code} code\n   * @param {Size} size\n   * @param {Uint8Array} digest\n   * @param {Uint8Array} bytes\n   */\n  constructor (code, size, digest, bytes) {\n    this.code = code\n    this.size = size\n    this.digest = digest\n    this.bytes = bytes\n  }\n}\n", "/* global crypto */\n\nimport { from } from './hasher.js'\n\n/**\n * @param {AlgorithmIdentifier} name\n */\nconst sha = name =>\n  /**\n   * @param {Uint8Array} data\n   */\n  async data => new Uint8Array(await crypto.subtle.digest(name, data))\n\nexport const sha256 = from({\n  name: 'sha2-256',\n  code: 0x12,\n  encode: sha('SHA-256')\n})\n\nexport const sha512 = from({\n  name: 'sha2-512',\n  code: 0x13,\n  encode: sha('SHA-512')\n})\n", "import * as Digest from './digest.js'\n\n/**\n * @template {string} Name\n * @template {number} Code\n * @param {object} options\n * @param {Name} options.name\n * @param {Code} options.code\n * @param {(input: Uint8Array) => Await<Uint8Array>} options.encode\n */\nexport const from = ({ name, code, encode }) => new Hasher(name, code, encode)\n\n/**\n * Hasher represents a hashing algorithm implementation that produces as\n * `MultihashDigest`.\n *\n * @template {string} Name\n * @template {number} Code\n * @class\n * @implements {MultihashHasher<Code>}\n */\nexport class Hasher {\n  /**\n   *\n   * @param {Name} name\n   * @param {Code} code\n   * @param {(input: Uint8Array) => Await<Uint8Array>} encode\n   */\n  constructor (name, code, encode) {\n    this.name = name\n    this.code = code\n    this.encode = encode\n  }\n\n  /**\n   * @param {Uint8Array} input\n   * @returns {Await<Digest.Digest<Code, number>>}\n   */\n  digest (input) {\n    if (input instanceof Uint8Array) {\n      const result = this.encode(input)\n      return result instanceof Uint8Array\n        ? Digest.create(this.code, result)\n        /* c8 ignore next 1 */\n        : result.then(digest => Digest.create(this.code, digest))\n    } else {\n      throw Error('Unknown type, must be binary type')\n      /* c8 ignore next 1 */\n    }\n  }\n}\n\n/**\n * @template {number} Alg\n * @typedef {import('./interface.js').MultihashHasher} MultihashHasher\n */\n\n/**\n * @template T\n * @typedef {Promise<T>|T} Await\n */\n", "import { base32 } from './bases/base32.js'\nimport { base58btc } from './bases/base58.js'\nimport { coerce } from './bytes.js'\nimport * as Digest from './hashes/digest.js'\n// Linter can see that API is used in types.\n// eslint-disable-next-line\nimport * as API from \"./link/interface.js\"\nimport * as varint from './varint.js'\n\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\n/**\n * @template {API.Link<unknown, number, number, API.Version>} T\n * @template {string} Prefix\n * @param {T} link\n * @param {API.MultibaseEncoder<Prefix>} [base]\n * @returns {API.ToString<T, Prefix>}\n */\nexport const format = (link, base) => {\n  const { bytes, version } = link\n  switch (version) {\n    case 0:\n      return toStringV0(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<\"z\">} */ (base) || base58btc.encoder\n      )\n    default:\n      return toStringV1(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<Prefix>} */ (base || base32.encoder)\n      )\n  }\n}\n\n/**\n * @template {API.UnknownLink} Link\n * @param {Link} link\n * @returns {API.LinkJSON<Link>}\n */\nexport const toJSON = (link) => ({\n  '/': format(link)\n})\n\n/**\n * @template {API.UnknownLink} Link\n * @param {API.LinkJSON<Link>} json\n */\nexport const fromJSON = (json) =>\n  CID.parse(json['/'])\n\n/** @type {WeakMap<API.UnknownLink, Map<string, string>>} */\nconst cache = new WeakMap()\n\n/**\n * @param {API.UnknownLink} cid\n * @returns {Map<string, string>}\n */\nconst baseCache = cid => {\n  const baseCache = cache.get(cid)\n  if (baseCache == null) {\n    const baseCache = new Map()\n    cache.set(cid, baseCache)\n    return baseCache\n  }\n  return baseCache\n}\n\n/**\n * @template {unknown} [Data=unknown]\n * @template {number} [Format=number]\n * @template {number} [Alg=number]\n * @template {API.Version} [Version=API.Version]\n * @implements {API.Link<Data, Format, Alg, Version>}\n */\n\nexport class CID {\n  /**\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.\n   * @param {Uint8Array} bytes\n   */\n  constructor (version, code, multihash, bytes) {\n    /** @readonly */\n    this.code = code\n    /** @readonly */\n    this.version = version\n    /** @readonly */\n    this.multihash = multihash\n    /** @readonly */\n    this.bytes = bytes\n\n    // flag to serializers that this is a CID and\n    // should be treated specially\n    /** @readonly */\n    this['/'] = bytes\n  }\n\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n  get asCID () {\n    return this\n  }\n\n  // ArrayBufferView\n  get byteOffset () {\n    return this.bytes.byteOffset\n  }\n\n  // ArrayBufferView\n  get byteLength () {\n    return this.bytes.byteLength\n  }\n\n  /**\n   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}\n   */\n  toV0 () {\n    switch (this.version) {\n      case 0: {\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (this)\n      }\n      case 1: {\n        const { code, multihash } = this\n\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n        }\n\n        // sha2-256\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n        }\n\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (\n          CID.createV0(\n            /** @type {API.MultihashDigest<API.SHA_256>} */ (multihash)\n          )\n        )\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 0. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @returns {CID<Data, Format, Alg, 1>}\n   */\n  toV1 () {\n    switch (this.version) {\n      case 0: {\n        const { code, digest } = this.multihash\n        const multihash = Digest.create(code, digest)\n        return /** @type {CID<Data, Format, Alg, 1>} */ (\n          CID.createV1(this.code, multihash)\n        )\n      }\n      case 1: {\n        return /** @type {CID<Data, Format, Alg, 1>} */ (this)\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 1. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @param {unknown} other\n   * @returns {other is CID<Data, Format, Alg, Version>}\n   */\n  equals (other) {\n    return CID.equals(this, other)\n  }\n\n  /**\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {API.Link<Data, Format, Alg, Version>} self\n   * @param {unknown} other\n   * @returns {other is CID}\n   */\n  static equals (self, other) {\n    const unknown =\n      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */ (\n        other\n      )\n    return (\n      unknown &&\n      self.code === unknown.code &&\n      self.version === unknown.version &&\n      Digest.equals(self.multihash, unknown.multihash)\n    )\n  }\n\n  /**\n   * @param {API.MultibaseEncoder<string>} [base]\n   * @returns {string}\n   */\n  toString (base) {\n    return format(this, base)\n  }\n\n  /**\n   * @returns {API.LinkJSON<this>}\n   */\n  toJSON () {\n    return { '/': format(this) }\n  }\n\n  link () {\n    return this\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'CID'\n  }\n\n  // Legacy\n\n  [Symbol.for('nodejs.util.inspect.custom')] () {\n    return `CID(${this.toString()})`\n  }\n\n  /**\n   * Takes any input `value` and returns a `CID` instance if it was\n   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n   * it will return value back. If `value` is not instance of this CID\n   * class, but is compatible CID it will return new instance of this\n   * `CID` class. Otherwise returns null.\n   *\n   * This allows two different incompatible versions of CID library to\n   * co-exist and interop as long as binary interface is compatible.\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @template {unknown} U\n   * @param {API.Link<Data, Format, Alg, Version>|U} input\n   * @returns {CID<Data, Format, Alg, Version>|null}\n   */\n  static asCID (input) {\n    if (input == null) {\n      return null\n    }\n\n    const value = /** @type {any} */ (input)\n    if (value instanceof CID) {\n      // If value is instance of CID then we're all set.\n      return value\n    } else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n      // If value isn't instance of this CID class but `this.asCID === this` or\n      // `value['/'] === value.bytes` is true it is CID instance coming from a\n      // different implementation (diff version or duplicate). In that case we\n      // rebase it to this `CID` implementation so caller is guaranteed to get\n      // instance with expected API.\n      const { version, code, multihash, bytes } = value\n      return new CID(\n        version,\n        code,\n        /** @type {API.MultihashDigest<Alg>} */ (multihash),\n        bytes || encodeCID(version, code, multihash.bytes)\n      )\n    } else if (value[cidSymbol] === true) {\n      // If value is a CID from older implementation that used to be tagged via\n      // symbol we still rebase it to the this `CID` implementation by\n      // delegating that to a constructor.\n      const { version, multihash, code } = value\n      const digest =\n        /** @type {API.MultihashDigest<Alg>} */\n        (Digest.decode(multihash))\n      return CID.create(version, code, digest)\n    } else {\n      // Otherwise value is not a CID (or an incompatible version of it) in\n      // which case we return `null`.\n      return null\n    }\n  }\n\n  /**\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.\n   * @returns {CID<Data, Format, Alg, Version>}\n   */\n  static create (version, code, digest) {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported')\n    }\n\n    if (!(digest.bytes instanceof Uint8Array)) {\n      throw new Error('Invalid digest')\n    }\n\n    switch (version) {\n      case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(\n            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`\n          )\n        } else {\n          return new CID(version, code, digest, digest.bytes)\n        }\n      }\n      case 1: {\n        const bytes = encodeCID(version, code, digest.bytes)\n        return new CID(version, code, digest, bytes)\n      }\n      default: {\n        throw new Error('Invalid version')\n      }\n    }\n  }\n\n  /**\n   * Simplified version of `create` for CIDv0.\n   *\n   * @template {unknown} [T=unknown]\n   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.\n   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}\n   */\n  static createV0 (digest) {\n    return CID.create(0, DAG_PB_CODE, digest)\n  }\n\n  /**\n   * Simplified version of `create` for CIDv1.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @param {Code} code - Content encoding format code.\n   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.\n   * @returns {CID<Data, Code, Alg, 1>}\n   */\n  static createV1 (code, digest) {\n    return CID.create(1, code, digest)\n  }\n\n  /**\n   * Decoded a CID from its binary representation. The byte array must contain\n   * only the CID with no additional bytes.\n   *\n   * An error will be thrown if the bytes provided do not contain a valid\n   * binary representation of a CID.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static decode (bytes) {\n    const [cid, remainder] = CID.decodeFirst(bytes)\n    if (remainder.length) {\n      throw new Error('Incorrect length')\n    }\n    return cid\n  }\n\n  /**\n   * Decoded a CID from its binary representation at the beginning of a byte\n   * array.\n   *\n   * Returns an array with the first element containing the CID and the second\n   * element containing the remainder of the original byte array. The remainder\n   * will be a zero-length byte array if the provided bytes only contained a\n   * binary CID representation.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes\n   * @returns {[CID<T, C, A, V>, Uint8Array]}\n   */\n  static decodeFirst (bytes) {\n    const specs = CID.inspectBytes(bytes)\n    const prefixSize = specs.size - specs.multihashSize\n    const multihashBytes = coerce(\n      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)\n    )\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length')\n    }\n    const digestBytes = multihashBytes.subarray(\n      specs.multihashSize - specs.digestSize\n    )\n    const digest = new Digest.Digest(\n      specs.multihashCode,\n      specs.digestSize,\n      digestBytes,\n      multihashBytes\n    )\n    const cid =\n      specs.version === 0\n        ? CID.createV0(/** @type {API.MultihashDigest<API.SHA_256>} */ (digest))\n        : CID.createV1(specs.codec, digest)\n    return [/** @type {CID<T, C, A, V>} */(cid), bytes.subarray(specs.size)]\n  }\n\n  /**\n   * Inspect the initial bytes of a CID to determine its properties.\n   *\n   * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n   * bytes but for larger multicodec code values and larger multihash digest\n   * lengths these varints can be quite large. It is recommended that at least\n   * 10 bytes be made available in the `initialBytes` argument for a complete\n   * inspection.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes\n   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}\n   */\n  static inspectBytes (initialBytes) {\n    let offset = 0\n    const next = () => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset))\n      offset += length\n      return i\n    }\n\n    let version = /** @type {V} */ (next())\n    let codec = /** @type {C} */ (DAG_PB_CODE)\n    if (/** @type {number} */(version) === 18) {\n      // CIDv0\n      version = /** @type {V} */ (0)\n      offset = 0\n    } else {\n      codec = /** @type {C} */ (next())\n    }\n\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`)\n    }\n\n    const prefixSize = offset\n    const multihashCode = /** @type {A} */ (next()) // multihash code\n    const digestSize = next() // multihash length\n    const size = offset + digestSize\n    const multihashSize = size - prefixSize\n\n    return { version, codec, multihashCode, digestSize, multihashSize, size }\n  }\n\n  /**\n   * Takes cid in a string representation and creates an instance. If `base`\n   * decoder is not provided will use a default from the configuration. It will\n   * throw an error if encoding of the CID is not compatible with supplied (or\n   * a default decoder).\n   *\n   * @template {string} Prefix\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n   * @param {API.MultibaseDecoder<Prefix>} [base]\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static parse (source, base) {\n    const [prefix, bytes] = parseCIDtoBytes(source, base)\n\n    const cid = CID.decode(bytes)\n\n    if (cid.version === 0 && source[0] !== 'Q') {\n      throw Error('Version 0 CID string must not include multibase prefix')\n    }\n\n    // Cache string representation to avoid computing it on `this.toString()`\n    baseCache(cid).set(prefix, source)\n\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @template {unknown} Data\n * @template {number} Code\n * @template {number} Alg\n * @template {API.Version} Ver\n * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n * @param {API.MultibaseDecoder<Prefix>} [base]\n * @returns {[Prefix, API.ByteView<API.Link<Data, Code, Alg, Ver>>]}\n */\nconst parseCIDtoBytes = (source, base) => {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q': {\n      const decoder = base || base58btc\n      return [\n        /** @type {Prefix} */ (base58btc.prefix),\n        decoder.decode(`${base58btc.prefix}${source}`)\n      ]\n    }\n    case base58btc.prefix: {\n      const decoder = base || base58btc\n      return [/** @type {Prefix} */(base58btc.prefix), decoder.decode(source)]\n    }\n    case base32.prefix: {\n      const decoder = base || base32\n      return [/** @type {Prefix} */(base32.prefix), decoder.decode(source)]\n    }\n    default: {\n      if (base == null) {\n        throw Error(\n          'To parse non base32 or base58btc encoded CID multibase decoder must be provided'\n        )\n      }\n      return [/** @type {Prefix} */(source[0]), base.decode(source)]\n    }\n  }\n}\n\n/**\n *\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<'z'>} base\n */\nconst toStringV0 = (bytes, cache, base) => {\n  const { prefix } = base\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`)\n  }\n\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<Prefix>} base\n */\nconst toStringV1 = (bytes, cache, base) => {\n  const { prefix } = base\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nconst DAG_PB_CODE = 0x70\nconst SHA_256_CODE = 0x12\n\n/**\n * @param {API.Version} version\n * @param {number} code\n * @param {Uint8Array} multihash\n * @returns {Uint8Array}\n */\nconst encodeCID = (version, code, multihash) => {\n  const codeOffset = varint.encodingLength(version)\n  const hashOffset = codeOffset + varint.encodingLength(code)\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength)\n  varint.encodeTo(version, bytes, 0)\n  varint.encodeTo(code, bytes, codeOffset)\n  bytes.set(multihash, hashOffset)\n  return bytes\n}\n\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID')\n", "// @ts-check\n\nimport * as base10 from './bases/base10.js'\nimport * as base16 from './bases/base16.js'\nimport * as base2 from './bases/base2.js'\nimport * as base256emoji from './bases/base256emoji.js'\nimport * as base32 from './bases/base32.js'\nimport * as base36 from './bases/base36.js'\nimport * as base58 from './bases/base58.js'\nimport * as base64 from './bases/base64.js'\nimport * as base8 from './bases/base8.js'\nimport * as identityBase from './bases/identity.js'\nimport * as json from './codecs/json.js'\nimport * as raw from './codecs/raw.js'\nimport * as identity from './hashes/identity.js'\nimport * as sha2 from './hashes/sha2.js'\nimport { CID, hasher, digest, varint, bytes } from './index.js'\n\nconst bases = { ...identityBase, ...base2, ...base8, ...base10, ...base16, ...base32, ...base36, ...base58, ...base64, ...base256emoji }\nconst hashes = { ...sha2, ...identity }\nconst codecs = { raw, json }\n\nexport { CID, hasher, digest, varint, bytes, hashes, bases, codecs }\n", "/**\n * To guarantee Uint8Array semantics, convert nodejs Buffers\n * into vanilla Uint8Arrays\n */\nexport function asUint8Array (buf: Uint8Array): Uint8Array {\n  if (globalThis.Buffer != null) {\n    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength)\n  }\n\n  return buf\n}\n", "import { asUint8Array } from './util/as-uint8array.js'\n\n/**\n * Returns a `Uint8Array` of the requested size. Referenced memory will\n * be initialized to 0.\n */\nexport function alloc (size: number = 0): Uint8Array {\n  if (globalThis.Buffer?.alloc != null) {\n    return asUint8Array(globalThis.Buffer.alloc(size))\n  }\n\n  return new Uint8Array(size)\n}\n\n/**\n * Where possible returns a Uint8Array of the requested size that references\n * uninitialized memory. Only use if you are certain you will immediately\n * overwrite every value in the returned `Uint8Array`.\n */\nexport function allocUnsafe (size: number = 0): Uint8Array {\n  if (globalThis.Buffer?.allocUnsafe != null) {\n    return asUint8Array(globalThis.Buffer.allocUnsafe(size))\n  }\n\n  return new Uint8Array(size)\n}\n", "import { bases } from 'multiformats/basics'\nimport { allocUnsafe } from '../alloc.js'\nimport type { MultibaseCodec } from 'multiformats'\n\nfunction createCodec (name: string, prefix: string, encode: (buf: Uint8Array) => string, decode: (str: string) => Uint8Array): MultibaseCodec<any> {\n  return {\n    name,\n    prefix,\n    encoder: {\n      name,\n      prefix,\n      encode\n    },\n    decoder: {\n      decode\n    }\n  }\n}\n\nconst string = createCodec('utf8', 'u', (buf) => {\n  const decoder = new TextDecoder('utf8')\n  return 'u' + decoder.decode(buf)\n}, (str) => {\n  const encoder = new TextEncoder()\n  return encoder.encode(str.substring(1))\n})\n\nconst ascii = createCodec('ascii', 'a', (buf) => {\n  let string = 'a'\n\n  for (let i = 0; i < buf.length; i++) {\n    string += String.fromCharCode(buf[i])\n  }\n  return string\n}, (str) => {\n  str = str.substring(1)\n  const buf = allocUnsafe(str.length)\n\n  for (let i = 0; i < str.length; i++) {\n    buf[i] = str.charCodeAt(i)\n  }\n\n  return buf\n})\n\nexport type SupportedEncodings = 'utf8' | 'utf-8' | 'hex' | 'latin1' | 'ascii' | 'binary' | keyof typeof bases\n\nconst BASES: Record<SupportedEncodings, MultibaseCodec<any>> = {\n  utf8: string,\n  'utf-8': string,\n  hex: bases.base16,\n  latin1: ascii,\n  ascii,\n  binary: ascii,\n\n  ...bases\n}\n\nexport default BASES\n", "import bases, { type SupportedEncodings } from './util/bases.js'\n\nexport type { SupportedEncodings }\n\n/**\n * Turns a `Uint8Array` into a string.\n *\n * Supports `utf8`, `utf-8` and any encoding supported by the multibase module.\n *\n * Also `ascii` which is similar to node's 'binary' encoding.\n */\nexport function toString (array: Uint8Array, encoding: SupportedEncodings = 'utf8'): string {\n  const base = bases[encoding]\n\n  if (base == null) {\n    throw new Error(`Unsupported encoding \"${encoding}\"`)\n  }\n\n  if ((encoding === 'utf8' || encoding === 'utf-8') && globalThis.Buffer != null && globalThis.Buffer.from != null) {\n    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString('utf8')\n  }\n\n  // strip multibase prefix\n  return base.encoder.encode(array).substring(1)\n}\n", "/* eslint-disable no-fallthrough */\nimport { allocUnsafe } from 'uint8arrays/alloc'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nconst N1 = Math.pow(2, 7)\nconst N2 = Math.pow(2, 14)\nconst N3 = Math.pow(2, 21)\nconst N4 = Math.pow(2, 28)\nconst N5 = Math.pow(2, 35)\nconst N6 = Math.pow(2, 42)\nconst N7 = Math.pow(2, 49)\n\n/** Most significant bit of a byte */\nconst MSB = 0x80\n/** Rest of the bits in a byte */\nconst REST = 0x7f\n\nexport function encodingLength (value: number): number {\n  if (value < N1) {\n    return 1\n  }\n\n  if (value < N2) {\n    return 2\n  }\n\n  if (value < N3) {\n    return 3\n  }\n\n  if (value < N4) {\n    return 4\n  }\n\n  if (value < N5) {\n    return 5\n  }\n\n  if (value < N6) {\n    return 6\n  }\n\n  if (value < N7) {\n    return 7\n  }\n\n  if (Number.MAX_SAFE_INTEGER != null && value > Number.MAX_SAFE_INTEGER) {\n    throw new RangeError('Could not encode varint')\n  }\n\n  return 8\n}\n\nexport function encodeUint8Array (value: number, buf: Uint8Array, offset: number = 0): Uint8Array {\n  switch (encodingLength(value)) {\n    case 8: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value /= 128\n    }\n    case 7: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value /= 128\n    }\n    case 6: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value /= 128\n    }\n    case 5: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value /= 128\n    }\n    case 4: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value >>>= 7\n    }\n    case 3: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value >>>= 7\n    }\n    case 2: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value >>>= 7\n    }\n    case 1: {\n      buf[offset++] = (value & 0xFF)\n      value >>>= 7\n      break\n    }\n    default: throw new Error('unreachable')\n  }\n  return buf\n}\n\nexport function encodeUint8ArrayList (value: number, buf: Uint8ArrayList, offset: number = 0): Uint8ArrayList {\n  switch (encodingLength(value)) {\n    case 8: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value /= 128\n    }\n    case 7: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value /= 128\n    }\n    case 6: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value /= 128\n    }\n    case 5: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value /= 128\n    }\n    case 4: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value >>>= 7\n    }\n    case 3: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value >>>= 7\n    }\n    case 2: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value >>>= 7\n    }\n    case 1: {\n      buf.set(offset++, (value & 0xFF))\n      value >>>= 7\n      break\n    }\n    default: throw new Error('unreachable')\n  }\n  return buf\n}\n\nexport function decodeUint8Array (buf: Uint8Array, offset: number): number {\n  let b = buf[offset]\n  let res = 0\n\n  res += b & REST\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 1]\n  res += (b & REST) << 7\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 2]\n  res += (b & REST) << 14\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 3]\n  res += (b & REST) << 21\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 4]\n  res += (b & REST) * N4\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 5]\n  res += (b & REST) * N5\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 6]\n  res += (b & REST) * N6\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 7]\n  res += (b & REST) * N7\n  if (b < MSB) {\n    return res\n  }\n\n  throw new RangeError('Could not decode varint')\n}\n\nexport function decodeUint8ArrayList (buf: Uint8ArrayList, offset: number): number {\n  let b = buf.get(offset)\n  let res = 0\n\n  res += b & REST\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 1)\n  res += (b & REST) << 7\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 2)\n  res += (b & REST) << 14\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 3)\n  res += (b & REST) << 21\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 4)\n  res += (b & REST) * N4\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 5)\n  res += (b & REST) * N5\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 6)\n  res += (b & REST) * N6\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 7)\n  res += (b & REST) * N7\n  if (b < MSB) {\n    return res\n  }\n\n  throw new RangeError('Could not decode varint')\n}\n\nexport function encode (value: number): Uint8Array\nexport function encode (value: number, buf: Uint8Array, offset?: number): Uint8Array\nexport function encode (value: number, buf: Uint8ArrayList, offset?: number): Uint8ArrayList\nexport function encode <T extends Uint8Array | Uint8ArrayList = Uint8Array> (value: number, buf?: T, offset: number = 0): T {\n  if (buf == null) {\n    buf = allocUnsafe(encodingLength(value)) as T\n  }\n  if (buf instanceof Uint8Array) {\n    return encodeUint8Array(value, buf, offset) as T\n  } else {\n    return encodeUint8ArrayList(value, buf, offset) as T\n  }\n}\n\nexport function decode (buf: Uint8ArrayList | Uint8Array, offset: number = 0): number {\n  if (buf instanceof Uint8Array) {\n    return decodeUint8Array(buf, offset)\n  } else {\n    return decodeUint8ArrayList(buf, offset)\n  }\n}\n", "import { allocUnsafe } from './alloc.js'\nimport { asUint8Array } from './util/as-uint8array.js'\n\n/**\n * Returns a new Uint8Array created by concatenating the passed ArrayLikes\n */\nexport function concat (arrays: Array<ArrayLike<number>>, length?: number): Uint8Array {\n  if (length == null) {\n    length = arrays.reduce((acc, curr) => acc + curr.length, 0)\n  }\n\n  const output = allocUnsafe(length)\n  let offset = 0\n\n  for (const arr of arrays) {\n    output.set(arr, offset)\n    offset += arr.length\n  }\n\n  return asUint8Array(output)\n}\n", null, null, "import { parseIP } from \"@chainsafe/is-ip/parse\";\nimport { allFF, deepEqual } from \"./util.js\";\n\nexport const IPv4Len = 4;\nexport const IPv6Len = 16;\n\nexport const maxIPv6Octet = parseInt(\"0xFFFF\", 16);\nexport const ipv4Prefix = new Uint8Array([\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255,\n]);\n\nexport interface IpNetRaw {\n  network: Uint8Array;\n  mask: Uint8Array;\n}\n\nexport function maskIp(ip: Uint8Array, mask: Uint8Array): Uint8Array {\n  if (mask.length === IPv6Len && ip.length === IPv4Len && allFF(mask, 0, 11)) {\n    mask = mask.slice(12);\n  }\n  if (\n    mask.length === IPv4Len &&\n    ip.length === IPv6Len &&\n    deepEqual(ip, ipv4Prefix, 0, 11)\n  ) {\n    ip = ip.slice(12);\n  }\n  const n = ip.length;\n  if (n != mask.length) {\n    throw new Error(\"Failed to mask ip\");\n  }\n  const out = new Uint8Array(n);\n  for (let i = 0; i < n; i++) {\n    out[i] = ip[i] & mask[i];\n  }\n  return out;\n}\n\nexport function containsIp(\n  net: IpNetRaw,\n  ip: Uint8Array | number[] | string\n): boolean {\n  if (typeof ip === \"string\") {\n    ip = parseIP(ip)!;\n  }\n  if (ip == null) throw new Error(\"Invalid ip\");\n  if (ip.length !== net.network.length) {\n    return false;\n  }\n  for (let i = 0; i < ip.length; i++) {\n    if ((net.network[i] & net.mask[i]) !== (ip[i] & net.mask[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function iPv4FromIPv6(ip: Uint8Array): Uint8Array {\n  if (!isIPv4mappedIPv6(ip)) {\n    throw new Error(\"Must have 0xffff prefix\");\n  }\n  return ip.slice(12);\n}\n\nexport function isIPv4mappedIPv6(ip: Uint8Array | number[]): boolean {\n  return deepEqual(ip, ipv4Prefix, 0, 11);\n}\n", "import { baseX } from './base.js'\n\nexport const base10 = baseX({\n  prefix: '9',\n  name: 'base10',\n  alphabet: '0123456789'\n})\n", "// @ts-check\n\nimport { rfc4648 } from './base.js'\n\nexport const base16 = rfc4648({\n  prefix: 'f',\n  name: 'base16',\n  alphabet: '0123456789abcdef',\n  bitsPerChar: 4\n})\n\nexport const base16upper = rfc4648({\n  prefix: 'F',\n  name: 'base16upper',\n  alphabet: '0123456789ABCDEF',\n  bitsPerChar: 4\n})\n", "// @ts-check\n\nimport { rfc4648 } from './base.js'\n\nexport const base2 = rfc4648({\n  prefix: '0',\n  name: 'base2',\n  alphabet: '01',\n  bitsPerChar: 1\n})\n", "import { from } from './base.js'\n\nconst alphabet = Array.from('🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂')\nconst alphabetBytesToChars = /** @type {string[]} */ (alphabet.reduce((p, c, i) => { p[i] = c; return p }, /** @type {string[]} */([])))\nconst alphabetCharsToBytes = /** @type {number[]} */ (alphabet.reduce((p, c, i) => { p[/** @type {number} */ (c.codePointAt(0))] = i; return p }, /** @type {number[]} */([])))\n\n/**\n * @param {Uint8Array} data\n * @returns {string}\n */\nfunction encode (data) {\n  return data.reduce((p, c) => {\n    p += alphabetBytesToChars[c]\n    return p\n  }, '')\n}\n\n/**\n * @param {string} str\n * @returns {Uint8Array}\n */\nfunction decode (str) {\n  const byts = []\n  for (const char of str) {\n    const byt = alphabetCharsToBytes[/** @type {number} */ (char.codePointAt(0))]\n    if (byt === undefined) {\n      throw new Error(`Non-base256emoji character: ${char}`)\n    }\n    byts.push(byt)\n  }\n  return new Uint8Array(byts)\n}\n\nexport const base256emoji = from({\n  prefix: '🚀',\n  name: 'base256emoji',\n  encode,\n  decode\n})\n", "import { baseX } from './base.js'\n\nexport const base36 = baseX({\n  prefix: 'k',\n  name: 'base36',\n  alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'\n})\n\nexport const base36upper = baseX({\n  prefix: 'K',\n  name: 'base36upper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n})\n", "// @ts-check\n\nimport { rfc4648 } from './base.js'\n\nexport const base64 = rfc4648({\n  prefix: 'm',\n  name: 'base64',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n  bitsPerChar: 6\n})\n\nexport const base64pad = rfc4648({\n  prefix: 'M',\n  name: 'base64pad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n  bitsPerChar: 6\n})\n\nexport const base64url = rfc4648({\n  prefix: 'u',\n  name: 'base64url',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n  bitsPerChar: 6\n})\n\nexport const base64urlpad = rfc4648({\n  prefix: 'U',\n  name: 'base64urlpad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',\n  bitsPerChar: 6\n})\n", "// @ts-check\n\nimport { rfc4648 } from './base.js'\n\nexport const base8 = rfc4648({\n  prefix: '7',\n  name: 'base8',\n  alphabet: '01234567',\n  bitsPerChar: 3\n})\n", "// @ts-check\n\nimport { fromString, toString } from '../bytes.js'\nimport { from } from './base.js'\n\nexport const identity = from({\n  prefix: '\\x00',\n  name: 'identity',\n  encode: (buf) => toString(buf),\n  decode: (str) => fromString(str)\n})\n", "// @ts-check\n\n/**\n * @template T\n * @typedef {import('./interface.js').ByteView<T>} ByteView\n */\n\nconst textEncoder = new TextEncoder()\nconst textDecoder = new TextDecoder()\n\nexport const name = 'json'\nexport const code = 0x0200\n\n/**\n * @template T\n * @param {T} node\n * @returns {ByteView<T>}\n */\nexport const encode = (node) => textEncoder.encode(JSON.stringify(node))\n\n/**\n * @template T\n * @param {ByteView<T>} data\n * @returns {T}\n */\nexport const decode = (data) => JSON.parse(textDecoder.decode(data))\n", "import { coerce } from '../bytes.js'\nimport * as Digest from './digest.js'\n\nconst code = 0x0\nconst name = 'identity'\n\n/** @type {(input:Uint8Array) => Uint8Array} */\nconst encode = coerce\n\n/**\n * @param {Uint8Array} input\n * @returns {Digest.Digest<typeof code, number>}\n */\nconst digest = (input) => Digest.create(code, encode(input))\n\nexport const identity = { code, name, encode, digest }\n", "/* global crypto */\n\nimport { from } from './hasher.js'\n\n/**\n * @param {AlgorithmIdentifier} name\n */\nconst sha = name =>\n  /**\n   * @param {Uint8Array} data\n   */\n  async data => new Uint8Array(await crypto.subtle.digest(name, data))\n\nexport const sha256 = from({\n  name: 'sha2-256',\n  code: 0x12,\n  encode: sha('SHA-256')\n})\n\nexport const sha512 = from({\n  name: 'sha2-512',\n  code: 0x13,\n  encode: sha('SHA-512')\n})\n", "import * as Digest from './digest.js'\n\n/**\n * @template {string} Name\n * @template {number} Code\n * @param {object} options\n * @param {Name} options.name\n * @param {Code} options.code\n * @param {(input: Uint8Array) => Await<Uint8Array>} options.encode\n */\nexport const from = ({ name, code, encode }) => new Hasher(name, code, encode)\n\n/**\n * Hasher represents a hashing algorithm implementation that produces as\n * `MultihashDigest`.\n *\n * @template {string} Name\n * @template {number} Code\n * @class\n * @implements {MultihashHasher<Code>}\n */\nexport class Hasher {\n  /**\n   *\n   * @param {Name} name\n   * @param {Code} code\n   * @param {(input: Uint8Array) => Await<Uint8Array>} encode\n   */\n  constructor (name, code, encode) {\n    this.name = name\n    this.code = code\n    this.encode = encode\n  }\n\n  /**\n   * @param {Uint8Array} input\n   * @returns {Await<Digest.Digest<Code, number>>}\n   */\n  digest (input) {\n    if (input instanceof Uint8Array) {\n      const result = this.encode(input)\n      return result instanceof Uint8Array\n        ? Digest.create(this.code, result)\n        /* c8 ignore next 1 */\n        : result.then(digest => Digest.create(this.code, digest))\n    } else {\n      throw Error('Unknown type, must be binary type')\n      /* c8 ignore next 1 */\n    }\n  }\n}\n\n/**\n * @template {number} Alg\n * @typedef {import('./interface.js').MultihashHasher} MultihashHasher\n */\n\n/**\n * @template T\n * @typedef {Promise<T>|T} Await\n */\n", "// @ts-check\n\nimport * as base10 from './bases/base10.js'\nimport * as base16 from './bases/base16.js'\nimport * as base2 from './bases/base2.js'\nimport * as base256emoji from './bases/base256emoji.js'\nimport * as base32 from './bases/base32.js'\nimport * as base36 from './bases/base36.js'\nimport * as base58 from './bases/base58.js'\nimport * as base64 from './bases/base64.js'\nimport * as base8 from './bases/base8.js'\nimport * as identityBase from './bases/identity.js'\nimport * as json from './codecs/json.js'\nimport * as raw from './codecs/raw.js'\nimport * as identity from './hashes/identity.js'\nimport * as sha2 from './hashes/sha2.js'\nimport { CID, hasher, digest, varint, bytes } from './index.js'\n\nconst bases = { ...identityBase, ...base2, ...base8, ...base10, ...base16, ...base32, ...base36, ...base58, ...base64, ...base256emoji }\nconst hashes = { ...sha2, ...identity }\nconst codecs = { raw, json }\n\nexport { CID, hasher, digest, varint, bytes, hashes, bases, codecs }\n", "import { asUint8Array } from './util/as-uint8array.js'\nimport bases, { type SupportedEncodings } from './util/bases.js'\n\nexport type { SupportedEncodings }\n\n/**\n * Create a `Uint8Array` from the passed string\n *\n * Supports `utf8`, `utf-8`, `hex`, and any encoding supported by the multiformats module.\n *\n * Also `ascii` which is similar to node's 'binary' encoding.\n */\nexport function fromString (string: string, encoding: SupportedEncodings = 'utf8'): Uint8Array {\n  const base = bases[encoding]\n\n  if (base == null) {\n    throw new Error(`Unsupported encoding \"${encoding}\"`)\n  }\n\n  if ((encoding === 'utf8' || encoding === 'utf-8') && globalThis.Buffer != null && globalThis.Buffer.from != null) {\n    return asUint8Array(globalThis.Buffer.from(string, 'utf-8'))\n  }\n\n  // add multibase prefix\n  return base.decoder.decode(`${base.prefix}${string}`) // eslint-disable-line @typescript-eslint/restrict-template-expressions\n}\n", null, "import { isIPv4, isIPv6 } from '@chainsafe/is-ip'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\n\nexport { isIP } from '@chainsafe/is-ip'\nexport const isV4 = isIPv4\nexport const isV6 = isIPv6\n\n// Copied from https://github.com/indutny/node-ip/blob/master/lib/ip.js#L7\n// but with buf/offset args removed because we don't use them\nexport const toBytes = function (ip: string): Uint8Array {\n  let offset = 0\n  ip = ip.toString().trim()\n\n  if (isV4(ip)) {\n    const bytes = new Uint8Array(offset + 4)\n\n    ip.split(/\\./g).forEach((byte) => {\n      bytes[offset++] = parseInt(byte, 10) & 0xff\n    })\n\n    return bytes\n  }\n\n  if (isV6(ip)) {\n    const sections = ip.split(':', 8)\n\n    let i\n    for (i = 0; i < sections.length; i++) {\n      const isv4 = isV4(sections[i])\n      let v4Buffer: Uint8Array | undefined\n\n      if (isv4) {\n        v4Buffer = toBytes(sections[i])\n        sections[i] = uint8ArrayToString(v4Buffer.slice(0, 2), 'base16')\n      }\n\n      if (v4Buffer != null && ++i < 8) {\n        sections.splice(i, 0, uint8ArrayToString(v4Buffer.slice(2, 4), 'base16'))\n      }\n    }\n\n    if (sections[0] === '') {\n      while (sections.length < 8) sections.unshift('0')\n    } else if (sections[sections.length - 1] === '') {\n      while (sections.length < 8) sections.push('0')\n    } else if (sections.length < 8) {\n      for (i = 0; i < sections.length && sections[i] !== ''; i++);\n      const argv: [number, number, ...string[]] = [i, 1]\n      for (i = 9 - sections.length; i > 0; i--) {\n        argv.push('0')\n      }\n      sections.splice.apply(sections, argv)\n    }\n\n    const bytes = new Uint8Array(offset + 16)\n\n    for (i = 0; i < sections.length; i++) {\n      const word = parseInt(sections[i], 16)\n      bytes[offset++] = (word >> 8) & 0xff\n      bytes[offset++] = word & 0xff\n    }\n\n    return bytes\n  }\n\n  throw new Error('invalid ip address')\n}\n\n// Copied from https://github.com/indutny/node-ip/blob/master/lib/ip.js#L63\nexport const toString = function (buf: Uint8Array, offset: number = 0, length?: number): string {\n  offset = ~~offset\n  length = length ?? (buf.length - offset)\n\n  const view = new DataView(buf.buffer)\n\n  if (length === 4) {\n    const result = []\n\n    // IPv4\n    for (let i = 0; i < length; i++) {\n      result.push(buf[offset + i])\n    }\n\n    return result.join('.')\n  }\n\n  if (length === 16) {\n    const result = []\n\n    // IPv6\n    for (let i = 0; i < length; i += 2) {\n      result.push(view.getUint16(offset + i).toString(16))\n    }\n\n    return result.join(':')\n      .replace(/(^|:)0(:0)*:0(:|$)/, '$1::$3')\n      .replace(/:{3,4}/, '::')\n  }\n\n  return ''\n}\n", "import type { Protocol } from './index.js'\n\nconst V = -1\nexport const names: Record<string, Protocol> = {}\nexport const codes: Record<number, Protocol> = {}\n\nexport const table: Array<[number, number, string, boolean?, boolean?]> = [\n  [4, 32, 'ip4'],\n  [6, 16, 'tcp'],\n  [33, 16, 'dccp'],\n  [41, 128, 'ip6'],\n  [42, V, 'ip6zone'],\n  [43, 8, 'ipcidr'],\n  [53, V, 'dns', true],\n  [54, V, 'dns4', true],\n  [55, V, 'dns6', true],\n  [56, V, 'dnsaddr', true],\n  [132, 16, 'sctp'],\n  [273, 16, 'udp'],\n  [275, 0, 'p2p-webrtc-star'],\n  [276, 0, 'p2p-webrtc-direct'],\n  [277, 0, 'p2p-stardust'],\n  [280, 0, 'webrtc-direct'],\n  [281, 0, 'webrtc'],\n  [290, 0, 'p2p-circuit'],\n  [301, 0, 'udt'],\n  [302, 0, 'utp'],\n  [400, V, 'unix', false, true],\n  // `ipfs` is added before `p2p` for legacy support.\n  // All text representations will default to `p2p`, but `ipfs` will\n  // still be supported\n  [421, V, 'ipfs'],\n  // `p2p` is the preferred name for 421, and is now the default\n  [421, V, 'p2p'],\n  [443, 0, 'https'],\n  [444, 96, 'onion'],\n  [445, 296, 'onion3'],\n  [446, V, 'garlic64'],\n  [448, 0, 'tls'],\n  [449, V, 'sni'],\n  [460, 0, 'quic'],\n  [461, 0, 'quic-v1'],\n  [465, 0, 'webtransport'],\n  [466, V, 'certhash'],\n  [477, 0, 'ws'],\n  [478, 0, 'wss'],\n  [479, 0, 'p2p-websocket-star'],\n  [480, 0, 'http'],\n  [777, V, 'memory']\n]\n\n// populate tables\ntable.forEach(row => {\n  const proto = createProtocol(...row)\n  codes[proto.code] = proto\n  names[proto.name] = proto\n})\n\nexport function createProtocol (code: number, size: number, name: string, resolvable?: any, path?: any): Protocol {\n  return {\n    code,\n    size,\n    name,\n    resolvable: Boolean(resolvable),\n    path: Boolean(path)\n  }\n}\n\n/**\n * For the passed proto string or number, return a {@link Protocol}\n *\n * @example\n *\n * ```js\n * import { protocol } from '@multiformats/multiaddr'\n *\n * console.info(protocol(4))\n * // { code: 4, size: 32, name: 'ip4', resolvable: false, path: false }\n * ```\n */\nexport function getProtocol (proto: number | string): Protocol {\n  if (typeof proto === 'number') {\n    if (codes[proto] != null) {\n      return codes[proto]\n    }\n\n    throw new Error(`no protocol with code: ${proto}`)\n  } else if (typeof proto === 'string') {\n    if (names[proto] != null) {\n      return names[proto]\n    }\n\n    throw new Error(`no protocol with name: ${proto}`)\n  }\n\n  throw new Error(`invalid protocol id type: ${typeof proto}`)\n}\n", "/**\n * @packageDocumentation\n *\n * Provides methods for converting\n */\n\nimport { IpNet } from '@chainsafe/netmask'\nimport { base32 } from 'multiformats/bases/base32'\nimport { base58btc } from 'multiformats/bases/base58'\nimport { bases } from 'multiformats/basics'\nimport { CID } from 'multiformats/cid'\nimport * as Digest from 'multiformats/hashes/digest'\nimport * as varint from 'uint8-varint'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport * as ip from './ip.js'\nimport { getProtocol } from './protocols-table.js'\nimport type { Multiaddr } from './index.js'\n\nconst ip4Protocol = getProtocol('ip4')\nconst ip6Protocol = getProtocol('ip6')\nconst ipcidrProtocol = getProtocol('ipcidr')\n\n/**\n * converts (serializes) addresses\n */\nexport function convert (proto: string, a: string): Uint8Array\nexport function convert (proto: string, a: Uint8Array): string\nexport function convert (proto: string, a: string | Uint8Array): Uint8Array | string {\n  if (a instanceof Uint8Array) {\n    return convertToString(proto, a)\n  } else {\n    return convertToBytes(proto, a)\n  }\n}\n\n/**\n * Convert [code,Uint8Array] to string\n */\nexport function convertToString (proto: number | string, buf: Uint8Array): string {\n  const protocol = getProtocol(proto)\n  switch (protocol.code) {\n    case 4: // ipv4\n    case 41: // ipv6\n      return bytes2ip(buf)\n    case 42: // ipv6zone\n      return bytes2str(buf)\n\n    case 6: // tcp\n    case 273: // udp\n    case 33: // dccp\n    case 132: // sctp\n      return bytes2port(buf).toString()\n\n    case 53: // dns\n    case 54: // dns4\n    case 55: // dns6\n    case 56: // dnsaddr\n    case 400: // unix\n    case 449: // sni\n    case 777: // memory\n      return bytes2str(buf)\n\n    case 421: // ipfs\n      return bytes2mh(buf)\n    case 444: // onion\n      return bytes2onion(buf)\n    case 445: // onion3\n      return bytes2onion(buf)\n    case 466: // certhash\n      return bytes2mb(buf)\n    default:\n      return uint8ArrayToString(buf, 'base16') // no clue. convert to hex\n  }\n}\n\nexport function convertToBytes (proto: string | number, str: string): Uint8Array {\n  const protocol = getProtocol(proto)\n  switch (protocol.code) {\n    case 4: // ipv4\n      return ip2bytes(str)\n    case 41: // ipv6\n      return ip2bytes(str)\n    case 42: // ipv6zone\n      return str2bytes(str)\n\n    case 6: // tcp\n    case 273: // udp\n    case 33: // dccp\n    case 132: // sctp\n      return port2bytes(parseInt(str, 10))\n\n    case 53: // dns\n    case 54: // dns4\n    case 55: // dns6\n    case 56: // dnsaddr\n    case 400: // unix\n    case 449: // sni\n    case 777: // memory\n      return str2bytes(str)\n\n    case 421: // ipfs\n      return mh2bytes(str)\n    case 444: // onion\n      return onion2bytes(str)\n    case 445: // onion3\n      return onion32bytes(str)\n    case 466: // certhash\n      return mb2bytes(str)\n    default:\n      return uint8ArrayFromString(str, 'base16') // no clue. convert from hex\n  }\n}\n\nexport function convertToIpNet (multiaddr: Multiaddr): IpNet {\n  let mask: string | undefined\n  let addr: string | undefined\n  multiaddr.stringTuples().forEach(([code, value]) => {\n    if (code === ip4Protocol.code || code === ip6Protocol.code) {\n      addr = value\n    }\n    if (code === ipcidrProtocol.code) {\n      mask = value\n    }\n  })\n  if (mask == null || addr == null) {\n    throw new Error('Invalid multiaddr')\n  }\n  return new IpNet(addr, mask)\n}\n\nconst decoders = Object.values(bases).map((c) => c.decoder)\nconst anybaseDecoder = (function () {\n  let acc = decoders[0].or(decoders[1])\n  decoders.slice(2).forEach((d) => (acc = acc.or(d)))\n  return acc\n})()\n\nfunction ip2bytes (ipString: string): Uint8Array {\n  if (!ip.isIP(ipString)) {\n    throw new Error('invalid ip address')\n  }\n  return ip.toBytes(ipString)\n}\n\nfunction bytes2ip (ipBuff: Uint8Array): string {\n  const ipString = ip.toString(ipBuff, 0, ipBuff.length)\n  if (ipString == null) {\n    throw new Error('ipBuff is required')\n  }\n  if (!ip.isIP(ipString)) {\n    throw new Error('invalid ip address')\n  }\n  return ipString\n}\n\nfunction port2bytes (port: number): Uint8Array {\n  const buf = new ArrayBuffer(2)\n  const view = new DataView(buf)\n  view.setUint16(0, port)\n\n  return new Uint8Array(buf)\n}\n\nfunction bytes2port (buf: Uint8Array): number {\n  const view = new DataView(buf.buffer)\n  return view.getUint16(buf.byteOffset)\n}\n\nfunction str2bytes (str: string): Uint8Array {\n  const buf = uint8ArrayFromString(str)\n  const size = Uint8Array.from(varint.encode(buf.length))\n  return uint8ArrayConcat([size, buf], size.length + buf.length)\n}\n\nfunction bytes2str (buf: Uint8Array): string {\n  const size = varint.decode(buf)\n  buf = buf.slice(varint.encodingLength(size))\n\n  if (buf.length !== size) {\n    throw new Error('inconsistent lengths')\n  }\n\n  return uint8ArrayToString(buf)\n}\n\nfunction mh2bytes (hash: string): Uint8Array {\n  let mh\n\n  if (hash[0] === 'Q' || hash[0] === '1') {\n    mh = Digest.decode(base58btc.decode(`z${hash}`)).bytes\n  } else {\n    mh = CID.parse(hash).multihash.bytes\n  }\n\n  // the address is a varint prefixed multihash string representation\n  const size = Uint8Array.from(varint.encode(mh.length))\n  return uint8ArrayConcat([size, mh], size.length + mh.length)\n}\n\nfunction mb2bytes (mbstr: string): Uint8Array {\n  const mb = anybaseDecoder.decode(mbstr)\n  const size = Uint8Array.from(varint.encode(mb.length))\n  return uint8ArrayConcat([size, mb], size.length + mb.length)\n}\nfunction bytes2mb (buf: Uint8Array): string {\n  const size = varint.decode(buf)\n  const hash = buf.slice(varint.encodingLength(size))\n\n  if (hash.length !== size) {\n    throw new Error('inconsistent lengths')\n  }\n\n  return 'u' + uint8ArrayToString(hash, 'base64url')\n}\n\n/**\n * Converts bytes to bas58btc string\n */\nfunction bytes2mh (buf: Uint8Array): string {\n  const size = varint.decode(buf)\n  const address = buf.slice(varint.encodingLength(size))\n\n  if (address.length !== size) {\n    throw new Error('inconsistent lengths')\n  }\n\n  return uint8ArrayToString(address, 'base58btc')\n}\n\nfunction onion2bytes (str: string): Uint8Array {\n  const addr = str.split(':')\n  if (addr.length !== 2) {\n    throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`)\n  }\n  if (addr[0].length !== 16) {\n    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`)\n  }\n\n  // onion addresses do not include the multibase prefix, add it before decoding\n  const buf = base32.decode('b' + addr[0])\n\n  // onion port number\n  const port = parseInt(addr[1], 10)\n  if (port < 1 || port > 65536) {\n    throw new Error('Port number is not in range(1, 65536)')\n  }\n  const portBuf = port2bytes(port)\n  return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length)\n}\n\nfunction onion32bytes (str: string): Uint8Array {\n  const addr = str.split(':')\n  if (addr.length !== 2) {\n    throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`)\n  }\n  if (addr[0].length !== 56) {\n    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`)\n  }\n  // onion addresses do not include the multibase prefix, add it before decoding\n  const buf = base32.decode(`b${addr[0]}`)\n\n  // onion port number\n  const port = parseInt(addr[1], 10)\n  if (port < 1 || port > 65536) {\n    throw new Error('Port number is not in range(1, 65536)')\n  }\n  const portBuf = port2bytes(port)\n  return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length)\n}\n\nfunction bytes2onion (buf: Uint8Array): string {\n  const addrBytes = buf.slice(0, buf.length - 2)\n  const portBytes = buf.slice(buf.length - 2)\n  const addr = uint8ArrayToString(addrBytes, 'base32')\n  const port = bytes2port(portBytes)\n  return `${addr}:${port}`\n}\n", "import * as varint from 'uint8-varint'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { convertToBytes, convertToString } from './convert.js'\nimport { getProtocol } from './protocols-table.js'\nimport type { StringTuple, Tuple, Protocol } from './index.js'\n\nexport interface MultiaddrParts {\n  bytes: Uint8Array\n  string: string\n  tuples: Tuple[]\n  stringTuples: StringTuple[]\n  path: string | null\n}\n\nexport function stringToMultiaddrParts (str: string): MultiaddrParts {\n  str = cleanPath(str)\n  const tuples: Tuple[] = []\n  const stringTuples: StringTuple[] = []\n  let path: string | null = null\n\n  const parts = str.split('/').slice(1)\n  if (parts.length === 1 && parts[0] === '') {\n    return {\n      bytes: new Uint8Array(),\n      string: '/',\n      tuples: [],\n      stringTuples: [],\n      path: null\n    }\n  }\n\n  for (let p = 0; p < parts.length; p++) {\n    const part = parts[p]\n    const proto = getProtocol(part)\n\n    if (proto.size === 0) {\n      tuples.push([proto.code])\n      stringTuples.push([proto.code])\n      // eslint-disable-next-line no-continue\n      continue\n    }\n\n    p++ // advance addr part\n    if (p >= parts.length) {\n      throw ParseError('invalid address: ' + str)\n    }\n\n    // if it's a path proto, take the rest\n    if (proto.path === true) {\n      // should we need to check each path part to see if it's a proto?\n      // This would allow for other protocols to be added after a unix path,\n      // however it would have issues if the path had a protocol name in the path\n      path = cleanPath(parts.slice(p).join('/'))\n      tuples.push([proto.code, convertToBytes(proto.code, path)])\n      stringTuples.push([proto.code, path])\n      break\n    }\n\n    const bytes = convertToBytes(proto.code, parts[p])\n    tuples.push([proto.code, bytes])\n    stringTuples.push([proto.code, convertToString(proto.code, bytes)])\n  }\n\n  return {\n    string: stringTuplesToString(stringTuples),\n    bytes: tuplesToBytes(tuples),\n    tuples,\n    stringTuples,\n    path\n  }\n}\n\nexport function bytesToMultiaddrParts (bytes: Uint8Array): MultiaddrParts {\n  const tuples: Tuple[] = []\n  const stringTuples: StringTuple[] = []\n  let path: string | null = null\n\n  let i = 0\n  while (i < bytes.length) {\n    const code = varint.decode(bytes, i)\n    const n = varint.encodingLength(code)\n\n    const p = getProtocol(code)\n\n    const size = sizeForAddr(p, bytes.slice(i + n))\n\n    if (size === 0) {\n      tuples.push([code])\n      stringTuples.push([code])\n      i += n\n      // eslint-disable-next-line no-continue\n      continue\n    }\n\n    const addr = bytes.slice(i + n, i + n + size)\n\n    i += (size + n)\n\n    if (i > bytes.length) { // did not end _exactly_ at buffer.length\n      throw ParseError('Invalid address Uint8Array: ' + uint8ArrayToString(bytes, 'base16'))\n    }\n\n    // ok, tuple seems good.\n    tuples.push([code, addr])\n    const stringAddr = convertToString(code, addr)\n    stringTuples.push([code, stringAddr])\n    if (p.path === true) {\n      // should we need to check each path part to see if it's a proto?\n      // This would allow for other protocols to be added after a unix path,\n      // however it would have issues if the path had a protocol name in the path\n      path = stringAddr\n      break\n    }\n  }\n\n  return {\n    bytes: Uint8Array.from(bytes),\n    string: stringTuplesToString(stringTuples),\n    tuples,\n    stringTuples,\n    path\n  }\n}\n\n/**\n * [[str name, str addr]... ] -> string\n */\nfunction stringTuplesToString (tuples: StringTuple[]): string {\n  const parts: string[] = []\n  tuples.map((tup) => {\n    const proto = getProtocol(tup[0])\n    parts.push(proto.name)\n    if (tup.length > 1 && tup[1] != null) {\n      parts.push(tup[1])\n    }\n    return null\n  })\n\n  return cleanPath(parts.join('/'))\n}\n\n/**\n * [[int code, Uint8Array ]... ] -> Uint8Array\n */\nexport function tuplesToBytes (tuples: Tuple[]): Uint8Array {\n  return uint8ArrayConcat(tuples.map((tup) => {\n    const proto = getProtocol(tup[0])\n    let buf = Uint8Array.from(varint.encode(proto.code))\n\n    if (tup.length > 1 && tup[1] != null) {\n      buf = uint8ArrayConcat([buf, tup[1]]) // add address buffer\n    }\n\n    return buf\n  }))\n}\n\n/**\n * For the passed address, return the serialized size\n */\nfunction sizeForAddr (p: Protocol, addr: Uint8Array | number[]): number {\n  if (p.size > 0) {\n    return p.size / 8\n  } else if (p.size === 0) {\n    return 0\n  } else {\n    const size = varint.decode(addr instanceof Uint8Array ? addr : Uint8Array.from(addr))\n    return size + varint.encodingLength(size)\n  }\n}\n\nexport function bytesToTuples (buf: Uint8Array): Tuple[] {\n  const tuples: Array<[number, Uint8Array?]> = []\n  let i = 0\n  while (i < buf.length) {\n    const code = varint.decode(buf, i)\n    const n = varint.encodingLength(code)\n\n    const p = getProtocol(code)\n\n    const size = sizeForAddr(p, buf.slice(i + n))\n\n    if (size === 0) {\n      tuples.push([code])\n      i += n\n      // eslint-disable-next-line no-continue\n      continue\n    }\n\n    const addr = buf.slice(i + n, i + n + size)\n\n    i += (size + n)\n\n    if (i > buf.length) { // did not end _exactly_ at buffer.length\n      throw ParseError('Invalid address Uint8Array: ' + uint8ArrayToString(buf, 'base16'))\n    }\n\n    // ok, tuple seems good.\n    tuples.push([code, addr])\n  }\n\n  return tuples\n}\n\nexport function cleanPath (str: string): string {\n  return '/' + str.trim().split('/').filter((a) => a).join('/')\n}\n\nexport function ParseError (str: string): Error {\n  return new Error('Error parsing address: ' + str)\n}\n", "/**\n * @packageDocumentation\n *\n * An implementation of a Multiaddr in JavaScript\n *\n * @example\n *\n * ```js\n * import { multiaddr } from '@multiformats/multiaddr'\n *\n * const ma = multiaddr('/ip4/127.0.0.1/tcp/1234')\n * ```\n */\n\nimport { CodeError } from '@libp2p/interface/errors'\nimport { base58btc } from 'multiformats/bases/base58'\nimport { CID } from 'multiformats/cid'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { bytesToMultiaddrParts, stringToMultiaddrParts, type MultiaddrParts, tuplesToBytes } from './codec.js'\nimport { getProtocol, names } from './protocols-table.js'\nimport { isMultiaddr, type AbortOptions, type MultiaddrInput, type Multiaddr as MultiaddrInterface, type MultiaddrObject, type Protocol, type StringTuple, type Tuple, resolvers, type NodeAddress } from './index.js'\n\nconst inspect = Symbol.for('nodejs.util.inspect.custom')\nexport const symbol = Symbol.for('@multiformats/js-multiaddr/multiaddr')\n\nconst DNS_CODES = [\n  getProtocol('dns').code,\n  getProtocol('dns4').code,\n  getProtocol('dns6').code,\n  getProtocol('dnsaddr').code\n]\n\n/**\n * Creates a {@link Multiaddr} from a {@link MultiaddrInput}\n */\nexport class Multiaddr implements MultiaddrInterface {\n  public bytes: Uint8Array\n  #string: string\n  #tuples: Tuple[]\n  #stringTuples: StringTuple[]\n  #path: string | null\n\n  [symbol]: boolean = true\n\n  constructor (addr?: MultiaddrInput) {\n    // default\n    if (addr == null) {\n      addr = ''\n    }\n\n    let parts: MultiaddrParts\n    if (addr instanceof Uint8Array) {\n      parts = bytesToMultiaddrParts(addr)\n    } else if (typeof addr === 'string') {\n      if (addr.length > 0 && addr.charAt(0) !== '/') {\n        throw new Error(`multiaddr \"${addr}\" must start with a \"/\"`)\n      }\n      parts = stringToMultiaddrParts(addr)\n    } else if (isMultiaddr(addr)) { // Multiaddr\n      parts = bytesToMultiaddrParts(addr.bytes)\n    } else {\n      throw new Error('addr must be a string, Buffer, or another Multiaddr')\n    }\n\n    this.bytes = parts.bytes\n    this.#string = parts.string\n    this.#tuples = parts.tuples\n    this.#stringTuples = parts.stringTuples\n    this.#path = parts.path\n  }\n\n  toString (): string {\n    return this.#string\n  }\n\n  toJSON (): string {\n    return this.toString()\n  }\n\n  toOptions (): MultiaddrObject {\n    let family: 4 | 6 | undefined\n    let transport: string | undefined\n    let host: string | undefined\n    let port: number | undefined\n    let zone = ''\n\n    const tcp = getProtocol('tcp')\n    const udp = getProtocol('udp')\n    const ip4 = getProtocol('ip4')\n    const ip6 = getProtocol('ip6')\n    const dns6 = getProtocol('dns6')\n    const ip6zone = getProtocol('ip6zone')\n\n    for (const [code, value] of this.stringTuples()) {\n      if (code === ip6zone.code) {\n        zone = `%${value ?? ''}`\n      }\n\n      // default to https when protocol & port are omitted from DNS addrs\n      if (DNS_CODES.includes(code)) {\n        transport = tcp.name\n        port = 443\n        host = `${value ?? ''}${zone}`\n        family = code === dns6.code ? 6 : 4\n      }\n\n      if (code === tcp.code || code === udp.code) {\n        transport = getProtocol(code).name\n        port = parseInt(value ?? '')\n      }\n\n      if (code === ip4.code || code === ip6.code) {\n        transport = getProtocol(code).name\n        host = `${value ?? ''}${zone}`\n        family = code === ip6.code ? 6 : 4\n      }\n    }\n\n    if (family == null || transport == null || host == null || port == null) {\n      throw new Error('multiaddr must have a valid format: \"/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}\".')\n    }\n\n    const opts: MultiaddrObject = {\n      family,\n      host,\n      transport,\n      port\n    }\n\n    return opts\n  }\n\n  protos (): Protocol[] {\n    return this.#tuples.map(([code]) => Object.assign({}, getProtocol(code)))\n  }\n\n  protoCodes (): number[] {\n    return this.#tuples.map(([code]) => code)\n  }\n\n  protoNames (): string[] {\n    return this.#tuples.map(([code]) => getProtocol(code).name)\n  }\n\n  tuples (): Array<[number, Uint8Array?]> {\n    return this.#tuples\n  }\n\n  stringTuples (): Array<[number, string?]> {\n    return this.#stringTuples\n  }\n\n  encapsulate (addr: MultiaddrInput): Multiaddr {\n    addr = new Multiaddr(addr)\n    return new Multiaddr(this.toString() + addr.toString())\n  }\n\n  decapsulate (addr: Multiaddr | string): Multiaddr {\n    const addrString = addr.toString()\n    const s = this.toString()\n    const i = s.lastIndexOf(addrString)\n    if (i < 0) {\n      throw new Error(`Address ${this.toString()} does not contain subaddress: ${addr.toString()}`)\n    }\n    return new Multiaddr(s.slice(0, i))\n  }\n\n  decapsulateCode (code: number): Multiaddr {\n    const tuples = this.tuples()\n    for (let i = tuples.length - 1; i >= 0; i--) {\n      if (tuples[i][0] === code) {\n        return new Multiaddr(tuplesToBytes(tuples.slice(0, i)))\n      }\n    }\n    return this\n  }\n\n  getPeerId (): string | null {\n    try {\n      let tuples: Array<[number, string | undefined]> = []\n\n      this.stringTuples().forEach(([code, name]) => {\n        if (code === names.p2p.code) {\n          tuples.push([code, name])\n        }\n\n        // if this is a p2p-circuit address, return the target peer id if present\n        // not the peer id of the relay\n        if (code === names['p2p-circuit'].code) {\n          tuples = []\n        }\n      })\n\n      // Get the last ipfs tuple ['p2p', 'peerid string']\n      const tuple = tuples.pop()\n      if (tuple?.[1] != null) {\n        const peerIdStr = tuple[1]\n\n        // peer id is base58btc encoded string but not multibase encoded so add the `z`\n        // prefix so we can validate that it is correctly encoded\n        if (peerIdStr[0] === 'Q' || peerIdStr[0] === '1') {\n          return uint8ArrayToString(base58btc.decode(`z${peerIdStr}`), 'base58btc')\n        }\n\n        // try to parse peer id as CID\n        return uint8ArrayToString(CID.parse(peerIdStr).multihash.bytes, 'base58btc')\n      }\n\n      return null\n    } catch (e) {\n      return null\n    }\n  }\n\n  getPath (): string | null {\n    return this.#path\n  }\n\n  equals (addr: { bytes: Uint8Array }): boolean {\n    return uint8ArrayEquals(this.bytes, addr.bytes)\n  }\n\n  async resolve (options?: AbortOptions): Promise<Multiaddr[]> {\n    const resolvableProto = this.protos().find((p) => p.resolvable)\n\n    // Multiaddr is not resolvable?\n    if (resolvableProto == null) {\n      return [this]\n    }\n\n    const resolver = resolvers.get(resolvableProto.name)\n    if (resolver == null) {\n      throw new CodeError(`no available resolver for ${resolvableProto.name}`, 'ERR_NO_AVAILABLE_RESOLVER')\n    }\n\n    const addresses = await resolver(this, options)\n    return addresses.map((a) => new Multiaddr(a))\n  }\n\n  nodeAddress (): NodeAddress {\n    const options = this.toOptions()\n\n    if (options.transport !== 'tcp' && options.transport !== 'udp') {\n      throw new Error(`multiaddr must have a valid format - no protocol with name: \"${options.transport}\". Must have a valid transport protocol: \"{tcp, udp}\"`)\n    }\n\n    return {\n      family: options.family,\n      address: options.host,\n      port: options.port\n    }\n  }\n\n  isThinWaistAddress (addr?: Multiaddr): boolean {\n    const protos = (addr ?? this).protos()\n\n    if (protos.length !== 2) {\n      return false\n    }\n\n    if (protos[0].code !== 4 && protos[0].code !== 41) {\n      return false\n    }\n    if (protos[1].code !== 6 && protos[1].code !== 273) {\n      return false\n    }\n    return true\n  }\n\n  /**\n   * Returns Multiaddr as a human-readable string\n   * https://nodejs.org/api/util.html#utilinspectcustom\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * console.info(multiaddr('/ip4/127.0.0.1/tcp/4001'))\n   * // 'Multiaddr(/ip4/127.0.0.1/tcp/4001)'\n   * ```\n   */\n  [inspect] (): string {\n    return `Multiaddr(${this.#string})`\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * An implementation of a Multiaddr in JavaScript\n *\n * @example\n *\n * ```js\n * import { multiaddr } from '@multiformats/multiaddr'\n *\n * const ma = multiaddr('/ip4/127.0.0.1/tcp/1234')\n * ```\n */\n\nimport { Multiaddr as MultiaddrClass, symbol } from './multiaddr.js'\nimport { getProtocol } from './protocols-table.js'\n\n/**\n * Protocols are present in the protocol table\n */\nexport interface Protocol {\n  code: number\n  size: number\n  name: string\n  resolvable?: boolean | undefined\n  path?: boolean | undefined\n}\n\n/**\n * A plain JavaScript object representation of a {@link Multiaddr}\n */\nexport interface MultiaddrObject {\n  family: 4 | 6\n  host: string\n  transport: string\n  port: number\n}\n\n/**\n * A NodeAddress is an IPv4/IPv6 address/TCP port combination\n */\nexport interface NodeAddress {\n  family: 4 | 6\n  address: string\n  port: number\n}\n\n/**\n * These types can be parsed into a {@link Multiaddr} object\n */\nexport type MultiaddrInput = string | Multiaddr | Uint8Array | null\n\n/**\n * A Resolver is a function that takes a {@link Multiaddr} and resolves it into one\n * or more string representations of that {@link Multiaddr}.\n */\nexport interface Resolver { (addr: Multiaddr, options?: AbortOptions): Promise<string[]> }\n\n/**\n * A code/value pair\n */\nexport type Tuple = [number, Uint8Array?]\n\n/**\n * A code/value pair with the value as a string\n */\nexport type StringTuple = [number, string?]\n\n/**\n * Allows aborting long-lived operations\n */\nexport interface AbortOptions {\n  signal?: AbortSignal\n}\n\n/**\n * All configured {@link Resolver}s\n */\nexport const resolvers = new Map<string, Resolver>()\n\nexport { MultiaddrFilter } from './filter/multiaddr-filter.js'\n\nexport interface Multiaddr {\n  bytes: Uint8Array\n\n  /**\n   * Returns Multiaddr as a String\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').toString()\n   * // '/ip4/127.0.0.1/tcp/4001'\n   * ```\n   */\n  toString(): string\n\n  /**\n   * Returns Multiaddr as a JSON encoded object\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * JSON.stringify(multiaddr('/ip4/127.0.0.1/tcp/4001'))\n   * // '/ip4/127.0.0.1/tcp/4001'\n   * ```\n   */\n  toJSON(): string\n\n  /**\n   * Returns Multiaddr as a convinient options object to be used with net.createConnection\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').toOptions()\n   * // { family: 4, host: '127.0.0.1', transport: 'tcp', port: 4001 }\n   * ```\n   */\n  toOptions(): MultiaddrObject\n\n  /**\n   * Returns the protocols the Multiaddr is defined with, as an array of objects, in\n   * left-to-right order. Each object contains the protocol code, protocol name,\n   * and the size of its address space in bits.\n   * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').protos()\n   * // [ { code: 4, size: 32, name: 'ip4' },\n   * //   { code: 6, size: 16, name: 'tcp' } ]\n   * ```\n   */\n  protos(): Protocol[]\n\n  /**\n   * Returns the codes of the protocols in left-to-right order.\n   * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').protoCodes()\n   * // [ 4, 6 ]\n   * ```\n   */\n  protoCodes(): number[]\n\n  /**\n   * Returns the names of the protocols in left-to-right order.\n   * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').protoNames()\n   * // [ 'ip4', 'tcp' ]\n   * ```\n   */\n  protoNames(): string[]\n\n  /**\n   * Returns a tuple of parts\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').tuples()\n   * // [ [ 4, <Buffer 7f 00 00 01> ], [ 6, <Buffer 0f a1> ] ]\n   * ```\n   */\n  tuples(): Tuple[]\n\n  /**\n   * Returns a tuple of string/number parts\n   * - tuples[][0] = code of protocol\n   * - tuples[][1] = contents of address\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').stringTuples()\n   * // [ [ 4, '127.0.0.1' ], [ 6, '4001' ] ]\n   * ```\n   */\n  stringTuples(): StringTuple[]\n\n  /**\n   * Encapsulates a Multiaddr in another Multiaddr\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * const mh1 = multiaddr('/ip4/8.8.8.8/tcp/1080')\n   * // Multiaddr(/ip4/8.8.8.8/tcp/1080)\n   *\n   * const mh2 = multiaddr('/ip4/127.0.0.1/tcp/4001')\n   * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n   *\n   * const mh3 = mh1.encapsulate(mh2)\n   * // Multiaddr(/ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001)\n   *\n   * mh3.toString()\n   * // '/ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001'\n   * ```\n   *\n   * @param {MultiaddrInput} addr - Multiaddr to add into this Multiaddr\n   */\n  encapsulate(addr: MultiaddrInput): Multiaddr\n\n  /**\n   * Decapsulates a Multiaddr from another Multiaddr\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * const mh1 = multiaddr('/ip4/8.8.8.8/tcp/1080')\n   * // Multiaddr(/ip4/8.8.8.8/tcp/1080)\n   *\n   * const mh2 = multiaddr('/ip4/127.0.0.1/tcp/4001')\n   * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n   *\n   * const mh3 = mh1.encapsulate(mh2)\n   * // Multiaddr(/ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001)\n   *\n   * mh3.decapsulate(mh2).toString()\n   * // '/ip4/8.8.8.8/tcp/1080'\n   * ```\n   *\n   * @param {Multiaddr | string} addr - Multiaddr to remove from this Multiaddr\n   */\n  decapsulate(addr: Multiaddr | string): Multiaddr\n\n  /**\n   * A more reliable version of `decapsulate` if you are targeting a\n   * specific code, such as 421 (the `p2p` protocol code). The last index of the code\n   * will be removed from the `Multiaddr`, and a new instance will be returned.\n   * If the code is not present, the original `Multiaddr` is returned.\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * const addr = multiaddr('/ip4/0.0.0.0/tcp/8080/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSupNKC')\n   * // Multiaddr(/ip4/0.0.0.0/tcp/8080/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSupNKC)\n   *\n   * addr.decapsulateCode(421).toString()\n   * // '/ip4/0.0.0.0/tcp/8080'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/8080').decapsulateCode(421).toString()\n   * // '/ip4/127.0.0.1/tcp/8080'\n   * ```\n   */\n  decapsulateCode(code: number): Multiaddr\n\n  /**\n   * Extract the peerId if the multiaddr contains one\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * const mh1 = multiaddr('/ip4/8.8.8.8/tcp/1080/ipfs/QmValidBase58string')\n   * // Multiaddr(/ip4/8.8.8.8/tcp/1080/ipfs/QmValidBase58string)\n   *\n   * // should return QmValidBase58string or null if the id is missing or invalid\n   * const peerId = mh1.getPeerId()\n   * ```\n   */\n  getPeerId(): string | null\n\n  /**\n   * Extract the path if the multiaddr contains one\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * const mh1 = multiaddr('/ip4/8.8.8.8/tcp/1080/unix/tmp/p2p.sock')\n   * // Multiaddr(/ip4/8.8.8.8/tcp/1080/unix/tmp/p2p.sock)\n   *\n   * // should return utf8 string or null if the id is missing or invalid\n   * const path = mh1.getPath()\n   * ```\n   */\n  getPath(): string | null\n\n  /**\n   * Checks if two Multiaddrs are the same\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * const mh1 = multiaddr('/ip4/8.8.8.8/tcp/1080')\n   * // Multiaddr(/ip4/8.8.8.8/tcp/1080)\n   *\n   * const mh2 = multiaddr('/ip4/127.0.0.1/tcp/4001')\n   * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n   *\n   * mh1.equals(mh1)\n   * // true\n   *\n   * mh1.equals(mh2)\n   * // false\n   * ```\n   */\n  equals(addr: { bytes: Uint8Array }): boolean\n\n  /**\n   * Resolve multiaddr if containing resolvable hostname.\n   *\n   * @example\n   * ```js\n   * import { multiaddr, resolvers } from '@multiformats/multiaddr'\n   *\n   * resolvers.set('dnsaddr', resolverFunction)\n   * const mh1 = multiaddr('/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb')\n   * const resolvedMultiaddrs = await mh1.resolve()\n   * // [\n   * //   Multiaddr(/ip4/147.75.83.83/tcp/4001/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb),\n   * //   Multiaddr(/ip4/147.75.83.83/tcp/443/wss/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb),\n   * //   Multiaddr(/ip4/147.75.83.83/udp/4001/quic/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb)\n   * // ]\n   * ```\n   */\n  resolve(options?: AbortOptions): Promise<Multiaddr[]>\n\n  /**\n   * Gets a Multiaddrs node-friendly address object. Note that protocol information\n   * is left out: in Node (and most network systems) the protocol is unknowable\n   * given only the address.\n   *\n   * Has to be a ThinWaist Address, otherwise throws error\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').nodeAddress()\n   * // {family: 4, address: '127.0.0.1', port: 4001}\n   * ```\n   */\n  nodeAddress(): NodeAddress\n\n  /**\n   * Returns if a Multiaddr is a Thin Waist address or not.\n   *\n   * Thin Waist is if a Multiaddr adheres to the standard combination of:\n   *\n   * `{IPv4, IPv6}/{TCP, UDP}`\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * const mh1 = multiaddr('/ip4/127.0.0.1/tcp/4001')\n   * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n   * const mh2 = multiaddr('/ip4/192.168.2.1/tcp/5001')\n   * // Multiaddr(/ip4/192.168.2.1/tcp/5001)\n   * const mh3 = mh1.encapsulate(mh2)\n   * // Multiaddr(/ip4/127.0.0.1/tcp/4001/ip4/192.168.2.1/tcp/5001)\n   * const mh4 = multiaddr('/ip4/127.0.0.1/tcp/2000/wss/p2p-webrtc-star/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSooo2a')\n   * // Multiaddr(/ip4/127.0.0.1/tcp/2000/wss/p2p-webrtc-star/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSooo2a)\n   * mh1.isThinWaistAddress()\n   * // true\n   * mh2.isThinWaistAddress()\n   * // true\n   * mh3.isThinWaistAddress()\n   * // false\n   * mh4.isThinWaistAddress()\n   * // false\n   * ```\n   */\n  isThinWaistAddress(addr?: Multiaddr): boolean\n}\n\n/**\n * Creates a Multiaddr from a node-friendly address object\n *\n * @example\n * ```js\n * import { fromNodeAddress } from '@multiformats/multiaddr'\n *\n * fromNodeAddress({address: '127.0.0.1', port: '4001'}, 'tcp')\n * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n * ```\n */\nexport function fromNodeAddress (addr: NodeAddress, transport: string): Multiaddr {\n  if (addr == null) {\n    throw new Error('requires node address object')\n  }\n  if (transport == null) {\n    throw new Error('requires transport protocol')\n  }\n  let ip: string | undefined\n  let host = addr.address\n  switch (addr.family) {\n    case 4:\n      ip = 'ip4'\n      break\n    case 6:\n      ip = 'ip6'\n\n      if (host.includes('%')) {\n        const parts = host.split('%')\n\n        if (parts.length !== 2) {\n          throw Error('Multiple ip6 zones in multiaddr')\n        }\n\n        host = parts[0]\n        const zone = parts[1]\n        ip = `/ip6zone/${zone}/ip6`\n      }\n      break\n    default:\n      throw Error('Invalid addr family, should be 4 or 6.')\n  }\n  return new MultiaddrClass('/' + [ip, host, transport, addr.port].join('/'))\n}\n\n/**\n * Returns if something is a {@link Multiaddr} that is a resolvable name\n *\n * @example\n *\n * ```js\n * import { isName, multiaddr } from '@multiformats/multiaddr'\n *\n * isName(multiaddr('/ip4/127.0.0.1'))\n * // false\n * isName(multiaddr('/dns/ipfs.io'))\n * // true\n * ```\n */\nexport function isName (addr: Multiaddr): boolean {\n  if (!isMultiaddr(addr)) {\n    return false\n  }\n\n  // if a part of the multiaddr is resolvable, then return true\n  return addr.protos().some((proto) => proto.resolvable)\n}\n\n/**\n * Check if object is a {@link Multiaddr} instance\n *\n * @example\n *\n * ```js\n * import { isMultiaddr, multiaddr } from '@multiformats/multiaddr'\n *\n * isMultiaddr(5)\n * // false\n * isMultiaddr(multiaddr('/ip4/127.0.0.1'))\n * // true\n * ```\n */\nexport function isMultiaddr (value: any): value is Multiaddr {\n  return Boolean(value?.[symbol])\n}\n\n/**\n * A function that takes a {@link MultiaddrInput} and returns a {@link Multiaddr}\n *\n * @example\n * ```js\n * import { multiaddr } from '@libp2p/multiaddr'\n *\n * multiaddr('/ip4/127.0.0.1/tcp/4001')\n * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n * ```\n *\n * @param {MultiaddrInput} [addr] - If String or Uint8Array, needs to adhere to the address format of a [multiaddr](https://github.com/multiformats/multiaddr#string-format)\n */\nexport function multiaddr (addr?: MultiaddrInput): Multiaddr {\n  return new MultiaddrClass(addr)\n}\n\nexport { getProtocol as protocols }\n"],
  "mappings": "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",
  "names": ["setMaxListeners", "code", "name", "encode", "length", "i", "j", "decode", "string", "name", "decoders", "encode", "decode", "alphabet", "string", "codes", "encode", "decode", "identity_exports", "identity", "encode", "decode", "decode", "code", "code", "digest", "decode", "equals", "encode", "identity", "from", "name", "code", "encode", "digest", "name", "from", "base", "baseCache", "code", "digest", "equals", "base", "decode", "length", "cache", "cid", "identity_exports", "equals", "_a", "equals", "decode", "identity", "base58_exports", "base58btc", "base58flickr", "base", "name", "encode", "length", "i", "j", "decode", "string", "src", "_brrp__multiformats_scope_baseX", "base_x_default", "empty", "equals", "coerce", "fromString", "toString", "Encoder", "name", "Decoder", "or", "ComposedDecoder", "decoders", "Codec", "from", "encode", "decode", "baseX", "alphabet", "base_x_default", "coerce", "string", "codes", "rfc4648", "base58btc", "baseX", "base58flickr", "base32_exports", "base32", "base32hex", "base32hexpad", "base32hexpadupper", "base32hexupper", "base32pad", "base32padupper", "base32upper", "base32z", "base32", "rfc4648", "base32upper", "base32pad", "base32padupper", "base32hex", "base32hexupper", "base32hexpad", "base32hexpadupper", "base32z", "encode_1", "encode", "MSB", "REST", "MSBALL", "INT", "decode", "read", "MSB$1", "REST$1", "N1", "N2", "N3", "N4", "N5", "N6", "N7", "N8", "N9", "length", "varint", "_brrp_varint", "varint_default", "decode", "code", "varint_default", "encodeTo", "encodingLength", "create", "code", "digest", "encodingLength", "encodeTo", "Digest", "decode", "coerce", "equals", "format", "base", "toStringV0", "baseCache", "base58btc", "toStringV1", "base32", "cache", "baseCache", "CID", "code", "DAG_PB_CODE", "SHA_256_CODE", "digest", "create", "equals", "base", "format", "encodeCID", "cidSymbol", "decode", "coerce", "Digest", "length", "parseCIDtoBytes", "base58btc", "base32", "toStringV0", "cid", "toStringV1", "encodingLength", "encodeTo", "base10_exports", "base10", "base", "name", "encode", "length", "i", "j", "decode", "string", "src", "_brrp__multiformats_scope_baseX", "base_x_default", "empty", "equals", "coerce", "fromString", "toString", "Encoder", "name", "Decoder", "or", "ComposedDecoder", "decoders", "Codec", "from", "encode", "decode", "baseX", "alphabet", "base_x_default", "coerce", "string", "codes", "rfc4648", "base10", "baseX", "base16_exports", "base16", "base16upper", "base16", "rfc4648", "base16upper", "base2_exports", "base2", "base2", "rfc4648", "base256emoji_exports", "base256emoji", "alphabet", "alphabetBytesToChars", "alphabetCharsToBytes", "encode", "decode", "base256emoji", "from", "base32_exports", "base32", "base32hex", "base32hexpad", "base32hexpadupper", "base32hexupper", "base32pad", "base32padupper", "base32upper", "base32z", "base32", "rfc4648", "base32upper", "base32pad", "base32padupper", "base32hex", "base32hexupper", "base32hexpad", "base32hexpadupper", "base32z", "base36_exports", "base36", "base36upper", "base36", "baseX", "base36upper", "base58_exports", "base58btc", "base58flickr", "base58btc", "baseX", "base58flickr", "base64_exports", "base64", "base64pad", "base64url", "base64urlpad", "base64", "rfc4648", "base64pad", "base64url", "base64urlpad", "base8_exports", "base8", "base8", "rfc4648", "identity_exports", "identity", "identity", "from", "toString", "fromString", "textEncoder", "textDecoder", "identity_exports", "identity", "encode_1", "encode", "MSB", "REST", "MSBALL", "INT", "decode", "read", "MSB$1", "REST$1", "N1", "N2", "N3", "N4", "N5", "N6", "N7", "N8", "N9", "length", "varint", "_brrp_varint", "varint_default", "decode", "code", "varint_default", "encodeTo", "encodingLength", "create", "code", "digest", "encodingLength", "encodeTo", "Digest", "decode", "coerce", "equals", "code", "name", "encode", "coerce", "digest", "create", "identity", "sha2_browser_exports", "sha256", "sha512", "from", "name", "code", "encode", "Hasher", "create", "digest", "sha", "name", "sha256", "from", "sha512", "format", "base", "toStringV0", "baseCache", "base58btc", "toStringV1", "base32", "cache", "baseCache", "CID", "code", "DAG_PB_CODE", "SHA_256_CODE", "digest", "create", "equals", "base", "format", "encodeCID", "cidSymbol", "decode", "coerce", "Digest", "length", "parseCIDtoBytes", "base58btc", "base32", "toStringV0", "cid", "toStringV1", "encodingLength", "encodeTo", "bases", "identity_exports", "base2_exports", "base8_exports", "base10_exports", "base16_exports", "base32_exports", "base36_exports", "base58_exports", "base64_exports", "base256emoji_exports", "hashes", "sha2_browser_exports", "_a", "name", "encode", "decode", "string", "bases", "toString", "base", "N1", "N2", "N3", "N4", "N5", "N6", "N7", "MSB", "REST", "encodingLength", "encode", "decode", "length", "base10_exports", "base10", "base10", "baseX", "base16_exports", "base16", "base16upper", "base16", "rfc4648", "base16upper", "base2_exports", "base2", "base2", "rfc4648", "base256emoji_exports", "base256emoji", "alphabet", "alphabetBytesToChars", "alphabetCharsToBytes", "encode", "decode", "base256emoji", "from", "base36_exports", "base36", "base36upper", "base36", "baseX", "base36upper", "base64_exports", "base64", "base64pad", "base64url", "base64urlpad", "base64", "rfc4648", "base64pad", "base64url", "base64urlpad", "base8_exports", "base8", "base8", "rfc4648", "identity_exports", "identity", "identity", "from", "toString", "fromString", "textEncoder", "textDecoder", "identity_exports", "identity", "code", "name", "encode", "coerce", "digest", "create", "identity", "sha2_browser_exports", "sha256", "sha512", "from", "name", "code", "encode", "Hasher", "create", "digest", "sha", "name", "sha256", "from", "sha512", "bases", "identity_exports", "base2_exports", "base8_exports", "base10_exports", "base16_exports", "base32_exports", "base36_exports", "base58_exports", "base64_exports", "base256emoji_exports", "hashes", "sha2_browser_exports", "fromString", "string", "base", "toString", "length", "code", "name", "toString", "fromString", "bases", "toString", "fromString", "encode", "decode", "encodingLength", "base58btc", "CID", "base32", "code", "decode", "encodingLength", "toString", "encode", "inspect", "symbol", "_a", "code", "name", "toString", "base58btc", "CID", "equals", "symbol"]
}
