import {
  IEvents,
  JsonRpcProvider,
  encodeIss,
  esm_exports,
  formatJsonRpcError,
  formatJsonRpcRequest,
  formatJsonRpcResult,
  generateKeyPair,
  getBigIntRpcId,
  h,
  init_esm,
  isJsonRpcError,
  isJsonRpcRequest,
  isJsonRpcResponse,
  isJsonRpcResult,
  isLocalhostUrl,
  isWsUrl,
  parseConnectionError,
  require_browser,
  require_cjs as require_cjs2,
  require_cjs2 as require_cjs3,
  require_lodash,
  safeJsonParse,
  safeJsonStringify,
  signJWT
} from "./chunk-5ZOHYXZQ.js";
import {
  require_events
} from "./chunk-U6HGNFOU.js";
import {
  RELAY_JSONRPC,
  detect,
  require_chacha20poly1305,
  require_cjs,
  require_cjs2 as require_cjs4,
  require_cjs3 as require_cjs5,
  require_decode_uri_component,
  require_filter_obj,
  require_hkdf,
  require_random,
  require_sha256,
  require_split_on_first,
  require_strict_uri_encode,
  require_x25519
} from "./chunk-CU6BV7PM.js";
import "./chunk-OOANPFWA.js";
import {
  bases,
  init_basics
} from "./chunk-J7OBOGMR.js";
import "./chunk-LI7O2WKS.js";
import {
  __commonJS,
  __toESM
} from "./chunk-P3R5BNFQ.js";

// node_modules/@walletconnect/core/node_modules/query-string/index.js
var require_query_string = __commonJS({
  "node_modules/@walletconnect/core/node_modules/query-string/index.js"(exports) {
    "use strict";
    var strictUriEncode = require_strict_uri_encode();
    var decodeComponent = require_decode_uri_component();
    var splitOnFirst = require_split_on_first();
    var filterObject = require_filter_obj();
    var isNullOrUndefined = (value) => value === null || value === void 0;
    var encodeFragmentIdentifier = Symbol("encodeFragmentIdentifier");
    function encoderForArrayFormat(options) {
      switch (options.arrayFormat) {
        case "index":
          return (key) => (result, value) => {
            const index = result.length;
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode(key, options), "[", index, "]"].join("")];
            }
            return [
              ...result,
              [encode(key, options), "[", encode(index, options), "]=", encode(value, options)].join("")
            ];
          };
        case "bracket":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode(key, options), "[]"].join("")];
            }
            return [...result, [encode(key, options), "[]=", encode(value, options)].join("")];
          };
        case "colon-list-separator":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode(key, options), ":list="].join("")];
            }
            return [...result, [encode(key, options), ":list=", encode(value, options)].join("")];
          };
        case "comma":
        case "separator":
        case "bracket-separator": {
          const keyValueSep = options.arrayFormat === "bracket-separator" ? "[]=" : "=";
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            value = value === null ? "" : value;
            if (result.length === 0) {
              return [[encode(key, options), keyValueSep, encode(value, options)].join("")];
            }
            return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
          };
        }
        default:
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, encode(key, options)];
            }
            return [...result, [encode(key, options), "=", encode(value, options)].join("")];
          };
      }
    }
    function parserForArrayFormat(options) {
      let result;
      switch (options.arrayFormat) {
        case "index":
          return (key, value, accumulator) => {
            result = /\[(\d*)\]$/.exec(key);
            key = key.replace(/\[\d*\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = {};
            }
            accumulator[key][result[1]] = value;
          };
        case "bracket":
          return (key, value, accumulator) => {
            result = /(\[\])$/.exec(key);
            key = key.replace(/\[\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "colon-list-separator":
          return (key, value, accumulator) => {
            result = /(:list)$/.exec(key);
            key = key.replace(/:list$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "comma":
        case "separator":
          return (key, value, accumulator) => {
            const isArray = typeof value === "string" && value.includes(options.arrayFormatSeparator);
            const isEncodedArray = typeof value === "string" && !isArray && decode(value, options).includes(options.arrayFormatSeparator);
            value = isEncodedArray ? decode(value, options) : value;
            const newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map((item) => decode(item, options)) : value === null ? value : decode(value, options);
            accumulator[key] = newValue;
          };
        case "bracket-separator":
          return (key, value, accumulator) => {
            const isArray = /(\[\])$/.test(key);
            key = key.replace(/\[\]$/, "");
            if (!isArray) {
              accumulator[key] = value ? decode(value, options) : value;
              return;
            }
            const arrayValue = value === null ? [] : value.split(options.arrayFormatSeparator).map((item) => decode(item, options));
            if (accumulator[key] === void 0) {
              accumulator[key] = arrayValue;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], arrayValue);
          };
        default:
          return (key, value, accumulator) => {
            if (accumulator[key] === void 0) {
              accumulator[key] = value;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
      }
    }
    function validateArrayFormatSeparator(value) {
      if (typeof value !== "string" || value.length !== 1) {
        throw new TypeError("arrayFormatSeparator must be single character string");
      }
    }
    function encode(value, options) {
      if (options.encode) {
        return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
      }
      return value;
    }
    function decode(value, options) {
      if (options.decode) {
        return decodeComponent(value);
      }
      return value;
    }
    function keysSorter(input) {
      if (Array.isArray(input)) {
        return input.sort();
      }
      if (typeof input === "object") {
        return keysSorter(Object.keys(input)).sort((a3, b2) => Number(a3) - Number(b2)).map((key) => input[key]);
      }
      return input;
    }
    function removeHash(input) {
      const hashStart = input.indexOf("#");
      if (hashStart !== -1) {
        input = input.slice(0, hashStart);
      }
      return input;
    }
    function getHash(url) {
      let hash = "";
      const hashStart = url.indexOf("#");
      if (hashStart !== -1) {
        hash = url.slice(hashStart);
      }
      return hash;
    }
    function extract(input) {
      input = removeHash(input);
      const queryStart = input.indexOf("?");
      if (queryStart === -1) {
        return "";
      }
      return input.slice(queryStart + 1);
    }
    function parseValue(value, options) {
      if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
        value = Number(value);
      } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
        value = value.toLowerCase() === "true";
      }
      return value;
    }
    function parse2(query, options) {
      options = Object.assign({
        decode: true,
        sort: true,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: false,
        parseBooleans: false
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const formatter = parserForArrayFormat(options);
      const ret = /* @__PURE__ */ Object.create(null);
      if (typeof query !== "string") {
        return ret;
      }
      query = query.trim().replace(/^[?#&]/, "");
      if (!query) {
        return ret;
      }
      for (const param of query.split("&")) {
        if (param === "") {
          continue;
        }
        let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, " ") : param, "=");
        value = value === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(options.arrayFormat) ? value : decode(value, options);
        formatter(decode(key, options), value, ret);
      }
      for (const key of Object.keys(ret)) {
        const value = ret[key];
        if (typeof value === "object" && value !== null) {
          for (const k of Object.keys(value)) {
            value[k] = parseValue(value[k], options);
          }
        } else {
          ret[key] = parseValue(value, options);
        }
      }
      if (options.sort === false) {
        return ret;
      }
      return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
        const value = ret[key];
        if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
          result[key] = keysSorter(value);
        } else {
          result[key] = value;
        }
        return result;
      }, /* @__PURE__ */ Object.create(null));
    }
    exports.extract = extract;
    exports.parse = parse2;
    exports.stringify = (object, options) => {
      if (!object) {
        return "";
      }
      options = Object.assign({
        encode: true,
        strict: true,
        arrayFormat: "none",
        arrayFormatSeparator: ","
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const shouldFilter = (key) => options.skipNull && isNullOrUndefined(object[key]) || options.skipEmptyString && object[key] === "";
      const formatter = encoderForArrayFormat(options);
      const objectCopy = {};
      for (const key of Object.keys(object)) {
        if (!shouldFilter(key)) {
          objectCopy[key] = object[key];
        }
      }
      const keys = Object.keys(objectCopy);
      if (options.sort !== false) {
        keys.sort(options.sort);
      }
      return keys.map((key) => {
        const value = object[key];
        if (value === void 0) {
          return "";
        }
        if (value === null) {
          return encode(key, options);
        }
        if (Array.isArray(value)) {
          if (value.length === 0 && options.arrayFormat === "bracket-separator") {
            return encode(key, options) + "[]";
          }
          return value.reduce(formatter(key), []).join("&");
        }
        return encode(key, options) + "=" + encode(value, options);
      }).filter((x2) => x2.length > 0).join("&");
    };
    exports.parseUrl = (url, options) => {
      options = Object.assign({
        decode: true
      }, options);
      const [url_, hash] = splitOnFirst(url, "#");
      return Object.assign(
        {
          url: url_.split("?")[0] || "",
          query: parse2(extract(url), options)
        },
        options && options.parseFragmentIdentifier && hash ? { fragmentIdentifier: decode(hash, options) } : {}
      );
    };
    exports.stringifyUrl = (object, options) => {
      options = Object.assign({
        encode: true,
        strict: true,
        [encodeFragmentIdentifier]: true
      }, options);
      const url = removeHash(object.url).split("?")[0] || "";
      const queryFromUrl = exports.extract(object.url);
      const parsedQueryFromUrl = exports.parse(queryFromUrl, { sort: false });
      const query = Object.assign(parsedQueryFromUrl, object.query);
      let queryString = exports.stringify(query, options);
      if (queryString) {
        queryString = `?${queryString}`;
      }
      let hash = getHash(object.url);
      if (object.fragmentIdentifier) {
        hash = `#${options[encodeFragmentIdentifier] ? encode(object.fragmentIdentifier, options) : object.fragmentIdentifier}`;
      }
      return `${url}${queryString}${hash}`;
    };
    exports.pick = (input, filter, options) => {
      options = Object.assign({
        parseFragmentIdentifier: true,
        [encodeFragmentIdentifier]: false
      }, options);
      const { url, query, fragmentIdentifier } = exports.parseUrl(input, options);
      return exports.stringifyUrl({
        url,
        query: filterObject(query, filter),
        fragmentIdentifier
      }, options);
    };
    exports.exclude = (input, filter, options) => {
      const exclusionFilter = Array.isArray(filter) ? (key) => !filter.includes(key) : (key, value) => !filter(key, value);
      return exports.pick(input, exclusionFilter, options);
    };
  }
});

// node_modules/@walletconnect/core/dist/index.es.js
var import_events4 = __toESM(require_events());
var import_heartbeat = __toESM(require_cjs2());
var import_logger = __toESM(require_cjs3());

// node_modules/@walletconnect/core/node_modules/@walletconnect/types/dist/index.es.js
init_esm();
var import_events2 = __toESM(require_events());
var n = class extends IEvents {
  constructor(s) {
    super(), this.opts = s, this.protocol = "wc", this.version = 2;
  }
};
var h2 = class extends IEvents {
  constructor(s, t) {
    super(), this.core = s, this.logger = t, this.records = /* @__PURE__ */ new Map();
  }
};
var a = class {
  constructor(s, t) {
    this.logger = s, this.core = t;
  }
};
var u = class extends IEvents {
  constructor(s, t) {
    super(), this.relayer = s, this.logger = t;
  }
};
var g = class extends IEvents {
  constructor(s) {
    super();
  }
};
var p = class {
  constructor(s, t, o, w4) {
    this.core = s, this.logger = t, this.name = o;
  }
};
var d = class extends IEvents {
  constructor(s, t) {
    super(), this.relayer = s, this.logger = t;
  }
};
var E = class extends IEvents {
  constructor(s, t) {
    super(), this.core = s, this.logger = t;
  }
};
var y = class {
  constructor(s, t) {
    this.projectId = s, this.logger = t;
  }
};

// node_modules/@walletconnect/core/node_modules/@walletconnect/utils/dist/index.es.js
var import_chacha20poly1305 = __toESM(require_chacha20poly1305());
var import_hkdf = __toESM(require_hkdf());
var import_random = __toESM(require_random());
var import_sha256 = __toESM(require_sha256());
var fe = __toESM(require_x25519());

// node_modules/@walletconnect/core/node_modules/uint8arrays/esm/src/util/as-uint8array.js
function asUint8Array(buf) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  return buf;
}

// node_modules/@walletconnect/core/node_modules/uint8arrays/esm/src/alloc.js
function allocUnsafe(size = 0) {
  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
    return asUint8Array(globalThis.Buffer.allocUnsafe(size));
  }
  return new Uint8Array(size);
}

// node_modules/@walletconnect/core/node_modules/uint8arrays/esm/src/concat.js
function concat(arrays, length) {
  if (!length) {
    length = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output = allocUnsafe(length);
  let offset = 0;
  for (const arr of arrays) {
    output.set(arr, offset);
    offset += arr.length;
  }
  return asUint8Array(output);
}

// node_modules/@walletconnect/core/node_modules/uint8arrays/esm/src/util/bases.js
init_basics();
function createCodec(name, prefix, encode, decode) {
  return {
    name,
    prefix,
    encoder: {
      name,
      prefix,
      encode
    },
    decoder: { decode }
  };
}
var string = createCodec("utf8", "u", (buf) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf);
}, (str) => {
  const encoder = new TextEncoder();
  return encoder.encode(str.substring(1));
});
var ascii = createCodec("ascii", "a", (buf) => {
  let string2 = "a";
  for (let i2 = 0; i2 < buf.length; i2++) {
    string2 += String.fromCharCode(buf[i2]);
  }
  return string2;
}, (str) => {
  str = str.substring(1);
  const buf = allocUnsafe(str.length);
  for (let i2 = 0; i2 < str.length; i2++) {
    buf[i2] = str.charCodeAt(i2);
  }
  return buf;
});
var BASES = {
  utf8: string,
  "utf-8": string,
  hex: bases.base16,
  latin1: ascii,
  ascii,
  binary: ascii,
  ...bases
};
var bases_default = BASES;

// node_modules/@walletconnect/core/node_modules/uint8arrays/esm/src/from-string.js
function fromString(string2, encoding = "utf8") {
  const base = bases_default[encoding];
  if (!base) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8Array(globalThis.Buffer.from(string2, "utf-8"));
  }
  return base.decoder.decode(`${base.prefix}${string2}`);
}

// node_modules/@walletconnect/core/node_modules/uint8arrays/esm/src/to-string.js
function toString(array, encoding = "utf8") {
  const base = bases_default[encoding];
  if (!base) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
  }
  return base.encoder.encode(array).substring(1);
}

// node_modules/@walletconnect/core/node_modules/@walletconnect/utils/dist/index.es.js
var import_time = __toESM(require_cjs());
var import_window_getters = __toESM(require_cjs4());
var import_window_metadata = __toESM(require_cjs5());
var V = __toESM(require_query_string());
var J = "base10";
var p2 = "base16";
var x = "base64pad";
var F = "utf8";
var Q = 0;
var _ = 1;
var $n = 0;
var Ie = 1;
var Z = 12;
var X = 32;
function jn() {
  const e = fe.generateKeyPair();
  return { privateKey: toString(e.secretKey, p2), publicKey: toString(e.publicKey, p2) };
}
function Dn() {
  const e = (0, import_random.randomBytes)(X);
  return toString(e, p2);
}
function kn(e, n2) {
  const t = fe.sharedKey(fromString(e, p2), fromString(n2, p2), true), r = new import_hkdf.HKDF(import_sha256.SHA256, t).expand(X);
  return toString(r, p2);
}
function Vn(e) {
  const n2 = (0, import_sha256.hash)(fromString(e, p2));
  return toString(n2, p2);
}
function Mn(e) {
  const n2 = (0, import_sha256.hash)(fromString(e, F));
  return toString(n2, p2);
}
function Pe(e) {
  return fromString(`${e}`, J);
}
function j(e) {
  return Number(toString(e, J));
}
function Kn(e) {
  const n2 = Pe(typeof e.type < "u" ? e.type : Q);
  if (j(n2) === _ && typeof e.senderPublicKey > "u")
    throw new Error("Missing sender public key for type 1 envelope");
  const t = typeof e.senderPublicKey < "u" ? fromString(e.senderPublicKey, p2) : void 0, r = typeof e.iv < "u" ? fromString(e.iv, p2) : (0, import_random.randomBytes)(Z), o = new import_chacha20poly1305.ChaCha20Poly1305(fromString(e.symKey, p2)).seal(r, fromString(e.message, F));
  return Te({ type: n2, sealed: o, iv: r, senderPublicKey: t });
}
function Ln(e) {
  const n2 = new import_chacha20poly1305.ChaCha20Poly1305(fromString(e.symKey, p2)), { sealed: t, iv: r } = ee(e.encoded), o = n2.open(r, t);
  if (o === null)
    throw new Error("Failed to decrypt");
  return toString(o, F);
}
function Te(e) {
  if (j(e.type) === _) {
    if (typeof e.senderPublicKey > "u")
      throw new Error("Missing sender public key for type 1 envelope");
    return toString(concat([e.type, e.senderPublicKey, e.iv, e.sealed]), x);
  }
  return toString(concat([e.type, e.iv, e.sealed]), x);
}
function ee(e) {
  const n2 = fromString(e, x), t = n2.slice($n, Ie), r = Ie;
  if (j(t) === _) {
    const d2 = r + X, l = d2 + Z, c2 = n2.slice(r, d2), u3 = n2.slice(d2, l), a3 = n2.slice(l);
    return { type: t, sealed: a3, iv: u3, senderPublicKey: c2 };
  }
  const o = r + Z, s = n2.slice(r, o), i2 = n2.slice(o);
  return { type: t, sealed: i2, iv: s };
}
function xn(e, n2) {
  const t = ee(e);
  return Re({ type: j(t.type), senderPublicKey: typeof t.senderPublicKey < "u" ? toString(t.senderPublicKey, p2) : void 0, receiverPublicKey: n2 == null ? void 0 : n2.receiverPublicKey });
}
function Re(e) {
  const n2 = (e == null ? void 0 : e.type) || Q;
  if (n2 === _) {
    if (typeof (e == null ? void 0 : e.senderPublicKey) > "u")
      throw new Error("missing sender public key");
    if (typeof (e == null ? void 0 : e.receiverPublicKey) > "u")
      throw new Error("missing receiver public key");
  }
  return { type: n2, senderPublicKey: e == null ? void 0 : e.senderPublicKey, receiverPublicKey: e == null ? void 0 : e.receiverPublicKey };
}
function Fn(e) {
  return e.type === _ && typeof e.senderPublicKey == "string" && typeof e.receiverPublicKey == "string";
}
var Hn = Object.defineProperty;
var Ae = Object.getOwnPropertySymbols;
var qn = Object.prototype.hasOwnProperty;
var Bn = Object.prototype.propertyIsEnumerable;
var Ue = (e, n2, t) => n2 in e ? Hn(e, n2, { enumerable: true, configurable: true, writable: true, value: t }) : e[n2] = t;
var _e = (e, n2) => {
  for (var t in n2 || (n2 = {}))
    qn.call(n2, t) && Ue(e, t, n2[t]);
  if (Ae)
    for (var t of Ae(n2))
      Bn.call(n2, t) && Ue(e, t, n2[t]);
  return e;
};
var Ce = "ReactNative";
var m = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" };
var je = "js";
function te() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
function C() {
  return !(0, import_window_getters.getDocument)() && !!(0, import_window_getters.getNavigator)() && navigator.product === Ce;
}
function q() {
  return !te() && !!(0, import_window_getters.getNavigator)();
}
function R() {
  return C() ? m.reactNative : te() ? m.node : q() ? m.browser : m.unknown;
}
function zn() {
  var e;
  try {
    return C() && typeof global < "u" && typeof (global == null ? void 0 : global.Application) < "u" ? (e = global.Application) == null ? void 0 : e.applicationId : void 0;
  } catch {
    return;
  }
}
function De(e, n2) {
  let t = V.parse(e);
  return t = _e(_e({}, t), n2), e = V.stringify(t), e;
}
function ke() {
  if (R() === m.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
    const { OS: t, Version: r } = global.Platform;
    return [t, r].join("-");
  }
  const e = detect();
  if (e === null)
    return "unknown";
  const n2 = e.os ? e.os.replace(" ", "").toLowerCase() : "unknown";
  return e.type === "browser" ? [n2, e.name, e.version].join("-") : [n2, e.version].join("-");
}
function Ve() {
  var e;
  const n2 = R();
  return n2 === m.browser ? [n2, ((e = (0, import_window_getters.getLocation)()) == null ? void 0 : e.host) || "unknown"].join(":") : n2;
}
function Me(e, n2, t) {
  const r = ke(), o = Ve();
  return [[e, n2].join("-"), [je, t].join("-"), r, o].join("/");
}
function Qn({ protocol: e, version: n2, relayUrl: t, sdkVersion: r, auth: o, projectId: s, useOnCloseEvent: i2, bundleId: d2 }) {
  const l = t.split("?"), c2 = Me(e, n2, r), u3 = { auth: o, ua: c2, projectId: s, useOnCloseEvent: i2 || void 0, origin: d2 || void 0 }, a3 = De(l[1] || "", u3);
  return l[0] + "?" + a3;
}
function nt(e) {
  return Object.fromEntries(e.entries());
}
function tt(e) {
  return new Map(Object.entries(e));
}
function it(e = import_time.FIVE_MINUTES, n2) {
  const t = (0, import_time.toMiliseconds)(e || import_time.FIVE_MINUTES);
  let r, o, s;
  return { resolve: (i2) => {
    s && r && (clearTimeout(s), r(i2));
  }, reject: (i2) => {
    s && o && (clearTimeout(s), o(i2));
  }, done: () => new Promise((i2, d2) => {
    s = setTimeout(() => {
      d2(new Error(n2));
    }, t), r = i2, o = d2;
  }) };
}
function ct(e, n2, t) {
  return new Promise(async (r, o) => {
    const s = setTimeout(() => o(new Error(t)), n2);
    try {
      const i2 = await e;
      r(i2);
    } catch (i2) {
      o(i2);
    }
    clearTimeout(s);
  });
}
function re(e, n2) {
  if (typeof n2 == "string" && n2.startsWith(`${e}:`))
    return n2;
  if (e.toLowerCase() === "topic") {
    if (typeof n2 != "string")
      throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${n2}`;
  } else if (e.toLowerCase() === "id") {
    if (typeof n2 != "number")
      throw new Error('Value must be "number" for expirer target type: id');
    return `id:${n2}`;
  }
  throw new Error(`Unknown expirer target type: ${e}`);
}
function at(e) {
  return re("topic", e);
}
function ut(e) {
  return re("id", e);
}
function lt(e) {
  const [n2, t] = e.split(":"), r = { id: void 0, topic: void 0 };
  if (n2 === "topic" && typeof t == "string")
    r.topic = t;
  else if (n2 === "id" && Number.isInteger(Number(t)))
    r.id = Number(t);
  else
    throw new Error(`Invalid target, expected id:number or topic:string, got ${n2}:${t}`);
  return r;
}
function dt(e, n2) {
  return (0, import_time.fromMiliseconds)((n2 || Date.now()) + (0, import_time.toMiliseconds)(e));
}
function ft(e) {
  return Date.now() >= (0, import_time.toMiliseconds)(e);
}
function pt(e, n2) {
  return `${e}${n2 ? `:${n2}` : ""}`;
}
var Fe = "irn";
function yt(e) {
  return (e == null ? void 0 : e.relay) || { protocol: Fe };
}
function ht(e) {
  const n2 = RELAY_JSONRPC[e];
  if (typeof n2 > "u")
    throw new Error(`Relay Protocol not supported: ${e}`);
  return n2;
}
var gt = Object.defineProperty;
var He = Object.getOwnPropertySymbols;
var vt = Object.prototype.hasOwnProperty;
var Et = Object.prototype.propertyIsEnumerable;
var qe = (e, n2, t) => n2 in e ? gt(e, n2, { enumerable: true, configurable: true, writable: true, value: t }) : e[n2] = t;
var bt = (e, n2) => {
  for (var t in n2 || (n2 = {}))
    vt.call(n2, t) && qe(e, t, n2[t]);
  if (He)
    for (var t of He(n2))
      Et.call(n2, t) && qe(e, t, n2[t]);
  return e;
};
function Be(e, n2 = "-") {
  const t = {}, r = "relay" + n2;
  return Object.keys(e).forEach((o) => {
    if (o.startsWith(r)) {
      const s = o.replace(r, ""), i2 = e[o];
      t[s] = i2;
    }
  }), t;
}
function Nt(e) {
  e = e.includes("wc://") ? e.replace("wc://", "") : e, e = e.includes("wc:") ? e.replace("wc:", "") : e;
  const n2 = e.indexOf(":"), t = e.indexOf("?") !== -1 ? e.indexOf("?") : void 0, r = e.substring(0, n2), o = e.substring(n2 + 1, t).split("@"), s = typeof t < "u" ? e.substring(t) : "", i2 = V.parse(s);
  return { protocol: r, topic: Ge(o[0]), version: parseInt(o[1], 10), symKey: i2.symKey, relay: Be(i2) };
}
function Ge(e) {
  return e.startsWith("//") ? e.substring(2) : e;
}
function We(e, n2 = "-") {
  const t = "relay", r = {};
  return Object.keys(e).forEach((o) => {
    const s = t + n2 + o;
    e[o] && (r[s] = e[o]);
  }), r;
}
function Ot(e) {
  return `${e.protocol}:${e.topic}@${e.version}?` + V.stringify(bt({ symKey: e.symKey }, We(e.relay)));
}
var Ct = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } };
var $t = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function N(e, n2) {
  const { message: t, code: r } = $t[e];
  return { message: n2 ? `${t} ${n2}` : t, code: r };
}
function U(e, n2) {
  const { message: t, code: r } = Ct[e];
  return { message: n2 ? `${t} ${n2}` : t, code: r };
}
function D(e, n2) {
  return Array.isArray(e) ? typeof n2 < "u" && e.length ? e.every(n2) : true : false;
}
function w(e) {
  return typeof e > "u";
}
function h3(e, n2) {
  return n2 && w(e) ? true : typeof e == "string" && !!e.trim().length;
}
function Dt(e) {
  if (h3(e, false))
    try {
      return typeof new URL(e) < "u";
    } catch {
      return false;
    }
  return false;
}
function kt(e) {
  var n2;
  return (n2 = e == null ? void 0 : e.proposer) == null ? void 0 : n2.publicKey;
}
function Vt(e) {
  return e == null ? void 0 : e.topic;
}
function Ft(e) {
  return typeof e < "u" && typeof e !== null;
}
function Xt() {
  const e = R();
  return new Promise((n2) => {
    switch (e) {
      case m.browser:
        n2(dn());
        break;
      case m.reactNative:
        n2(fn());
        break;
      case m.node:
        n2(pn());
        break;
      default:
        n2(true);
    }
  });
}
function dn() {
  return q() && (navigator == null ? void 0 : navigator.onLine);
}
async function fn() {
  if (C() && typeof global < "u" && global != null && global.NetInfo) {
    const e = await (global == null ? void 0 : global.NetInfo.fetch());
    return e == null ? void 0 : e.isConnected;
  }
  return true;
}
function pn() {
  return true;
}
function er(e) {
  switch (R()) {
    case m.browser:
      mn(e);
      break;
    case m.reactNative:
      yn(e);
      break;
    case m.node:
      break;
  }
}
function mn(e) {
  !C() && q() && (window.addEventListener("online", () => e(true)), window.addEventListener("offline", () => e(false)));
}
function yn(e) {
  C() && typeof global < "u" && global != null && global.NetInfo && (global == null ? void 0 : global.NetInfo.addEventListener((n2) => e(n2 == null ? void 0 : n2.isConnected)));
}

// node_modules/@walletconnect/core/dist/index.es.js
var import_time2 = __toESM(require_cjs());

// node_modules/@walletconnect/jsonrpc-ws-connection/dist/index.es.js
var import_events3 = __toESM(require_events());
var w2 = () => typeof WebSocket < "u" ? WebSocket : typeof global < "u" && typeof global.WebSocket < "u" ? global.WebSocket : typeof window < "u" && typeof window.WebSocket < "u" ? window.WebSocket : typeof self < "u" && typeof self.WebSocket < "u" ? self.WebSocket : require_browser();
var b = () => typeof WebSocket < "u" || typeof global < "u" && typeof global.WebSocket < "u" || typeof window < "u" && typeof window.WebSocket < "u" || typeof self < "u" && typeof self.WebSocket < "u";
var a2 = (c2) => c2.split("?")[0];
var h4 = 10;
var S = w2();
var f = class {
  constructor(e) {
    if (this.url = e, this.events = new import_events3.EventEmitter(), this.registering = false, !isWsUrl(e))
      throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
    this.url = e;
  }
  get connected() {
    return typeof this.socket < "u";
  }
  get connecting() {
    return this.registering;
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async open(e = this.url) {
    await this.register(e);
  }
  async close() {
    return new Promise((e, t) => {
      if (typeof this.socket > "u") {
        t(new Error("Connection already closed"));
        return;
      }
      this.socket.onclose = (n2) => {
        this.onClose(n2), e();
      }, this.socket.close();
    });
  }
  async send(e) {
    typeof this.socket > "u" && (this.socket = await this.register());
    try {
      this.socket.send(safeJsonStringify(e));
    } catch (t) {
      this.onError(e.id, t);
    }
  }
  register(e = this.url) {
    if (!isWsUrl(e))
      throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
    if (this.registering) {
      const t = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= t || this.events.listenerCount("open") >= t) && this.events.setMaxListeners(t + 1), new Promise((n2, o) => {
        this.events.once("register_error", (s) => {
          this.resetMaxListeners(), o(s);
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.socket > "u")
            return o(new Error("WebSocket connection is missing or invalid"));
          n2(this.socket);
        });
      });
    }
    return this.url = e, this.registering = true, new Promise((t, n2) => {
      const o = new URLSearchParams(e).get("origin"), s = (0, esm_exports.isReactNative)() ? { headers: { origin: o } } : { rejectUnauthorized: !isLocalhostUrl(e) }, i2 = new S(e, [], s);
      b() ? i2.onerror = (r) => {
        const l = r;
        n2(this.emitError(l.error));
      } : i2.on("error", (r) => {
        n2(this.emitError(r));
      }), i2.onopen = () => {
        this.onOpen(i2), t(i2);
      };
    });
  }
  onOpen(e) {
    e.onmessage = (t) => this.onPayload(t), e.onclose = (t) => this.onClose(t), this.socket = e, this.registering = false, this.events.emit("open");
  }
  onClose(e) {
    this.socket = void 0, this.registering = false, this.events.emit("close", e);
  }
  onPayload(e) {
    if (typeof e.data > "u")
      return;
    const t = typeof e.data == "string" ? safeJsonParse(e.data) : e.data;
    this.events.emit("payload", t);
  }
  onError(e, t) {
    const n2 = this.parseError(t), o = n2.message || n2.toString(), s = formatJsonRpcError(e, o);
    this.events.emit("payload", s);
  }
  parseError(e, t = this.url) {
    return parseConnectionError(e, a2(t), "WS");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > h4 && this.events.setMaxListeners(h4);
  }
  emitError(e) {
    const t = this.parseError(new Error((e == null ? void 0 : e.message) || `WebSocket connection failed for host: ${a2(this.url)}`));
    return this.events.emit("register_error", t), t;
  }
};

// node_modules/@walletconnect/core/dist/index.es.js
var import_lodash = __toESM(require_lodash());
function Vi(r, e) {
  if (r.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), i2 = 0; i2 < t.length; i2++)
    t[i2] = 255;
  for (var s = 0; s < r.length; s++) {
    var n2 = r.charAt(s), a3 = n2.charCodeAt(0);
    if (t[a3] !== 255)
      throw new TypeError(n2 + " is ambiguous");
    t[a3] = s;
  }
  var o = r.length, h5 = r.charAt(0), u3 = Math.log(o) / Math.log(256), d2 = Math.log(256) / Math.log(o);
  function p3(c2) {
    if (c2 instanceof Uint8Array || (ArrayBuffer.isView(c2) ? c2 = new Uint8Array(c2.buffer, c2.byteOffset, c2.byteLength) : Array.isArray(c2) && (c2 = Uint8Array.from(c2))), !(c2 instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (c2.length === 0)
      return "";
    for (var b2 = 0, z = 0, I = 0, _2 = c2.length; I !== _2 && c2[I] === 0; )
      I++, b2++;
    for (var S2 = (_2 - I) * d2 + 1 >>> 0, m2 = new Uint8Array(S2); I !== _2; ) {
      for (var T = c2[I], A = 0, C2 = S2 - 1; (T !== 0 || A < z) && C2 !== -1; C2--, A++)
        T += 256 * m2[C2] >>> 0, m2[C2] = T % o >>> 0, T = T / o >>> 0;
      if (T !== 0)
        throw new Error("Non-zero carry");
      z = A, I++;
    }
    for (var x2 = S2 - z; x2 !== S2 && m2[x2] === 0; )
      x2++;
    for (var j2 = h5.repeat(b2); x2 < S2; ++x2)
      j2 += r.charAt(m2[x2]);
    return j2;
  }
  function y3(c2) {
    if (typeof c2 != "string")
      throw new TypeError("Expected String");
    if (c2.length === 0)
      return new Uint8Array();
    var b2 = 0;
    if (c2[b2] !== " ") {
      for (var z = 0, I = 0; c2[b2] === h5; )
        z++, b2++;
      for (var _2 = (c2.length - b2) * u3 + 1 >>> 0, S2 = new Uint8Array(_2); c2[b2]; ) {
        var m2 = t[c2.charCodeAt(b2)];
        if (m2 === 255)
          return;
        for (var T = 0, A = _2 - 1; (m2 !== 0 || T < I) && A !== -1; A--, T++)
          m2 += o * S2[A] >>> 0, S2[A] = m2 % 256 >>> 0, m2 = m2 / 256 >>> 0;
        if (m2 !== 0)
          throw new Error("Non-zero carry");
        I = T, b2++;
      }
      if (c2[b2] !== " ") {
        for (var C2 = _2 - I; C2 !== _2 && S2[C2] === 0; )
          C2++;
        for (var x2 = new Uint8Array(z + (_2 - C2)), j2 = z; C2 !== _2; )
          x2[j2++] = S2[C2++];
        return x2;
      }
    }
  }
  function M(c2) {
    var b2 = y3(c2);
    if (b2)
      return b2;
    throw new Error(`Non-${e} character`);
  }
  return { encode: p3, decodeUnsafe: y3, decode: M };
}
var qi = Vi;
var ji = qi;
var ze = (r) => {
  if (r instanceof Uint8Array && r.constructor.name === "Uint8Array")
    return r;
  if (r instanceof ArrayBuffer)
    return new Uint8Array(r);
  if (ArrayBuffer.isView(r))
    return new Uint8Array(r.buffer, r.byteOffset, r.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var Yi = (r) => new TextEncoder().encode(r);
var Gi = (r) => new TextDecoder().decode(r);
var Hi = class {
  constructor(e, t, i2) {
    this.name = e, this.prefix = t, this.baseEncode = i2;
  }
  encode(e) {
    if (e instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var Ji = class {
  constructor(e, t, i2) {
    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = i2;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(e) {
    return Ne(this, e);
  }
};
var Wi = class {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return Ne(this, e);
  }
  decode(e) {
    const t = e[0], i2 = this.decoders[t];
    if (i2)
      return i2.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var Ne = (r, e) => new Wi({ ...r.decoders || { [r.prefix]: r }, ...e.decoders || { [e.prefix]: e } });
var Xi = class {
  constructor(e, t, i2, s) {
    this.name = e, this.prefix = t, this.baseEncode = i2, this.baseDecode = s, this.encoder = new Hi(e, t, i2), this.decoder = new Ji(e, t, s);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
};
var X2 = ({ name: r, prefix: e, encode: t, decode: i2 }) => new Xi(r, e, t, i2);
var B = ({ prefix: r, name: e, alphabet: t }) => {
  const { encode: i2, decode: s } = ji(t, e);
  return X2({ prefix: r, name: e, encode: i2, decode: (n2) => ze(s(n2)) });
};
var Qi = (r, e, t, i2) => {
  const s = {};
  for (let d2 = 0; d2 < e.length; ++d2)
    s[e[d2]] = d2;
  let n2 = r.length;
  for (; r[n2 - 1] === "="; )
    --n2;
  const a3 = new Uint8Array(n2 * t / 8 | 0);
  let o = 0, h5 = 0, u3 = 0;
  for (let d2 = 0; d2 < n2; ++d2) {
    const p3 = s[r[d2]];
    if (p3 === void 0)
      throw new SyntaxError(`Non-${i2} character`);
    h5 = h5 << t | p3, o += t, o >= 8 && (o -= 8, a3[u3++] = 255 & h5 >> o);
  }
  if (o >= t || 255 & h5 << 8 - o)
    throw new SyntaxError("Unexpected end of data");
  return a3;
};
var Zi = (r, e, t) => {
  const i2 = e[e.length - 1] === "=", s = (1 << t) - 1;
  let n2 = "", a3 = 0, o = 0;
  for (let h5 = 0; h5 < r.length; ++h5)
    for (o = o << 8 | r[h5], a3 += 8; a3 > t; )
      a3 -= t, n2 += e[s & o >> a3];
  if (a3 && (n2 += e[s & o << t - a3]), i2)
    for (; n2.length * t & 7; )
      n2 += "=";
  return n2;
};
var g2 = ({ name: r, prefix: e, bitsPerChar: t, alphabet: i2 }) => X2({ prefix: e, name: r, encode(s) {
  return Zi(s, i2, t);
}, decode(s) {
  return Qi(s, i2, t, r);
} });
var es = X2({ prefix: "\0", name: "identity", encode: (r) => Gi(r), decode: (r) => Yi(r) });
var ts = Object.freeze({ __proto__: null, identity: es });
var is = g2({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var ss = Object.freeze({ __proto__: null, base2: is });
var rs = g2({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var ns = Object.freeze({ __proto__: null, base8: rs });
var as = B({ prefix: "9", name: "base10", alphabet: "0123456789" });
var os = Object.freeze({ __proto__: null, base10: as });
var hs = g2({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var cs = g2({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var us = Object.freeze({ __proto__: null, base16: hs, base16upper: cs });
var ls = g2({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var ds = g2({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var gs = g2({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var ps = g2({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var Ds = g2({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var ys = g2({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var bs = g2({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var ms = g2({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var fs = g2({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var Es = Object.freeze({ __proto__: null, base32: ls, base32upper: ds, base32pad: gs, base32padupper: ps, base32hex: Ds, base32hexupper: ys, base32hexpad: bs, base32hexpadupper: ms, base32z: fs });
var ws = B({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var vs = B({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var Is = Object.freeze({ __proto__: null, base36: ws, base36upper: vs });
var Cs = B({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var Rs = B({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var _s = Object.freeze({ __proto__: null, base58btc: Cs, base58flickr: Rs });
var Ss = g2({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var Ts = g2({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var Ps = g2({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var xs = g2({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Os = Object.freeze({ __proto__: null, base64: Ss, base64pad: Ts, base64url: Ps, base64urlpad: xs });
var Ue2 = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂");
var As = Ue2.reduce((r, e, t) => (r[t] = e, r), []);
var zs = Ue2.reduce((r, e, t) => (r[e.codePointAt(0)] = t, r), []);
function Ns(r) {
  return r.reduce((e, t) => (e += As[t], e), "");
}
function Us(r) {
  const e = [];
  for (const t of r) {
    const i2 = zs[t.codePointAt(0)];
    if (i2 === void 0)
      throw new Error(`Non-base256emoji character: ${t}`);
    e.push(i2);
  }
  return new Uint8Array(e);
}
var Ls = X2({ prefix: "🚀", name: "base256emoji", encode: Ns, decode: Us });
var Fs = Object.freeze({ __proto__: null, base256emoji: Ls });
var $s = Fe2;
var Le = 128;
var Ms = 127;
var ks = ~Ms;
var Ks = Math.pow(2, 31);
function Fe2(r, e, t) {
  e = e || [], t = t || 0;
  for (var i2 = t; r >= Ks; )
    e[t++] = r & 255 | Le, r /= 128;
  for (; r & ks; )
    e[t++] = r & 255 | Le, r >>>= 7;
  return e[t] = r | 0, Fe2.bytes = t - i2 + 1, e;
}
var Bs = he2;
var Vs = 128;
var $e = 127;
function he2(r, i2) {
  var t = 0, i2 = i2 || 0, s = 0, n2 = i2, a3, o = r.length;
  do {
    if (n2 >= o)
      throw he2.bytes = 0, new RangeError("Could not decode varint");
    a3 = r[n2++], t += s < 28 ? (a3 & $e) << s : (a3 & $e) * Math.pow(2, s), s += 7;
  } while (a3 >= Vs);
  return he2.bytes = n2 - i2, t;
}
var qs = Math.pow(2, 7);
var js = Math.pow(2, 14);
var Ys = Math.pow(2, 21);
var Gs = Math.pow(2, 28);
var Hs = Math.pow(2, 35);
var Js = Math.pow(2, 42);
var Ws = Math.pow(2, 49);
var Xs = Math.pow(2, 56);
var Qs = Math.pow(2, 63);
var Zs = function(r) {
  return r < qs ? 1 : r < js ? 2 : r < Ys ? 3 : r < Gs ? 4 : r < Hs ? 5 : r < Js ? 6 : r < Ws ? 7 : r < Xs ? 8 : r < Qs ? 9 : 10;
};
var er2 = { encode: $s, decode: Bs, encodingLength: Zs };
var Me2 = er2;
var ke2 = (r, e, t = 0) => (Me2.encode(r, e, t), e);
var Ke = (r) => Me2.encodingLength(r);
var ce = (r, e) => {
  const t = e.byteLength, i2 = Ke(r), s = i2 + Ke(t), n2 = new Uint8Array(s + t);
  return ke2(r, n2, 0), ke2(t, n2, i2), n2.set(e, s), new tr(r, t, e, n2);
};
var tr = class {
  constructor(e, t, i2, s) {
    this.code = e, this.size = t, this.digest = i2, this.bytes = s;
  }
};
var Be2 = ({ name: r, code: e, encode: t }) => new ir(r, e, t);
var ir = class {
  constructor(e, t, i2) {
    this.name = e, this.code = t, this.encode = i2;
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const t = this.encode(e);
      return t instanceof Uint8Array ? ce(this.code, t) : t.then((i2) => ce(this.code, i2));
    } else
      throw Error("Unknown type, must be binary type");
  }
};
var Ve2 = (r) => async (e) => new Uint8Array(await crypto.subtle.digest(r, e));
var sr = Be2({ name: "sha2-256", code: 18, encode: Ve2("SHA-256") });
var rr = Be2({ name: "sha2-512", code: 19, encode: Ve2("SHA-512") });
var nr = Object.freeze({ __proto__: null, sha256: sr, sha512: rr });
var qe2 = 0;
var ar = "identity";
var je2 = ze;
var or = (r) => ce(qe2, je2(r));
var hr = { code: qe2, name: ar, encode: je2, digest: or };
var cr = Object.freeze({ __proto__: null, identity: hr });
new TextEncoder(), new TextDecoder();
var Ye = { ...ts, ...ss, ...ns, ...os, ...us, ...Es, ...Is, ..._s, ...Os, ...Fs };
({ ...nr, ...cr });
function Ge2(r) {
  return globalThis.Buffer != null ? new Uint8Array(r.buffer, r.byteOffset, r.byteLength) : r;
}
function ur(r = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? Ge2(globalThis.Buffer.allocUnsafe(r)) : new Uint8Array(r);
}
function He2(r, e, t, i2) {
  return { name: r, prefix: e, encoder: { name: r, prefix: e, encode: t }, decoder: { decode: i2 } };
}
var Je = He2("utf8", "u", (r) => "u" + new TextDecoder("utf8").decode(r), (r) => new TextEncoder().encode(r.substring(1)));
var ue2 = He2("ascii", "a", (r) => {
  let e = "a";
  for (let t = 0; t < r.length; t++)
    e += String.fromCharCode(r[t]);
  return e;
}, (r) => {
  r = r.substring(1);
  const e = ur(r.length);
  for (let t = 0; t < r.length; t++)
    e[t] = r.charCodeAt(t);
  return e;
});
var lr = { utf8: Je, "utf-8": Je, hex: Ye.base16, latin1: ue2, ascii: ue2, binary: ue2, ...Ye };
function dr(r, e = "utf8") {
  const t = lr[e];
  if (!t)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? Ge2(globalThis.Buffer.from(r, "utf-8")) : t.decoder.decode(`${t.prefix}${r}`);
}
var le2 = "wc";
var We2 = 2;
var Q2 = "core";
var O = `${le2}@2:${Q2}:`;
var Xe = { name: Q2, logger: "error" };
var Qe = { database: ":memory:" };
var Ze = "crypto";
var de2 = "client_ed25519_seed";
var et = import_time2.ONE_DAY;
var tt2 = "keychain";
var it2 = "0.3";
var st = "messages";
var rt = "0.3";
var nt2 = import_time2.SIX_HOURS;
var at2 = "publisher";
var ot = "irn";
var ht2 = "error";
var ge = "wss://relay.walletconnect.com";
var pe = "wss://relay.walletconnect.org";
var ct2 = "relayer";
var D2 = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" };
var ut2 = "_subscription";
var P = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" };
var lt2 = import_time2.ONE_SECOND;
var gr = { database: ":memory:" };
var dt2 = "2.10.5";
var gt2 = 1e4;
var pt2 = "0.3";
var Dt2 = "WALLETCONNECT_CLIENT_ID";
var w3 = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" };
var pr = import_time2.THIRTY_DAYS;
var yt2 = "subscription";
var bt2 = "0.3";
var mt = import_time2.FIVE_SECONDS * 1e3;
var ft2 = "pairing";
var Et2 = "0.3";
var Dr = import_time2.THIRTY_DAYS;
var F2 = { wc_pairingDelete: { req: { ttl: import_time2.ONE_DAY, prompt: false, tag: 1e3 }, res: { ttl: import_time2.ONE_DAY, prompt: false, tag: 1001 } }, wc_pairingPing: { req: { ttl: import_time2.THIRTY_SECONDS, prompt: false, tag: 1002 }, res: { ttl: import_time2.THIRTY_SECONDS, prompt: false, tag: 1003 } }, unregistered_method: { req: { ttl: import_time2.ONE_DAY, prompt: false, tag: 0 }, res: { ttl: import_time2.ONE_DAY, prompt: false, tag: 0 } } };
var V2 = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" };
var R2 = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" };
var wt = "history";
var vt2 = "0.3";
var It = "expirer";
var v = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" };
var Ct2 = "0.3";
var yr = import_time2.ONE_DAY;
var Z2 = "verify-api";
var $ = "https://verify.walletconnect.com";
var ee2 = "https://verify.walletconnect.org";
var Rt = [$, ee2];
var _t = class {
  constructor(e, t) {
    this.core = e, this.logger = t, this.keychain = /* @__PURE__ */ new Map(), this.name = tt2, this.version = it2, this.initialized = false, this.storagePrefix = O, this.init = async () => {
      if (!this.initialized) {
        const i2 = await this.getKeyChain();
        typeof i2 < "u" && (this.keychain = i2), this.initialized = true;
      }
    }, this.has = (i2) => (this.isInitialized(), this.keychain.has(i2)), this.set = async (i2, s) => {
      this.isInitialized(), this.keychain.set(i2, s), await this.persist();
    }, this.get = (i2) => {
      this.isInitialized();
      const s = this.keychain.get(i2);
      if (typeof s > "u") {
        const { message: n2 } = N("NO_MATCHING_KEY", `${this.name}: ${i2}`);
        throw new Error(n2);
      }
      return s;
    }, this.del = async (i2) => {
      this.isInitialized(), this.keychain.delete(i2), await this.persist();
    }, this.core = e, this.logger = (0, import_logger.generateChildLogger)(t, this.name);
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setKeyChain(e) {
    await this.core.storage.setItem(this.storageKey, nt(e));
  }
  async getKeyChain() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? tt(e) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var St = class {
  constructor(e, t, i2) {
    this.core = e, this.logger = t, this.name = Ze, this.initialized = false, this.init = async () => {
      this.initialized || (await this.keychain.init(), this.initialized = true);
    }, this.hasKeys = (s) => (this.isInitialized(), this.keychain.has(s)), this.getClientId = async () => {
      this.isInitialized();
      const s = await this.getClientSeed(), n2 = generateKeyPair(s);
      return encodeIss(n2.publicKey);
    }, this.generateKeyPair = () => {
      this.isInitialized();
      const s = jn();
      return this.setPrivateKey(s.publicKey, s.privateKey);
    }, this.signJWT = async (s) => {
      this.isInitialized();
      const n2 = await this.getClientSeed(), a3 = generateKeyPair(n2), o = Dn(), h5 = et;
      return await signJWT(o, s, h5, a3);
    }, this.generateSharedKey = (s, n2, a3) => {
      this.isInitialized();
      const o = this.getPrivateKey(s), h5 = kn(o, n2);
      return this.setSymKey(h5, a3);
    }, this.setSymKey = async (s, n2) => {
      this.isInitialized();
      const a3 = n2 || Vn(s);
      return await this.keychain.set(a3, s), a3;
    }, this.deleteKeyPair = async (s) => {
      this.isInitialized(), await this.keychain.del(s);
    }, this.deleteSymKey = async (s) => {
      this.isInitialized(), await this.keychain.del(s);
    }, this.encode = async (s, n2, a3) => {
      this.isInitialized();
      const o = Re(a3), h5 = safeJsonStringify(n2);
      if (Fn(o)) {
        const y3 = o.senderPublicKey, M = o.receiverPublicKey;
        s = await this.generateSharedKey(y3, M);
      }
      const u3 = this.getSymKey(s), { type: d2, senderPublicKey: p3 } = o;
      return Kn({ type: d2, symKey: u3, message: h5, senderPublicKey: p3 });
    }, this.decode = async (s, n2, a3) => {
      this.isInitialized();
      const o = xn(n2, a3);
      if (Fn(o)) {
        const h5 = o.receiverPublicKey, u3 = o.senderPublicKey;
        s = await this.generateSharedKey(h5, u3);
      }
      try {
        const h5 = this.getSymKey(s), u3 = Ln({ symKey: h5, encoded: n2 });
        return safeJsonParse(u3);
      } catch (h5) {
        this.logger.error(`Failed to decode message from topic: '${s}', clientId: '${await this.getClientId()}'`), this.logger.error(h5);
      }
    }, this.getPayloadType = (s) => {
      const n2 = ee(s);
      return j(n2.type);
    }, this.getPayloadSenderPublicKey = (s) => {
      const n2 = ee(s);
      return n2.senderPublicKey ? toString(n2.senderPublicKey, p2) : void 0;
    }, this.core = e, this.logger = (0, import_logger.generateChildLogger)(t, this.name), this.keychain = i2 || new _t(this.core, this.logger);
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  async setPrivateKey(e, t) {
    return await this.keychain.set(e, t), e;
  }
  getPrivateKey(e) {
    return this.keychain.get(e);
  }
  async getClientSeed() {
    let e = "";
    try {
      e = this.keychain.get(de2);
    } catch {
      e = Dn(), await this.keychain.set(de2, e);
    }
    return dr(e, "base16");
  }
  getSymKey(e) {
    return this.keychain.get(e);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Tt = class extends a {
  constructor(e, t) {
    super(e, t), this.logger = e, this.core = t, this.messages = /* @__PURE__ */ new Map(), this.name = st, this.version = rt, this.initialized = false, this.storagePrefix = O, this.init = async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const i2 = await this.getRelayerMessages();
          typeof i2 < "u" && (this.messages = i2), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (i2) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(i2);
        } finally {
          this.initialized = true;
        }
      }
    }, this.set = async (i2, s) => {
      this.isInitialized();
      const n2 = Mn(s);
      let a3 = this.messages.get(i2);
      return typeof a3 > "u" && (a3 = {}), typeof a3[n2] < "u" || (a3[n2] = s, this.messages.set(i2, a3), await this.persist()), n2;
    }, this.get = (i2) => {
      this.isInitialized();
      let s = this.messages.get(i2);
      return typeof s > "u" && (s = {}), s;
    }, this.has = (i2, s) => {
      this.isInitialized();
      const n2 = this.get(i2), a3 = Mn(s);
      return typeof n2[a3] < "u";
    }, this.del = async (i2) => {
      this.isInitialized(), this.messages.delete(i2), await this.persist();
    }, this.logger = (0, import_logger.generateChildLogger)(e, this.name), this.core = t;
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setRelayerMessages(e) {
    await this.core.storage.setItem(this.storageKey, nt(e));
  }
  async getRelayerMessages() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? tt(e) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var br = class extends u {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, this.events = new import_events4.EventEmitter(), this.name = at2, this.queue = /* @__PURE__ */ new Map(), this.publishTimeout = (0, import_time2.toMiliseconds)(import_time2.TEN_SECONDS), this.needsTransportRestart = false, this.publish = async (i2, s, n2) => {
      var a3;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: i2, message: s, opts: n2 } });
      try {
        const o = (n2 == null ? void 0 : n2.ttl) || nt2, h5 = yt(n2), u3 = (n2 == null ? void 0 : n2.prompt) || false, d2 = (n2 == null ? void 0 : n2.tag) || 0, p3 = (n2 == null ? void 0 : n2.id) || getBigIntRpcId().toString(), y3 = { topic: i2, message: s, opts: { ttl: o, relay: h5, prompt: u3, tag: d2, id: p3 } }, M = setTimeout(() => this.queue.set(p3, y3), this.publishTimeout);
        try {
          await await ct(this.rpcPublish(i2, s, o, h5, u3, d2, p3), this.publishTimeout, "Failed to publish payload, please try again."), this.removeRequestFromQueue(p3), this.relayer.events.emit(D2.publish, y3);
        } catch (c2) {
          if (this.logger.debug("Publishing Payload stalled"), this.needsTransportRestart = true, (a3 = n2 == null ? void 0 : n2.internal) != null && a3.throwOnFailedPublish)
            throw this.removeRequestFromQueue(p3), c2;
          return;
        } finally {
          clearTimeout(M);
        }
        this.logger.debug("Successfully Published Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: i2, message: s, opts: n2 } });
      } catch (o) {
        throw this.logger.debug("Failed to Publish Payload"), this.logger.error(o), o;
      }
    }, this.on = (i2, s) => {
      this.events.on(i2, s);
    }, this.once = (i2, s) => {
      this.events.once(i2, s);
    }, this.off = (i2, s) => {
      this.events.off(i2, s);
    }, this.removeListener = (i2, s) => {
      this.events.removeListener(i2, s);
    }, this.relayer = e, this.logger = (0, import_logger.generateChildLogger)(t, this.name), this.registerEventListeners();
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  rpcPublish(e, t, i2, s, n2, a3, o) {
    var h5, u3, d2, p3;
    const y3 = { method: ht(s.protocol).publish, params: { topic: e, message: t, ttl: i2, prompt: n2, tag: a3 }, id: o };
    return w((h5 = y3.params) == null ? void 0 : h5.prompt) && ((u3 = y3.params) == null || delete u3.prompt), w((d2 = y3.params) == null ? void 0 : d2.tag) && ((p3 = y3.params) == null || delete p3.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: y3 }), this.relayer.request(y3);
  }
  removeRequestFromQueue(e) {
    this.queue.delete(e);
  }
  checkQueue() {
    this.queue.forEach(async (e) => {
      const { topic: t, message: i2, opts: s } = e;
      await this.publish(t, i2, s);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(import_heartbeat.HEARTBEAT_EVENTS.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = false, this.relayer.events.emit(D2.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(D2.message_ack, (e) => {
      this.removeRequestFromQueue(e.id.toString());
    });
  }
};
var mr = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map(), this.set = (e, t) => {
      const i2 = this.get(e);
      this.exists(e, t) || this.map.set(e, [...i2, t]);
    }, this.get = (e) => this.map.get(e) || [], this.exists = (e, t) => this.get(e).includes(t), this.delete = (e, t) => {
      if (typeof t > "u") {
        this.map.delete(e);
        return;
      }
      if (!this.map.has(e))
        return;
      const i2 = this.get(e);
      if (!this.exists(e, t))
        return;
      const s = i2.filter((n2) => n2 !== t);
      if (!s.length) {
        this.map.delete(e);
        return;
      }
      this.map.set(e, s);
    }, this.clear = () => {
      this.map.clear();
    };
  }
  get topics() {
    return Array.from(this.map.keys());
  }
};
var fr = Object.defineProperty;
var Er = Object.defineProperties;
var wr = Object.getOwnPropertyDescriptors;
var Pt = Object.getOwnPropertySymbols;
var vr = Object.prototype.hasOwnProperty;
var Ir = Object.prototype.propertyIsEnumerable;
var xt = (r, e, t) => e in r ? fr(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var q2 = (r, e) => {
  for (var t in e || (e = {}))
    vr.call(e, t) && xt(r, t, e[t]);
  if (Pt)
    for (var t of Pt(e))
      Ir.call(e, t) && xt(r, t, e[t]);
  return r;
};
var De2 = (r, e) => Er(r, wr(e));
var Ot2 = class extends d {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, this.subscriptions = /* @__PURE__ */ new Map(), this.topicMap = new mr(), this.events = new import_events4.EventEmitter(), this.name = yt2, this.version = bt2, this.pending = /* @__PURE__ */ new Map(), this.cached = [], this.initialized = false, this.pendingSubscriptionWatchLabel = "pending_sub_watch_label", this.pollingInterval = 20, this.storagePrefix = O, this.subscribeTimeout = 1e4, this.restartInProgress = false, this.batchSubscribeTopicsLimit = 500, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), this.clientId = await this.relayer.core.crypto.getClientId());
    }, this.subscribe = async (i2, s) => {
      await this.restartToComplete(), this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i2, opts: s } });
      try {
        const n2 = yt(s), a3 = { topic: i2, relay: n2 };
        this.pending.set(i2, a3);
        const o = await this.rpcSubscribe(i2, n2);
        return this.onSubscribe(o, a3), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i2, opts: s } }), o;
      } catch (n2) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(n2), n2;
      }
    }, this.unsubscribe = async (i2, s) => {
      await this.restartToComplete(), this.isInitialized(), typeof (s == null ? void 0 : s.id) < "u" ? await this.unsubscribeById(i2, s.id, s) : await this.unsubscribeByTopic(i2, s);
    }, this.isSubscribed = async (i2) => this.topics.includes(i2) ? true : await new Promise((s, n2) => {
      const a3 = new import_time2.Watch();
      a3.start(this.pendingSubscriptionWatchLabel);
      const o = setInterval(() => {
        !this.pending.has(i2) && this.topics.includes(i2) && (clearInterval(o), a3.stop(this.pendingSubscriptionWatchLabel), s(true)), a3.elapsed(this.pendingSubscriptionWatchLabel) >= mt && (clearInterval(o), a3.stop(this.pendingSubscriptionWatchLabel), n2(new Error("Subscription resolution timeout")));
      }, this.pollingInterval);
    }).catch(() => false), this.on = (i2, s) => {
      this.events.on(i2, s);
    }, this.once = (i2, s) => {
      this.events.once(i2, s);
    }, this.off = (i2, s) => {
      this.events.off(i2, s);
    }, this.removeListener = (i2, s) => {
      this.events.removeListener(i2, s);
    }, this.restart = async () => {
      this.restartInProgress = true, await this.restore(), await this.reset(), this.restartInProgress = false;
    }, this.relayer = e, this.logger = (0, import_logger.generateChildLogger)(t, this.name), this.clientId = "";
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  hasSubscription(e, t) {
    let i2 = false;
    try {
      i2 = this.getSubscription(e).topic === t;
    } catch {
    }
    return i2;
  }
  onEnable() {
    this.cached = [], this.initialized = true;
  }
  onDisable() {
    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e, t) {
    const i2 = this.topicMap.get(e);
    await Promise.all(i2.map(async (s) => await this.unsubscribeById(e, s, t)));
  }
  async unsubscribeById(e, t, i2) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: i2 } });
    try {
      const s = yt(i2);
      await this.rpcUnsubscribe(e, t, s);
      const n2 = U("USER_DISCONNECTED", `${this.name}, ${e}`);
      await this.onUnsubscribe(e, t, n2), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: i2 } });
    } catch (s) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(s), s;
    }
  }
  async rpcSubscribe(e, t) {
    const i2 = { method: ht(t.protocol).subscribe, params: { topic: e } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i2 });
    try {
      await await ct(this.relayer.request(i2), this.subscribeTimeout);
    } catch {
      this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(D2.connection_stalled);
    }
    return Mn(e + this.clientId);
  }
  async rpcBatchSubscribe(e) {
    if (!e.length)
      return;
    const t = e[0].relay, i2 = { method: ht(t.protocol).batchSubscribe, params: { topics: e.map((s) => s.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i2 });
    try {
      return await await ct(this.relayer.request(i2), this.subscribeTimeout);
    } catch {
      this.logger.debug("Outgoing Relay Payload stalled"), this.relayer.events.emit(D2.connection_stalled);
    }
  }
  rpcUnsubscribe(e, t, i2) {
    const s = { method: ht(i2.protocol).unsubscribe, params: { topic: e, id: t } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s }), this.relayer.request(s);
  }
  onSubscribe(e, t) {
    this.setSubscription(e, De2(q2({}, t), { id: e })), this.pending.delete(t.topic);
  }
  onBatchSubscribe(e) {
    e.length && e.forEach((t) => {
      this.setSubscription(t.id, q2({}, t)), this.pending.delete(t.topic);
    });
  }
  async onUnsubscribe(e, t, i2) {
    this.events.removeAllListeners(t), this.hasSubscription(t, e) && this.deleteSubscription(t, i2), await this.relayer.messages.del(e);
  }
  async setRelayerSubscriptions(e) {
    await this.relayer.core.storage.setItem(this.storageKey, e);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e, t) {
    this.subscriptions.has(e) || (this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e, subscription: t }), this.addSubscription(e, t));
  }
  addSubscription(e, t) {
    this.subscriptions.set(e, q2({}, t)), this.topicMap.set(t.topic, e), this.events.emit(w3.created, t);
  }
  getSubscription(e) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e });
    const t = this.subscriptions.get(e);
    if (!t) {
      const { message: i2 } = N("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(i2);
    }
    return t;
  }
  deleteSubscription(e, t) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e, reason: t });
    const i2 = this.getSubscription(e);
    this.subscriptions.delete(e), this.topicMap.delete(i2.topic, e), this.events.emit(w3.deleted, De2(q2({}, i2), { reason: t }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit(w3.sync);
  }
  async reset() {
    if (this.cached.length) {
      const e = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let t = 0; t < e; t++) {
        const i2 = this.cached.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchSubscribe(i2);
      }
    }
    this.events.emit(w3.resubscribed);
  }
  async restore() {
    try {
      const e = await this.getRelayerSubscriptions();
      if (typeof e > "u" || !e.length)
        return;
      if (this.subscriptions.size) {
        const { message: t } = N("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);
    }
  }
  async batchSubscribe(e) {
    if (!e.length)
      return;
    const t = await this.rpcBatchSubscribe(e);
    D(t) && this.onBatchSubscribe(t.map((i2, s) => De2(q2({}, e[s]), { id: i2 })));
  }
  async onConnect() {
    this.restartInProgress || (await this.restart(), this.onEnable());
  }
  onDisconnect() {
    this.onDisable();
  }
  async checkPending() {
    if (!this.initialized || this.relayer.transportExplicitlyClosed)
      return;
    const e = [];
    this.pending.forEach((t) => {
      e.push(t);
    }), await this.batchSubscribe(e);
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(import_heartbeat.HEARTBEAT_EVENTS.pulse, async () => {
      await this.checkPending();
    }), this.relayer.on(D2.connect, async () => {
      await this.onConnect();
    }), this.relayer.on(D2.disconnect, () => {
      this.onDisconnect();
    }), this.events.on(w3.created, async (e) => {
      const t = w3.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), await this.persist();
    }), this.events.on(w3.deleted, async (e) => {
      const t = w3.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), await this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async restartToComplete() {
    this.restartInProgress && await new Promise((e) => {
      const t = setInterval(() => {
        this.restartInProgress || (clearInterval(t), e());
      }, this.pollingInterval);
    });
  }
};
var Cr = Object.defineProperty;
var At = Object.getOwnPropertySymbols;
var Rr = Object.prototype.hasOwnProperty;
var _r = Object.prototype.propertyIsEnumerable;
var zt = (r, e, t) => e in r ? Cr(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var Sr = (r, e) => {
  for (var t in e || (e = {}))
    Rr.call(e, t) && zt(r, t, e[t]);
  if (At)
    for (var t of At(e))
      _r.call(e, t) && zt(r, t, e[t]);
  return r;
};
var Nt2 = class extends g {
  constructor(e) {
    super(e), this.protocol = "wc", this.version = 2, this.events = new import_events4.EventEmitter(), this.name = ct2, this.transportExplicitlyClosed = false, this.initialized = false, this.connectionAttemptInProgress = false, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = ["socket hang up", "socket stalled"], this.hasExperiencedNetworkDisruption = false, this.request = async (t) => {
      this.logger.debug("Publishing Request Payload");
      try {
        return await this.toEstablishConnection(), await this.provider.request(t);
      } catch (i2) {
        throw this.logger.debug("Failed to Publish Request"), this.logger.error(i2), i2;
      }
    }, this.onPayloadHandler = (t) => {
      this.onProviderPayload(t);
    }, this.onConnectHandler = () => {
      this.events.emit(D2.connect);
    }, this.onDisconnectHandler = () => {
      this.onProviderDisconnect();
    }, this.onProviderErrorHandler = (t) => {
      this.logger.error(t), this.events.emit(D2.error, t), this.logger.info("Fatal socket error received, closing transport"), this.transportClose();
    }, this.registerProviderListeners = () => {
      this.provider.on(P.payload, this.onPayloadHandler), this.provider.on(P.connect, this.onConnectHandler), this.provider.on(P.disconnect, this.onDisconnectHandler), this.provider.on(P.error, this.onProviderErrorHandler);
    }, this.core = e.core, this.logger = typeof e.logger < "u" && typeof e.logger != "string" ? (0, import_logger.generateChildLogger)(e.logger, this.name) : (0, import_logger.pino)((0, import_logger.getDefaultLoggerOptions)({ level: e.logger || ht2 })), this.messages = new Tt(this.logger, e.core), this.subscriber = new Ot2(this, this.logger), this.publisher = new br(this, this.logger), this.relayUrl = (e == null ? void 0 : e.relayUrl) || ge, this.projectId = e.projectId, this.bundleId = zn(), this.provider = {};
  }
  async init() {
    this.logger.trace("Initialized"), this.registerEventListeners(), await this.createProvider(), await Promise.all([this.messages.init(), this.subscriber.init()]);
    try {
      await this.transportOpen();
    } catch {
      this.logger.warn(`Connection via ${this.relayUrl} failed, attempting to connect via failover domain ${pe}...`), await this.restartTransport(pe);
    }
    this.initialized = true, setTimeout(async () => {
      this.subscriber.topics.length === 0 && (this.logger.info("No topics subscribed to after init, closing transport"), await this.transportClose(), this.transportExplicitlyClosed = false);
    }, gt2);
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get connected() {
    return this.provider.connection.connected;
  }
  get connecting() {
    return this.provider.connection.connecting;
  }
  async publish(e, t, i2) {
    this.isInitialized(), await this.publisher.publish(e, t, i2), await this.recordMessageEvent({ topic: e, message: t, publishedAt: Date.now() });
  }
  async subscribe(e, t) {
    var i2;
    this.isInitialized();
    let s = ((i2 = this.subscriber.topicMap.get(e)) == null ? void 0 : i2[0]) || "";
    if (s)
      return s;
    let n2;
    const a3 = (o) => {
      o.topic === e && (this.subscriber.off(w3.created, a3), n2());
    };
    return await Promise.all([new Promise((o) => {
      n2 = o, this.subscriber.on(w3.created, a3);
    }), new Promise(async (o) => {
      s = await this.subscriber.subscribe(e, t), o();
    })]), s;
  }
  async unsubscribe(e, t) {
    this.isInitialized(), await this.subscriber.unsubscribe(e, t);
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async transportClose() {
    this.transportExplicitlyClosed = true, this.hasExperiencedNetworkDisruption && this.connected ? await ct(this.provider.disconnect(), 1e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.connected && await this.provider.disconnect();
  }
  async transportOpen(e) {
    if (this.transportExplicitlyClosed = false, await this.confirmOnlineStateOrThrow(), !this.connectionAttemptInProgress) {
      e && e !== this.relayUrl && (this.relayUrl = e, await this.transportClose(), await this.createProvider()), this.connectionAttemptInProgress = true;
      try {
        await Promise.all([new Promise((t) => {
          if (!this.initialized)
            return t();
          this.subscriber.once(w3.resubscribed, () => {
            t();
          });
        }), new Promise(async (t, i2) => {
          try {
            await ct(this.provider.connect(), 1e4, `Socket stalled when trying to connect to ${this.relayUrl}`);
          } catch (s) {
            i2(s);
            return;
          }
          t();
        })]);
      } catch (t) {
        this.logger.error(t);
        const i2 = t;
        if (!this.isConnectionStalled(i2.message))
          throw t;
        this.provider.events.emit(P.disconnect);
      } finally {
        this.connectionAttemptInProgress = false, this.hasExperiencedNetworkDisruption = false;
      }
    }
  }
  async restartTransport(e) {
    await this.confirmOnlineStateOrThrow(), !this.connectionAttemptInProgress && (this.relayUrl = e || this.relayUrl, await this.transportClose(), await this.createProvider(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await Xt())
      throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  isConnectionStalled(e) {
    return this.staleConnectionErrors.some((t) => e.includes(t));
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const e = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new JsonRpcProvider(new f(Qn({ sdkVersion: dt2, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e, useOnCloseEvent: true, bundleId: this.bundleId }))), this.registerProviderListeners();
  }
  async recordMessageEvent(e) {
    const { topic: t, message: i2 } = e;
    await this.messages.set(t, i2);
  }
  async shouldIgnoreMessageEvent(e) {
    const { topic: t, message: i2 } = e;
    if (!i2 || i2.length === 0)
      return this.logger.debug(`Ignoring invalid/empty message: ${i2}`), true;
    if (!await this.subscriber.isSubscribed(t))
      return this.logger.debug(`Ignoring message for non-subscribed topic ${t}`), true;
    const s = this.messages.has(t, i2);
    return s && this.logger.debug(`Ignoring duplicate message: ${i2}`), s;
  }
  async onProviderPayload(e) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e }), isJsonRpcRequest(e)) {
      if (!e.method.endsWith(ut2))
        return;
      const t = e.params, { topic: i2, message: s, publishedAt: n2 } = t.data, a3 = { topic: i2, message: s, publishedAt: n2 };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(Sr({ type: "event", event: t.id }, a3)), this.events.emit(t.id, a3), await this.acknowledgePayload(e), await this.onMessageEvent(a3);
    } else
      isJsonRpcResponse(e) && this.events.emit(D2.message_ack, e);
  }
  async onMessageEvent(e) {
    await this.shouldIgnoreMessageEvent(e) || (this.events.emit(D2.message, e), await this.recordMessageEvent(e));
  }
  async acknowledgePayload(e) {
    const t = formatJsonRpcResult(e.id, true);
    await this.provider.connection.send(t);
  }
  unregisterProviderListeners() {
    this.provider.off(P.payload, this.onPayloadHandler), this.provider.off(P.connect, this.onConnectHandler), this.provider.off(P.disconnect, this.onDisconnectHandler), this.provider.off(P.error, this.onProviderErrorHandler);
  }
  async registerEventListeners() {
    this.events.on(D2.connection_stalled, () => {
      this.restartTransport().catch((t) => this.logger.error(t));
    });
    let e = await Xt();
    er(async (t) => {
      this.initialized && e !== t && (e = t, t ? await this.restartTransport().catch((i2) => this.logger.error(i2)) : (this.hasExperiencedNetworkDisruption = true, await this.transportClose().catch((i2) => this.logger.error(i2))));
    });
  }
  onProviderDisconnect() {
    this.events.emit(D2.disconnect), this.attemptToReconnect();
  }
  attemptToReconnect() {
    this.transportExplicitlyClosed || (this.logger.info("attemptToReconnect called. Connecting..."), setTimeout(async () => {
      await this.restartTransport().catch((e) => this.logger.error(e));
    }, (0, import_time2.toMiliseconds)(lt2)));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async toEstablishConnection() {
    if (await this.confirmOnlineStateOrThrow(), !this.connected) {
      if (this.connectionAttemptInProgress)
        return await new Promise((e) => {
          const t = setInterval(() => {
            this.connected && (clearInterval(t), e());
          }, this.connectionStatusPollingInterval);
        });
      await this.restartTransport();
    }
  }
};
var Tr = Object.defineProperty;
var Ut = Object.getOwnPropertySymbols;
var Pr = Object.prototype.hasOwnProperty;
var xr = Object.prototype.propertyIsEnumerable;
var Lt = (r, e, t) => e in r ? Tr(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var Ft2 = (r, e) => {
  for (var t in e || (e = {}))
    Pr.call(e, t) && Lt(r, t, e[t]);
  if (Ut)
    for (var t of Ut(e))
      xr.call(e, t) && Lt(r, t, e[t]);
  return r;
};
var $t2 = class extends p {
  constructor(e, t, i2, s = O, n2 = void 0) {
    super(e, t, i2, s), this.core = e, this.logger = t, this.name = i2, this.map = /* @__PURE__ */ new Map(), this.version = pt2, this.cached = [], this.initialized = false, this.storagePrefix = O, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((a3) => {
        this.getKey && a3 !== null && !w(a3) ? this.map.set(this.getKey(a3), a3) : kt(a3) ? this.map.set(a3.id, a3) : Vt(a3) && this.map.set(a3.topic, a3);
      }), this.cached = [], this.initialized = true);
    }, this.set = async (a3, o) => {
      this.isInitialized(), this.map.has(a3) ? await this.update(a3, o) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: a3, value: o }), this.map.set(a3, o), await this.persist());
    }, this.get = (a3) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: a3 }), this.getData(a3)), this.getAll = (a3) => (this.isInitialized(), a3 ? this.values.filter((o) => Object.keys(a3).every((h5) => (0, import_lodash.default)(o[h5], a3[h5]))) : this.values), this.update = async (a3, o) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: a3, update: o });
      const h5 = Ft2(Ft2({}, this.getData(a3)), o);
      this.map.set(a3, h5), await this.persist();
    }, this.delete = async (a3, o) => {
      this.isInitialized(), this.map.has(a3) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: a3, reason: o }), this.map.delete(a3), await this.persist());
    }, this.logger = (0, import_logger.generateChildLogger)(t, this.name), this.storagePrefix = s, this.getKey = n2;
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  async setDataStore(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e) {
    const t = this.map.get(e);
    if (!t) {
      const { message: i2 } = N("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(i2), new Error(i2);
    }
    return t;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e = await this.getDataStore();
      if (typeof e > "u" || !e.length)
        return;
      if (this.map.size) {
        const { message: t } = N("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Mt = class {
  constructor(e, t) {
    this.core = e, this.logger = t, this.name = ft2, this.version = Et2, this.events = new import_events4.default(), this.initialized = false, this.storagePrefix = O, this.ignoredPayloadTypes = [_], this.registeredMethods = [], this.init = async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = true, this.logger.trace("Initialized"));
    }, this.register = ({ methods: i2 }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...i2])];
    }, this.create = async () => {
      this.isInitialized();
      const i2 = Dn(), s = await this.core.crypto.setSymKey(i2), n2 = dt(import_time2.FIVE_MINUTES), a3 = { protocol: ot }, o = { topic: s, expiry: n2, relay: a3, active: false }, h5 = Ot({ protocol: this.core.protocol, version: this.core.version, topic: s, symKey: i2, relay: a3 });
      return await this.pairings.set(s, o), await this.core.relayer.subscribe(s), this.core.expirer.set(s, n2), { topic: s, uri: h5 };
    }, this.pair = async (i2) => {
      this.isInitialized(), this.isValidPair(i2);
      const { topic: s, symKey: n2, relay: a3 } = Nt(i2.uri);
      let o;
      if (this.pairings.keys.includes(s) && (o = this.pairings.get(s), o.active))
        throw new Error(`Pairing already exists: ${s}. Please try again with a new connection URI.`);
      this.core.crypto.keychain.has(s) || (await this.core.crypto.setSymKey(n2, s), await this.core.relayer.subscribe(s, { relay: a3 }));
      const h5 = dt(import_time2.FIVE_MINUTES), u3 = { topic: s, relay: a3, expiry: h5, active: false };
      return await this.pairings.set(s, u3), this.core.expirer.set(s, h5), i2.activatePairing && await this.activate({ topic: s }), this.events.emit(V2.create, u3), u3;
    }, this.activate = async ({ topic: i2 }) => {
      this.isInitialized();
      const s = dt(import_time2.THIRTY_DAYS);
      await this.pairings.update(i2, { active: true, expiry: s }), this.core.expirer.set(i2, s);
    }, this.ping = async (i2) => {
      this.isInitialized(), await this.isValidPing(i2);
      const { topic: s } = i2;
      if (this.pairings.keys.includes(s)) {
        const n2 = await this.sendRequest(s, "wc_pairingPing", {}), { done: a3, resolve: o, reject: h5 } = it();
        this.events.once(pt("pairing_ping", n2), ({ error: u3 }) => {
          u3 ? h5(u3) : o();
        }), await a3();
      }
    }, this.updateExpiry = async ({ topic: i2, expiry: s }) => {
      this.isInitialized(), await this.pairings.update(i2, { expiry: s });
    }, this.updateMetadata = async ({ topic: i2, metadata: s }) => {
      this.isInitialized(), await this.pairings.update(i2, { peerMetadata: s });
    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async (i2) => {
      this.isInitialized(), await this.isValidDisconnect(i2);
      const { topic: s } = i2;
      this.pairings.keys.includes(s) && (await this.sendRequest(s, "wc_pairingDelete", U("USER_DISCONNECTED")), await this.deletePairing(s));
    }, this.sendRequest = async (i2, s, n2) => {
      const a3 = formatJsonRpcRequest(s, n2), o = await this.core.crypto.encode(i2, a3), h5 = F2[s].req;
      return this.core.history.set(i2, a3), this.core.relayer.publish(i2, o, h5), a3.id;
    }, this.sendResult = async (i2, s, n2) => {
      const a3 = formatJsonRpcResult(i2, n2), o = await this.core.crypto.encode(s, a3), h5 = await this.core.history.get(s, i2), u3 = F2[h5.request.method].res;
      await this.core.relayer.publish(s, o, u3), await this.core.history.resolve(a3);
    }, this.sendError = async (i2, s, n2) => {
      const a3 = formatJsonRpcError(i2, n2), o = await this.core.crypto.encode(s, a3), h5 = await this.core.history.get(s, i2), u3 = F2[h5.request.method] ? F2[h5.request.method].res : F2.unregistered_method.res;
      await this.core.relayer.publish(s, o, u3), await this.core.history.resolve(a3);
    }, this.deletePairing = async (i2, s) => {
      await this.core.relayer.unsubscribe(i2), await Promise.all([this.pairings.delete(i2, U("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(i2), s ? Promise.resolve() : this.core.expirer.del(i2)]);
    }, this.cleanup = async () => {
      const i2 = this.pairings.getAll().filter((s) => ft(s.expiry));
      await Promise.all(i2.map((s) => this.deletePairing(s.topic)));
    }, this.onRelayEventRequest = (i2) => {
      const { topic: s, payload: n2 } = i2;
      switch (n2.method) {
        case "wc_pairingPing":
          return this.onPairingPingRequest(s, n2);
        case "wc_pairingDelete":
          return this.onPairingDeleteRequest(s, n2);
        default:
          return this.onUnknownRpcMethodRequest(s, n2);
      }
    }, this.onRelayEventResponse = async (i2) => {
      const { topic: s, payload: n2 } = i2, a3 = (await this.core.history.get(s, n2.id)).request.method;
      switch (a3) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(s, n2);
        default:
          return this.onUnknownRpcMethodResponse(a3);
      }
    }, this.onPairingPingRequest = async (i2, s) => {
      const { id: n2 } = s;
      try {
        this.isValidPing({ topic: i2 }), await this.sendResult(n2, i2, true), this.events.emit(V2.ping, { id: n2, topic: i2 });
      } catch (a3) {
        await this.sendError(n2, i2, a3), this.logger.error(a3);
      }
    }, this.onPairingPingResponse = (i2, s) => {
      const { id: n2 } = s;
      setTimeout(() => {
        isJsonRpcResult(s) ? this.events.emit(pt("pairing_ping", n2), {}) : isJsonRpcError(s) && this.events.emit(pt("pairing_ping", n2), { error: s.error });
      }, 500);
    }, this.onPairingDeleteRequest = async (i2, s) => {
      const { id: n2 } = s;
      try {
        this.isValidDisconnect({ topic: i2 }), await this.deletePairing(i2), this.events.emit(V2.delete, { id: n2, topic: i2 });
      } catch (a3) {
        await this.sendError(n2, i2, a3), this.logger.error(a3);
      }
    }, this.onUnknownRpcMethodRequest = async (i2, s) => {
      const { id: n2, method: a3 } = s;
      try {
        if (this.registeredMethods.includes(a3))
          return;
        const o = U("WC_METHOD_UNSUPPORTED", a3);
        await this.sendError(n2, i2, o), this.logger.error(o);
      } catch (o) {
        await this.sendError(n2, i2, o), this.logger.error(o);
      }
    }, this.onUnknownRpcMethodResponse = (i2) => {
      this.registeredMethods.includes(i2) || this.logger.error(U("WC_METHOD_UNSUPPORTED", i2));
    }, this.isValidPair = (i2) => {
      if (!Ft(i2)) {
        const { message: s } = N("MISSING_OR_INVALID", `pair() params: ${i2}`);
        throw new Error(s);
      }
      if (!Dt(i2.uri)) {
        const { message: s } = N("MISSING_OR_INVALID", `pair() uri: ${i2.uri}`);
        throw new Error(s);
      }
    }, this.isValidPing = async (i2) => {
      if (!Ft(i2)) {
        const { message: n2 } = N("MISSING_OR_INVALID", `ping() params: ${i2}`);
        throw new Error(n2);
      }
      const { topic: s } = i2;
      await this.isValidPairingTopic(s);
    }, this.isValidDisconnect = async (i2) => {
      if (!Ft(i2)) {
        const { message: n2 } = N("MISSING_OR_INVALID", `disconnect() params: ${i2}`);
        throw new Error(n2);
      }
      const { topic: s } = i2;
      await this.isValidPairingTopic(s);
    }, this.isValidPairingTopic = async (i2) => {
      if (!h3(i2, false)) {
        const { message: s } = N("MISSING_OR_INVALID", `pairing topic should be a string: ${i2}`);
        throw new Error(s);
      }
      if (!this.pairings.keys.includes(i2)) {
        const { message: s } = N("NO_MATCHING_KEY", `pairing topic doesn't exist: ${i2}`);
        throw new Error(s);
      }
      if (ft(this.pairings.get(i2).expiry)) {
        await this.deletePairing(i2);
        const { message: s } = N("EXPIRED", `pairing topic: ${i2}`);
        throw new Error(s);
      }
    }, this.core = e, this.logger = (0, import_logger.generateChildLogger)(t, this.name), this.pairings = new $t2(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(D2.message, async (e) => {
      const { topic: t, message: i2 } = e;
      if (!this.pairings.keys.includes(t) || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(i2)))
        return;
      const s = await this.core.crypto.decode(t, i2);
      try {
        isJsonRpcRequest(s) ? (this.core.history.set(t, s), this.onRelayEventRequest({ topic: t, payload: s })) : isJsonRpcResponse(s) && (await this.core.history.resolve(s), await this.onRelayEventResponse({ topic: t, payload: s }), this.core.history.delete(t, s.id));
      } catch (n2) {
        this.logger.error(n2);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(v.expired, async (e) => {
      const { topic: t } = lt(e.target);
      t && this.pairings.keys.includes(t) && (await this.deletePairing(t, true), this.events.emit(V2.expire, { topic: t }));
    });
  }
};
var kt2 = class extends h2 {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, this.records = /* @__PURE__ */ new Map(), this.events = new import_events4.EventEmitter(), this.name = wt, this.version = vt2, this.cached = [], this.initialized = false, this.storagePrefix = O, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i2) => this.records.set(i2.id, i2)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }, this.set = (i2, s, n2) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: i2, request: s, chainId: n2 }), this.records.has(s.id))
        return;
      const a3 = { id: s.id, topic: i2, request: { method: s.method, params: s.params || null }, chainId: n2, expiry: dt(import_time2.THIRTY_DAYS) };
      this.records.set(a3.id, a3), this.events.emit(R2.created, a3);
    }, this.resolve = async (i2) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: i2 }), !this.records.has(i2.id))
        return;
      const s = await this.getRecord(i2.id);
      typeof s.response > "u" && (s.response = isJsonRpcError(i2) ? { error: i2.error } : { result: i2.result }, this.records.set(s.id, s), this.events.emit(R2.updated, s));
    }, this.get = async (i2, s) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: i2, id: s }), await this.getRecord(s)), this.delete = (i2, s) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: s }), this.values.forEach((n2) => {
        if (n2.topic === i2) {
          if (typeof s < "u" && n2.id !== s)
            return;
          this.records.delete(n2.id), this.events.emit(R2.deleted, n2);
        }
      });
    }, this.exists = async (i2, s) => (this.isInitialized(), this.records.has(s) ? (await this.getRecord(s)).topic === i2 : false), this.on = (i2, s) => {
      this.events.on(i2, s);
    }, this.once = (i2, s) => {
      this.events.once(i2, s);
    }, this.off = (i2, s) => {
      this.events.off(i2, s);
    }, this.removeListener = (i2, s) => {
      this.events.removeListener(i2, s);
    }, this.logger = (0, import_logger.generateChildLogger)(t, this.name);
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e = [];
    return this.values.forEach((t) => {
      if (typeof t.response < "u")
        return;
      const i2 = { topic: t.topic, request: formatJsonRpcRequest(t.request.method, t.request.params, t.id), chainId: t.chainId };
      return e.push(i2);
    }), e;
  }
  async setJsonRpcRecords(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e) {
    this.isInitialized();
    const t = this.records.get(e);
    if (!t) {
      const { message: i2 } = N("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(i2);
    }
    return t;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(R2.sync);
  }
  async restore() {
    try {
      const e = await this.getJsonRpcRecords();
      if (typeof e > "u" || !e.length)
        return;
      if (this.records.size) {
        const { message: t } = N("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);
    }
  }
  registerEventListeners() {
    this.events.on(R2.created, (e) => {
      const t = R2.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e }), this.persist();
    }), this.events.on(R2.updated, (e) => {
      const t = R2.updated;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e }), this.persist();
    }), this.events.on(R2.deleted, (e) => {
      const t = R2.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e }), this.persist();
    }), this.core.heartbeat.on(import_heartbeat.HEARTBEAT_EVENTS.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.records.forEach((e) => {
        (0, import_time2.toMiliseconds)(e.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${e.id}`), this.delete(e.topic, e.id));
      });
    } catch (e) {
      this.logger.warn(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Kt = class extends E {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, this.expirations = /* @__PURE__ */ new Map(), this.events = new import_events4.EventEmitter(), this.name = It, this.version = Ct2, this.cached = [], this.initialized = false, this.storagePrefix = O, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i2) => this.expirations.set(i2.target, i2)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }, this.has = (i2) => {
      try {
        const s = this.formatTarget(i2);
        return typeof this.getExpiration(s) < "u";
      } catch {
        return false;
      }
    }, this.set = (i2, s) => {
      this.isInitialized();
      const n2 = this.formatTarget(i2), a3 = { target: n2, expiry: s };
      this.expirations.set(n2, a3), this.checkExpiry(n2, a3), this.events.emit(v.created, { target: n2, expiration: a3 });
    }, this.get = (i2) => {
      this.isInitialized();
      const s = this.formatTarget(i2);
      return this.getExpiration(s);
    }, this.del = (i2) => {
      if (this.isInitialized(), this.has(i2)) {
        const s = this.formatTarget(i2), n2 = this.getExpiration(s);
        this.expirations.delete(s), this.events.emit(v.deleted, { target: s, expiration: n2 });
      }
    }, this.on = (i2, s) => {
      this.events.on(i2, s);
    }, this.once = (i2, s) => {
      this.events.once(i2, s);
    }, this.off = (i2, s) => {
      this.events.off(i2, s);
    }, this.removeListener = (i2, s) => {
      this.events.removeListener(i2, s);
    }, this.logger = (0, import_logger.generateChildLogger)(t, this.name);
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e) {
    if (typeof e == "string")
      return at(e);
    if (typeof e == "number")
      return ut(e);
    const { message: t } = N("UNKNOWN_TYPE", `Target type: ${typeof e}`);
    throw new Error(t);
  }
  async setExpirations(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(v.sync);
  }
  async restore() {
    try {
      const e = await this.getExpirations();
      if (typeof e > "u" || !e.length)
        return;
      if (this.expirations.size) {
        const { message: t } = N("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);
    }
  }
  getExpiration(e) {
    const t = this.expirations.get(e);
    if (!t) {
      const { message: i2 } = N("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(i2), new Error(i2);
    }
    return t;
  }
  checkExpiry(e, t) {
    const { expiry: i2 } = t;
    (0, import_time2.toMiliseconds)(i2) - Date.now() <= 0 && this.expire(e, t);
  }
  expire(e, t) {
    this.expirations.delete(e), this.events.emit(v.expired, { target: e, expiration: t });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e, t) => this.checkExpiry(t, e));
  }
  registerEventListeners() {
    this.core.heartbeat.on(import_heartbeat.HEARTBEAT_EVENTS.pulse, () => this.checkExpirations()), this.events.on(v.created, (e) => {
      const t = v.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(v.expired, (e) => {
      const t = v.expired;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(v.deleted, (e) => {
      const t = v.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Bt = class extends y {
  constructor(e, t) {
    super(e, t), this.projectId = e, this.logger = t, this.name = Z2, this.initialized = false, this.queue = [], this.verifyDisabled = false, this.init = async (i2) => {
      if (this.verifyDisabled || C() || !q())
        return;
      const s = this.getVerifyUrl(i2 == null ? void 0 : i2.verifyUrl);
      this.verifyUrl !== s && this.removeIframe(), this.verifyUrl = s;
      try {
        await this.createIframe();
      } catch (n2) {
        this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.info(n2);
      }
      if (!this.initialized) {
        this.removeIframe(), this.verifyUrl = ee2;
        try {
          await this.createIframe();
        } catch (n2) {
          this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.info(n2), this.verifyDisabled = true;
        }
      }
    }, this.register = async (i2) => {
      this.initialized ? this.sendPost(i2.attestationId) : (this.addToQueue(i2.attestationId), await this.init());
    }, this.resolve = async (i2) => {
      if (this.isDevEnv)
        return "";
      const s = this.getVerifyUrl(i2 == null ? void 0 : i2.verifyUrl);
      let n2;
      try {
        n2 = await this.fetchAttestation(i2.attestationId, s);
      } catch (a3) {
        this.logger.info(`failed to resolve attestation: ${i2.attestationId} from url: ${s}`), this.logger.info(a3), n2 = await this.fetchAttestation(i2.attestationId, ee2);
      }
      return n2;
    }, this.fetchAttestation = async (i2, s) => {
      this.logger.info(`resolving attestation: ${i2} from url: ${s}`);
      const n2 = this.startAbortTimer(import_time2.ONE_SECOND * 2), a3 = await fetch(`${s}/attestation/${i2}`, { signal: this.abortController.signal });
      return clearTimeout(n2), a3.status === 200 ? await a3.json() : void 0;
    }, this.addToQueue = (i2) => {
      this.queue.push(i2);
    }, this.processQueue = () => {
      this.queue.length !== 0 && (this.queue.forEach((i2) => this.sendPost(i2)), this.queue = []);
    }, this.sendPost = (i2) => {
      var s;
      try {
        if (!this.iframe)
          return;
        (s = this.iframe.contentWindow) == null || s.postMessage(i2, "*"), this.logger.info(`postMessage sent: ${i2} ${this.verifyUrl}`);
      } catch {
      }
    }, this.createIframe = async () => {
      let i2;
      const s = (n2) => {
        n2.data === "verify_ready" && (this.initialized = true, this.processQueue(), window.removeEventListener("message", s), i2());
      };
      await Promise.race([new Promise((n2) => {
        if (document.getElementById(Z2))
          return n2();
        window.addEventListener("message", s);
        const a3 = document.createElement("iframe");
        a3.id = Z2, a3.src = `${this.verifyUrl}/${this.projectId}`, a3.style.display = "none", document.body.append(a3), this.iframe = a3, i2 = n2;
      }), new Promise((n2, a3) => setTimeout(() => {
        window.removeEventListener("message", s), a3("verify iframe load timeout");
      }, (0, import_time2.toMiliseconds)(import_time2.FIVE_SECONDS)))]);
    }, this.removeIframe = () => {
      this.iframe && (this.iframe.remove(), this.iframe = void 0, this.initialized = false);
    }, this.getVerifyUrl = (i2) => {
      let s = i2 || $;
      return Rt.includes(s) || (this.logger.info(`verify url: ${s}, not included in trusted list, assigning default: ${$}`), s = $), s;
    }, this.logger = (0, import_logger.generateChildLogger)(t, this.name), this.verifyUrl = $, this.abortController = new AbortController(), this.isDevEnv = te() && process.env.IS_VITEST;
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  startAbortTimer(e) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), (0, import_time2.toMiliseconds)(e));
  }
};
var Or = Object.defineProperty;
var Vt2 = Object.getOwnPropertySymbols;
var Ar = Object.prototype.hasOwnProperty;
var zr = Object.prototype.propertyIsEnumerable;
var qt = (r, e, t) => e in r ? Or(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var jt = (r, e) => {
  for (var t in e || (e = {}))
    Ar.call(e, t) && qt(r, t, e[t]);
  if (Vt2)
    for (var t of Vt2(e))
      zr.call(e, t) && qt(r, t, e[t]);
  return r;
};
var te2 = class _te extends n {
  constructor(e) {
    super(e), this.protocol = le2, this.version = We2, this.name = Q2, this.events = new import_events4.EventEmitter(), this.initialized = false, this.on = (i2, s) => this.events.on(i2, s), this.once = (i2, s) => this.events.once(i2, s), this.off = (i2, s) => this.events.off(i2, s), this.removeListener = (i2, s) => this.events.removeListener(i2, s), this.projectId = e == null ? void 0 : e.projectId, this.relayUrl = (e == null ? void 0 : e.relayUrl) || ge, this.customStoragePrefix = e != null && e.customStoragePrefix ? `:${e.customStoragePrefix}` : "";
    const t = typeof (e == null ? void 0 : e.logger) < "u" && typeof (e == null ? void 0 : e.logger) != "string" ? e.logger : (0, import_logger.pino)((0, import_logger.getDefaultLoggerOptions)({ level: (e == null ? void 0 : e.logger) || Xe.logger }));
    this.logger = (0, import_logger.generateChildLogger)(t, this.name), this.heartbeat = new import_heartbeat.HeartBeat(), this.crypto = new St(this, this.logger, e == null ? void 0 : e.keychain), this.history = new kt2(this, this.logger), this.expirer = new Kt(this, this.logger), this.storage = e != null && e.storage ? e.storage : new h(jt(jt({}, Qe), e == null ? void 0 : e.storageOptions)), this.relayer = new Nt2({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new Mt(this, this.logger), this.verify = new Bt(this.projectId || "", this.logger);
  }
  static async init(e) {
    const t = new _te(e);
    await t.initialize();
    const i2 = await t.crypto.getClientId();
    return await t.storage.setItem(Dt2, i2), t;
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.initialized = true, this.logger.info("Core Initialization Success");
    } catch (e) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e;
    }
  }
};
var Nr = te2;
export {
  Q2 as CORE_CONTEXT,
  Xe as CORE_DEFAULT,
  le2 as CORE_PROTOCOL,
  Qe as CORE_STORAGE_OPTIONS,
  O as CORE_STORAGE_PREFIX,
  We2 as CORE_VERSION,
  de2 as CRYPTO_CLIENT_SEED,
  Ze as CRYPTO_CONTEXT,
  et as CRYPTO_JWT_TTL,
  Nr as Core,
  St as Crypto,
  It as EXPIRER_CONTEXT,
  yr as EXPIRER_DEFAULT_TTL,
  v as EXPIRER_EVENTS,
  Ct2 as EXPIRER_STORAGE_VERSION,
  Kt as Expirer,
  wt as HISTORY_CONTEXT,
  R2 as HISTORY_EVENTS,
  vt2 as HISTORY_STORAGE_VERSION,
  kt2 as JsonRpcHistory,
  tt2 as KEYCHAIN_CONTEXT,
  it2 as KEYCHAIN_STORAGE_VERSION,
  _t as KeyChain,
  st as MESSAGES_CONTEXT,
  rt as MESSAGES_STORAGE_VERSION,
  Tt as MessageTracker,
  ft2 as PAIRING_CONTEXT,
  Dr as PAIRING_DEFAULT_TTL,
  V2 as PAIRING_EVENTS,
  F2 as PAIRING_RPC_OPTS,
  Et2 as PAIRING_STORAGE_VERSION,
  mt as PENDING_SUB_RESOLUTION_TIMEOUT,
  at2 as PUBLISHER_CONTEXT,
  nt2 as PUBLISHER_DEFAULT_TTL,
  Mt as Pairing,
  ct2 as RELAYER_CONTEXT,
  ht2 as RELAYER_DEFAULT_LOGGER,
  ot as RELAYER_DEFAULT_PROTOCOL,
  ge as RELAYER_DEFAULT_RELAY_URL,
  D2 as RELAYER_EVENTS,
  pe as RELAYER_FAILOVER_RELAY_URL,
  P as RELAYER_PROVIDER_EVENTS,
  lt2 as RELAYER_RECONNECT_TIMEOUT,
  dt2 as RELAYER_SDK_VERSION,
  gr as RELAYER_STORAGE_OPTIONS,
  ut2 as RELAYER_SUBSCRIBER_SUFFIX,
  gt2 as RELAYER_TRANSPORT_CUTOFF,
  Nt2 as Relayer,
  pt2 as STORE_STORAGE_VERSION,
  yt2 as SUBSCRIBER_CONTEXT,
  pr as SUBSCRIBER_DEFAULT_TTL,
  w3 as SUBSCRIBER_EVENTS,
  bt2 as SUBSCRIBER_STORAGE_VERSION,
  $t2 as Store,
  Ot2 as Subscriber,
  Rt as TRUSTED_VERIFY_URLS,
  Z2 as VERIFY_CONTEXT,
  ee2 as VERIFY_FALLBACK_SERVER,
  $ as VERIFY_SERVER,
  Bt as Verify,
  Dt2 as WALLETCONNECT_CLIENT_ID,
  te2 as default
};
//# sourceMappingURL=@walletconnect_core.js.map
