{
  "version": 3,
  "sources": ["../../rate-limiter-flexible/lib/RateLimiterAbstract.js", "../../rate-limiter-flexible/lib/component/BlockedKeys/BlockedKeys.js", "../../rate-limiter-flexible/lib/component/BlockedKeys/index.js", "../../rate-limiter-flexible/lib/RateLimiterRes.js", "../../rate-limiter-flexible/lib/RateLimiterStoreAbstract.js", "../../rate-limiter-flexible/lib/RateLimiterRedis.js", "../../rate-limiter-flexible/lib/RateLimiterMongo.js", "../../rate-limiter-flexible/lib/RateLimiterMySQL.js", "../../rate-limiter-flexible/lib/RateLimiterPostgres.js", "browser-external:cluster", "../../rate-limiter-flexible/lib/component/MemoryStorage/Record.js", "../../rate-limiter-flexible/lib/component/MemoryStorage/MemoryStorage.js", "../../rate-limiter-flexible/lib/RateLimiterMemory.js", "../../rate-limiter-flexible/lib/RateLimiterCluster.js", "../../rate-limiter-flexible/lib/RateLimiterMemcache.js", "../../rate-limiter-flexible/lib/RLWrapperBlackAndWhite.js", "../../rate-limiter-flexible/lib/RateLimiterUnion.js", "../../rate-limiter-flexible/lib/component/RateLimiterQueueError.js", "../../rate-limiter-flexible/lib/RateLimiterQueue.js", "../../rate-limiter-flexible/lib/BurstyRateLimiter.js", "../../rate-limiter-flexible/index.js", "../../event-iterator/lib/event-iterator.js", "../../event-iterator/lib/dom.js", "../../iso-url/src/url-browser.js", "../../iso-url/src/relative.js", "../../iso-url/index.js", "../../is-electron/index.js", "../../protobufjs/minimal.js", "../../@chainsafe/libp2p-gossipsub/dist/src/message/rpc.cjs", "../../denque/index.js", "../../truncate-utf8-bytes/lib/truncate.js", "../../utf8-byte-length/browser.js", "../../truncate-utf8-bytes/browser.js", "../../sanitize-filename/index.js", "../../p-queue/node_modules/eventemitter3/index.js", "../../netmask/lib/netmask.js", "../../ipaddr.js/lib/ipaddr.js", "../../ms/index.js", "../../receptacle/index.js", "../../@waku/core/src/index.ts", "../../@waku/core/src/lib/waku.ts", "../../@waku/interfaces/src/protocols.ts", "../../@waku/interfaces/src/store.ts", "../../@waku/interfaces/src/connection_manager.ts", "../../@libp2p/interfaces/src/events.ts", "../../@waku/core/src/lib/message/version_0.ts", "../../@waku/proto/src/lib/message.ts", "../../@waku/proto/src/lib/filter.ts", "../../@waku/proto/src/lib/topic_only_message.ts", "../../@waku/proto/src/lib/filter_v2.ts", "../../@waku/proto/src/lib/light_push.ts", "../../@waku/proto/src/lib/store.ts", "../../@waku/proto/src/lib/peer_exchange.ts", "../../@waku/core/src/lib/constants.ts", "../../@waku/core/src/lib/keep_alive_manager.ts", "../../@waku/core/src/lib/connection_manager.ts", "../../@waku/core/src/lib/message/index.ts", "../../@waku/core/src/lib/filter/index.ts", "../../it-all/src/index.ts", "../../uint8arraylist/src/index.ts", "../../it-length-prefixed/src/utils.ts", "../../it-length-prefixed/src/encode.ts", "../../it-length-prefixed/src/decode.ts", "../../p-defer/index.js", "../../it-pushable/src/fifo.ts", "../../it-pushable/src/index.ts", "../../it-merge/src/index.ts", "../../it-pipe/src/index.ts", "../../@waku/utils/src/libp2p/index.ts", "../../@waku/core/src/lib/filterPeers.ts", "../../@waku/core/src/lib/stream_manager.ts", "../../@waku/core/src/lib/base_protocol.ts", "../../@waku/core/node_modules/uuid/dist/esm-browser/rng.js", "../../@waku/core/node_modules/uuid/dist/esm-browser/regex.js", "../../@waku/core/node_modules/uuid/dist/esm-browser/validate.js", "../../@waku/core/node_modules/uuid/dist/esm-browser/stringify.js", "../../@waku/core/node_modules/uuid/dist/esm-browser/parse.js", "../../@waku/core/node_modules/uuid/dist/esm-browser/v35.js", "../../@waku/core/node_modules/uuid/dist/esm-browser/md5.js", "../../@waku/core/node_modules/uuid/dist/esm-browser/v3.js", "../../@waku/core/node_modules/uuid/dist/esm-browser/native.js", "../../@waku/core/node_modules/uuid/dist/esm-browser/v4.js", "../../@waku/core/node_modules/uuid/dist/esm-browser/sha1.js", "../../@waku/core/node_modules/uuid/dist/esm-browser/v5.js", "../../@waku/core/src/lib/filter/filter_rpc.ts", "../../@waku/core/src/lib/light_push/index.ts", "../../@waku/core/src/lib/light_push/push_rpc.ts", "../../@waku/core/src/lib/store/index.ts", "../../@waku/core/src/lib/to_proto_message.ts", "../../@waku/core/src/lib/store/history_rpc.ts", "../../p-timeout/index.js", "../../p-event/index.js", "../../@waku/core/src/lib/wait_for_remote_peer.ts", "../../race-signal/src/index.ts", "../../it-byte-stream/src/pushable.ts", "../../it-byte-stream/src/index.ts", "../../it-length-prefixed-stream/src/index.ts", "../../it-pair/src/index.ts", "../../it-pair/src/duplex.ts", "../../@chainsafe/libp2p-noise/src/constants.ts", "../../@noble/ciphers/src/utils.ts", "../../@noble/ciphers/src/_assert.ts", "../../@noble/ciphers/src/_poly1305.ts", "../../@noble/ciphers/src/_arx.ts", "../../@noble/ciphers/src/chacha.ts", "../../@noble/hashes/src/sha512.ts", "../../@noble/curves/src/abstract/edwards.ts", "../../@noble/curves/src/abstract/montgomery.ts", "../../@noble/curves/src/ed25519.ts", "../../@noble/hashes/src/hkdf.ts", "../../@chainsafe/libp2p-noise/src/crypto/js.ts", "../../@chainsafe/libp2p-noise/src/crypto/index.browser.ts", "../../@chainsafe/libp2p-noise/src/encoder.ts", "../../@chainsafe/libp2p-noise/src/crypto/streaming.ts", "../../@libp2p/crypto/src/keys/index.ts", "../../@libp2p/crypto/src/keys/ed25519-class.ts", "../../@libp2p/crypto/node_modules/multiformats/vendor/base-x.js", "../../@libp2p/crypto/node_modules/multiformats/src/bytes.js", "../../@libp2p/crypto/node_modules/multiformats/src/bases/base.js", "../../@libp2p/crypto/node_modules/multiformats/src/bases/base58.js", "../../@libp2p/crypto/node_modules/multiformats/vendor/varint.js", "../../@libp2p/crypto/node_modules/multiformats/src/varint.js", "../../@libp2p/crypto/node_modules/multiformats/src/hashes/digest.js", "../../@libp2p/crypto/node_modules/multiformats/src/hashes/identity.js", "../../@libp2p/crypto/node_modules/multiformats/src/hashes/hasher.js", "../../@libp2p/crypto/node_modules/multiformats/src/hashes/sha2-browser.js", "../../@libp2p/crypto/src/keys/ed25519-browser.ts", "../../@libp2p/crypto/node_modules/multiformats/src/bases/base64.js", "../../@libp2p/crypto/src/webcrypto.ts", "../../@libp2p/crypto/src/ciphers/aes-gcm.browser.ts", "../../@libp2p/crypto/src/keys/exporter.ts", "../../@libp2p/crypto/src/keys/keys.ts", "../../@libp2p/crypto/src/util.ts", "../../@libp2p/crypto/src/keys/ecdh-browser.ts", "../../@libp2p/crypto/src/keys/importer.ts", "../../@libp2p/crypto/src/keys/rsa-class.ts", "../../@libp2p/crypto/src/random-bytes.ts", "../../@libp2p/crypto/src/keys/jwk2pem.ts", "../../@libp2p/crypto/src/keys/rsa-utils.ts", "../../@libp2p/crypto/src/keys/rsa-browser.ts", "../../@libp2p/crypto/src/keys/secp256k1-class.ts", "../../@libp2p/crypto/src/keys/secp256k1.ts", "../../@chainsafe/libp2p-noise/src/proto/payload.ts", "../../@chainsafe/libp2p-noise/src/utils.ts", "../../@chainsafe/libp2p-noise/src/logger.ts", "../../@chainsafe/libp2p-noise/src/nonce.ts", "../../@chainsafe/libp2p-noise/src/handshakes/abstract-handshake.ts", "../../@chainsafe/libp2p-noise/src/handshakes/xx.ts", "../../@chainsafe/libp2p-noise/src/handshake-xx.ts", "../../@chainsafe/libp2p-noise/src/metrics.ts", "../../@chainsafe/libp2p-noise/src/noise.ts", "../../@chainsafe/libp2p-noise/src/index.ts", "../../abortable-iterator/src/abort-error.ts", "../../abortable-iterator/node_modules/get-iterator/src/index.ts", "../../abortable-iterator/src/index.ts", "../../@libp2p/mplex/src/mplex.ts", "../../@libp2p/mplex/src/message-types.ts", "../../@libp2p/mplex/src/decode.ts", "../../it-batched-bytes/src/index.ts", "../../@libp2p/mplex/src/alloc-unsafe-browser.ts", "../../@libp2p/mplex/src/encode.ts", "../../@libp2p/interface/src/stream-muxer/stream.ts", "../../@libp2p/mplex/src/stream.ts", "../../@libp2p/mplex/src/index.ts", "../../@libp2p/interface/src/transport/index.ts", "../../@multiformats/multiaddr-to-uri/src/index.ts", "../../it-ws/src/ready.ts", "../../it-ws/src/sink.ts", "../../it-ws/src/source.ts", "../../it-ws/src/duplex.ts", "../../it-ws/src/web-socket.browser.ts", "../../it-ws/src/ws-url.ts", "../../it-ws/src/client.ts", "../../wherearewe/src/index.js", "../../@libp2p/websockets/src/constants.ts", "../../@libp2p/websockets/src/filters.ts", "../../@libp2p/websockets/src/listener.browser.ts", "../../@libp2p/websockets/src/socket-to-conn.ts", "../../@libp2p/websockets/src/index.ts", "../../@waku/peer-exchange/src/rpc.ts", "../../@waku/peer-exchange/src/waku_peer_exchange.ts", "../../@waku/peer-exchange/src/waku_peer_exchange_discovery.ts", "../../@waku/relay/src/index.ts", "../../@chainsafe/libp2p-gossipsub/src/message-cache.ts", "../../@chainsafe/libp2p-gossipsub/dist/src/message/rpc.js", "../../@chainsafe/libp2p-gossipsub/src/constants.ts", "../../@chainsafe/libp2p-gossipsub/src/utils/shuffle.ts", "../../@chainsafe/libp2p-gossipsub/src/utils/messageIdToString.ts", "../../@libp2p/interface/src/pubsub/index.ts", "../../@chainsafe/libp2p-gossipsub/src/types.ts", "../../@chainsafe/libp2p-gossipsub/src/utils/publishConfig.ts", "../../@chainsafe/libp2p-gossipsub/src/score/constants.ts", "../../@chainsafe/libp2p-gossipsub/src/score/peer-score-params.ts", "../../@chainsafe/libp2p-gossipsub/src/score/peer-score-thresholds.ts", "../../@chainsafe/libp2p-gossipsub/src/score/compute-score.ts", "../../@chainsafe/libp2p-gossipsub/src/score/message-deliveries.ts", "../../@chainsafe/libp2p-gossipsub/src/utils/set.ts", "../../@chainsafe/libp2p-gossipsub/src/score/peer-score.ts", "../../@chainsafe/libp2p-gossipsub/src/tracer.ts", "../../@chainsafe/libp2p-gossipsub/src/utils/time-cache.ts", "../../@chainsafe/libp2p-gossipsub/src/metrics.ts", "../../@libp2p/crypto/src/aes/ciphers-browser.ts", "../../@libp2p/crypto/src/pbkdf2.ts", "../../@chainsafe/libp2p-gossipsub/src/utils/buildRawMessage.ts", "../../@chainsafe/libp2p-gossipsub/node_modules/multiformats/src/bytes.js", "../../@chainsafe/libp2p-gossipsub/node_modules/multiformats/vendor/varint.js", "../../@chainsafe/libp2p-gossipsub/node_modules/multiformats/src/varint.js", "../../@chainsafe/libp2p-gossipsub/node_modules/multiformats/src/hashes/digest.js", "../../@chainsafe/libp2p-gossipsub/node_modules/multiformats/src/hashes/hasher.js", "../../@chainsafe/libp2p-gossipsub/node_modules/multiformats/src/hashes/sha2-browser.js", "../../@libp2p/pubsub/node_modules/multiformats/src/bytes.js", "../../@libp2p/pubsub/node_modules/multiformats/vendor/varint.js", "../../@libp2p/pubsub/node_modules/multiformats/src/varint.js", "../../@libp2p/pubsub/node_modules/multiformats/src/hashes/digest.js", "../../@libp2p/pubsub/node_modules/multiformats/src/hashes/hasher.js", "../../@libp2p/pubsub/node_modules/multiformats/src/hashes/sha2-browser.js", "../../@libp2p/pubsub/src/utils.ts", "../../@chainsafe/libp2p-gossipsub/src/utils/msgIdFn.ts", "../../@chainsafe/libp2p-gossipsub/src/score/scoreMetrics.ts", "../../@chainsafe/libp2p-gossipsub/src/stream.ts", "../../@chainsafe/libp2p-gossipsub/src/message/decodeRpc.ts", "../../@chainsafe/libp2p-gossipsub/src/utils/multiaddr.ts", "../../@chainsafe/libp2p-gossipsub/src/index.ts", "../../@waku/relay/src/constants.ts", "../../@waku/relay/src/message_validator.ts", "../../@waku/relay/src/topic_only_message.ts", "../../@libp2p/interface/src/content-routing/index.ts", "../../@libp2p/interface/src/peer-routing/index.ts", "../../interface-datastore/node_modules/nanoid/index.browser.js", "../../interface-datastore/src/key.ts", "../../@libp2p/keychain/src/index.ts", "../../@libp2p/keychain/src/errors.ts", "../../@libp2p/peer-collections/src/util.ts", "../../@libp2p/peer-collections/src/map.ts", "../../@libp2p/peer-collections/src/set.ts", "../../@libp2p/peer-collections/src/list.ts", "../../@libp2p/peer-id-factory/src/proto.ts", "../../@libp2p/peer-id-factory/src/index.ts", "../../@libp2p/peer-record/src/errors.ts", "../../@libp2p/peer-record/src/envelope/envelope.ts", "../../@libp2p/peer-record/src/envelope/index.ts", "../../@libp2p/utils/src/array-equals.ts", "../../@libp2p/peer-record/src/peer-record/consts.ts", "../../@libp2p/peer-record/src/peer-record/peer-record.ts", "../../@libp2p/peer-record/src/peer-record/index.ts", "../../p-queue/node_modules/eventemitter3/index.mjs", "../../p-queue/node_modules/p-timeout/index.js", "../../p-queue/dist/lower-bound.js", "../../p-queue/dist/priority-queue.js", "../../p-queue/dist/index.js", "../../mortice/node_modules/nanoid/index.browser.js", "../../mortice/src/constants.ts", "../../observable-webworkers/src/index.ts", "../../mortice/src/browser.ts", "../../mortice/src/index.ts", "../../@libp2p/peer-store/node_modules/multiformats/src/bytes.js", "../../@libp2p/peer-store/node_modules/multiformats/src/bases/base.js", "../../@libp2p/peer-store/node_modules/multiformats/src/bases/base32.js", "../../@libp2p/peer-store/src/errors.ts", "../../@libp2p/peer-store/src/pb/peer.ts", "../../@libp2p/peer-store/src/utils/bytes-to-peer.ts", "../../@libp2p/peer-store/src/utils/peer-id-to-datastore-key.ts", "../../@libp2p/peer-store/src/utils/dedupe-addresses.ts", "../../@libp2p/peer-store/src/utils/to-peer-pb.ts", "../../@libp2p/peer-store/src/store.ts", "../../@libp2p/peer-store/src/index.ts", "../../it-drain/src/index.ts", "../../it-peekable/src/index.ts", "../../it-filter/src/index.ts", "../../it-sort/src/index.ts", "../../datastore-core/node_modules/it-take/src/index.ts", "../../datastore-core/src/base.ts", "../../datastore-core/src/errors.ts", "../../datastore-core/src/memory.ts", "../../libp2p/src/address-manager/utils.ts", "../../libp2p/src/address-manager/index.ts", "../../@libp2p/interface/src/startable.ts", "../../libp2p/src/components.ts", "../../private-ip/lib/index.js", "../../ip-regex/index.js", "../../private-ip/index.js", "../../libp2p/src/config/connection-gater.browser.ts", "../../@multiformats/multiaddr-matcher/node_modules/multiformats/vendor/base-x.js", "../../@multiformats/multiaddr-matcher/node_modules/multiformats/src/bytes.js", "../../@multiformats/multiaddr-matcher/node_modules/multiformats/src/bases/base.js", "../../@multiformats/multiaddr-matcher/node_modules/multiformats/src/bases/base58.js", "../../@multiformats/multiaddr-matcher/node_modules/multiformats/src/bases/base64.js", "../../@multiformats/multiaddr-matcher/src/index.ts", "../../@libp2p/utils/src/multiaddr/is-private.ts", "../../@libp2p/utils/src/address-sort.ts", "../../dns-over-http-resolver/src/index.ts", "../../dns-over-http-resolver/src/utils.ts", "../../@multiformats/multiaddr/src/resolvers/dns.browser.ts", "../../@multiformats/multiaddr/src/resolvers/index.ts", "../../libp2p/src/errors.ts", "../../libp2p/src/config.ts", "../../@libp2p/interface/src/peer-store/tags.ts", "../../libp2p/src/connection-manager/index.ts", "../../libp2p/src/get-peer.ts", "../../libp2p/src/utils/peer-job-queue.ts", "../../libp2p/src/connection-manager/constants.defaults.ts", "../../libp2p/src/connection-manager/constants.browser.ts", "../../libp2p/src/connection-manager/auto-dial.ts", "../../libp2p/src/connection-manager/connection-pruner.ts", "../../any-signal/src/index.ts", "../../libp2p/src/connection-manager/utils.ts", "../../libp2p/src/connection-manager/dial-queue.ts", "../../it-map/src/index.ts", "../../libp2p/src/content-routing/utils.ts", "../../libp2p/src/content-routing/index.ts", "../../it-first/src/index.ts", "../../libp2p/src/peer-routing.ts", "../../libp2p/src/registrar.ts", "../../@libp2p/interface/src/metrics/tracked-map.ts", "../../libp2p/src/transport-manager.ts", "../../@libp2p/multistream-select/src/constants.ts", "../../it-reader/src/index.ts", "../../it-handshake/src/index.ts", "../../@libp2p/multistream-select/src/multistream.ts", "../../@libp2p/multistream-select/src/select.ts", "../../@libp2p/multistream-select/src/handle.ts", "../../@libp2p/interface/src/connection/index.ts", "../../libp2p/src/connection/index.ts", "../../libp2p/src/upgrader.ts", "../../libp2p/src/libp2p.ts", "../../libp2p/src/index.ts", "../../libp2p/src/version.ts", "../../libp2p/src/identify/consts.ts", "../../it-protobuf-stream/src/index.ts", "../../libp2p/src/identify/pb/message.ts", "../../libp2p/src/identify/identify.ts", "../../libp2p/src/identify/index.ts", "../../libp2p/src/ping/constants.ts", "../../libp2p/src/ping/index.ts", "../../@waku/sdk/src/create.ts"],
  "sourcesContent": ["module.exports = class RateLimiterAbstract {\n  /**\n   *\n   * @param opts Object Defaults {\n   *   points: 4, // Number of points\n   *   duration: 1, // Per seconds\n   *   blockDuration: 0, // Block if consumed more than points in current duration for blockDuration seconds\n   *   execEvenly: false, // Execute allowed actions evenly over duration\n   *   execEvenlyMinDelayMs: duration * 1000 / points, // ms, works with execEvenly=true option\n   *   keyPrefix: 'rlflx',\n   * }\n   */\n  constructor(opts = {}) {\n    this.points = opts.points;\n    this.duration = opts.duration;\n    this.blockDuration = opts.blockDuration;\n    this.execEvenly = opts.execEvenly;\n    this.execEvenlyMinDelayMs = opts.execEvenlyMinDelayMs;\n    this.keyPrefix = opts.keyPrefix;\n  }\n\n  get points() {\n    return this._points;\n  }\n\n  set points(value) {\n    this._points = value >= 0 ? value : 4;\n  }\n\n  get duration() {\n    return this._duration;\n  }\n\n  set duration(value) {\n    this._duration = typeof value === 'undefined' ? 1 : value;\n  }\n\n  get msDuration() {\n    return this.duration * 1000;\n  }\n\n  get blockDuration() {\n    return this._blockDuration;\n  }\n\n  set blockDuration(value) {\n    this._blockDuration = typeof value === 'undefined' ? 0 : value;\n  }\n\n  get msBlockDuration() {\n    return this.blockDuration * 1000;\n  }\n\n  get execEvenly() {\n    return this._execEvenly;\n  }\n\n  set execEvenly(value) {\n    this._execEvenly = typeof value === 'undefined' ? false : Boolean(value);\n  }\n\n  get execEvenlyMinDelayMs() {\n    return this._execEvenlyMinDelayMs;\n  }\n\n  set execEvenlyMinDelayMs(value) {\n    this._execEvenlyMinDelayMs = typeof value === 'undefined' ? Math.ceil(this.msDuration / this.points) : value;\n  }\n\n  get keyPrefix() {\n    return this._keyPrefix;\n  }\n\n  set keyPrefix(value) {\n    if (typeof value === 'undefined') {\n      value = 'rlflx';\n    }\n    if (typeof value !== 'string') {\n      throw new Error('keyPrefix must be string');\n    }\n    this._keyPrefix = value;\n  }\n\n  _getKeySecDuration(options = {}) {\n    return options && options.customDuration >= 0\n      ? options.customDuration\n      : this.duration;\n  }\n\n  getKey(key) {\n    return this.keyPrefix.length > 0 ? `${this.keyPrefix}:${key}` : key;\n  }\n\n  parseKey(rlKey) {\n    return rlKey.substring(this.keyPrefix.length);\n  }\n\n  consume() {\n    throw new Error(\"You have to implement the method 'consume'!\");\n  }\n\n  penalty() {\n    throw new Error(\"You have to implement the method 'penalty'!\");\n  }\n\n  reward() {\n    throw new Error(\"You have to implement the method 'reward'!\");\n  }\n\n  get() {\n    throw new Error(\"You have to implement the method 'get'!\");\n  }\n\n  set() {\n    throw new Error(\"You have to implement the method 'set'!\");\n  }\n\n  block() {\n    throw new Error(\"You have to implement the method 'block'!\");\n  }\n\n  delete() {\n    throw new Error(\"You have to implement the method 'delete'!\");\n  }\n};\n", "module.exports = class BlockedKeys {\n  constructor() {\n    this._keys = {}; // {'key': 1526279430331}\n    this._addedKeysAmount = 0;\n  }\n\n  collectExpired() {\n    const now = Date.now();\n\n    Object.keys(this._keys).forEach((key) => {\n      if (this._keys[key] <= now) {\n        delete this._keys[key];\n      }\n    });\n\n    this._addedKeysAmount = Object.keys(this._keys).length;\n  }\n\n  /**\n   * Add new blocked key\n   *\n   * @param key String\n   * @param sec Number\n   */\n  add(key, sec) {\n    this.addMs(key, sec * 1000);\n  }\n\n  /**\n   * Add new blocked key for ms\n   *\n   * @param key String\n   * @param ms Number\n   */\n  addMs(key, ms) {\n    this._keys[key] = Date.now() + ms;\n    this._addedKeysAmount++;\n    if (this._addedKeysAmount > 999) {\n      this.collectExpired();\n    }\n  }\n\n  /**\n   * 0 means not blocked\n   *\n   * @param key\n   * @returns {number}\n   */\n  msBeforeExpire(key) {\n    const expire = this._keys[key];\n\n    if (expire && expire >= Date.now()) {\n      this.collectExpired();\n      const now = Date.now();\n      return expire >= now ? expire - now : 0;\n    }\n\n    return 0;\n  }\n\n  /**\n   * If key is not given, delete all data in memory\n   * \n   * @param {string|undefined} key\n   */\n  delete(key) {\n    if (key) {\n      delete this._keys[key];\n    } else {\n      Object.keys(this._keys).forEach((key) => {\n        delete this._keys[key];\n      });\n    }\n  }\n};\n", "const BlockedKeys = require('./BlockedKeys');\n\nmodule.exports = BlockedKeys;\n", "module.exports = class RateLimiterRes {\n  constructor(remainingPoints, msBeforeNext, consumedPoints, isFirstInDuration) {\n    this.remainingPoints = typeof remainingPoints === 'undefined' ? 0 : remainingPoints; // Remaining points in current duration\n    this.msBeforeNext = typeof msBeforeNext === 'undefined' ? 0 : msBeforeNext; // Milliseconds before next action\n    this.consumedPoints = typeof consumedPoints === 'undefined' ? 0 : consumedPoints; // Consumed points in current duration\n    this.isFirstInDuration = typeof isFirstInDuration === 'undefined' ? false : isFirstInDuration;\n  }\n\n  get msBeforeNext() {\n    return this._msBeforeNext;\n  }\n\n  set msBeforeNext(ms) {\n    this._msBeforeNext = ms;\n    return this;\n  }\n\n  get remainingPoints() {\n    return this._remainingPoints;\n  }\n\n  set remainingPoints(p) {\n    this._remainingPoints = p;\n    return this;\n  }\n\n  get consumedPoints() {\n    return this._consumedPoints;\n  }\n\n  set consumedPoints(p) {\n    this._consumedPoints = p;\n    return this;\n  }\n\n  get isFirstInDuration() {\n    return this._isFirstInDuration;\n  }\n\n  set isFirstInDuration(value) {\n    this._isFirstInDuration = Boolean(value);\n  }\n\n  _getDecoratedProperties() {\n    return {\n      remainingPoints: this.remainingPoints,\n      msBeforeNext: this.msBeforeNext,\n      consumedPoints: this.consumedPoints,\n      isFirstInDuration: this.isFirstInDuration,\n    };\n  }\n\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    return this._getDecoratedProperties();\n  }\n\n  toString() {\n    return JSON.stringify(this._getDecoratedProperties());\n  }\n\n  toJSON() {\n    return this._getDecoratedProperties();\n  }\n};\n", "const RateLimiterAbstract = require('./RateLimiterAbstract');\nconst BlockedKeys = require('./component/BlockedKeys');\nconst RateLimiterRes = require('./RateLimiterRes');\n\nmodule.exports = class RateLimiterStoreAbstract extends RateLimiterAbstract {\n  /**\n   *\n   * @param opts Object Defaults {\n   *   ... see other in RateLimiterAbstract\n   *\n   *   inMemoryBlockOnConsumed: 40, // Number of points when key is blocked\n   *   inMemoryBlockDuration: 10, // Block duration in seconds\n   *   insuranceLimiter: RateLimiterAbstract\n   * }\n   */\n  constructor(opts = {}) {\n    super(opts);\n\n    this.inMemoryBlockOnConsumed = opts.inMemoryBlockOnConsumed;\n    this.inMemoryBlockDuration = opts.inMemoryBlockDuration;\n    this.insuranceLimiter = opts.insuranceLimiter;\n    this._inMemoryBlockedKeys = new BlockedKeys();\n  }\n\n  get client() {\n    return this._client;\n  }\n\n  set client(value) {\n    if (typeof value === 'undefined') {\n      throw new Error('storeClient is not set');\n    }\n    this._client = value;\n  }\n\n  /**\n   * Have to be launched after consume\n   * It blocks key and execute evenly depending on result from store\n   *\n   * It uses _getRateLimiterRes function to prepare RateLimiterRes from store result\n   *\n   * @param resolve\n   * @param reject\n   * @param rlKey\n   * @param changedPoints\n   * @param storeResult\n   * @param {Object} options\n   * @private\n   */\n  _afterConsume(resolve, reject, rlKey, changedPoints, storeResult, options = {}) {\n    const res = this._getRateLimiterRes(rlKey, changedPoints, storeResult);\n\n    if (this.inMemoryBlockOnConsumed > 0 && !(this.inMemoryBlockDuration > 0)\n      && res.consumedPoints >= this.inMemoryBlockOnConsumed\n    ) {\n      this._inMemoryBlockedKeys.addMs(rlKey, res.msBeforeNext);\n      if (res.consumedPoints > this.points) {\n        return reject(res);\n      } else {\n        return resolve(res)\n      }\n    } else if (res.consumedPoints > this.points) {\n      let blockPromise = Promise.resolve();\n      // Block only first time when consumed more than points\n      if (this.blockDuration > 0 && res.consumedPoints <= (this.points + changedPoints)) {\n        res.msBeforeNext = this.msBlockDuration;\n        blockPromise = this._block(rlKey, res.consumedPoints, this.msBlockDuration, options);\n      }\n\n      if (this.inMemoryBlockOnConsumed > 0 && res.consumedPoints >= this.inMemoryBlockOnConsumed) {\n        // Block key for this.inMemoryBlockDuration seconds\n        this._inMemoryBlockedKeys.add(rlKey, this.inMemoryBlockDuration);\n        res.msBeforeNext = this.msInMemoryBlockDuration;\n      }\n\n      blockPromise\n        .then(() => {\n          reject(res);\n        })\n        .catch((err) => {\n          reject(err);\n        });\n    } else if (this.execEvenly && res.msBeforeNext > 0 && !res.isFirstInDuration) {\n      let delay = Math.ceil(res.msBeforeNext / (res.remainingPoints + 2));\n      if (delay < this.execEvenlyMinDelayMs) {\n        delay = res.consumedPoints * this.execEvenlyMinDelayMs;\n      }\n\n      setTimeout(resolve, delay, res);\n    } else {\n      resolve(res);\n    }\n  }\n\n  _handleError(err, funcName, resolve, reject, key, data = false, options = {}) {\n    if (!(this.insuranceLimiter instanceof RateLimiterAbstract)) {\n      reject(err);\n    } else {\n      this.insuranceLimiter[funcName](key, data, options)\n        .then((res) => {\n          resolve(res);\n        })\n        .catch((res) => {\n          reject(res);\n        });\n    }\n  }\n\n  getInMemoryBlockMsBeforeExpire(rlKey) {\n    if (this.inMemoryBlockOnConsumed > 0) {\n      return this._inMemoryBlockedKeys.msBeforeExpire(rlKey);\n    }\n\n    return 0;\n  }\n\n  get inMemoryBlockOnConsumed() {\n    return this._inMemoryBlockOnConsumed;\n  }\n\n  set inMemoryBlockOnConsumed(value) {\n    this._inMemoryBlockOnConsumed = value ? parseInt(value) : 0;\n    if (this.inMemoryBlockOnConsumed > 0 && this.points > this.inMemoryBlockOnConsumed) {\n      throw new Error('inMemoryBlockOnConsumed option must be greater or equal \"points\" option');\n    }\n  }\n\n  get inMemoryBlockDuration() {\n    return this._inMemoryBlockDuration;\n  }\n\n  set inMemoryBlockDuration(value) {\n    this._inMemoryBlockDuration = value ? parseInt(value) : 0;\n    if (this.inMemoryBlockDuration > 0 && this.inMemoryBlockOnConsumed === 0) {\n      throw new Error('inMemoryBlockOnConsumed option must be set up');\n    }\n  }\n\n  get msInMemoryBlockDuration() {\n    return this._inMemoryBlockDuration * 1000;\n  }\n\n  get insuranceLimiter() {\n    return this._insuranceLimiter;\n  }\n\n  set insuranceLimiter(value) {\n    if (typeof value !== 'undefined' && !(value instanceof RateLimiterAbstract)) {\n      throw new Error('insuranceLimiter must be instance of RateLimiterAbstract');\n    }\n    this._insuranceLimiter = value;\n    if (this._insuranceLimiter) {\n      this._insuranceLimiter.blockDuration = this.blockDuration;\n      this._insuranceLimiter.execEvenly = this.execEvenly;\n    }\n  }\n\n  /**\n   * Block any key for secDuration seconds\n   *\n   * @param key\n   * @param secDuration\n   * @param {Object} options\n   *\n   * @return Promise<RateLimiterRes>\n   */\n  block(key, secDuration, options = {}) {\n    const msDuration = secDuration * 1000;\n    return this._block(this.getKey(key), this.points + 1, msDuration, options);\n  }\n\n  /**\n   * Set points by key for any duration\n   *\n   * @param key\n   * @param points\n   * @param secDuration\n   * @param {Object} options\n   *\n   * @return Promise<RateLimiterRes>\n   */\n  set(key, points, secDuration, options = {}) {\n    const msDuration = (secDuration >= 0 ? secDuration : this.duration) * 1000;\n    return this._block(this.getKey(key), points, msDuration, options);\n  }\n\n  /**\n   *\n   * @param key\n   * @param pointsToConsume\n   * @param {Object} options\n   * @returns Promise<RateLimiterRes>\n   */\n  consume(key, pointsToConsume = 1, options = {}) {\n    return new Promise((resolve, reject) => {\n      const rlKey = this.getKey(key);\n\n      const inMemoryBlockMsBeforeExpire = this.getInMemoryBlockMsBeforeExpire(rlKey);\n      if (inMemoryBlockMsBeforeExpire > 0) {\n        return reject(new RateLimiterRes(0, inMemoryBlockMsBeforeExpire));\n      }\n\n      this._upsert(rlKey, pointsToConsume, this._getKeySecDuration(options) * 1000, false, options)\n        .then((res) => {\n          this._afterConsume(resolve, reject, rlKey, pointsToConsume, res);\n        })\n        .catch((err) => {\n          this._handleError(err, 'consume', resolve, reject, key, pointsToConsume, options);\n        });\n    });\n  }\n\n  /**\n   *\n   * @param key\n   * @param points\n   * @param {Object} options\n   * @returns Promise<RateLimiterRes>\n   */\n  penalty(key, points = 1, options = {}) {\n    const rlKey = this.getKey(key);\n    return new Promise((resolve, reject) => {\n      this._upsert(rlKey, points, this._getKeySecDuration(options) * 1000, false, options)\n        .then((res) => {\n          resolve(this._getRateLimiterRes(rlKey, points, res));\n        })\n        .catch((err) => {\n          this._handleError(err, 'penalty', resolve, reject, key, points, options);\n        });\n    });\n  }\n\n  /**\n   *\n   * @param key\n   * @param points\n   * @param {Object} options\n   * @returns Promise<RateLimiterRes>\n   */\n  reward(key, points = 1, options = {}) {\n    const rlKey = this.getKey(key);\n    return new Promise((resolve, reject) => {\n      this._upsert(rlKey, -points, this._getKeySecDuration(options) * 1000, false, options)\n        .then((res) => {\n          resolve(this._getRateLimiterRes(rlKey, -points, res));\n        })\n        .catch((err) => {\n          this._handleError(err, 'reward', resolve, reject, key, points, options);\n        });\n    });\n  }\n\n  /**\n   *\n   * @param key\n   * @param {Object} options\n   * @returns Promise<RateLimiterRes>|null\n   */\n  get(key, options = {}) {\n    const rlKey = this.getKey(key);\n    return new Promise((resolve, reject) => {\n      this._get(rlKey, options)\n        .then((res) => {\n          if (res === null || typeof res === 'undefined') {\n            resolve(null);\n          } else {\n            resolve(this._getRateLimiterRes(rlKey, 0, res));\n          }\n        })\n        .catch((err) => {\n          this._handleError(err, 'get', resolve, reject, key, options);\n        });\n    });\n  }\n\n  /**\n   *\n   * @param key\n   * @param {Object} options\n   * @returns Promise<boolean>\n   */\n  delete(key, options = {}) {\n    const rlKey = this.getKey(key);\n    return new Promise((resolve, reject) => {\n      this._delete(rlKey, options)\n        .then((res) => {\n          this._inMemoryBlockedKeys.delete(rlKey);\n          resolve(res);\n        })\n        .catch((err) => {\n          this._handleError(err, 'delete', resolve, reject, key, options);\n        });\n    });\n  }\n\n  /**\n   * Cleanup keys no-matter expired or not.\n   */\n  deleteInMemoryBlockedAll() {\n    this._inMemoryBlockedKeys.delete();\n  }\n\n  /**\n   * Get RateLimiterRes object filled depending on storeResult, which specific for exact store\n   *\n   * @param rlKey\n   * @param changedPoints\n   * @param storeResult\n   * @private\n   */\n  _getRateLimiterRes(rlKey, changedPoints, storeResult) { // eslint-disable-line no-unused-vars\n    throw new Error(\"You have to implement the method '_getRateLimiterRes'!\");\n  }\n\n  /**\n   * Block key for this.msBlockDuration milliseconds\n   * Usually, it just prolongs lifetime of key\n   *\n   * @param rlKey\n   * @param initPoints\n   * @param msDuration\n   * @param {Object} options\n   *\n   * @return Promise<any>\n   */\n  _block(rlKey, initPoints, msDuration, options = {}) {\n    return new Promise((resolve, reject) => {\n      this._upsert(rlKey, initPoints, msDuration, true, options)\n        .then(() => {\n          resolve(new RateLimiterRes(0, msDuration > 0 ? msDuration : -1, initPoints));\n        })\n        .catch((err) => {\n          this._handleError(err, 'block', resolve, reject, this.parseKey(rlKey), msDuration / 1000, options);\n        });\n    });\n  }\n\n  /**\n   * Have to be implemented in every limiter\n   * Resolve with raw result from Store OR null if rlKey is not set\n   * or Reject with error\n   *\n   * @param rlKey\n   * @param {Object} options\n   * @private\n   *\n   * @return Promise<any>\n   */\n  _get(rlKey, options = {}) { // eslint-disable-line no-unused-vars\n    throw new Error(\"You have to implement the method '_get'!\");\n  }\n\n  /**\n   * Have to be implemented\n   * Resolve with true OR false if rlKey doesn't exist\n   * or Reject with error\n   *\n   * @param rlKey\n   * @param {Object} options\n   * @private\n   *\n   * @return Promise<any>\n   */\n  _delete(rlKey, options = {}) { // eslint-disable-line no-unused-vars\n    throw new Error(\"You have to implement the method '_delete'!\");\n  }\n\n  /**\n   * Have to be implemented\n   * Resolve with object used for {@link _getRateLimiterRes} to generate {@link RateLimiterRes}\n   *\n   * @param {string} rlKey\n   * @param {number} points\n   * @param {number} msDuration\n   * @param {boolean} forceExpire\n   * @param {Object} options\n   * @abstract\n   *\n   * @return Promise<Object>\n   */\n  _upsert(rlKey, points, msDuration, forceExpire = false, options = {}) {\n    throw new Error(\"You have to implement the method '_upsert'!\");\n  }\n};\n", "const RateLimiterStoreAbstract = require('./RateLimiterStoreAbstract');\nconst RateLimiterRes = require('./RateLimiterRes');\n\nconst incrTtlLuaScript = `redis.call('set', KEYS[1], 0, 'EX', ARGV[2], 'NX') \\\nlocal consumed = redis.call('incrby', KEYS[1], ARGV[1]) \\\nlocal ttl = redis.call('pttl', KEYS[1]) \\\nif ttl == -1 then \\\n  redis.call('expire', KEYS[1], ARGV[2]) \\\n  ttl = 1000 * ARGV[2] \\\nend \\\nreturn {consumed, ttl} \\\n`;\n\nclass RateLimiterRedis extends RateLimiterStoreAbstract {\n  /**\n   *\n   * @param {Object} opts\n   * Defaults {\n   *   ... see other in RateLimiterStoreAbstract\n   *\n   *   redis: RedisClient\n   *   rejectIfRedisNotReady: boolean = false - reject / invoke insuranceLimiter immediately when redis connection is not \"ready\"\n   * }\n   */\n  constructor(opts) {\n    super(opts);\n    this.client = opts.storeClient;\n\n    this._rejectIfRedisNotReady = !!opts.rejectIfRedisNotReady;\n\n    this.useRedisPackage = opts.useRedisPackage || this.client.constructor.name === 'Commander' || false;\n    this.useRedis3AndLowerPackage = opts.useRedis3AndLowerPackage;\n    if (typeof this.client.defineCommand === 'function') {\n      this.client.defineCommand(\"rlflxIncr\", {\n        numberOfKeys: 1,\n        lua: incrTtlLuaScript,\n      });\n    }\n  }\n\n  /**\n   * Prevent actual redis call if redis connection is not ready\n   * Because of different connection state checks for ioredis and node-redis, only this clients would be actually checked.\n   * For any other clients all the requests would be passed directly to redis client\n   * @return {boolean}\n   * @private\n   */\n  _isRedisReady() {\n    if (!this._rejectIfRedisNotReady) {\n      return true;\n    }\n    // ioredis client\n    if (this.client.status && this.client.status !== 'ready') {\n      return false;\n    }\n    // node-redis client\n    if (typeof this.client.isReady === 'function' && !this.client.isReady()) {\n      return false;\n    }\n    return true;\n  }\n\n  _getRateLimiterRes(rlKey, changedPoints, result) {\n    let [consumed, resTtlMs] = result;\n    // Support ioredis results format\n    if (Array.isArray(consumed)) {\n      [, consumed] = consumed;\n      [, resTtlMs] = resTtlMs;\n    }\n\n    const res = new RateLimiterRes();\n    res.consumedPoints = parseInt(consumed);\n    res.isFirstInDuration = res.consumedPoints === changedPoints;\n    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n    res.msBeforeNext = resTtlMs;\n\n    return res;\n  }\n\n  async _upsert(rlKey, points, msDuration, forceExpire = false) {\n    if (!this._isRedisReady()) {\n      throw new Error('Redis connection is not ready');\n    }\n\n    const secDuration = Math.floor(msDuration / 1000);\n    const multi = this.client.multi();\n\n    if (forceExpire) {\n      if (secDuration > 0) {\n        if(!this.useRedisPackage && !this.useRedis3AndLowerPackage){\n          multi.set(rlKey, points, \"EX\", secDuration);\n        }else{\n          multi.set(rlKey, points, { EX: secDuration });\n        }\n      } else {\n        multi.set(rlKey, points);\n      }\n\n      if(!this.useRedisPackage && !this.useRedis3AndLowerPackage){\n        return multi.pttl(rlKey).exec(true);\n      }\n      return multi.pTTL(rlKey).exec(true);\n    }\n\n    if (secDuration > 0) {\n      if(!this.useRedisPackage && !this.useRedis3AndLowerPackage){\n        return this.client.rlflxIncr(\n          [rlKey].concat([String(points), String(secDuration)]));\n      }\n      if (this.useRedis3AndLowerPackage) {\n        return new Promise((resolve, reject) => {\n          const incrCallback = function (err, result) {\n            if (err) {\n              return reject(err);\n            }\n\n            return resolve(result);\n          };\n\n          if (typeof this.client.rlflxIncr === 'function') {\n            this.client.rlflxIncr(rlKey, points, secDuration, incrCallback);\n          } else {\n            this.client.eval(incrTtlLuaScript, 1, rlKey, points, secDuration, incrCallback);\n          }\n        });\n      } else {\n        return this.client.eval(incrTtlLuaScript, {\n          keys: [rlKey],\n          arguments: [String(points), String(secDuration)],\n        });\n      }\n    } else {\n      if(!this.useRedisPackage && !this.useRedis3AndLowerPackage){\n        return multi.incrby(rlKey, points).pttl(rlKey).exec(true);\n      }\n\n      return multi.incrBy(rlKey, points).pTTL(rlKey).exec(true);\n    }\n  }\n\n  async _get(rlKey) {\n    if (!this._isRedisReady()) {\n      throw new Error('Redis connection is not ready');\n    }\n    if(!this.useRedisPackage && !this.useRedis3AndLowerPackage){\n      return this.client\n        .multi()\n        .get(rlKey)\n        .pttl(rlKey)\n        .exec()\n        .then((result) => {\n          const [[,points]] = result;\n          if (points === null) return null;\n          return result;\n        });\n    }\n\n    return this.client\n      .multi()\n      .get(rlKey)\n      .pTTL(rlKey)\n      .exec(true)\n      .then((result) => {\n        const [points] = result;\n        if (points === null) return null;\n        return result;\n      });\n  }\n\n  _delete(rlKey) {\n    return this.client\n      .del(rlKey)\n      .then(result => result > 0);\n  }\n}\n\nmodule.exports = RateLimiterRedis;\n", "const RateLimiterStoreAbstract = require('./RateLimiterStoreAbstract');\nconst RateLimiterRes = require('./RateLimiterRes');\n\n/**\n * Get MongoDB driver version as upsert options differ\n * @params {Object} Client instance\n * @returns {Object} Version Object containing major, feature & minor versions.\n */\nfunction getDriverVersion(client) {\n  try {\n    const _client = client.client ? client.client : client;\n\n    const { version } = _client.topology.s.options.metadata.driver;\n    const _v = version.split('.').map(v => parseInt(v));\n\n    return {\n      major: _v[0],\n      feature: _v[1],\n      patch: _v[2],\n    };\n  } catch (err) {\n    return { major: 0, feature: 0, patch: 0 };\n  }\n}\n\nclass RateLimiterMongo extends RateLimiterStoreAbstract {\n  /**\n   *\n   * @param {Object} opts\n   * Defaults {\n   *   indexKeyPrefix: {attr1: 1, attr2: 1}\n   *   ... see other in RateLimiterStoreAbstract\n   *\n   *   mongo: MongoClient\n   * }\n   */\n  constructor(opts) {\n    super(opts);\n\n    this.dbName = opts.dbName;\n    this.tableName = opts.tableName;\n    this.indexKeyPrefix = opts.indexKeyPrefix;\n\n    if (opts.mongo) {\n      this.client = opts.mongo;\n    } else {\n      this.client = opts.storeClient;\n    }\n    if (typeof this.client.then === 'function') {\n      // If Promise\n      this.client\n        .then((conn) => {\n          this.client = conn;\n          this._initCollection();\n          this._driverVersion = getDriverVersion(this.client);\n        });\n    } else {\n      this._initCollection();\n      this._driverVersion = getDriverVersion(this.client);\n    }\n  }\n\n  get dbName() {\n    return this._dbName;\n  }\n\n  set dbName(value) {\n    this._dbName = typeof value === 'undefined' ? RateLimiterMongo.getDbName() : value;\n  }\n\n  static getDbName() {\n    return 'node-rate-limiter-flexible';\n  }\n\n  get tableName() {\n    return this._tableName;\n  }\n\n  set tableName(value) {\n    this._tableName = typeof value === 'undefined' ? this.keyPrefix : value;\n  }\n\n  get client() {\n    return this._client;\n  }\n\n  set client(value) {\n    if (typeof value === 'undefined') {\n      throw new Error('mongo is not set');\n    }\n    this._client = value;\n  }\n\n  get indexKeyPrefix() {\n    return this._indexKeyPrefix;\n  }\n\n  set indexKeyPrefix(obj) {\n    this._indexKeyPrefix = obj || {};\n  }\n\n  _initCollection() {\n    const db = typeof this.client.db === 'function'\n      ? this.client.db(this.dbName)\n      : this.client;\n\n    const collection = db.collection(this.tableName);\n    collection.createIndex({ expire: -1 }, { expireAfterSeconds: 0 });\n    collection.createIndex(Object.assign({}, this.indexKeyPrefix, { key: 1 }), { unique: true });\n\n    this._collection = collection;\n  }\n\n  _getRateLimiterRes(rlKey, changedPoints, result) {\n    const res = new RateLimiterRes();\n\n    let doc;\n    if (typeof result.value === 'undefined') {\n      doc = result;\n    } else {\n      doc = result.value;\n    }\n\n    res.isFirstInDuration = doc.points === changedPoints;\n    res.consumedPoints = doc.points;\n\n    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n    res.msBeforeNext = doc.expire !== null\n      ? Math.max(new Date(doc.expire).getTime() - Date.now(), 0)\n      : -1;\n\n    return res;\n  }\n\n  _upsert(key, points, msDuration, forceExpire = false, options = {}) {\n    if (!this._collection) {\n      return Promise.reject(Error('Mongo connection is not established'));\n    }\n\n    const docAttrs = options.attrs || {};\n\n    let where;\n    let upsertData;\n    if (forceExpire) {\n      where = { key };\n      where = Object.assign(where, docAttrs);\n      upsertData = {\n        $set: {\n          key,\n          points,\n          expire: msDuration > 0 ? new Date(Date.now() + msDuration) : null,\n        },\n      };\n      upsertData.$set = Object.assign(upsertData.$set, docAttrs);\n    } else {\n      where = {\n        $or: [\n          { expire: { $gt: new Date() } },\n          { expire: { $eq: null } },\n        ],\n        key,\n      };\n      where = Object.assign(where, docAttrs);\n      upsertData = {\n        $setOnInsert: {\n          key,\n          expire: msDuration > 0 ? new Date(Date.now() + msDuration) : null,\n        },\n        $inc: { points },\n      };\n      upsertData.$setOnInsert = Object.assign(upsertData.$setOnInsert, docAttrs);\n    }\n\n    // Options for collection updates differ between driver versions\n    const upsertOptions = {\n      upsert: true,\n    };\n    if ((this._driverVersion.major >= 4) ||\n        (this._driverVersion.major === 3 &&\n          (this._driverVersion.feature >=7) || \n          (this._driverVersion.feature >= 6 && \n              this._driverVersion.patch >= 7 ))) \n    {\n      upsertOptions.returnDocument = 'after';\n    } else {\n      upsertOptions.returnOriginal = false;\n    }\n\n    /*\n     * 1. Find actual limit and increment points\n     * 2. If limit expired, but Mongo doesn't clean doc by TTL yet, try to replace limit doc completely\n     * 3. If 2 or more Mongo threads try to insert the new limit doc, only the first succeed\n     * 4. Try to upsert from step 1. Actual limit is created now, points are incremented without problems\n     */\n    return new Promise((resolve, reject) => {\n      this._collection.findOneAndUpdate(\n        where,\n        upsertData,\n        upsertOptions\n      ).then((res) => {\n        resolve(res);\n      }).catch((errUpsert) => {\n        if (errUpsert && errUpsert.code === 11000) { // E11000 duplicate key error collection\n          const replaceWhere = Object.assign({ // try to replace OLD limit doc\n            $or: [\n              { expire: { $lte: new Date() } },\n              { expire: { $eq: null } },\n            ],\n            key,\n          }, docAttrs);\n\n          const replaceTo = {\n            $set: Object.assign({\n              key,\n              points,\n              expire: msDuration > 0 ? new Date(Date.now() + msDuration) : null,\n            }, docAttrs)\n          };\n\n          this._collection.findOneAndUpdate(\n            replaceWhere,\n            replaceTo,\n            upsertOptions\n          ).then((res) => {\n            resolve(res);\n          }).catch((errReplace) => {\n            if (errReplace && errReplace.code === 11000) { // E11000 duplicate key error collection\n              this._upsert(key, points, msDuration, forceExpire)\n                .then(res => resolve(res))\n                .catch(err => reject(err));\n            } else {\n              reject(errReplace);\n            }\n          });\n        } else {\n          reject(errUpsert);\n        }\n      });\n    });\n  }\n\n  _get(rlKey, options = {}) {\n    if (!this._collection) {\n      return Promise.reject(Error('Mongo connection is not established'));\n    }\n\n    const docAttrs = options.attrs || {};\n\n    const where = Object.assign({\n      key: rlKey,\n      $or: [\n        { expire: { $gt: new Date() } },\n        { expire: { $eq: null } },\n      ],\n    }, docAttrs);\n\n    return this._collection.findOne(where);\n  }\n\n  _delete(rlKey, options = {}) {\n    if (!this._collection) {\n      return Promise.reject(Error('Mongo connection is not established'));\n    }\n\n    const docAttrs = options.attrs || {};\n    const where = Object.assign({ key: rlKey }, docAttrs);\n\n    return this._collection.deleteOne(where)\n      .then(res => res.deletedCount > 0);\n  }\n}\n\nmodule.exports = RateLimiterMongo;\n", "const RateLimiterStoreAbstract = require('./RateLimiterStoreAbstract');\nconst RateLimiterRes = require('./RateLimiterRes');\n\nclass RateLimiterMySQL extends RateLimiterStoreAbstract {\n  /**\n   * @callback callback\n   * @param {Object} err\n   *\n   * @param {Object} opts\n   * @param {callback} cb\n   * Defaults {\n   *   ... see other in RateLimiterStoreAbstract\n   *\n   *   storeClient: anySqlClient,\n   *   storeType: 'knex', // required only for Knex instance\n   *   dbName: 'string',\n   *   tableName: 'string',\n   * }\n   */\n  constructor(opts, cb = null) {\n    super(opts);\n\n    this.client = opts.storeClient;\n    this.clientType = opts.storeType;\n\n    this.dbName = opts.dbName;\n    this.tableName = opts.tableName;\n\n    this.clearExpiredByTimeout = opts.clearExpiredByTimeout;\n\n    this.tableCreated = opts.tableCreated;\n    if (!this.tableCreated) {\n      this._createDbAndTable()\n        .then(() => {\n          this.tableCreated = true;\n          if (this.clearExpiredByTimeout) {\n            this._clearExpiredHourAgo();\n          }\n          if (typeof cb === 'function') {\n            cb();\n          }\n        })\n        .catch((err) => {\n          if (typeof cb === 'function') {\n            cb(err);\n          } else {\n            throw err;\n          }\n        });\n    } else {\n      if (this.clearExpiredByTimeout) {\n        this._clearExpiredHourAgo();\n      }\n      if (typeof cb === 'function') {\n        cb();\n      }\n    }\n  }\n\n  clearExpired(expire) {\n    return new Promise((resolve) => {\n      this._getConnection()\n        .then((conn) => {\n          conn.query(`DELETE FROM ??.?? WHERE expire < ?`, [this.dbName, this.tableName, expire], () => {\n            this._releaseConnection(conn);\n            resolve();\n          });\n        })\n        .catch(() => {\n          resolve();\n        });\n    });\n  }\n\n  _clearExpiredHourAgo() {\n    if (this._clearExpiredTimeoutId) {\n      clearTimeout(this._clearExpiredTimeoutId);\n    }\n    this._clearExpiredTimeoutId = setTimeout(() => {\n      this.clearExpired(Date.now() - 3600000) // Never rejected\n        .then(() => {\n          this._clearExpiredHourAgo();\n        });\n    }, 300000);\n    this._clearExpiredTimeoutId.unref();\n  }\n\n  /**\n   *\n   * @return Promise<any>\n   * @private\n   */\n  _getConnection() {\n    switch (this.clientType) {\n      case 'pool':\n        return new Promise((resolve, reject) => {\n          this.client.getConnection((errConn, conn) => {\n            if (errConn) {\n              return reject(errConn);\n            }\n\n            resolve(conn);\n          });\n        });\n      case 'sequelize':\n        return this.client.connectionManager.getConnection();\n      case 'knex':\n        return this.client.client.acquireConnection();\n      default:\n        return Promise.resolve(this.client);\n    }\n  }\n\n  _releaseConnection(conn) {\n    switch (this.clientType) {\n      case 'pool':\n        return conn.release();\n      case 'sequelize':\n        return this.client.connectionManager.releaseConnection(conn);\n      case 'knex':\n        return this.client.client.releaseConnection(conn);\n      default:\n        return true;\n    }\n  }\n\n  /**\n   *\n   * @returns {Promise<any>}\n   * @private\n   */\n  _createDbAndTable() {\n    return new Promise((resolve, reject) => {\n      this._getConnection()\n        .then((conn) => {\n          conn.query(`CREATE DATABASE IF NOT EXISTS \\`${this.dbName}\\`;`, (errDb) => {\n            if (errDb) {\n              this._releaseConnection(conn);\n              return reject(errDb);\n            }\n            conn.query(this._getCreateTableStmt(), (err) => {\n              if (err) {\n                this._releaseConnection(conn);\n                return reject(err);\n              }\n              this._releaseConnection(conn);\n              resolve();\n            });\n          });\n        })\n        .catch((err) => {\n          reject(err);\n        });\n    });\n  }\n\n  _getCreateTableStmt() {\n    return `CREATE TABLE IF NOT EXISTS \\`${this.dbName}\\`.\\`${this.tableName}\\` (` +\n      '`key` VARCHAR(255) CHARACTER SET utf8 NOT NULL,' +\n      '`points` INT(9) NOT NULL default 0,' +\n      '`expire` BIGINT UNSIGNED,' +\n      'PRIMARY KEY (`key`)' +\n      ') ENGINE = INNODB;';\n  }\n\n  get clientType() {\n    return this._clientType;\n  }\n\n  set clientType(value) {\n    if (typeof value === 'undefined') {\n      if (this.client.constructor.name === 'Connection') {\n        value = 'connection';\n      } else if (this.client.constructor.name === 'Pool') {\n        value = 'pool';\n      } else if (this.client.constructor.name === 'Sequelize') {\n        value = 'sequelize';\n      } else {\n        throw new Error('storeType is not defined');\n      }\n    }\n    this._clientType = value.toLowerCase();\n  }\n\n  get dbName() {\n    return this._dbName;\n  }\n\n  set dbName(value) {\n    this._dbName = typeof value === 'undefined' ? 'rtlmtrflx' : value;\n  }\n\n  get tableName() {\n    return this._tableName;\n  }\n\n  set tableName(value) {\n    this._tableName = typeof value === 'undefined' ? this.keyPrefix : value;\n  }\n\n  get tableCreated() {\n    return this._tableCreated\n  }\n\n  set tableCreated(value) {\n    this._tableCreated = typeof value === 'undefined' ? false : !!value;\n  }\n\n  get clearExpiredByTimeout() {\n    return this._clearExpiredByTimeout;\n  }\n\n  set clearExpiredByTimeout(value) {\n    this._clearExpiredByTimeout = typeof value === 'undefined' ? true : Boolean(value);\n  }\n\n  _getRateLimiterRes(rlKey, changedPoints, result) {\n    const res = new RateLimiterRes();\n    const [row] = result;\n\n    res.isFirstInDuration = changedPoints === row.points;\n    res.consumedPoints = res.isFirstInDuration ? changedPoints : row.points;\n\n    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n    res.msBeforeNext = row.expire\n      ? Math.max(row.expire - Date.now(), 0)\n      : -1;\n\n    return res;\n  }\n\n  _upsertTransaction(conn, key, points, msDuration, forceExpire) {\n    return new Promise((resolve, reject) => {\n      conn.query('BEGIN', (errBegin) => {\n        if (errBegin) {\n          conn.rollback();\n\n          return reject(errBegin);\n        }\n\n        const dateNow = Date.now();\n        const newExpire = msDuration > 0 ? dateNow + msDuration : null;\n\n        let q;\n        let values;\n        if (forceExpire) {\n          q = `INSERT INTO ??.?? VALUES (?, ?, ?)\n          ON DUPLICATE KEY UPDATE \n            points = ?, \n            expire = ?;`;\n          values = [\n            this.dbName, this.tableName, key, points, newExpire,\n            points,\n            newExpire,\n          ];\n        } else {\n          q = `INSERT INTO ??.?? VALUES (?, ?, ?)\n          ON DUPLICATE KEY UPDATE \n            points = IF(expire <= ?, ?, points + (?)), \n            expire = IF(expire <= ?, ?, expire);`;\n          values = [\n            this.dbName, this.tableName, key, points, newExpire,\n            dateNow, points, points,\n            dateNow, newExpire,\n          ];\n        }\n\n        conn.query(q, values, (errUpsert) => {\n          if (errUpsert) {\n            conn.rollback();\n\n            return reject(errUpsert);\n          }\n          conn.query('SELECT points, expire FROM ??.?? WHERE `key` = ?;', [this.dbName, this.tableName, key], (errSelect, res) => {\n            if (errSelect) {\n              conn.rollback();\n\n              return reject(errSelect);\n            }\n\n            conn.query('COMMIT', (err) => {\n              if (err) {\n                conn.rollback();\n\n                return reject(err);\n              }\n\n              resolve(res);\n            });\n          });\n        });\n      });\n    });\n  }\n\n  _upsert(key, points, msDuration, forceExpire = false) {\n    if (!this.tableCreated) {\n      return Promise.reject(Error('Table is not created yet'));\n    }\n\n    return new Promise((resolve, reject) => {\n      this._getConnection()\n        .then((conn) => {\n          this._upsertTransaction(conn, key, points, msDuration, forceExpire)\n            .then((res) => {\n              resolve(res);\n              this._releaseConnection(conn);\n            })\n            .catch((err) => {\n              reject(err);\n              this._releaseConnection(conn);\n            });\n        })\n        .catch((err) => {\n          reject(err);\n        });\n    });\n  }\n\n  _get(rlKey) {\n    if (!this.tableCreated) {\n      return Promise.reject(Error('Table is not created yet'));\n    }\n\n    return new Promise((resolve, reject) => {\n      this._getConnection()\n        .then((conn) => {\n          conn.query(\n            'SELECT points, expire FROM ??.?? WHERE `key` = ? AND (`expire` > ? OR `expire` IS NULL)',\n            [this.dbName, this.tableName, rlKey, Date.now()],\n            (err, res) => {\n              if (err) {\n                reject(err);\n              } else if (res.length === 0) {\n                resolve(null);\n              } else {\n                resolve(res);\n              }\n\n              this._releaseConnection(conn);\n            } // eslint-disable-line\n          );\n        })\n        .catch((err) => {\n          reject(err);\n        });\n    });\n  }\n\n  _delete(rlKey) {\n    if (!this.tableCreated) {\n      return Promise.reject(Error('Table is not created yet'));\n    }\n\n    return new Promise((resolve, reject) => {\n      this._getConnection()\n        .then((conn) => {\n          conn.query(\n            'DELETE FROM ??.?? WHERE `key` = ?',\n            [this.dbName, this.tableName, rlKey],\n            (err, res) => {\n              if (err) {\n                reject(err);\n              } else {\n                resolve(res.affectedRows > 0);\n              }\n\n              this._releaseConnection(conn);\n            } // eslint-disable-line\n          );\n        })\n        .catch((err) => {\n          reject(err);\n        });\n    });\n  }\n}\n\nmodule.exports = RateLimiterMySQL;\n", "const RateLimiterStoreAbstract = require('./RateLimiterStoreAbstract');\nconst RateLimiterRes = require('./RateLimiterRes');\n\nclass RateLimiterPostgres extends RateLimiterStoreAbstract {\n  /**\n   * @callback callback\n   * @param {Object} err\n   *\n   * @param {Object} opts\n   * @param {callback} cb\n   * Defaults {\n   *   ... see other in RateLimiterStoreAbstract\n   *\n   *   storeClient: postgresClient,\n   *   storeType: 'knex', // required only for Knex instance\n   *   tableName: 'string',\n   *   schemaName: 'string', // optional\n   * }\n   */\n  constructor(opts, cb = null) {\n    super(opts);\n\n    this.client = opts.storeClient;\n    this.clientType = opts.storeType;\n\n    this.tableName = opts.tableName;\n    this.schemaName = opts.schemaName;\n\n    this.clearExpiredByTimeout = opts.clearExpiredByTimeout;\n\n    this.tableCreated = opts.tableCreated;\n    if (!this.tableCreated) {\n      this._createTable()\n        .then(() => {\n          this.tableCreated = true;\n          if (this.clearExpiredByTimeout) {\n            this._clearExpiredHourAgo();\n          }\n          if (typeof cb === 'function') {\n            cb();\n          }\n        })\n        .catch((err) => {\n          if (typeof cb === 'function') {\n            cb(err);\n          } else {\n            throw err;\n          }\n        });\n    } else {\n      if (this.clearExpiredByTimeout) {\n        this._clearExpiredHourAgo();\n      }\n      if (typeof cb === 'function') {\n        cb();\n      }\n    }\n  }\n\n  _getTableIdentifier() {\n    return this.schemaName ? `\"${this.schemaName}\".\"${this.tableName}\"` : `\"${this.tableName}\"`;\n  }\n\n  clearExpired(expire) {\n    return new Promise((resolve) => {\n      const q = {\n        name: 'rlflx-clear-expired',\n        text: `DELETE FROM ${this._getTableIdentifier()} WHERE expire < $1`,\n        values: [expire],\n      };\n      this._query(q)\n        .then(() => {\n          resolve();\n        })\n        .catch(() => {\n          // Deleting expired query is not critical\n          resolve();\n        });\n    });\n  }\n\n  /**\n   * Delete all rows expired 1 hour ago once per 5 minutes\n   *\n   * @private\n   */\n  _clearExpiredHourAgo() {\n    if (this._clearExpiredTimeoutId) {\n      clearTimeout(this._clearExpiredTimeoutId);\n    }\n    this._clearExpiredTimeoutId = setTimeout(() => {\n      this.clearExpired(Date.now() - 3600000) // Never rejected\n        .then(() => {\n          this._clearExpiredHourAgo();\n        });\n    }, 300000);\n    this._clearExpiredTimeoutId.unref();\n  }\n\n  /**\n   *\n   * @return Promise<any>\n   * @private\n   */\n  _getConnection() {\n    switch (this.clientType) {\n      case 'pool':\n        return Promise.resolve(this.client);\n      case 'sequelize':\n        return this.client.connectionManager.getConnection();\n      case 'knex':\n        return this.client.client.acquireConnection();\n      case 'typeorm':\n        return Promise.resolve(this.client.driver.master);\n      default:\n        return Promise.resolve(this.client);\n    }\n  }\n\n  _releaseConnection(conn) {\n    switch (this.clientType) {\n      case 'pool':\n        return true;\n      case 'sequelize':\n        return this.client.connectionManager.releaseConnection(conn);\n      case 'knex':\n        return this.client.client.releaseConnection(conn);\n      case 'typeorm':\n        return true;\n      default:\n        return true;\n    }\n  }\n\n  /**\n   *\n   * @returns {Promise<any>}\n   * @private\n   */\n  _createTable() {\n    return new Promise((resolve, reject) => {\n      this._query({\n        text: this._getCreateTableStmt(),\n      })\n        .then(() => {\n          resolve();\n        })\n        .catch((err) => {\n          if (err.code === '23505') {\n            // Error: duplicate key value violates unique constraint \"pg_type_typname_nsp_index\"\n            // Postgres doesn't handle concurrent table creation\n            // It is supposed, that table is created by another worker\n            resolve();\n          } else {\n            reject(err);\n          }\n        });\n    });\n  }\n\n  _getCreateTableStmt() {\n    return `CREATE TABLE IF NOT EXISTS ${this._getTableIdentifier()} (\n      key varchar(255) PRIMARY KEY,\n      points integer NOT NULL DEFAULT 0,\n      expire bigint\n    );`;\n  }\n\n  get clientType() {\n    return this._clientType;\n  }\n\n  set clientType(value) {\n    const constructorName = this.client.constructor.name;\n\n    if (typeof value === 'undefined') {\n      if (constructorName === 'Client') {\n        value = 'client';\n      } else if (\n        constructorName === 'Pool' ||\n        constructorName === 'BoundPool'\n      ) {\n        value = 'pool';\n      } else if (constructorName === 'Sequelize') {\n        value = 'sequelize';\n      } else {\n        throw new Error('storeType is not defined');\n      }\n    }\n\n    this._clientType = value.toLowerCase();\n  }\n\n  get tableName() {\n    return this._tableName;\n  }\n\n  set tableName(value) {\n    this._tableName = typeof value === 'undefined' ? this.keyPrefix : value;\n  }\n\n  get schemaName() {\n    return this._schemaName;\n  }\n\n  set schemaName(value) {\n    this._schemaName = value;\n  }\n\n  get tableCreated() {\n    return this._tableCreated;\n  }\n\n  set tableCreated(value) {\n    this._tableCreated = typeof value === 'undefined' ? false : !!value;\n  }\n\n  get clearExpiredByTimeout() {\n    return this._clearExpiredByTimeout;\n  }\n\n  set clearExpiredByTimeout(value) {\n    this._clearExpiredByTimeout = typeof value === 'undefined' ? true : Boolean(value);\n  }\n\n  _getRateLimiterRes(rlKey, changedPoints, result) {\n    const res = new RateLimiterRes();\n    const row = result.rows[0];\n\n    res.isFirstInDuration = changedPoints === row.points;\n    res.consumedPoints = res.isFirstInDuration ? changedPoints : row.points;\n\n    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n    res.msBeforeNext = row.expire\n      ? Math.max(row.expire - Date.now(), 0)\n      : -1;\n\n    return res;\n  }\n\n  _query(q) {\n    const prefix = this.tableName.toLowerCase();\n    const queryObj = { name: `${prefix}:${q.name}`, text: q.text, values: q.values };\n    return new Promise((resolve, reject) => {\n      this._getConnection()\n        .then((conn) => {\n          conn.query(queryObj)\n            .then((res) => {\n              resolve(res);\n              this._releaseConnection(conn);\n            })\n            .catch((err) => {\n              reject(err);\n              this._releaseConnection(conn);\n            });\n        })\n        .catch((err) => {\n          reject(err);\n        });\n    });\n  }\n\n  _upsert(key, points, msDuration, forceExpire = false) {\n    if (!this.tableCreated) {\n      return Promise.reject(Error('Table is not created yet'));\n    }\n\n    const newExpire = msDuration > 0 ? Date.now() + msDuration : null;\n    const expireQ = forceExpire\n      ? ' $3 '\n      : ` CASE\n             WHEN ${this._getTableIdentifier()}.expire <= $4 THEN $3\n             ELSE ${this._getTableIdentifier()}.expire\n            END `;\n\n    return this._query({\n      name: forceExpire ? 'rlflx-upsert-force' : 'rlflx-upsert',\n      text: `\n            INSERT INTO ${this._getTableIdentifier()} VALUES ($1, $2, $3)\n              ON CONFLICT(key) DO UPDATE SET\n                points = CASE\n                          WHEN (${this._getTableIdentifier()}.expire <= $4 OR 1=${forceExpire ? 1 : 0}) THEN $2\n                          ELSE ${this._getTableIdentifier()}.points + ($2)\n                         END,\n                expire = ${expireQ}\n            RETURNING points, expire;`,\n      values: [key, points, newExpire, Date.now()],\n    });\n  }\n\n  _get(rlKey) {\n    if (!this.tableCreated) {\n      return Promise.reject(Error('Table is not created yet'));\n    }\n\n    return new Promise((resolve, reject) => {\n      this._query({\n        name: 'rlflx-get',\n        text: `\n            SELECT points, expire FROM ${this._getTableIdentifier()} WHERE key = $1 AND (expire > $2 OR expire IS NULL);`,\n        values: [rlKey, Date.now()],\n      })\n        .then((res) => {\n          if (res.rowCount === 0) {\n            res = null;\n          }\n          resolve(res);\n        })\n        .catch((err) => {\n          reject(err);\n        });\n    });\n  }\n\n  _delete(rlKey) {\n    if (!this.tableCreated) {\n      return Promise.reject(Error('Table is not created yet'));\n    }\n\n    return this._query({\n      name: 'rlflx-delete',\n      text: `DELETE FROM ${this._getTableIdentifier()} WHERE key = $1`,\n      values: [rlKey],\n    })\n      .then(res => res.rowCount > 0);\n  }\n}\n\nmodule.exports = RateLimiterPostgres;\n", "module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"cluster\" has been externalized for browser compatibility. Cannot access \"cluster.${key}\" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`)\n    }\n  }\n}))", "module.exports = class Record {\n  /**\n   *\n   * @param value int\n   * @param expiresAt Date|int\n   * @param timeoutId\n   */\n  constructor(value, expiresAt, timeoutId = null) {\n    this.value = value;\n    this.expiresAt = expiresAt;\n    this.timeoutId = timeoutId;\n  }\n\n  get value() {\n    return this._value;\n  }\n\n  set value(value) {\n    this._value = parseInt(value);\n  }\n\n  get expiresAt() {\n    return this._expiresAt;\n  }\n\n  set expiresAt(value) {\n    if (!(value instanceof Date) && Number.isInteger(value)) {\n      value = new Date(value);\n    }\n    this._expiresAt = value;\n  }\n\n  get timeoutId() {\n    return this._timeoutId;\n  }\n\n  set timeoutId(value) {\n    this._timeoutId = value;\n  }\n};\n", "const Record = require('./Record');\nconst RateLimiterRes = require('../../RateLimiterRes');\n\nmodule.exports = class MemoryStorage {\n  constructor() {\n    /**\n     * @type {Object.<string, Record>}\n     * @private\n     */\n    this._storage = {};\n  }\n\n  incrby(key, value, durationSec) {\n    if (this._storage[key]) {\n      const msBeforeExpires = this._storage[key].expiresAt\n        ? this._storage[key].expiresAt.getTime() - new Date().getTime()\n        : -1;\n      if (msBeforeExpires !== 0) {\n        // Change value\n        this._storage[key].value = this._storage[key].value + value;\n\n        return new RateLimiterRes(0, msBeforeExpires, this._storage[key].value, false);\n      }\n\n      return this.set(key, value, durationSec);\n    }\n    return this.set(key, value, durationSec);\n  }\n\n  set(key, value, durationSec) {\n    const durationMs = durationSec * 1000;\n\n    if (this._storage[key] && this._storage[key].timeoutId) {\n      clearTimeout(this._storage[key].timeoutId);\n    }\n\n    this._storage[key] = new Record(\n      value,\n      durationMs > 0 ? new Date(Date.now() + durationMs) : null\n    );\n    if (durationMs > 0) {\n      this._storage[key].timeoutId = setTimeout(() => {\n        delete this._storage[key];\n      }, durationMs);\n      if (this._storage[key].timeoutId.unref) {\n        this._storage[key].timeoutId.unref();\n      }\n    }\n\n    return new RateLimiterRes(0, durationMs === 0 ? -1 : durationMs, this._storage[key].value, true);\n  }\n\n  /**\n   *\n   * @param key\n   * @returns {*}\n   */\n  get(key) {\n    if (this._storage[key]) {\n      const msBeforeExpires = this._storage[key].expiresAt\n        ? this._storage[key].expiresAt.getTime() - new Date().getTime()\n        : -1;\n      return new RateLimiterRes(0, msBeforeExpires, this._storage[key].value, false);\n    }\n    return null;\n  }\n\n  /**\n   *\n   * @param key\n   * @returns {boolean}\n   */\n  delete(key) {\n    if (this._storage[key]) {\n      if (this._storage[key].timeoutId) {\n        clearTimeout(this._storage[key].timeoutId);\n      }\n      delete this._storage[key];\n      return true;\n    }\n    return false;\n  }\n};\n", "const RateLimiterAbstract = require('./RateLimiterAbstract');\nconst MemoryStorage = require('./component/MemoryStorage/MemoryStorage');\nconst RateLimiterRes = require('./RateLimiterRes');\n\nclass RateLimiterMemory extends RateLimiterAbstract {\n  constructor(opts = {}) {\n    super(opts);\n\n    this._memoryStorage = new MemoryStorage();\n  }\n  /**\n   *\n   * @param key\n   * @param pointsToConsume\n   * @param {Object} options\n   * @returns {Promise<RateLimiterRes>}\n   */\n  consume(key, pointsToConsume = 1, options = {}) {\n    return new Promise((resolve, reject) => {\n      const rlKey = this.getKey(key);\n      const secDuration = this._getKeySecDuration(options);\n      let res = this._memoryStorage.incrby(rlKey, pointsToConsume, secDuration);\n      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n\n      if (res.consumedPoints > this.points) {\n        // Block only first time when consumed more than points\n        if (this.blockDuration > 0 && res.consumedPoints <= (this.points + pointsToConsume)) {\n          // Block key\n          res = this._memoryStorage.set(rlKey, res.consumedPoints, this.blockDuration);\n        }\n        reject(res);\n      } else if (this.execEvenly && res.msBeforeNext > 0 && !res.isFirstInDuration) {\n        // Execute evenly\n        let delay = Math.ceil(res.msBeforeNext / (res.remainingPoints + 2));\n        if (delay < this.execEvenlyMinDelayMs) {\n          delay = res.consumedPoints * this.execEvenlyMinDelayMs;\n        }\n\n        setTimeout(resolve, delay, res);\n      } else {\n        resolve(res);\n      }\n    });\n  }\n\n  penalty(key, points = 1, options = {}) {\n    const rlKey = this.getKey(key);\n    return new Promise((resolve) => {\n      const secDuration = this._getKeySecDuration(options);\n      const res = this._memoryStorage.incrby(rlKey, points, secDuration);\n      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n      resolve(res);\n    });\n  }\n\n  reward(key, points = 1, options = {}) {\n    const rlKey = this.getKey(key);\n    return new Promise((resolve) => {\n      const secDuration = this._getKeySecDuration(options);\n      const res = this._memoryStorage.incrby(rlKey, -points, secDuration);\n      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n      resolve(res);\n    });\n  }\n\n  /**\n   * Block any key for secDuration seconds\n   *\n   * @param key\n   * @param secDuration\n   */\n  block(key, secDuration) {\n    const msDuration = secDuration * 1000;\n    const initPoints = this.points + 1;\n\n    this._memoryStorage.set(this.getKey(key), initPoints, secDuration);\n    return Promise.resolve(\n      new RateLimiterRes(0, msDuration === 0 ? -1 : msDuration, initPoints)\n    );\n  }\n\n  set(key, points, secDuration) {\n    const msDuration = (secDuration >= 0 ? secDuration : this.duration) * 1000;\n\n    this._memoryStorage.set(this.getKey(key), points, secDuration);\n    return Promise.resolve(\n      new RateLimiterRes(0, msDuration === 0 ? -1 : msDuration, points)\n    );\n  }\n\n  get(key) {\n    const res = this._memoryStorage.get(this.getKey(key));\n    if (res !== null) {\n      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n    }\n\n    return Promise.resolve(res);\n  }\n\n  delete(key) {\n    return Promise.resolve(this._memoryStorage.delete(this.getKey(key)));\n  }\n}\n\nmodule.exports = RateLimiterMemory;\n\n", "/**\n * Implements rate limiting in cluster using built-in IPC\n *\n * Two classes are described here: master and worker\n * Master have to be create in the master process without any options.\n * Any number of rate limiters can be created in workers, but each rate limiter must be with unique keyPrefix\n *\n * Workflow:\n * 1. master rate limiter created in master process\n * 2. worker rate limiter sends 'init' message with necessary options during creating\n * 3. master receives options and adds new rate limiter by keyPrefix if it isn't created yet\n * 4. master sends 'init' back to worker's rate limiter\n * 5. worker can process requests immediately,\n *    but they will be postponed by 'workerWaitInit' until master sends 'init' to worker\n * 6. every request to worker rate limiter creates a promise\n * 7. if master doesn't response for 'timeout', promise is rejected\n * 8. master sends 'resolve' or 'reject' command to worker\n * 9. worker resolves or rejects promise depending on message from master\n *\n */\n\nconst cluster = require('cluster');\nconst crypto = require('crypto');\nconst RateLimiterAbstract = require('./RateLimiterAbstract');\nconst RateLimiterMemory = require('./RateLimiterMemory');\nconst RateLimiterRes = require('./RateLimiterRes');\n\nconst channel = 'rate_limiter_flexible';\nlet masterInstance = null;\n\nconst masterSendToWorker = function (worker, msg, type, res) {\n  let data;\n  if (res === null || res === true || res === false) {\n    data = res;\n  } else {\n    data = {\n      remainingPoints: res.remainingPoints,\n      msBeforeNext: res.msBeforeNext,\n      consumedPoints: res.consumedPoints,\n      isFirstInDuration: res.isFirstInDuration,\n    };\n  }\n  worker.send({\n    channel,\n    keyPrefix: msg.keyPrefix, // which rate limiter exactly\n    promiseId: msg.promiseId,\n    type,\n    data,\n  });\n};\n\nconst workerWaitInit = function (payload) {\n  setTimeout(() => {\n    if (this._initiated) {\n      process.send(payload);\n      // Promise will be removed by timeout if too long\n    } else if (typeof this._promises[payload.promiseId] !== 'undefined') {\n      workerWaitInit.call(this, payload);\n    }\n  }, 30);\n};\n\nconst workerSendToMaster = function (func, promiseId, key, arg, opts) {\n  const payload = {\n    channel,\n    keyPrefix: this.keyPrefix,\n    func,\n    promiseId,\n    data: {\n      key,\n      arg,\n      opts,\n    },\n  };\n\n  if (!this._initiated) {\n    // Wait init before sending messages to master\n    workerWaitInit.call(this, payload);\n  } else {\n    process.send(payload);\n  }\n};\n\nconst masterProcessMsg = function (worker, msg) {\n  if (!msg || msg.channel !== channel || typeof this._rateLimiters[msg.keyPrefix] === 'undefined') {\n    return false;\n  }\n\n  let promise;\n\n  switch (msg.func) {\n    case 'consume':\n      promise = this._rateLimiters[msg.keyPrefix].consume(msg.data.key, msg.data.arg, msg.data.opts);\n      break;\n    case 'penalty':\n      promise = this._rateLimiters[msg.keyPrefix].penalty(msg.data.key, msg.data.arg, msg.data.opts);\n      break;\n    case 'reward':\n      promise = this._rateLimiters[msg.keyPrefix].reward(msg.data.key, msg.data.arg, msg.data.opts);\n      break;\n    case 'block':\n      promise = this._rateLimiters[msg.keyPrefix].block(msg.data.key, msg.data.arg, msg.data.opts);\n      break;\n    case 'get':\n      promise = this._rateLimiters[msg.keyPrefix].get(msg.data.key, msg.data.opts);\n      break;\n    case 'delete':\n      promise = this._rateLimiters[msg.keyPrefix].delete(msg.data.key, msg.data.opts);\n      break;\n    default:\n      return false;\n  }\n\n  if (promise) {\n    promise\n      .then((res) => {\n        masterSendToWorker(worker, msg, 'resolve', res);\n      })\n      .catch((rejRes) => {\n        masterSendToWorker(worker, msg, 'reject', rejRes);\n      });\n  }\n};\n\nconst workerProcessMsg = function (msg) {\n  if (!msg || msg.channel !== channel || msg.keyPrefix !== this.keyPrefix) {\n    return false;\n  }\n\n  if (this._promises[msg.promiseId]) {\n    clearTimeout(this._promises[msg.promiseId].timeoutId);\n    let res;\n    if (msg.data === null || msg.data === true || msg.data === false) {\n      res = msg.data;\n    } else {\n      res = new RateLimiterRes(\n        msg.data.remainingPoints,\n        msg.data.msBeforeNext,\n        msg.data.consumedPoints,\n        msg.data.isFirstInDuration // eslint-disable-line comma-dangle\n      );\n    }\n\n    switch (msg.type) {\n      case 'resolve':\n        this._promises[msg.promiseId].resolve(res);\n        break;\n      case 'reject':\n        this._promises[msg.promiseId].reject(res);\n        break;\n      default:\n        throw new Error(`RateLimiterCluster: no such message type '${msg.type}'`);\n    }\n\n    delete this._promises[msg.promiseId];\n  }\n};\n/**\n * Prepare options to send to master\n * Master will create rate limiter depending on options\n *\n * @returns {{points: *, duration: *, blockDuration: *, execEvenly: *, execEvenlyMinDelayMs: *, keyPrefix: *}}\n */\nconst getOpts = function () {\n  return {\n    points: this.points,\n    duration: this.duration,\n    blockDuration: this.blockDuration,\n    execEvenly: this.execEvenly,\n    execEvenlyMinDelayMs: this.execEvenlyMinDelayMs,\n    keyPrefix: this.keyPrefix,\n  };\n};\n\nconst savePromise = function (resolve, reject) {\n  const hrtime = process.hrtime();\n  let promiseId = hrtime[0].toString() + hrtime[1].toString();\n\n  if (typeof this._promises[promiseId] !== 'undefined') {\n    promiseId += crypto.randomBytes(12).toString('base64');\n  }\n\n  this._promises[promiseId] = {\n    resolve,\n    reject,\n    timeoutId: setTimeout(() => {\n      delete this._promises[promiseId];\n      reject(new Error('RateLimiterCluster timeout: no answer from master in time'));\n    }, this.timeoutMs),\n  };\n\n  return promiseId;\n};\n\nclass RateLimiterClusterMaster {\n  constructor() {\n    if (masterInstance) {\n      return masterInstance;\n    }\n\n    this._rateLimiters = {};\n\n    cluster.setMaxListeners(0);\n\n    cluster.on('message', (worker, msg) => {\n      if (msg && msg.channel === channel && msg.type === 'init') {\n        // If init request, check or create rate limiter by key prefix and send 'init' back to worker\n        if (typeof this._rateLimiters[msg.opts.keyPrefix] === 'undefined') {\n          this._rateLimiters[msg.opts.keyPrefix] = new RateLimiterMemory(msg.opts);\n        }\n\n        worker.send({\n          channel,\n          type: 'init',\n          keyPrefix: msg.opts.keyPrefix,\n        });\n      } else {\n        masterProcessMsg.call(this, worker, msg);\n      }\n    });\n\n    masterInstance = this;\n  }\n}\n\nclass RateLimiterClusterMasterPM2 {\n  constructor(pm2) {\n    if (masterInstance) {\n      return masterInstance;\n    }\n\n    this._rateLimiters = {};\n\n    pm2.launchBus((err, pm2Bus) => {\n      pm2Bus.on('process:msg', (packet) => {\n        const msg = packet.raw;\n        if (msg && msg.channel === channel && msg.type === 'init') {\n          // If init request, check or create rate limiter by key prefix and send 'init' back to worker\n          if (typeof this._rateLimiters[msg.opts.keyPrefix] === 'undefined') {\n            this._rateLimiters[msg.opts.keyPrefix] = new RateLimiterMemory(msg.opts);\n          }\n\n          pm2.sendDataToProcessId(packet.process.pm_id, {\n            data: {},\n            topic: channel,\n            channel,\n            type: 'init',\n            keyPrefix: msg.opts.keyPrefix,\n          }, (sendErr, res) => {\n            if (sendErr) {\n              console.log(sendErr, res);\n            }\n          });\n        } else {\n          const worker = {\n            send: (msgData) => {\n              const pm2Message = msgData;\n              pm2Message.topic = channel;\n              if (typeof pm2Message.data === 'undefined') {\n                pm2Message.data = {};\n              }\n              pm2.sendDataToProcessId(packet.process.pm_id, pm2Message, (sendErr, res) => {\n                if (sendErr) {\n                  console.log(sendErr, res);\n                }\n              });\n            },\n          };\n          masterProcessMsg.call(this, worker, msg);\n        }\n      });\n    });\n\n    masterInstance = this;\n  }\n}\n\nclass RateLimiterClusterWorker extends RateLimiterAbstract {\n  get timeoutMs() {\n    return this._timeoutMs;\n  }\n\n  set timeoutMs(value) {\n    this._timeoutMs = typeof value === 'undefined' ? 5000 : Math.abs(parseInt(value));\n  }\n\n  constructor(opts = {}) {\n    super(opts);\n\n    process.setMaxListeners(0);\n\n    this.timeoutMs = opts.timeoutMs;\n\n    this._initiated = false;\n\n    process.on('message', (msg) => {\n      if (msg && msg.channel === channel && msg.type === 'init' && msg.keyPrefix === this.keyPrefix) {\n        this._initiated = true;\n      } else {\n        workerProcessMsg.call(this, msg);\n      }\n    });\n\n    // Create limiter on master with specific options\n    process.send({\n      channel,\n      type: 'init',\n      opts: getOpts.call(this),\n    });\n\n    this._promises = {};\n  }\n\n  consume(key, pointsToConsume = 1, options = {}) {\n    return new Promise((resolve, reject) => {\n      const promiseId = savePromise.call(this, resolve, reject);\n\n      workerSendToMaster.call(this, 'consume', promiseId, key, pointsToConsume, options);\n    });\n  }\n\n  penalty(key, points = 1, options = {}) {\n    return new Promise((resolve, reject) => {\n      const promiseId = savePromise.call(this, resolve, reject);\n\n      workerSendToMaster.call(this, 'penalty', promiseId, key, points, options);\n    });\n  }\n\n  reward(key, points = 1, options = {}) {\n    return new Promise((resolve, reject) => {\n      const promiseId = savePromise.call(this, resolve, reject);\n\n      workerSendToMaster.call(this, 'reward', promiseId, key, points, options);\n    });\n  }\n\n  block(key, secDuration, options = {}) {\n    return new Promise((resolve, reject) => {\n      const promiseId = savePromise.call(this, resolve, reject);\n\n      workerSendToMaster.call(this, 'block', promiseId, key, secDuration, options);\n    });\n  }\n\n  get(key, options = {}) {\n    return new Promise((resolve, reject) => {\n      const promiseId = savePromise.call(this, resolve, reject);\n\n      workerSendToMaster.call(this, 'get', promiseId, key, options);\n    });\n  }\n\n  delete(key, options = {}) {\n    return new Promise((resolve, reject) => {\n      const promiseId = savePromise.call(this, resolve, reject);\n\n      workerSendToMaster.call(this, 'delete', promiseId, key, options);\n    });\n  }\n}\n\nmodule.exports = {\n  RateLimiterClusterMaster,\n  RateLimiterClusterMasterPM2,\n  RateLimiterCluster: RateLimiterClusterWorker,\n};\n", "const RateLimiterStoreAbstract = require('./RateLimiterStoreAbstract');\nconst RateLimiterRes = require('./RateLimiterRes');\n\nclass RateLimiterMemcache extends RateLimiterStoreAbstract {\n  /**\n   *\n   * @param {Object} opts\n   * Defaults {\n   *   ... see other in RateLimiterStoreAbstract\n   *\n   *   storeClient: memcacheClient\n   * }\n   */\n  constructor(opts) {\n    super(opts);\n\n    this.client = opts.storeClient;\n  }\n\n  _getRateLimiterRes(rlKey, changedPoints, result) {\n    const res = new RateLimiterRes();\n    res.consumedPoints = parseInt(result.consumedPoints);\n    res.isFirstInDuration = result.consumedPoints === changedPoints;\n    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n    res.msBeforeNext = result.msBeforeNext;\n\n    return res;\n  }\n\n  _upsert(rlKey, points, msDuration, forceExpire = false, options = {}) {\n    return new Promise((resolve, reject) => {\n      const nowMs = Date.now();\n      const secDuration = Math.floor(msDuration / 1000);\n\n      if (forceExpire) {\n        this.client.set(rlKey, points, secDuration, (err) => {\n          if (!err) {\n            this.client.set(\n              `${rlKey}_expire`,\n              secDuration > 0 ? nowMs + (secDuration * 1000) : -1,\n              secDuration,\n              () => {\n                const res = {\n                  consumedPoints: points,\n                  msBeforeNext: secDuration > 0 ? secDuration * 1000 : -1,\n                };\n                resolve(res);\n              }\n            );\n          } else {\n            reject(err);\n          }\n        });\n      } else {\n        this.client.incr(rlKey, points, (err, consumedPoints) => {\n          if (err || consumedPoints === false) {\n            this.client.add(rlKey, points, secDuration, (errAddKey, createdNew) => {\n              if (errAddKey || !createdNew) {\n                // Try to upsert again in case of race condition\n                if (typeof options.attemptNumber === 'undefined' || options.attemptNumber < 3) {\n                  const nextOptions = Object.assign({}, options);\n                  nextOptions.attemptNumber = nextOptions.attemptNumber ? (nextOptions.attemptNumber + 1) : 1;\n\n                  this._upsert(rlKey, points, msDuration, forceExpire, nextOptions)\n                    .then(resUpsert => resolve(resUpsert))\n                    .catch(errUpsert => reject(errUpsert));\n                } else {\n                  reject(new Error('Can not add key'));\n                }\n              } else {\n                this.client.add(\n                  `${rlKey}_expire`,\n                  secDuration > 0 ? nowMs + (secDuration * 1000) : -1,\n                  secDuration,\n                  () => {\n                    const res = {\n                      consumedPoints: points,\n                      msBeforeNext: secDuration > 0 ? secDuration * 1000 : -1,\n                    };\n                    resolve(res);\n                  }\n                );\n              }\n            });\n          } else {\n            this.client.get(`${rlKey}_expire`, (errGetExpire, resGetExpireMs) => {\n              if (errGetExpire) {\n                reject(errGetExpire);\n              } else {\n                const expireMs = resGetExpireMs === false ? 0 : resGetExpireMs;\n                const res = {\n                  consumedPoints,\n                  msBeforeNext: expireMs >= 0 ? Math.max(expireMs - nowMs, 0) : -1,\n                };\n                resolve(res);\n              }\n            });\n          }\n        });\n      }\n    });\n  }\n\n  _get(rlKey) {\n    return new Promise((resolve, reject) => {\n      const nowMs = Date.now();\n\n      this.client.get(rlKey, (err, consumedPoints) => {\n        if (!consumedPoints) {\n          resolve(null);\n        } else {\n          this.client.get(`${rlKey}_expire`, (errGetExpire, resGetExpireMs) => {\n            if (errGetExpire) {\n              reject(errGetExpire);\n            } else {\n              const expireMs = resGetExpireMs === false ? 0 : resGetExpireMs;\n              const res = {\n                consumedPoints,\n                msBeforeNext: expireMs >= 0 ? Math.max(expireMs - nowMs, 0) : -1,\n              };\n              resolve(res);\n            }\n          });\n        }\n      });\n    });\n  }\n\n  _delete(rlKey) {\n    return new Promise((resolve, reject) => {\n      this.client.del(rlKey, (err, res) => {\n        if (err) {\n          reject(err);\n        } else if (res === false) {\n          resolve(res);\n        } else {\n          this.client.del(`${rlKey}_expire`, (errDelExpire) => {\n            if (errDelExpire) {\n              reject(errDelExpire);\n            } else {\n              resolve(res);\n            }\n          });\n        }\n      });\n    });\n  }\n}\n\nmodule.exports = RateLimiterMemcache;\n", "const RateLimiterRes = require('./RateLimiterRes');\n\nmodule.exports = class RLWrapperBlackAndWhite {\n  constructor(opts = {}) {\n    this.limiter = opts.limiter;\n    this.blackList = opts.blackList;\n    this.whiteList = opts.whiteList;\n    this.isBlackListed = opts.isBlackListed;\n    this.isWhiteListed = opts.isWhiteListed;\n    this.runActionAnyway = opts.runActionAnyway;\n  }\n\n  get limiter() {\n    return this._limiter;\n  }\n\n  set limiter(value) {\n    if (typeof value === 'undefined') {\n      throw new Error('limiter is not set');\n    }\n\n    this._limiter = value;\n  }\n\n  get runActionAnyway() {\n    return this._runActionAnyway;\n  }\n\n  set runActionAnyway(value) {\n    this._runActionAnyway = typeof value === 'undefined' ? false : value;\n  }\n\n  get blackList() {\n    return this._blackList;\n  }\n\n  set blackList(value) {\n    this._blackList = Array.isArray(value) ? value : [];\n  }\n\n  get isBlackListed() {\n    return this._isBlackListed;\n  }\n\n  set isBlackListed(func) {\n    if (typeof func === 'undefined') {\n      func = () => false;\n    }\n    if (typeof func !== 'function') {\n      throw new Error('isBlackListed must be function');\n    }\n    this._isBlackListed = func;\n  }\n\n  get whiteList() {\n    return this._whiteList;\n  }\n\n  set whiteList(value) {\n    this._whiteList = Array.isArray(value) ? value : [];\n  }\n\n  get isWhiteListed() {\n    return this._isWhiteListed;\n  }\n\n  set isWhiteListed(func) {\n    if (typeof func === 'undefined') {\n      func = () => false;\n    }\n    if (typeof func !== 'function') {\n      throw new Error('isWhiteListed must be function');\n    }\n    this._isWhiteListed = func;\n  }\n\n  isBlackListedSomewhere(key) {\n    return this.blackList.indexOf(key) >= 0 || this.isBlackListed(key);\n  }\n\n  isWhiteListedSomewhere(key) {\n    return this.whiteList.indexOf(key) >= 0 || this.isWhiteListed(key);\n  }\n\n  getBlackRes() {\n    return new RateLimiterRes(0, Number.MAX_SAFE_INTEGER, 0, false);\n  }\n\n  getWhiteRes() {\n    return new RateLimiterRes(Number.MAX_SAFE_INTEGER, 0, 0, false);\n  }\n\n  rejectBlack() {\n    return Promise.reject(this.getBlackRes());\n  }\n\n  resolveBlack() {\n    return Promise.resolve(this.getBlackRes());\n  }\n\n  resolveWhite() {\n    return Promise.resolve(this.getWhiteRes());\n  }\n\n  consume(key, pointsToConsume = 1) {\n    let res;\n    if (this.isWhiteListedSomewhere(key)) {\n      res = this.resolveWhite();\n    } else if (this.isBlackListedSomewhere(key)) {\n      res = this.rejectBlack();\n    }\n\n    if (typeof res === 'undefined') {\n      return this.limiter.consume(key, pointsToConsume);\n    }\n\n    if (this.runActionAnyway) {\n      this.limiter.consume(key, pointsToConsume).catch(() => {});\n    }\n    return res;\n  }\n\n  block(key, secDuration) {\n    let res;\n    if (this.isWhiteListedSomewhere(key)) {\n      res = this.resolveWhite();\n    } else if (this.isBlackListedSomewhere(key)) {\n      res = this.resolveBlack();\n    }\n\n    if (typeof res === 'undefined') {\n      return this.limiter.block(key, secDuration);\n    }\n\n    if (this.runActionAnyway) {\n      this.limiter.block(key, secDuration).catch(() => {});\n    }\n    return res;\n  }\n\n  penalty(key, points) {\n    let res;\n    if (this.isWhiteListedSomewhere(key)) {\n      res = this.resolveWhite();\n    } else if (this.isBlackListedSomewhere(key)) {\n      res = this.resolveBlack();\n    }\n\n    if (typeof res === 'undefined') {\n      return this.limiter.penalty(key, points);\n    }\n\n    if (this.runActionAnyway) {\n      this.limiter.penalty(key, points).catch(() => {});\n    }\n    return res;\n  }\n\n  reward(key, points) {\n    let res;\n    if (this.isWhiteListedSomewhere(key)) {\n      res = this.resolveWhite();\n    } else if (this.isBlackListedSomewhere(key)) {\n      res = this.resolveBlack();\n    }\n\n    if (typeof res === 'undefined') {\n      return this.limiter.reward(key, points);\n    }\n\n    if (this.runActionAnyway) {\n      this.limiter.reward(key, points).catch(() => {});\n    }\n    return res;\n  }\n\n  get(key) {\n    let res;\n    if (this.isWhiteListedSomewhere(key)) {\n      res = this.resolveWhite();\n    } else if (this.isBlackListedSomewhere(key)) {\n      res = this.resolveBlack();\n    }\n\n    if (typeof res === 'undefined' || this.runActionAnyway) {\n      return this.limiter.get(key);\n    }\n\n    return res;\n  }\n\n  delete(key) {\n    return this.limiter.delete(key);\n  }\n};\n", "const RateLimiterAbstract = require('./RateLimiterAbstract');\n\nmodule.exports = class RateLimiterUnion {\n  constructor(...limiters) {\n    if (limiters.length < 1) {\n      throw new Error('RateLimiterUnion: at least one limiter have to be passed');\n    }\n    limiters.forEach((limiter) => {\n      if (!(limiter instanceof RateLimiterAbstract)) {\n        throw new Error('RateLimiterUnion: all limiters have to be instance of RateLimiterAbstract');\n      }\n    });\n\n    this._limiters = limiters;\n  }\n\n  consume(key, points = 1) {\n    return new Promise((resolve, reject) => {\n      const promises = [];\n      this._limiters.forEach((limiter) => {\n        promises.push(limiter.consume(key, points).catch(rej => ({ rejected: true, rej })));\n      });\n\n      Promise.all(promises)\n        .then((res) => {\n          const resObj = {};\n          let rejected = false;\n\n          res.forEach((item) => {\n            if (item.rejected === true) {\n              rejected = true;\n            }\n          });\n\n          for (let i = 0; i < res.length; i++) {\n            if (rejected && res[i].rejected === true) {\n              resObj[this._limiters[i].keyPrefix] = res[i].rej;\n            } else if (!rejected) {\n              resObj[this._limiters[i].keyPrefix] = res[i];\n            }\n          }\n\n          if (rejected) {\n            reject(resObj);\n          } else {\n            resolve(resObj);\n          }\n        });\n    });\n  }\n};\n", "module.exports = class RateLimiterQueueError extends Error {\n  constructor(message, extra) {\n    super();\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n    this.name = 'CustomError';\n    this.message = message;\n    if (extra) {\n      this.extra = extra;\n    }\n  }\n};\n", "const RateLimiterQueueError = require('./component/RateLimiterQueueError')\nconst MAX_QUEUE_SIZE = 4294967295;\nconst KEY_DEFAULT = 'limiter';\n\nmodule.exports = class RateLimiterQueue {\n  constructor(limiterFlexible, opts = {\n    maxQueueSize: MAX_QUEUE_SIZE,\n  }) {\n    this._queueLimiters = {\n      KEY_DEFAULT: new RateLimiterQueueInternal(limiterFlexible, opts)\n    };\n    this._limiterFlexible = limiterFlexible;\n    this._maxQueueSize = opts.maxQueueSize\n  }\n\n  getTokensRemaining(key = KEY_DEFAULT) {\n    if (this._queueLimiters[key]) {\n      return this._queueLimiters[key].getTokensRemaining()\n    } else {\n      return Promise.resolve(this._limiterFlexible.points)\n    }\n  }\n\n  removeTokens(tokens, key = KEY_DEFAULT) {\n    if (!this._queueLimiters[key]) {\n      this._queueLimiters[key] = new RateLimiterQueueInternal(\n        this._limiterFlexible, {\n          key,\n          maxQueueSize: this._maxQueueSize,\n        })\n    }\n\n    return this._queueLimiters[key].removeTokens(tokens)\n  }\n};\n\nclass RateLimiterQueueInternal {\n\n  constructor(limiterFlexible, opts = {\n    maxQueueSize: MAX_QUEUE_SIZE,\n    key: KEY_DEFAULT,\n  }) {\n    this._key = opts.key;\n    this._waitTimeout = null;\n    this._queue = [];\n    this._limiterFlexible = limiterFlexible;\n\n    this._maxQueueSize = opts.maxQueueSize\n  }\n\n  getTokensRemaining() {\n    return this._limiterFlexible.get(this._key)\n      .then((rlRes) => {\n        return rlRes !== null ? rlRes.remainingPoints : this._limiterFlexible.points;\n      })\n  }\n\n  removeTokens(tokens) {\n    const _this = this;\n\n    return new Promise((resolve, reject) => {\n      if (tokens > _this._limiterFlexible.points) {\n        reject(new RateLimiterQueueError(`Requested tokens ${tokens} exceeds maximum ${_this._limiterFlexible.points} tokens per interval`));\n        return\n      }\n\n      if (_this._queue.length > 0) {\n        _this._queueRequest.call(_this, resolve, reject, tokens);\n      } else {\n        _this._limiterFlexible.consume(_this._key, tokens)\n          .then((res) => {\n            resolve(res.remainingPoints);\n          })\n          .catch((rej) => {\n            if (rej instanceof Error) {\n              reject(rej);\n            } else {\n              _this._queueRequest.call(_this, resolve, reject, tokens);\n              if (_this._waitTimeout === null) {\n                _this._waitTimeout = setTimeout(_this._processFIFO.bind(_this), rej.msBeforeNext);\n              }\n            }\n          });\n      }\n    })\n  }\n\n  _queueRequest(resolve, reject, tokens) {\n    const _this = this;\n    if (_this._queue.length < _this._maxQueueSize) {\n      _this._queue.push({resolve, reject, tokens});\n    } else {\n      reject(new RateLimiterQueueError(`Number of requests reached it's maximum ${_this._maxQueueSize}`))\n    }\n  }\n\n  _processFIFO() {\n    const _this = this;\n\n    if (_this._waitTimeout !== null) {\n      clearTimeout(_this._waitTimeout);\n      _this._waitTimeout = null;\n    }\n\n    if (_this._queue.length === 0) {\n      return;\n    }\n\n    const item = _this._queue.shift();\n    _this._limiterFlexible.consume(_this._key, item.tokens)\n      .then((res) => {\n        item.resolve(res.remainingPoints);\n        _this._processFIFO.call(_this);\n      })\n      .catch((rej) => {\n        if (rej instanceof Error) {\n          item.reject(rej);\n          _this._processFIFO.call(_this);\n        } else {\n          _this._queue.unshift(item);\n          if (_this._waitTimeout === null) {\n            _this._waitTimeout = setTimeout(_this._processFIFO.bind(_this), rej.msBeforeNext);\n          }\n        }\n      });\n  }\n}\n", "const RateLimiterRes = require(\"./RateLimiterRes\");\n\n/**\n * Bursty rate limiter exposes only msBeforeNext time and doesn't expose points from bursty limiter by default\n * @type {BurstyRateLimiter}\n */\nmodule.exports = class BurstyRateLimiter {\n  constructor(rateLimiter, burstLimiter) {\n    this._rateLimiter = rateLimiter;\n    this._burstLimiter = burstLimiter\n  }\n\n  /**\n   * Merge rate limiter response objects. Responses can be null\n   *\n   * @param {RateLimiterRes} [rlRes] Rate limiter response\n   * @param {RateLimiterRes} [blRes] Bursty limiter response\n   */\n  _combineRes(rlRes, blRes) {\n    if (!rlRes) {\n      return null\n    }\n\n    return new RateLimiterRes(\n      rlRes.remainingPoints,\n      Math.min(rlRes.msBeforeNext, blRes ? blRes.msBeforeNext : 0),\n      rlRes.consumedPoints,\n      rlRes.isFirstInDuration\n    )\n  }\n\n  /**\n   * @param key\n   * @param pointsToConsume\n   * @param options\n   * @returns {Promise<any>}\n   */\n  consume(key, pointsToConsume = 1, options = {}) {\n    return this._rateLimiter.consume(key, pointsToConsume, options)\n      .catch((rlRej) => {\n        if (rlRej instanceof RateLimiterRes) {\n          return this._burstLimiter.consume(key, pointsToConsume, options)\n            .then((blRes) => {\n              return Promise.resolve(this._combineRes(rlRej, blRes))\n            })\n            .catch((blRej) => {\n                if (blRej instanceof RateLimiterRes) {\n                  return Promise.reject(this._combineRes(rlRej, blRej))\n                } else {\n                  return Promise.reject(blRej)\n                }\n              }\n            )\n        } else {\n          return Promise.reject(rlRej)\n        }\n      })\n  }\n\n  /**\n   * It doesn't expose available points from burstLimiter\n   *\n   * @param key\n   * @returns {Promise<RateLimiterRes>}\n   */\n  get(key) {\n    return Promise.all([\n      this._rateLimiter.get(key),\n      this._burstLimiter.get(key),\n    ]).then(([rlRes, blRes]) => {\n      return this._combineRes(rlRes, blRes);\n    });\n  }\n\n  get points() {\n    return this._rateLimiter.points;\n  }\n};\n", "const RateLimiterRedis = require('./lib/RateLimiterRedis');\nconst RateLimiterMongo = require('./lib/RateLimiterMongo');\nconst RateLimiterMySQL = require('./lib/RateLimiterMySQL');\nconst RateLimiterPostgres = require('./lib/RateLimiterPostgres');\nconst {RateLimiterClusterMaster, RateLimiterClusterMasterPM2, RateLimiterCluster} = require('./lib/RateLimiterCluster');\nconst RateLimiterMemory = require('./lib/RateLimiterMemory');\nconst RateLimiterMemcache = require('./lib/RateLimiterMemcache');\nconst RLWrapperBlackAndWhite = require('./lib/RLWrapperBlackAndWhite');\nconst RateLimiterUnion = require('./lib/RateLimiterUnion');\nconst RateLimiterQueue = require('./lib/RateLimiterQueue');\nconst BurstyRateLimiter = require('./lib/BurstyRateLimiter');\nconst RateLimiterRes = require('./lib/RateLimiterRes');\n\nmodule.exports = {\n  RateLimiterRedis,\n  RateLimiterMongo,\n  RateLimiterMySQL,\n  RateLimiterPostgres,\n  RateLimiterMemory,\n  RateLimiterMemcache,\n  RateLimiterClusterMaster,\n  RateLimiterClusterMasterPM2,\n  RateLimiterCluster,\n  RLWrapperBlackAndWhite,\n  RateLimiterUnion,\n  RateLimiterQueue,\n  BurstyRateLimiter,\n  RateLimiterRes,\n};\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass EventQueue {\n    constructor() {\n        this.pullQueue = [];\n        this.pushQueue = [];\n        this.eventHandlers = {};\n        this.isPaused = false;\n        this.isStopped = false;\n    }\n    push(value) {\n        if (this.isStopped)\n            return;\n        const resolution = { value, done: false };\n        if (this.pullQueue.length) {\n            const placeholder = this.pullQueue.shift();\n            if (placeholder)\n                placeholder.resolve(resolution);\n        }\n        else {\n            this.pushQueue.push(Promise.resolve(resolution));\n            if (this.highWaterMark !== undefined &&\n                this.pushQueue.length >= this.highWaterMark &&\n                !this.isPaused) {\n                this.isPaused = true;\n                if (this.eventHandlers.highWater) {\n                    this.eventHandlers.highWater();\n                }\n                else if (console) {\n                    console.warn(`EventIterator queue reached ${this.pushQueue.length} items`);\n                }\n            }\n        }\n    }\n    stop() {\n        if (this.isStopped)\n            return;\n        this.isStopped = true;\n        this.remove();\n        for (const placeholder of this.pullQueue) {\n            placeholder.resolve({ value: undefined, done: true });\n        }\n        this.pullQueue.length = 0;\n    }\n    fail(error) {\n        if (this.isStopped)\n            return;\n        this.isStopped = true;\n        this.remove();\n        if (this.pullQueue.length) {\n            for (const placeholder of this.pullQueue) {\n                placeholder.reject(error);\n            }\n            this.pullQueue.length = 0;\n        }\n        else {\n            const rejection = Promise.reject(error);\n            /* Attach error handler to avoid leaking an unhandled promise rejection. */\n            rejection.catch(() => { });\n            this.pushQueue.push(rejection);\n        }\n    }\n    remove() {\n        Promise.resolve().then(() => {\n            if (this.removeCallback)\n                this.removeCallback();\n        });\n    }\n    [Symbol.asyncIterator]() {\n        return {\n            next: (value) => {\n                const result = this.pushQueue.shift();\n                if (result) {\n                    if (this.lowWaterMark !== undefined &&\n                        this.pushQueue.length <= this.lowWaterMark &&\n                        this.isPaused) {\n                        this.isPaused = false;\n                        if (this.eventHandlers.lowWater) {\n                            this.eventHandlers.lowWater();\n                        }\n                    }\n                    return result;\n                }\n                else if (this.isStopped) {\n                    return Promise.resolve({ value: undefined, done: true });\n                }\n                else {\n                    return new Promise((resolve, reject) => {\n                        this.pullQueue.push({ resolve, reject });\n                    });\n                }\n            },\n            return: () => {\n                this.isStopped = true;\n                this.pushQueue.length = 0;\n                this.remove();\n                return Promise.resolve({ value: undefined, done: true });\n            },\n        };\n    }\n}\nclass EventIterator {\n    constructor(listen, { highWaterMark = 100, lowWaterMark = 1 } = {}) {\n        const queue = new EventQueue();\n        queue.highWaterMark = highWaterMark;\n        queue.lowWaterMark = lowWaterMark;\n        queue.removeCallback =\n            listen({\n                push: value => queue.push(value),\n                stop: () => queue.stop(),\n                fail: error => queue.fail(error),\n                on: (event, fn) => {\n                    queue.eventHandlers[event] = fn;\n                },\n            }) || (() => { });\n        this[Symbol.asyncIterator] = () => queue[Symbol.asyncIterator]();\n        Object.freeze(this);\n    }\n}\nexports.EventIterator = EventIterator;\nexports.default = EventIterator;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst event_iterator_1 = require(\"./event-iterator\");\nexports.EventIterator = event_iterator_1.EventIterator;\nfunction subscribe(event, options, evOptions) {\n    return new event_iterator_1.EventIterator(({ push }) => {\n        this.addEventListener(event, push, options);\n        return () => this.removeEventListener(event, push, options);\n    }, evOptions);\n}\nexports.subscribe = subscribe;\nexports.default = event_iterator_1.EventIterator;\n", "'use strict'\n\nconst isReactNative =\n    typeof navigator !== 'undefined' &&\n    navigator.product === 'ReactNative'\n\nfunction getDefaultBase () {\n  if (isReactNative) {\n    return 'http://localhost'\n  }\n  // in some environments i.e. cloudflare workers location is not available\n  if (!self.location) {\n    return ''\n  }\n\n  return self.location.protocol + '//' + self.location.host\n}\n\nconst URL = self.URL\nconst defaultBase = getDefaultBase()\n\nclass URLWithLegacySupport {\n  constructor (url = '', base = defaultBase) {\n    this.super = new URL(url, base)\n    this.path = this.pathname + this.search\n    this.auth =\n            this.username && this.password\n              ? this.username + ':' + this.password\n              : null\n\n    this.query =\n            this.search && this.search.startsWith('?')\n              ? this.search.slice(1)\n              : null\n  }\n\n  get hash () {\n    return this.super.hash\n  }\n\n  get host () {\n    return this.super.host\n  }\n\n  get hostname () {\n    return this.super.hostname\n  }\n\n  get href () {\n    return this.super.href\n  }\n\n  get origin () {\n    return this.super.origin\n  }\n\n  get password () {\n    return this.super.password\n  }\n\n  get pathname () {\n    return this.super.pathname\n  }\n\n  get port () {\n    return this.super.port\n  }\n\n  get protocol () {\n    return this.super.protocol\n  }\n\n  get search () {\n    return this.super.search\n  }\n\n  get searchParams () {\n    return this.super.searchParams\n  }\n\n  get username () {\n    return this.super.username\n  }\n\n  set hash (hash) {\n    this.super.hash = hash\n  }\n\n  set host (host) {\n    this.super.host = host\n  }\n\n  set hostname (hostname) {\n    this.super.hostname = hostname\n  }\n\n  set href (href) {\n    this.super.href = href\n  }\n\n  set password (password) {\n    this.super.password = password\n  }\n\n  set pathname (pathname) {\n    this.super.pathname = pathname\n  }\n\n  set port (port) {\n    this.super.port = port\n  }\n\n  set protocol (protocol) {\n    this.super.protocol = protocol\n  }\n\n  set search (search) {\n    this.super.search = search\n  }\n\n  set username (username) {\n    this.super.username = username\n  }\n\n  /**\n   * @param {any} o\n   */\n  static createObjectURL (o) {\n    return URL.createObjectURL(o)\n  }\n\n  /**\n   * @param {string} o\n   */\n  static revokeObjectURL (o) {\n    URL.revokeObjectURL(o)\n  }\n\n  toJSON () {\n    return this.super.toJSON()\n  }\n\n  toString () {\n    return this.super.toString()\n  }\n\n  format () {\n    return this.toString()\n  }\n}\n\n/**\n * @param {string | import('url').UrlObject} obj\n */\nfunction format (obj) {\n  if (typeof obj === 'string') {\n    const url = new URL(obj)\n\n    return url.toString()\n  }\n\n  if (!(obj instanceof URL)) {\n    const userPass =\n            // @ts-ignore its not supported in node but we normalise\n            obj.username && obj.password\n              // @ts-ignore its not supported in node but we normalise\n              ? `${obj.username}:${obj.password}@`\n              : ''\n    const auth = obj.auth ? obj.auth + '@' : ''\n    const port = obj.port ? ':' + obj.port : ''\n    const protocol = obj.protocol ? obj.protocol + '//' : ''\n    const host = obj.host || ''\n    const hostname = obj.hostname || ''\n    const search = obj.search || (obj.query ? '?' + obj.query : '')\n    const hash = obj.hash || ''\n    const pathname = obj.pathname || ''\n    // @ts-ignore - path is not supported in node but we normalise\n    const path = obj.path || pathname + search\n\n    return `${protocol}${userPass || auth}${\n            host || hostname + port\n        }${path}${hash}`\n  }\n}\n\nmodule.exports = {\n  URLWithLegacySupport,\n  URLSearchParams: self.URLSearchParams,\n  defaultBase,\n  format\n}\n", "'use strict'\n\nconst { URLWithLegacySupport, format } = require('./url')\n\n/**\n * @param {string | undefined} url\n * @param {any} [location]\n * @param {any} [protocolMap]\n * @param {any} [defaultProtocol]\n */\nmodule.exports = (url, location = {}, protocolMap = {}, defaultProtocol) => {\n  let protocol = location.protocol\n    ? location.protocol.replace(':', '')\n    : 'http'\n\n  // Check protocol map\n  protocol = (protocolMap[protocol] || defaultProtocol || protocol) + ':'\n  let urlParsed\n\n  try {\n    urlParsed = new URLWithLegacySupport(url)\n  } catch (err) {\n    urlParsed = {}\n  }\n\n  const base = Object.assign({}, location, {\n    protocol: protocol || urlParsed.protocol,\n    host: location.host || urlParsed.host\n  })\n\n  return new URLWithLegacySupport(url, format(base)).toString()\n}\n", "'use strict'\n\nconst {\n  URLWithLegacySupport,\n  format,\n  URLSearchParams,\n  defaultBase\n} = require('./src/url')\nconst relative = require('./src/relative')\n\nmodule.exports = {\n  URL: URLWithLegacySupport,\n  URLSearchParams,\n  format,\n  relative,\n  defaultBase\n}\n", "// https://github.com/electron/electron/issues/2288\nfunction isElectron() {\n    // Renderer process\n    if (typeof window !== 'undefined' && typeof window.process === 'object' && window.process.type === 'renderer') {\n        return true;\n    }\n\n    // Main process\n    if (typeof process !== 'undefined' && typeof process.versions === 'object' && !!process.versions.electron) {\n        return true;\n    }\n\n    // Detect the user agent when the `nodeIntegration` option is set to false\n    if (typeof navigator === 'object' && typeof navigator.userAgent === 'string' && navigator.userAgent.indexOf('Electron') >= 0) {\n        return true;\n    }\n\n    return false;\n}\n\nmodule.exports = isElectron;\n", "// minimal library entry point.\n\n\"use strict\";\nmodule.exports = require(\"./src/index-minimal\");\n", "// @ts-nocheck\n/*eslint-disable*/\n(function(global, factory) { /* global define, require, module */\n\n    /* AMD */ if (typeof define === 'function' && define.amd)\n        define([\"protobufjs/minimal\"], factory);\n\n    /* CommonJS */ else if (typeof require === 'function' && typeof module === 'object' && module && module.exports)\n        module.exports = factory(require(\"protobufjs/minimal\"));\n\n})(this, function($protobuf) {\n    \"use strict\";\n\n    // Common aliases\n    var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;\n\n    // Exported root namespace\n    var $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n\n    $root.RPC = (function() {\n\n        /**\n         * Properties of a RPC.\n         * @exports IRPC\n         * @interface IRPC\n         * @property {Array.<RPC.ISubOpts>|null} [subscriptions] RPC subscriptions\n         * @property {Array.<RPC.IMessage>|null} [messages] RPC messages\n         * @property {RPC.IControlMessage|null} [control] RPC control\n         */\n\n        /**\n         * Constructs a new RPC.\n         * @exports RPC\n         * @classdesc Represents a RPC.\n         * @implements IRPC\n         * @constructor\n         * @param {IRPC=} [p] Properties to set\n         */\n        function RPC(p) {\n            this.subscriptions = [];\n            this.messages = [];\n            if (p)\n                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                    if (p[ks[i]] != null)\n                        this[ks[i]] = p[ks[i]];\n        }\n\n        /**\n         * RPC subscriptions.\n         * @member {Array.<RPC.ISubOpts>} subscriptions\n         * @memberof RPC\n         * @instance\n         */\n        RPC.prototype.subscriptions = $util.emptyArray;\n\n        /**\n         * RPC messages.\n         * @member {Array.<RPC.IMessage>} messages\n         * @memberof RPC\n         * @instance\n         */\n        RPC.prototype.messages = $util.emptyArray;\n\n        /**\n         * RPC control.\n         * @member {RPC.IControlMessage|null|undefined} control\n         * @memberof RPC\n         * @instance\n         */\n        RPC.prototype.control = null;\n\n        // OneOf field names bound to virtual getters and setters\n        var $oneOfFields;\n\n        /**\n         * RPC _control.\n         * @member {\"control\"|undefined} _control\n         * @memberof RPC\n         * @instance\n         */\n        Object.defineProperty(RPC.prototype, \"_control\", {\n            get: $util.oneOfGetter($oneOfFields = [\"control\"]),\n            set: $util.oneOfSetter($oneOfFields)\n        });\n\n        /**\n         * Encodes the specified RPC message. Does not implicitly {@link RPC.verify|verify} messages.\n         * @function encode\n         * @memberof RPC\n         * @static\n         * @param {IRPC} m RPC message or plain object to encode\n         * @param {$protobuf.Writer} [w] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        RPC.encode = function encode(m, w) {\n            if (!w)\n                w = $Writer.create();\n            if (m.subscriptions != null && m.subscriptions.length) {\n                for (var i = 0; i < m.subscriptions.length; ++i)\n                    $root.RPC.SubOpts.encode(m.subscriptions[i], w.uint32(10).fork()).ldelim();\n            }\n            if (m.messages != null && m.messages.length) {\n                for (var i = 0; i < m.messages.length; ++i)\n                    $root.RPC.Message.encode(m.messages[i], w.uint32(18).fork()).ldelim();\n            }\n            if (m.control != null && Object.hasOwnProperty.call(m, \"control\"))\n                $root.RPC.ControlMessage.encode(m.control, w.uint32(26).fork()).ldelim();\n            return w;\n        };\n\n        /**\n         * Decodes a RPC message from the specified reader or buffer.\n         * @function decode\n         * @memberof RPC\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n         * @param {number} [l] Message length if known beforehand\n         * @returns {RPC} RPC\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        RPC.decode = function decode(r, l) {\n            if (!(r instanceof $Reader))\n                r = $Reader.create(r);\n            var c = l === undefined ? r.len : r.pos + l, m = new $root.RPC();\n            while (r.pos < c) {\n                var t = r.uint32();\n                switch (t >>> 3) {\n                case 1:\n                    if (!(m.subscriptions && m.subscriptions.length))\n                        m.subscriptions = [];\n                    m.subscriptions.push($root.RPC.SubOpts.decode(r, r.uint32()));\n                    break;\n                case 2:\n                    if (!(m.messages && m.messages.length))\n                        m.messages = [];\n                    m.messages.push($root.RPC.Message.decode(r, r.uint32()));\n                    break;\n                case 3:\n                    m.control = $root.RPC.ControlMessage.decode(r, r.uint32());\n                    break;\n                default:\n                    r.skipType(t & 7);\n                    break;\n                }\n            }\n            return m;\n        };\n\n        /**\n         * Creates a RPC message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof RPC\n         * @static\n         * @param {Object.<string,*>} d Plain object\n         * @returns {RPC} RPC\n         */\n        RPC.fromObject = function fromObject(d) {\n            if (d instanceof $root.RPC)\n                return d;\n            var m = new $root.RPC();\n            if (d.subscriptions) {\n                if (!Array.isArray(d.subscriptions))\n                    throw TypeError(\".RPC.subscriptions: array expected\");\n                m.subscriptions = [];\n                for (var i = 0; i < d.subscriptions.length; ++i) {\n                    if (typeof d.subscriptions[i] !== \"object\")\n                        throw TypeError(\".RPC.subscriptions: object expected\");\n                    m.subscriptions[i] = $root.RPC.SubOpts.fromObject(d.subscriptions[i]);\n                }\n            }\n            if (d.messages) {\n                if (!Array.isArray(d.messages))\n                    throw TypeError(\".RPC.messages: array expected\");\n                m.messages = [];\n                for (var i = 0; i < d.messages.length; ++i) {\n                    if (typeof d.messages[i] !== \"object\")\n                        throw TypeError(\".RPC.messages: object expected\");\n                    m.messages[i] = $root.RPC.Message.fromObject(d.messages[i]);\n                }\n            }\n            if (d.control != null) {\n                if (typeof d.control !== \"object\")\n                    throw TypeError(\".RPC.control: object expected\");\n                m.control = $root.RPC.ControlMessage.fromObject(d.control);\n            }\n            return m;\n        };\n\n        /**\n         * Creates a plain object from a RPC message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof RPC\n         * @static\n         * @param {RPC} m RPC\n         * @param {$protobuf.IConversionOptions} [o] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        RPC.toObject = function toObject(m, o) {\n            if (!o)\n                o = {};\n            var d = {};\n            if (o.arrays || o.defaults) {\n                d.subscriptions = [];\n                d.messages = [];\n            }\n            if (m.subscriptions && m.subscriptions.length) {\n                d.subscriptions = [];\n                for (var j = 0; j < m.subscriptions.length; ++j) {\n                    d.subscriptions[j] = $root.RPC.SubOpts.toObject(m.subscriptions[j], o);\n                }\n            }\n            if (m.messages && m.messages.length) {\n                d.messages = [];\n                for (var j = 0; j < m.messages.length; ++j) {\n                    d.messages[j] = $root.RPC.Message.toObject(m.messages[j], o);\n                }\n            }\n            if (m.control != null && m.hasOwnProperty(\"control\")) {\n                d.control = $root.RPC.ControlMessage.toObject(m.control, o);\n                if (o.oneofs)\n                    d._control = \"control\";\n            }\n            return d;\n        };\n\n        /**\n         * Converts this RPC to JSON.\n         * @function toJSON\n         * @memberof RPC\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        RPC.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        RPC.SubOpts = (function() {\n\n            /**\n             * Properties of a SubOpts.\n             * @memberof RPC\n             * @interface ISubOpts\n             * @property {boolean|null} [subscribe] SubOpts subscribe\n             * @property {string|null} [topic] SubOpts topic\n             */\n\n            /**\n             * Constructs a new SubOpts.\n             * @memberof RPC\n             * @classdesc Represents a SubOpts.\n             * @implements ISubOpts\n             * @constructor\n             * @param {RPC.ISubOpts=} [p] Properties to set\n             */\n            function SubOpts(p) {\n                if (p)\n                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                        if (p[ks[i]] != null)\n                            this[ks[i]] = p[ks[i]];\n            }\n\n            /**\n             * SubOpts subscribe.\n             * @member {boolean|null|undefined} subscribe\n             * @memberof RPC.SubOpts\n             * @instance\n             */\n            SubOpts.prototype.subscribe = null;\n\n            /**\n             * SubOpts topic.\n             * @member {string|null|undefined} topic\n             * @memberof RPC.SubOpts\n             * @instance\n             */\n            SubOpts.prototype.topic = null;\n\n            // OneOf field names bound to virtual getters and setters\n            var $oneOfFields;\n\n            /**\n             * SubOpts _subscribe.\n             * @member {\"subscribe\"|undefined} _subscribe\n             * @memberof RPC.SubOpts\n             * @instance\n             */\n            Object.defineProperty(SubOpts.prototype, \"_subscribe\", {\n                get: $util.oneOfGetter($oneOfFields = [\"subscribe\"]),\n                set: $util.oneOfSetter($oneOfFields)\n            });\n\n            /**\n             * SubOpts _topic.\n             * @member {\"topic\"|undefined} _topic\n             * @memberof RPC.SubOpts\n             * @instance\n             */\n            Object.defineProperty(SubOpts.prototype, \"_topic\", {\n                get: $util.oneOfGetter($oneOfFields = [\"topic\"]),\n                set: $util.oneOfSetter($oneOfFields)\n            });\n\n            /**\n             * Encodes the specified SubOpts message. Does not implicitly {@link RPC.SubOpts.verify|verify} messages.\n             * @function encode\n             * @memberof RPC.SubOpts\n             * @static\n             * @param {RPC.ISubOpts} m SubOpts message or plain object to encode\n             * @param {$protobuf.Writer} [w] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            SubOpts.encode = function encode(m, w) {\n                if (!w)\n                    w = $Writer.create();\n                if (m.subscribe != null && Object.hasOwnProperty.call(m, \"subscribe\"))\n                    w.uint32(8).bool(m.subscribe);\n                if (m.topic != null && Object.hasOwnProperty.call(m, \"topic\"))\n                    w.uint32(18).string(m.topic);\n                return w;\n            };\n\n            /**\n             * Decodes a SubOpts message from the specified reader or buffer.\n             * @function decode\n             * @memberof RPC.SubOpts\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n             * @param {number} [l] Message length if known beforehand\n             * @returns {RPC.SubOpts} SubOpts\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            SubOpts.decode = function decode(r, l) {\n                if (!(r instanceof $Reader))\n                    r = $Reader.create(r);\n                var c = l === undefined ? r.len : r.pos + l, m = new $root.RPC.SubOpts();\n                while (r.pos < c) {\n                    var t = r.uint32();\n                    switch (t >>> 3) {\n                    case 1:\n                        m.subscribe = r.bool();\n                        break;\n                    case 2:\n                        m.topic = r.string();\n                        break;\n                    default:\n                        r.skipType(t & 7);\n                        break;\n                    }\n                }\n                return m;\n            };\n\n            /**\n             * Creates a SubOpts message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof RPC.SubOpts\n             * @static\n             * @param {Object.<string,*>} d Plain object\n             * @returns {RPC.SubOpts} SubOpts\n             */\n            SubOpts.fromObject = function fromObject(d) {\n                if (d instanceof $root.RPC.SubOpts)\n                    return d;\n                var m = new $root.RPC.SubOpts();\n                if (d.subscribe != null) {\n                    m.subscribe = Boolean(d.subscribe);\n                }\n                if (d.topic != null) {\n                    m.topic = String(d.topic);\n                }\n                return m;\n            };\n\n            /**\n             * Creates a plain object from a SubOpts message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof RPC.SubOpts\n             * @static\n             * @param {RPC.SubOpts} m SubOpts\n             * @param {$protobuf.IConversionOptions} [o] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            SubOpts.toObject = function toObject(m, o) {\n                if (!o)\n                    o = {};\n                var d = {};\n                if (m.subscribe != null && m.hasOwnProperty(\"subscribe\")) {\n                    d.subscribe = m.subscribe;\n                    if (o.oneofs)\n                        d._subscribe = \"subscribe\";\n                }\n                if (m.topic != null && m.hasOwnProperty(\"topic\")) {\n                    d.topic = m.topic;\n                    if (o.oneofs)\n                        d._topic = \"topic\";\n                }\n                return d;\n            };\n\n            /**\n             * Converts this SubOpts to JSON.\n             * @function toJSON\n             * @memberof RPC.SubOpts\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            SubOpts.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return SubOpts;\n        })();\n\n        RPC.Message = (function() {\n\n            /**\n             * Properties of a Message.\n             * @memberof RPC\n             * @interface IMessage\n             * @property {Uint8Array|null} [from] Message from\n             * @property {Uint8Array|null} [data] Message data\n             * @property {Uint8Array|null} [seqno] Message seqno\n             * @property {string} topic Message topic\n             * @property {Uint8Array|null} [signature] Message signature\n             * @property {Uint8Array|null} [key] Message key\n             */\n\n            /**\n             * Constructs a new Message.\n             * @memberof RPC\n             * @classdesc Represents a Message.\n             * @implements IMessage\n             * @constructor\n             * @param {RPC.IMessage=} [p] Properties to set\n             */\n            function Message(p) {\n                if (p)\n                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                        if (p[ks[i]] != null)\n                            this[ks[i]] = p[ks[i]];\n            }\n\n            /**\n             * Message from.\n             * @member {Uint8Array|null|undefined} from\n             * @memberof RPC.Message\n             * @instance\n             */\n            Message.prototype.from = null;\n\n            /**\n             * Message data.\n             * @member {Uint8Array|null|undefined} data\n             * @memberof RPC.Message\n             * @instance\n             */\n            Message.prototype.data = null;\n\n            /**\n             * Message seqno.\n             * @member {Uint8Array|null|undefined} seqno\n             * @memberof RPC.Message\n             * @instance\n             */\n            Message.prototype.seqno = null;\n\n            /**\n             * Message topic.\n             * @member {string} topic\n             * @memberof RPC.Message\n             * @instance\n             */\n            Message.prototype.topic = \"\";\n\n            /**\n             * Message signature.\n             * @member {Uint8Array|null|undefined} signature\n             * @memberof RPC.Message\n             * @instance\n             */\n            Message.prototype.signature = null;\n\n            /**\n             * Message key.\n             * @member {Uint8Array|null|undefined} key\n             * @memberof RPC.Message\n             * @instance\n             */\n            Message.prototype.key = null;\n\n            // OneOf field names bound to virtual getters and setters\n            var $oneOfFields;\n\n            /**\n             * Message _from.\n             * @member {\"from\"|undefined} _from\n             * @memberof RPC.Message\n             * @instance\n             */\n            Object.defineProperty(Message.prototype, \"_from\", {\n                get: $util.oneOfGetter($oneOfFields = [\"from\"]),\n                set: $util.oneOfSetter($oneOfFields)\n            });\n\n            /**\n             * Message _data.\n             * @member {\"data\"|undefined} _data\n             * @memberof RPC.Message\n             * @instance\n             */\n            Object.defineProperty(Message.prototype, \"_data\", {\n                get: $util.oneOfGetter($oneOfFields = [\"data\"]),\n                set: $util.oneOfSetter($oneOfFields)\n            });\n\n            /**\n             * Message _seqno.\n             * @member {\"seqno\"|undefined} _seqno\n             * @memberof RPC.Message\n             * @instance\n             */\n            Object.defineProperty(Message.prototype, \"_seqno\", {\n                get: $util.oneOfGetter($oneOfFields = [\"seqno\"]),\n                set: $util.oneOfSetter($oneOfFields)\n            });\n\n            /**\n             * Message _signature.\n             * @member {\"signature\"|undefined} _signature\n             * @memberof RPC.Message\n             * @instance\n             */\n            Object.defineProperty(Message.prototype, \"_signature\", {\n                get: $util.oneOfGetter($oneOfFields = [\"signature\"]),\n                set: $util.oneOfSetter($oneOfFields)\n            });\n\n            /**\n             * Message _key.\n             * @member {\"key\"|undefined} _key\n             * @memberof RPC.Message\n             * @instance\n             */\n            Object.defineProperty(Message.prototype, \"_key\", {\n                get: $util.oneOfGetter($oneOfFields = [\"key\"]),\n                set: $util.oneOfSetter($oneOfFields)\n            });\n\n            /**\n             * Encodes the specified Message message. Does not implicitly {@link RPC.Message.verify|verify} messages.\n             * @function encode\n             * @memberof RPC.Message\n             * @static\n             * @param {RPC.IMessage} m Message message or plain object to encode\n             * @param {$protobuf.Writer} [w] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Message.encode = function encode(m, w) {\n                if (!w)\n                    w = $Writer.create();\n                if (m.from != null && Object.hasOwnProperty.call(m, \"from\"))\n                    w.uint32(10).bytes(m.from);\n                if (m.data != null && Object.hasOwnProperty.call(m, \"data\"))\n                    w.uint32(18).bytes(m.data);\n                if (m.seqno != null && Object.hasOwnProperty.call(m, \"seqno\"))\n                    w.uint32(26).bytes(m.seqno);\n                w.uint32(34).string(m.topic);\n                if (m.signature != null && Object.hasOwnProperty.call(m, \"signature\"))\n                    w.uint32(42).bytes(m.signature);\n                if (m.key != null && Object.hasOwnProperty.call(m, \"key\"))\n                    w.uint32(50).bytes(m.key);\n                return w;\n            };\n\n            /**\n             * Decodes a Message message from the specified reader or buffer.\n             * @function decode\n             * @memberof RPC.Message\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n             * @param {number} [l] Message length if known beforehand\n             * @returns {RPC.Message} Message\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Message.decode = function decode(r, l) {\n                if (!(r instanceof $Reader))\n                    r = $Reader.create(r);\n                var c = l === undefined ? r.len : r.pos + l, m = new $root.RPC.Message();\n                while (r.pos < c) {\n                    var t = r.uint32();\n                    switch (t >>> 3) {\n                    case 1:\n                        m.from = r.bytes();\n                        break;\n                    case 2:\n                        m.data = r.bytes();\n                        break;\n                    case 3:\n                        m.seqno = r.bytes();\n                        break;\n                    case 4:\n                        m.topic = r.string();\n                        break;\n                    case 5:\n                        m.signature = r.bytes();\n                        break;\n                    case 6:\n                        m.key = r.bytes();\n                        break;\n                    default:\n                        r.skipType(t & 7);\n                        break;\n                    }\n                }\n                if (!m.hasOwnProperty(\"topic\"))\n                    throw $util.ProtocolError(\"missing required 'topic'\", { instance: m });\n                return m;\n            };\n\n            /**\n             * Creates a Message message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof RPC.Message\n             * @static\n             * @param {Object.<string,*>} d Plain object\n             * @returns {RPC.Message} Message\n             */\n            Message.fromObject = function fromObject(d) {\n                if (d instanceof $root.RPC.Message)\n                    return d;\n                var m = new $root.RPC.Message();\n                if (d.from != null) {\n                    if (typeof d.from === \"string\")\n                        $util.base64.decode(d.from, m.from = $util.newBuffer($util.base64.length(d.from)), 0);\n                    else if (d.from.length)\n                        m.from = d.from;\n                }\n                if (d.data != null) {\n                    if (typeof d.data === \"string\")\n                        $util.base64.decode(d.data, m.data = $util.newBuffer($util.base64.length(d.data)), 0);\n                    else if (d.data.length)\n                        m.data = d.data;\n                }\n                if (d.seqno != null) {\n                    if (typeof d.seqno === \"string\")\n                        $util.base64.decode(d.seqno, m.seqno = $util.newBuffer($util.base64.length(d.seqno)), 0);\n                    else if (d.seqno.length)\n                        m.seqno = d.seqno;\n                }\n                if (d.topic != null) {\n                    m.topic = String(d.topic);\n                }\n                if (d.signature != null) {\n                    if (typeof d.signature === \"string\")\n                        $util.base64.decode(d.signature, m.signature = $util.newBuffer($util.base64.length(d.signature)), 0);\n                    else if (d.signature.length)\n                        m.signature = d.signature;\n                }\n                if (d.key != null) {\n                    if (typeof d.key === \"string\")\n                        $util.base64.decode(d.key, m.key = $util.newBuffer($util.base64.length(d.key)), 0);\n                    else if (d.key.length)\n                        m.key = d.key;\n                }\n                return m;\n            };\n\n            /**\n             * Creates a plain object from a Message message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof RPC.Message\n             * @static\n             * @param {RPC.Message} m Message\n             * @param {$protobuf.IConversionOptions} [o] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            Message.toObject = function toObject(m, o) {\n                if (!o)\n                    o = {};\n                var d = {};\n                if (o.defaults) {\n                    d.topic = \"\";\n                }\n                if (m.from != null && m.hasOwnProperty(\"from\")) {\n                    d.from = o.bytes === String ? $util.base64.encode(m.from, 0, m.from.length) : o.bytes === Array ? Array.prototype.slice.call(m.from) : m.from;\n                    if (o.oneofs)\n                        d._from = \"from\";\n                }\n                if (m.data != null && m.hasOwnProperty(\"data\")) {\n                    d.data = o.bytes === String ? $util.base64.encode(m.data, 0, m.data.length) : o.bytes === Array ? Array.prototype.slice.call(m.data) : m.data;\n                    if (o.oneofs)\n                        d._data = \"data\";\n                }\n                if (m.seqno != null && m.hasOwnProperty(\"seqno\")) {\n                    d.seqno = o.bytes === String ? $util.base64.encode(m.seqno, 0, m.seqno.length) : o.bytes === Array ? Array.prototype.slice.call(m.seqno) : m.seqno;\n                    if (o.oneofs)\n                        d._seqno = \"seqno\";\n                }\n                if (m.topic != null && m.hasOwnProperty(\"topic\")) {\n                    d.topic = m.topic;\n                }\n                if (m.signature != null && m.hasOwnProperty(\"signature\")) {\n                    d.signature = o.bytes === String ? $util.base64.encode(m.signature, 0, m.signature.length) : o.bytes === Array ? Array.prototype.slice.call(m.signature) : m.signature;\n                    if (o.oneofs)\n                        d._signature = \"signature\";\n                }\n                if (m.key != null && m.hasOwnProperty(\"key\")) {\n                    d.key = o.bytes === String ? $util.base64.encode(m.key, 0, m.key.length) : o.bytes === Array ? Array.prototype.slice.call(m.key) : m.key;\n                    if (o.oneofs)\n                        d._key = \"key\";\n                }\n                return d;\n            };\n\n            /**\n             * Converts this Message to JSON.\n             * @function toJSON\n             * @memberof RPC.Message\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            Message.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return Message;\n        })();\n\n        RPC.ControlMessage = (function() {\n\n            /**\n             * Properties of a ControlMessage.\n             * @memberof RPC\n             * @interface IControlMessage\n             * @property {Array.<RPC.IControlIHave>|null} [ihave] ControlMessage ihave\n             * @property {Array.<RPC.IControlIWant>|null} [iwant] ControlMessage iwant\n             * @property {Array.<RPC.IControlGraft>|null} [graft] ControlMessage graft\n             * @property {Array.<RPC.IControlPrune>|null} [prune] ControlMessage prune\n             */\n\n            /**\n             * Constructs a new ControlMessage.\n             * @memberof RPC\n             * @classdesc Represents a ControlMessage.\n             * @implements IControlMessage\n             * @constructor\n             * @param {RPC.IControlMessage=} [p] Properties to set\n             */\n            function ControlMessage(p) {\n                this.ihave = [];\n                this.iwant = [];\n                this.graft = [];\n                this.prune = [];\n                if (p)\n                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                        if (p[ks[i]] != null)\n                            this[ks[i]] = p[ks[i]];\n            }\n\n            /**\n             * ControlMessage ihave.\n             * @member {Array.<RPC.IControlIHave>} ihave\n             * @memberof RPC.ControlMessage\n             * @instance\n             */\n            ControlMessage.prototype.ihave = $util.emptyArray;\n\n            /**\n             * ControlMessage iwant.\n             * @member {Array.<RPC.IControlIWant>} iwant\n             * @memberof RPC.ControlMessage\n             * @instance\n             */\n            ControlMessage.prototype.iwant = $util.emptyArray;\n\n            /**\n             * ControlMessage graft.\n             * @member {Array.<RPC.IControlGraft>} graft\n             * @memberof RPC.ControlMessage\n             * @instance\n             */\n            ControlMessage.prototype.graft = $util.emptyArray;\n\n            /**\n             * ControlMessage prune.\n             * @member {Array.<RPC.IControlPrune>} prune\n             * @memberof RPC.ControlMessage\n             * @instance\n             */\n            ControlMessage.prototype.prune = $util.emptyArray;\n\n            /**\n             * Encodes the specified ControlMessage message. Does not implicitly {@link RPC.ControlMessage.verify|verify} messages.\n             * @function encode\n             * @memberof RPC.ControlMessage\n             * @static\n             * @param {RPC.IControlMessage} m ControlMessage message or plain object to encode\n             * @param {$protobuf.Writer} [w] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            ControlMessage.encode = function encode(m, w) {\n                if (!w)\n                    w = $Writer.create();\n                if (m.ihave != null && m.ihave.length) {\n                    for (var i = 0; i < m.ihave.length; ++i)\n                        $root.RPC.ControlIHave.encode(m.ihave[i], w.uint32(10).fork()).ldelim();\n                }\n                if (m.iwant != null && m.iwant.length) {\n                    for (var i = 0; i < m.iwant.length; ++i)\n                        $root.RPC.ControlIWant.encode(m.iwant[i], w.uint32(18).fork()).ldelim();\n                }\n                if (m.graft != null && m.graft.length) {\n                    for (var i = 0; i < m.graft.length; ++i)\n                        $root.RPC.ControlGraft.encode(m.graft[i], w.uint32(26).fork()).ldelim();\n                }\n                if (m.prune != null && m.prune.length) {\n                    for (var i = 0; i < m.prune.length; ++i)\n                        $root.RPC.ControlPrune.encode(m.prune[i], w.uint32(34).fork()).ldelim();\n                }\n                return w;\n            };\n\n            /**\n             * Decodes a ControlMessage message from the specified reader or buffer.\n             * @function decode\n             * @memberof RPC.ControlMessage\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n             * @param {number} [l] Message length if known beforehand\n             * @returns {RPC.ControlMessage} ControlMessage\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            ControlMessage.decode = function decode(r, l) {\n                if (!(r instanceof $Reader))\n                    r = $Reader.create(r);\n                var c = l === undefined ? r.len : r.pos + l, m = new $root.RPC.ControlMessage();\n                while (r.pos < c) {\n                    var t = r.uint32();\n                    switch (t >>> 3) {\n                    case 1:\n                        if (!(m.ihave && m.ihave.length))\n                            m.ihave = [];\n                        m.ihave.push($root.RPC.ControlIHave.decode(r, r.uint32()));\n                        break;\n                    case 2:\n                        if (!(m.iwant && m.iwant.length))\n                            m.iwant = [];\n                        m.iwant.push($root.RPC.ControlIWant.decode(r, r.uint32()));\n                        break;\n                    case 3:\n                        if (!(m.graft && m.graft.length))\n                            m.graft = [];\n                        m.graft.push($root.RPC.ControlGraft.decode(r, r.uint32()));\n                        break;\n                    case 4:\n                        if (!(m.prune && m.prune.length))\n                            m.prune = [];\n                        m.prune.push($root.RPC.ControlPrune.decode(r, r.uint32()));\n                        break;\n                    default:\n                        r.skipType(t & 7);\n                        break;\n                    }\n                }\n                return m;\n            };\n\n            /**\n             * Creates a ControlMessage message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof RPC.ControlMessage\n             * @static\n             * @param {Object.<string,*>} d Plain object\n             * @returns {RPC.ControlMessage} ControlMessage\n             */\n            ControlMessage.fromObject = function fromObject(d) {\n                if (d instanceof $root.RPC.ControlMessage)\n                    return d;\n                var m = new $root.RPC.ControlMessage();\n                if (d.ihave) {\n                    if (!Array.isArray(d.ihave))\n                        throw TypeError(\".RPC.ControlMessage.ihave: array expected\");\n                    m.ihave = [];\n                    for (var i = 0; i < d.ihave.length; ++i) {\n                        if (typeof d.ihave[i] !== \"object\")\n                            throw TypeError(\".RPC.ControlMessage.ihave: object expected\");\n                        m.ihave[i] = $root.RPC.ControlIHave.fromObject(d.ihave[i]);\n                    }\n                }\n                if (d.iwant) {\n                    if (!Array.isArray(d.iwant))\n                        throw TypeError(\".RPC.ControlMessage.iwant: array expected\");\n                    m.iwant = [];\n                    for (var i = 0; i < d.iwant.length; ++i) {\n                        if (typeof d.iwant[i] !== \"object\")\n                            throw TypeError(\".RPC.ControlMessage.iwant: object expected\");\n                        m.iwant[i] = $root.RPC.ControlIWant.fromObject(d.iwant[i]);\n                    }\n                }\n                if (d.graft) {\n                    if (!Array.isArray(d.graft))\n                        throw TypeError(\".RPC.ControlMessage.graft: array expected\");\n                    m.graft = [];\n                    for (var i = 0; i < d.graft.length; ++i) {\n                        if (typeof d.graft[i] !== \"object\")\n                            throw TypeError(\".RPC.ControlMessage.graft: object expected\");\n                        m.graft[i] = $root.RPC.ControlGraft.fromObject(d.graft[i]);\n                    }\n                }\n                if (d.prune) {\n                    if (!Array.isArray(d.prune))\n                        throw TypeError(\".RPC.ControlMessage.prune: array expected\");\n                    m.prune = [];\n                    for (var i = 0; i < d.prune.length; ++i) {\n                        if (typeof d.prune[i] !== \"object\")\n                            throw TypeError(\".RPC.ControlMessage.prune: object expected\");\n                        m.prune[i] = $root.RPC.ControlPrune.fromObject(d.prune[i]);\n                    }\n                }\n                return m;\n            };\n\n            /**\n             * Creates a plain object from a ControlMessage message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof RPC.ControlMessage\n             * @static\n             * @param {RPC.ControlMessage} m ControlMessage\n             * @param {$protobuf.IConversionOptions} [o] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            ControlMessage.toObject = function toObject(m, o) {\n                if (!o)\n                    o = {};\n                var d = {};\n                if (o.arrays || o.defaults) {\n                    d.ihave = [];\n                    d.iwant = [];\n                    d.graft = [];\n                    d.prune = [];\n                }\n                if (m.ihave && m.ihave.length) {\n                    d.ihave = [];\n                    for (var j = 0; j < m.ihave.length; ++j) {\n                        d.ihave[j] = $root.RPC.ControlIHave.toObject(m.ihave[j], o);\n                    }\n                }\n                if (m.iwant && m.iwant.length) {\n                    d.iwant = [];\n                    for (var j = 0; j < m.iwant.length; ++j) {\n                        d.iwant[j] = $root.RPC.ControlIWant.toObject(m.iwant[j], o);\n                    }\n                }\n                if (m.graft && m.graft.length) {\n                    d.graft = [];\n                    for (var j = 0; j < m.graft.length; ++j) {\n                        d.graft[j] = $root.RPC.ControlGraft.toObject(m.graft[j], o);\n                    }\n                }\n                if (m.prune && m.prune.length) {\n                    d.prune = [];\n                    for (var j = 0; j < m.prune.length; ++j) {\n                        d.prune[j] = $root.RPC.ControlPrune.toObject(m.prune[j], o);\n                    }\n                }\n                return d;\n            };\n\n            /**\n             * Converts this ControlMessage to JSON.\n             * @function toJSON\n             * @memberof RPC.ControlMessage\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            ControlMessage.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return ControlMessage;\n        })();\n\n        RPC.ControlIHave = (function() {\n\n            /**\n             * Properties of a ControlIHave.\n             * @memberof RPC\n             * @interface IControlIHave\n             * @property {string|null} [topicID] ControlIHave topicID\n             * @property {Array.<Uint8Array>|null} [messageIDs] ControlIHave messageIDs\n             */\n\n            /**\n             * Constructs a new ControlIHave.\n             * @memberof RPC\n             * @classdesc Represents a ControlIHave.\n             * @implements IControlIHave\n             * @constructor\n             * @param {RPC.IControlIHave=} [p] Properties to set\n             */\n            function ControlIHave(p) {\n                this.messageIDs = [];\n                if (p)\n                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                        if (p[ks[i]] != null)\n                            this[ks[i]] = p[ks[i]];\n            }\n\n            /**\n             * ControlIHave topicID.\n             * @member {string|null|undefined} topicID\n             * @memberof RPC.ControlIHave\n             * @instance\n             */\n            ControlIHave.prototype.topicID = null;\n\n            /**\n             * ControlIHave messageIDs.\n             * @member {Array.<Uint8Array>} messageIDs\n             * @memberof RPC.ControlIHave\n             * @instance\n             */\n            ControlIHave.prototype.messageIDs = $util.emptyArray;\n\n            // OneOf field names bound to virtual getters and setters\n            var $oneOfFields;\n\n            /**\n             * ControlIHave _topicID.\n             * @member {\"topicID\"|undefined} _topicID\n             * @memberof RPC.ControlIHave\n             * @instance\n             */\n            Object.defineProperty(ControlIHave.prototype, \"_topicID\", {\n                get: $util.oneOfGetter($oneOfFields = [\"topicID\"]),\n                set: $util.oneOfSetter($oneOfFields)\n            });\n\n            /**\n             * Encodes the specified ControlIHave message. Does not implicitly {@link RPC.ControlIHave.verify|verify} messages.\n             * @function encode\n             * @memberof RPC.ControlIHave\n             * @static\n             * @param {RPC.IControlIHave} m ControlIHave message or plain object to encode\n             * @param {$protobuf.Writer} [w] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            ControlIHave.encode = function encode(m, w) {\n                if (!w)\n                    w = $Writer.create();\n                if (m.topicID != null && Object.hasOwnProperty.call(m, \"topicID\"))\n                    w.uint32(10).string(m.topicID);\n                if (m.messageIDs != null && m.messageIDs.length) {\n                    for (var i = 0; i < m.messageIDs.length; ++i)\n                        w.uint32(18).bytes(m.messageIDs[i]);\n                }\n                return w;\n            };\n\n            /**\n             * Decodes a ControlIHave message from the specified reader or buffer.\n             * @function decode\n             * @memberof RPC.ControlIHave\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n             * @param {number} [l] Message length if known beforehand\n             * @returns {RPC.ControlIHave} ControlIHave\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            ControlIHave.decode = function decode(r, l) {\n                if (!(r instanceof $Reader))\n                    r = $Reader.create(r);\n                var c = l === undefined ? r.len : r.pos + l, m = new $root.RPC.ControlIHave();\n                while (r.pos < c) {\n                    var t = r.uint32();\n                    switch (t >>> 3) {\n                    case 1:\n                        m.topicID = r.string();\n                        break;\n                    case 2:\n                        if (!(m.messageIDs && m.messageIDs.length))\n                            m.messageIDs = [];\n                        m.messageIDs.push(r.bytes());\n                        break;\n                    default:\n                        r.skipType(t & 7);\n                        break;\n                    }\n                }\n                return m;\n            };\n\n            /**\n             * Creates a ControlIHave message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof RPC.ControlIHave\n             * @static\n             * @param {Object.<string,*>} d Plain object\n             * @returns {RPC.ControlIHave} ControlIHave\n             */\n            ControlIHave.fromObject = function fromObject(d) {\n                if (d instanceof $root.RPC.ControlIHave)\n                    return d;\n                var m = new $root.RPC.ControlIHave();\n                if (d.topicID != null) {\n                    m.topicID = String(d.topicID);\n                }\n                if (d.messageIDs) {\n                    if (!Array.isArray(d.messageIDs))\n                        throw TypeError(\".RPC.ControlIHave.messageIDs: array expected\");\n                    m.messageIDs = [];\n                    for (var i = 0; i < d.messageIDs.length; ++i) {\n                        if (typeof d.messageIDs[i] === \"string\")\n                            $util.base64.decode(d.messageIDs[i], m.messageIDs[i] = $util.newBuffer($util.base64.length(d.messageIDs[i])), 0);\n                        else if (d.messageIDs[i].length)\n                            m.messageIDs[i] = d.messageIDs[i];\n                    }\n                }\n                return m;\n            };\n\n            /**\n             * Creates a plain object from a ControlIHave message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof RPC.ControlIHave\n             * @static\n             * @param {RPC.ControlIHave} m ControlIHave\n             * @param {$protobuf.IConversionOptions} [o] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            ControlIHave.toObject = function toObject(m, o) {\n                if (!o)\n                    o = {};\n                var d = {};\n                if (o.arrays || o.defaults) {\n                    d.messageIDs = [];\n                }\n                if (m.topicID != null && m.hasOwnProperty(\"topicID\")) {\n                    d.topicID = m.topicID;\n                    if (o.oneofs)\n                        d._topicID = \"topicID\";\n                }\n                if (m.messageIDs && m.messageIDs.length) {\n                    d.messageIDs = [];\n                    for (var j = 0; j < m.messageIDs.length; ++j) {\n                        d.messageIDs[j] = o.bytes === String ? $util.base64.encode(m.messageIDs[j], 0, m.messageIDs[j].length) : o.bytes === Array ? Array.prototype.slice.call(m.messageIDs[j]) : m.messageIDs[j];\n                    }\n                }\n                return d;\n            };\n\n            /**\n             * Converts this ControlIHave to JSON.\n             * @function toJSON\n             * @memberof RPC.ControlIHave\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            ControlIHave.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return ControlIHave;\n        })();\n\n        RPC.ControlIWant = (function() {\n\n            /**\n             * Properties of a ControlIWant.\n             * @memberof RPC\n             * @interface IControlIWant\n             * @property {Array.<Uint8Array>|null} [messageIDs] ControlIWant messageIDs\n             */\n\n            /**\n             * Constructs a new ControlIWant.\n             * @memberof RPC\n             * @classdesc Represents a ControlIWant.\n             * @implements IControlIWant\n             * @constructor\n             * @param {RPC.IControlIWant=} [p] Properties to set\n             */\n            function ControlIWant(p) {\n                this.messageIDs = [];\n                if (p)\n                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                        if (p[ks[i]] != null)\n                            this[ks[i]] = p[ks[i]];\n            }\n\n            /**\n             * ControlIWant messageIDs.\n             * @member {Array.<Uint8Array>} messageIDs\n             * @memberof RPC.ControlIWant\n             * @instance\n             */\n            ControlIWant.prototype.messageIDs = $util.emptyArray;\n\n            /**\n             * Encodes the specified ControlIWant message. Does not implicitly {@link RPC.ControlIWant.verify|verify} messages.\n             * @function encode\n             * @memberof RPC.ControlIWant\n             * @static\n             * @param {RPC.IControlIWant} m ControlIWant message or plain object to encode\n             * @param {$protobuf.Writer} [w] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            ControlIWant.encode = function encode(m, w) {\n                if (!w)\n                    w = $Writer.create();\n                if (m.messageIDs != null && m.messageIDs.length) {\n                    for (var i = 0; i < m.messageIDs.length; ++i)\n                        w.uint32(10).bytes(m.messageIDs[i]);\n                }\n                return w;\n            };\n\n            /**\n             * Decodes a ControlIWant message from the specified reader or buffer.\n             * @function decode\n             * @memberof RPC.ControlIWant\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n             * @param {number} [l] Message length if known beforehand\n             * @returns {RPC.ControlIWant} ControlIWant\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            ControlIWant.decode = function decode(r, l) {\n                if (!(r instanceof $Reader))\n                    r = $Reader.create(r);\n                var c = l === undefined ? r.len : r.pos + l, m = new $root.RPC.ControlIWant();\n                while (r.pos < c) {\n                    var t = r.uint32();\n                    switch (t >>> 3) {\n                    case 1:\n                        if (!(m.messageIDs && m.messageIDs.length))\n                            m.messageIDs = [];\n                        m.messageIDs.push(r.bytes());\n                        break;\n                    default:\n                        r.skipType(t & 7);\n                        break;\n                    }\n                }\n                return m;\n            };\n\n            /**\n             * Creates a ControlIWant message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof RPC.ControlIWant\n             * @static\n             * @param {Object.<string,*>} d Plain object\n             * @returns {RPC.ControlIWant} ControlIWant\n             */\n            ControlIWant.fromObject = function fromObject(d) {\n                if (d instanceof $root.RPC.ControlIWant)\n                    return d;\n                var m = new $root.RPC.ControlIWant();\n                if (d.messageIDs) {\n                    if (!Array.isArray(d.messageIDs))\n                        throw TypeError(\".RPC.ControlIWant.messageIDs: array expected\");\n                    m.messageIDs = [];\n                    for (var i = 0; i < d.messageIDs.length; ++i) {\n                        if (typeof d.messageIDs[i] === \"string\")\n                            $util.base64.decode(d.messageIDs[i], m.messageIDs[i] = $util.newBuffer($util.base64.length(d.messageIDs[i])), 0);\n                        else if (d.messageIDs[i].length)\n                            m.messageIDs[i] = d.messageIDs[i];\n                    }\n                }\n                return m;\n            };\n\n            /**\n             * Creates a plain object from a ControlIWant message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof RPC.ControlIWant\n             * @static\n             * @param {RPC.ControlIWant} m ControlIWant\n             * @param {$protobuf.IConversionOptions} [o] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            ControlIWant.toObject = function toObject(m, o) {\n                if (!o)\n                    o = {};\n                var d = {};\n                if (o.arrays || o.defaults) {\n                    d.messageIDs = [];\n                }\n                if (m.messageIDs && m.messageIDs.length) {\n                    d.messageIDs = [];\n                    for (var j = 0; j < m.messageIDs.length; ++j) {\n                        d.messageIDs[j] = o.bytes === String ? $util.base64.encode(m.messageIDs[j], 0, m.messageIDs[j].length) : o.bytes === Array ? Array.prototype.slice.call(m.messageIDs[j]) : m.messageIDs[j];\n                    }\n                }\n                return d;\n            };\n\n            /**\n             * Converts this ControlIWant to JSON.\n             * @function toJSON\n             * @memberof RPC.ControlIWant\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            ControlIWant.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return ControlIWant;\n        })();\n\n        RPC.ControlGraft = (function() {\n\n            /**\n             * Properties of a ControlGraft.\n             * @memberof RPC\n             * @interface IControlGraft\n             * @property {string|null} [topicID] ControlGraft topicID\n             */\n\n            /**\n             * Constructs a new ControlGraft.\n             * @memberof RPC\n             * @classdesc Represents a ControlGraft.\n             * @implements IControlGraft\n             * @constructor\n             * @param {RPC.IControlGraft=} [p] Properties to set\n             */\n            function ControlGraft(p) {\n                if (p)\n                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                        if (p[ks[i]] != null)\n                            this[ks[i]] = p[ks[i]];\n            }\n\n            /**\n             * ControlGraft topicID.\n             * @member {string|null|undefined} topicID\n             * @memberof RPC.ControlGraft\n             * @instance\n             */\n            ControlGraft.prototype.topicID = null;\n\n            // OneOf field names bound to virtual getters and setters\n            var $oneOfFields;\n\n            /**\n             * ControlGraft _topicID.\n             * @member {\"topicID\"|undefined} _topicID\n             * @memberof RPC.ControlGraft\n             * @instance\n             */\n            Object.defineProperty(ControlGraft.prototype, \"_topicID\", {\n                get: $util.oneOfGetter($oneOfFields = [\"topicID\"]),\n                set: $util.oneOfSetter($oneOfFields)\n            });\n\n            /**\n             * Encodes the specified ControlGraft message. Does not implicitly {@link RPC.ControlGraft.verify|verify} messages.\n             * @function encode\n             * @memberof RPC.ControlGraft\n             * @static\n             * @param {RPC.IControlGraft} m ControlGraft message or plain object to encode\n             * @param {$protobuf.Writer} [w] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            ControlGraft.encode = function encode(m, w) {\n                if (!w)\n                    w = $Writer.create();\n                if (m.topicID != null && Object.hasOwnProperty.call(m, \"topicID\"))\n                    w.uint32(10).string(m.topicID);\n                return w;\n            };\n\n            /**\n             * Decodes a ControlGraft message from the specified reader or buffer.\n             * @function decode\n             * @memberof RPC.ControlGraft\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n             * @param {number} [l] Message length if known beforehand\n             * @returns {RPC.ControlGraft} ControlGraft\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            ControlGraft.decode = function decode(r, l) {\n                if (!(r instanceof $Reader))\n                    r = $Reader.create(r);\n                var c = l === undefined ? r.len : r.pos + l, m = new $root.RPC.ControlGraft();\n                while (r.pos < c) {\n                    var t = r.uint32();\n                    switch (t >>> 3) {\n                    case 1:\n                        m.topicID = r.string();\n                        break;\n                    default:\n                        r.skipType(t & 7);\n                        break;\n                    }\n                }\n                return m;\n            };\n\n            /**\n             * Creates a ControlGraft message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof RPC.ControlGraft\n             * @static\n             * @param {Object.<string,*>} d Plain object\n             * @returns {RPC.ControlGraft} ControlGraft\n             */\n            ControlGraft.fromObject = function fromObject(d) {\n                if (d instanceof $root.RPC.ControlGraft)\n                    return d;\n                var m = new $root.RPC.ControlGraft();\n                if (d.topicID != null) {\n                    m.topicID = String(d.topicID);\n                }\n                return m;\n            };\n\n            /**\n             * Creates a plain object from a ControlGraft message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof RPC.ControlGraft\n             * @static\n             * @param {RPC.ControlGraft} m ControlGraft\n             * @param {$protobuf.IConversionOptions} [o] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            ControlGraft.toObject = function toObject(m, o) {\n                if (!o)\n                    o = {};\n                var d = {};\n                if (m.topicID != null && m.hasOwnProperty(\"topicID\")) {\n                    d.topicID = m.topicID;\n                    if (o.oneofs)\n                        d._topicID = \"topicID\";\n                }\n                return d;\n            };\n\n            /**\n             * Converts this ControlGraft to JSON.\n             * @function toJSON\n             * @memberof RPC.ControlGraft\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            ControlGraft.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return ControlGraft;\n        })();\n\n        RPC.ControlPrune = (function() {\n\n            /**\n             * Properties of a ControlPrune.\n             * @memberof RPC\n             * @interface IControlPrune\n             * @property {string|null} [topicID] ControlPrune topicID\n             * @property {Array.<RPC.IPeerInfo>|null} [peers] ControlPrune peers\n             * @property {number|null} [backoff] ControlPrune backoff\n             */\n\n            /**\n             * Constructs a new ControlPrune.\n             * @memberof RPC\n             * @classdesc Represents a ControlPrune.\n             * @implements IControlPrune\n             * @constructor\n             * @param {RPC.IControlPrune=} [p] Properties to set\n             */\n            function ControlPrune(p) {\n                this.peers = [];\n                if (p)\n                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                        if (p[ks[i]] != null)\n                            this[ks[i]] = p[ks[i]];\n            }\n\n            /**\n             * ControlPrune topicID.\n             * @member {string|null|undefined} topicID\n             * @memberof RPC.ControlPrune\n             * @instance\n             */\n            ControlPrune.prototype.topicID = null;\n\n            /**\n             * ControlPrune peers.\n             * @member {Array.<RPC.IPeerInfo>} peers\n             * @memberof RPC.ControlPrune\n             * @instance\n             */\n            ControlPrune.prototype.peers = $util.emptyArray;\n\n            /**\n             * ControlPrune backoff.\n             * @member {number|null|undefined} backoff\n             * @memberof RPC.ControlPrune\n             * @instance\n             */\n            ControlPrune.prototype.backoff = null;\n\n            // OneOf field names bound to virtual getters and setters\n            var $oneOfFields;\n\n            /**\n             * ControlPrune _topicID.\n             * @member {\"topicID\"|undefined} _topicID\n             * @memberof RPC.ControlPrune\n             * @instance\n             */\n            Object.defineProperty(ControlPrune.prototype, \"_topicID\", {\n                get: $util.oneOfGetter($oneOfFields = [\"topicID\"]),\n                set: $util.oneOfSetter($oneOfFields)\n            });\n\n            /**\n             * ControlPrune _backoff.\n             * @member {\"backoff\"|undefined} _backoff\n             * @memberof RPC.ControlPrune\n             * @instance\n             */\n            Object.defineProperty(ControlPrune.prototype, \"_backoff\", {\n                get: $util.oneOfGetter($oneOfFields = [\"backoff\"]),\n                set: $util.oneOfSetter($oneOfFields)\n            });\n\n            /**\n             * Encodes the specified ControlPrune message. Does not implicitly {@link RPC.ControlPrune.verify|verify} messages.\n             * @function encode\n             * @memberof RPC.ControlPrune\n             * @static\n             * @param {RPC.IControlPrune} m ControlPrune message or plain object to encode\n             * @param {$protobuf.Writer} [w] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            ControlPrune.encode = function encode(m, w) {\n                if (!w)\n                    w = $Writer.create();\n                if (m.topicID != null && Object.hasOwnProperty.call(m, \"topicID\"))\n                    w.uint32(10).string(m.topicID);\n                if (m.peers != null && m.peers.length) {\n                    for (var i = 0; i < m.peers.length; ++i)\n                        $root.RPC.PeerInfo.encode(m.peers[i], w.uint32(18).fork()).ldelim();\n                }\n                if (m.backoff != null && Object.hasOwnProperty.call(m, \"backoff\"))\n                    w.uint32(24).uint64(m.backoff);\n                return w;\n            };\n\n            /**\n             * Decodes a ControlPrune message from the specified reader or buffer.\n             * @function decode\n             * @memberof RPC.ControlPrune\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n             * @param {number} [l] Message length if known beforehand\n             * @returns {RPC.ControlPrune} ControlPrune\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            ControlPrune.decode = function decode(r, l) {\n                if (!(r instanceof $Reader))\n                    r = $Reader.create(r);\n                var c = l === undefined ? r.len : r.pos + l, m = new $root.RPC.ControlPrune();\n                while (r.pos < c) {\n                    var t = r.uint32();\n                    switch (t >>> 3) {\n                    case 1:\n                        m.topicID = r.string();\n                        break;\n                    case 2:\n                        if (!(m.peers && m.peers.length))\n                            m.peers = [];\n                        m.peers.push($root.RPC.PeerInfo.decode(r, r.uint32()));\n                        break;\n                    case 3:\n                        m.backoff = r.uint64();\n                        break;\n                    default:\n                        r.skipType(t & 7);\n                        break;\n                    }\n                }\n                return m;\n            };\n\n            /**\n             * Creates a ControlPrune message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof RPC.ControlPrune\n             * @static\n             * @param {Object.<string,*>} d Plain object\n             * @returns {RPC.ControlPrune} ControlPrune\n             */\n            ControlPrune.fromObject = function fromObject(d) {\n                if (d instanceof $root.RPC.ControlPrune)\n                    return d;\n                var m = new $root.RPC.ControlPrune();\n                if (d.topicID != null) {\n                    m.topicID = String(d.topicID);\n                }\n                if (d.peers) {\n                    if (!Array.isArray(d.peers))\n                        throw TypeError(\".RPC.ControlPrune.peers: array expected\");\n                    m.peers = [];\n                    for (var i = 0; i < d.peers.length; ++i) {\n                        if (typeof d.peers[i] !== \"object\")\n                            throw TypeError(\".RPC.ControlPrune.peers: object expected\");\n                        m.peers[i] = $root.RPC.PeerInfo.fromObject(d.peers[i]);\n                    }\n                }\n                if (d.backoff != null) {\n                    if ($util.Long)\n                        (m.backoff = $util.Long.fromValue(d.backoff)).unsigned = true;\n                    else if (typeof d.backoff === \"string\")\n                        m.backoff = parseInt(d.backoff, 10);\n                    else if (typeof d.backoff === \"number\")\n                        m.backoff = d.backoff;\n                    else if (typeof d.backoff === \"object\")\n                        m.backoff = new $util.LongBits(d.backoff.low >>> 0, d.backoff.high >>> 0).toNumber(true);\n                }\n                return m;\n            };\n\n            /**\n             * Creates a plain object from a ControlPrune message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof RPC.ControlPrune\n             * @static\n             * @param {RPC.ControlPrune} m ControlPrune\n             * @param {$protobuf.IConversionOptions} [o] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            ControlPrune.toObject = function toObject(m, o) {\n                if (!o)\n                    o = {};\n                var d = {};\n                if (o.arrays || o.defaults) {\n                    d.peers = [];\n                }\n                if (m.topicID != null && m.hasOwnProperty(\"topicID\")) {\n                    d.topicID = m.topicID;\n                    if (o.oneofs)\n                        d._topicID = \"topicID\";\n                }\n                if (m.peers && m.peers.length) {\n                    d.peers = [];\n                    for (var j = 0; j < m.peers.length; ++j) {\n                        d.peers[j] = $root.RPC.PeerInfo.toObject(m.peers[j], o);\n                    }\n                }\n                if (m.backoff != null && m.hasOwnProperty(\"backoff\")) {\n                    if (typeof m.backoff === \"number\")\n                        d.backoff = o.longs === String ? String(m.backoff) : m.backoff;\n                    else\n                        d.backoff = o.longs === String ? $util.Long.prototype.toString.call(m.backoff) : o.longs === Number ? new $util.LongBits(m.backoff.low >>> 0, m.backoff.high >>> 0).toNumber(true) : m.backoff;\n                    if (o.oneofs)\n                        d._backoff = \"backoff\";\n                }\n                return d;\n            };\n\n            /**\n             * Converts this ControlPrune to JSON.\n             * @function toJSON\n             * @memberof RPC.ControlPrune\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            ControlPrune.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return ControlPrune;\n        })();\n\n        RPC.PeerInfo = (function() {\n\n            /**\n             * Properties of a PeerInfo.\n             * @memberof RPC\n             * @interface IPeerInfo\n             * @property {Uint8Array|null} [peerID] PeerInfo peerID\n             * @property {Uint8Array|null} [signedPeerRecord] PeerInfo signedPeerRecord\n             */\n\n            /**\n             * Constructs a new PeerInfo.\n             * @memberof RPC\n             * @classdesc Represents a PeerInfo.\n             * @implements IPeerInfo\n             * @constructor\n             * @param {RPC.IPeerInfo=} [p] Properties to set\n             */\n            function PeerInfo(p) {\n                if (p)\n                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                        if (p[ks[i]] != null)\n                            this[ks[i]] = p[ks[i]];\n            }\n\n            /**\n             * PeerInfo peerID.\n             * @member {Uint8Array|null|undefined} peerID\n             * @memberof RPC.PeerInfo\n             * @instance\n             */\n            PeerInfo.prototype.peerID = null;\n\n            /**\n             * PeerInfo signedPeerRecord.\n             * @member {Uint8Array|null|undefined} signedPeerRecord\n             * @memberof RPC.PeerInfo\n             * @instance\n             */\n            PeerInfo.prototype.signedPeerRecord = null;\n\n            // OneOf field names bound to virtual getters and setters\n            var $oneOfFields;\n\n            /**\n             * PeerInfo _peerID.\n             * @member {\"peerID\"|undefined} _peerID\n             * @memberof RPC.PeerInfo\n             * @instance\n             */\n            Object.defineProperty(PeerInfo.prototype, \"_peerID\", {\n                get: $util.oneOfGetter($oneOfFields = [\"peerID\"]),\n                set: $util.oneOfSetter($oneOfFields)\n            });\n\n            /**\n             * PeerInfo _signedPeerRecord.\n             * @member {\"signedPeerRecord\"|undefined} _signedPeerRecord\n             * @memberof RPC.PeerInfo\n             * @instance\n             */\n            Object.defineProperty(PeerInfo.prototype, \"_signedPeerRecord\", {\n                get: $util.oneOfGetter($oneOfFields = [\"signedPeerRecord\"]),\n                set: $util.oneOfSetter($oneOfFields)\n            });\n\n            /**\n             * Encodes the specified PeerInfo message. Does not implicitly {@link RPC.PeerInfo.verify|verify} messages.\n             * @function encode\n             * @memberof RPC.PeerInfo\n             * @static\n             * @param {RPC.IPeerInfo} m PeerInfo message or plain object to encode\n             * @param {$protobuf.Writer} [w] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            PeerInfo.encode = function encode(m, w) {\n                if (!w)\n                    w = $Writer.create();\n                if (m.peerID != null && Object.hasOwnProperty.call(m, \"peerID\"))\n                    w.uint32(10).bytes(m.peerID);\n                if (m.signedPeerRecord != null && Object.hasOwnProperty.call(m, \"signedPeerRecord\"))\n                    w.uint32(18).bytes(m.signedPeerRecord);\n                return w;\n            };\n\n            /**\n             * Decodes a PeerInfo message from the specified reader or buffer.\n             * @function decode\n             * @memberof RPC.PeerInfo\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n             * @param {number} [l] Message length if known beforehand\n             * @returns {RPC.PeerInfo} PeerInfo\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            PeerInfo.decode = function decode(r, l) {\n                if (!(r instanceof $Reader))\n                    r = $Reader.create(r);\n                var c = l === undefined ? r.len : r.pos + l, m = new $root.RPC.PeerInfo();\n                while (r.pos < c) {\n                    var t = r.uint32();\n                    switch (t >>> 3) {\n                    case 1:\n                        m.peerID = r.bytes();\n                        break;\n                    case 2:\n                        m.signedPeerRecord = r.bytes();\n                        break;\n                    default:\n                        r.skipType(t & 7);\n                        break;\n                    }\n                }\n                return m;\n            };\n\n            /**\n             * Creates a PeerInfo message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof RPC.PeerInfo\n             * @static\n             * @param {Object.<string,*>} d Plain object\n             * @returns {RPC.PeerInfo} PeerInfo\n             */\n            PeerInfo.fromObject = function fromObject(d) {\n                if (d instanceof $root.RPC.PeerInfo)\n                    return d;\n                var m = new $root.RPC.PeerInfo();\n                if (d.peerID != null) {\n                    if (typeof d.peerID === \"string\")\n                        $util.base64.decode(d.peerID, m.peerID = $util.newBuffer($util.base64.length(d.peerID)), 0);\n                    else if (d.peerID.length)\n                        m.peerID = d.peerID;\n                }\n                if (d.signedPeerRecord != null) {\n                    if (typeof d.signedPeerRecord === \"string\")\n                        $util.base64.decode(d.signedPeerRecord, m.signedPeerRecord = $util.newBuffer($util.base64.length(d.signedPeerRecord)), 0);\n                    else if (d.signedPeerRecord.length)\n                        m.signedPeerRecord = d.signedPeerRecord;\n                }\n                return m;\n            };\n\n            /**\n             * Creates a plain object from a PeerInfo message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof RPC.PeerInfo\n             * @static\n             * @param {RPC.PeerInfo} m PeerInfo\n             * @param {$protobuf.IConversionOptions} [o] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            PeerInfo.toObject = function toObject(m, o) {\n                if (!o)\n                    o = {};\n                var d = {};\n                if (m.peerID != null && m.hasOwnProperty(\"peerID\")) {\n                    d.peerID = o.bytes === String ? $util.base64.encode(m.peerID, 0, m.peerID.length) : o.bytes === Array ? Array.prototype.slice.call(m.peerID) : m.peerID;\n                    if (o.oneofs)\n                        d._peerID = \"peerID\";\n                }\n                if (m.signedPeerRecord != null && m.hasOwnProperty(\"signedPeerRecord\")) {\n                    d.signedPeerRecord = o.bytes === String ? $util.base64.encode(m.signedPeerRecord, 0, m.signedPeerRecord.length) : o.bytes === Array ? Array.prototype.slice.call(m.signedPeerRecord) : m.signedPeerRecord;\n                    if (o.oneofs)\n                        d._signedPeerRecord = \"signedPeerRecord\";\n                }\n                return d;\n            };\n\n            /**\n             * Converts this PeerInfo to JSON.\n             * @function toJSON\n             * @memberof RPC.PeerInfo\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            PeerInfo.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return PeerInfo;\n        })();\n\n        return RPC;\n    })();\n\n    return $root;\n});\n", "'use strict';\n\n/**\n * Custom implementation of a double ended queue.\n */\nfunction Denque(array, options) {\n  var options = options || {};\n  this._capacity = options.capacity;\n\n  this._head = 0;\n  this._tail = 0;\n\n  if (Array.isArray(array)) {\n    this._fromArray(array);\n  } else {\n    this._capacityMask = 0x3;\n    this._list = new Array(4);\n  }\n}\n\n/**\n * --------------\n *  PUBLIC API\n * -------------\n */\n\n/**\n * Returns the item at the specified index from the list.\n * 0 is the first element, 1 is the second, and so on...\n * Elements at negative values are that many from the end: -1 is one before the end\n * (the last element), -2 is two before the end (one before last), etc.\n * @param index\n * @returns {*}\n */\nDenque.prototype.peekAt = function peekAt(index) {\n  var i = index;\n  // expect a number or return undefined\n  if ((i !== (i | 0))) {\n    return void 0;\n  }\n  var len = this.size();\n  if (i >= len || i < -len) return undefined;\n  if (i < 0) i += len;\n  i = (this._head + i) & this._capacityMask;\n  return this._list[i];\n};\n\n/**\n * Alias for peekAt()\n * @param i\n * @returns {*}\n */\nDenque.prototype.get = function get(i) {\n  return this.peekAt(i);\n};\n\n/**\n * Returns the first item in the list without removing it.\n * @returns {*}\n */\nDenque.prototype.peek = function peek() {\n  if (this._head === this._tail) return undefined;\n  return this._list[this._head];\n};\n\n/**\n * Alias for peek()\n * @returns {*}\n */\nDenque.prototype.peekFront = function peekFront() {\n  return this.peek();\n};\n\n/**\n * Returns the item that is at the back of the queue without removing it.\n * Uses peekAt(-1)\n */\nDenque.prototype.peekBack = function peekBack() {\n  return this.peekAt(-1);\n};\n\n/**\n * Returns the current length of the queue\n * @return {Number}\n */\nObject.defineProperty(Denque.prototype, 'length', {\n  get: function length() {\n    return this.size();\n  }\n});\n\n/**\n * Return the number of items on the list, or 0 if empty.\n * @returns {number}\n */\nDenque.prototype.size = function size() {\n  if (this._head === this._tail) return 0;\n  if (this._head < this._tail) return this._tail - this._head;\n  else return this._capacityMask + 1 - (this._head - this._tail);\n};\n\n/**\n * Add an item at the beginning of the list.\n * @param item\n */\nDenque.prototype.unshift = function unshift(item) {\n  if (arguments.length === 0) return this.size();\n  var len = this._list.length;\n  this._head = (this._head - 1 + len) & this._capacityMask;\n  this._list[this._head] = item;\n  if (this._tail === this._head) this._growArray();\n  if (this._capacity && this.size() > this._capacity) this.pop();\n  if (this._head < this._tail) return this._tail - this._head;\n  else return this._capacityMask + 1 - (this._head - this._tail);\n};\n\n/**\n * Remove and return the first item on the list,\n * Returns undefined if the list is empty.\n * @returns {*}\n */\nDenque.prototype.shift = function shift() {\n  var head = this._head;\n  if (head === this._tail) return undefined;\n  var item = this._list[head];\n  this._list[head] = undefined;\n  this._head = (head + 1) & this._capacityMask;\n  if (head < 2 && this._tail > 10000 && this._tail <= this._list.length >>> 2) this._shrinkArray();\n  return item;\n};\n\n/**\n * Add an item to the bottom of the list.\n * @param item\n */\nDenque.prototype.push = function push(item) {\n  if (arguments.length === 0) return this.size();\n  var tail = this._tail;\n  this._list[tail] = item;\n  this._tail = (tail + 1) & this._capacityMask;\n  if (this._tail === this._head) {\n    this._growArray();\n  }\n  if (this._capacity && this.size() > this._capacity) {\n    this.shift();\n  }\n  if (this._head < this._tail) return this._tail - this._head;\n  else return this._capacityMask + 1 - (this._head - this._tail);\n};\n\n/**\n * Remove and return the last item on the list.\n * Returns undefined if the list is empty.\n * @returns {*}\n */\nDenque.prototype.pop = function pop() {\n  var tail = this._tail;\n  if (tail === this._head) return undefined;\n  var len = this._list.length;\n  this._tail = (tail - 1 + len) & this._capacityMask;\n  var item = this._list[this._tail];\n  this._list[this._tail] = undefined;\n  if (this._head < 2 && tail > 10000 && tail <= len >>> 2) this._shrinkArray();\n  return item;\n};\n\n/**\n * Remove and return the item at the specified index from the list.\n * Returns undefined if the list is empty.\n * @param index\n * @returns {*}\n */\nDenque.prototype.removeOne = function removeOne(index) {\n  var i = index;\n  // expect a number or return undefined\n  if ((i !== (i | 0))) {\n    return void 0;\n  }\n  if (this._head === this._tail) return void 0;\n  var size = this.size();\n  var len = this._list.length;\n  if (i >= size || i < -size) return void 0;\n  if (i < 0) i += size;\n  i = (this._head + i) & this._capacityMask;\n  var item = this._list[i];\n  var k;\n  if (index < size / 2) {\n    for (k = index; k > 0; k--) {\n      this._list[i] = this._list[i = (i - 1 + len) & this._capacityMask];\n    }\n    this._list[i] = void 0;\n    this._head = (this._head + 1 + len) & this._capacityMask;\n  } else {\n    for (k = size - 1 - index; k > 0; k--) {\n      this._list[i] = this._list[i = (i + 1 + len) & this._capacityMask];\n    }\n    this._list[i] = void 0;\n    this._tail = (this._tail - 1 + len) & this._capacityMask;\n  }\n  return item;\n};\n\n/**\n * Remove number of items from the specified index from the list.\n * Returns array of removed items.\n * Returns undefined if the list is empty.\n * @param index\n * @param count\n * @returns {array}\n */\nDenque.prototype.remove = function remove(index, count) {\n  var i = index;\n  var removed;\n  var del_count = count;\n  // expect a number or return undefined\n  if ((i !== (i | 0))) {\n    return void 0;\n  }\n  if (this._head === this._tail) return void 0;\n  var size = this.size();\n  var len = this._list.length;\n  if (i >= size || i < -size || count < 1) return void 0;\n  if (i < 0) i += size;\n  if (count === 1 || !count) {\n    removed = new Array(1);\n    removed[0] = this.removeOne(i);\n    return removed;\n  }\n  if (i === 0 && i + count >= size) {\n    removed = this.toArray();\n    this.clear();\n    return removed;\n  }\n  if (i + count > size) count = size - i;\n  var k;\n  removed = new Array(count);\n  for (k = 0; k < count; k++) {\n    removed[k] = this._list[(this._head + i + k) & this._capacityMask];\n  }\n  i = (this._head + i) & this._capacityMask;\n  if (index + count === size) {\n    this._tail = (this._tail - count + len) & this._capacityMask;\n    for (k = count; k > 0; k--) {\n      this._list[i = (i + 1 + len) & this._capacityMask] = void 0;\n    }\n    return removed;\n  }\n  if (index === 0) {\n    this._head = (this._head + count + len) & this._capacityMask;\n    for (k = count - 1; k > 0; k--) {\n      this._list[i = (i + 1 + len) & this._capacityMask] = void 0;\n    }\n    return removed;\n  }\n  if (i < size / 2) {\n    this._head = (this._head + index + count + len) & this._capacityMask;\n    for (k = index; k > 0; k--) {\n      this.unshift(this._list[i = (i - 1 + len) & this._capacityMask]);\n    }\n    i = (this._head - 1 + len) & this._capacityMask;\n    while (del_count > 0) {\n      this._list[i = (i - 1 + len) & this._capacityMask] = void 0;\n      del_count--;\n    }\n    if (index < 0) this._tail = i;\n  } else {\n    this._tail = i;\n    i = (i + count + len) & this._capacityMask;\n    for (k = size - (count + index); k > 0; k--) {\n      this.push(this._list[i++]);\n    }\n    i = this._tail;\n    while (del_count > 0) {\n      this._list[i = (i + 1 + len) & this._capacityMask] = void 0;\n      del_count--;\n    }\n  }\n  if (this._head < 2 && this._tail > 10000 && this._tail <= len >>> 2) this._shrinkArray();\n  return removed;\n};\n\n/**\n * Native splice implementation.\n * Remove number of items from the specified index from the list and/or add new elements.\n * Returns array of removed items or empty array if count == 0.\n * Returns undefined if the list is empty.\n *\n * @param index\n * @param count\n * @param {...*} [elements]\n * @returns {array}\n */\nDenque.prototype.splice = function splice(index, count) {\n  var i = index;\n  // expect a number or return undefined\n  if ((i !== (i | 0))) {\n    return void 0;\n  }\n  var size = this.size();\n  if (i < 0) i += size;\n  if (i > size) return void 0;\n  if (arguments.length > 2) {\n    var k;\n    var temp;\n    var removed;\n    var arg_len = arguments.length;\n    var len = this._list.length;\n    var arguments_index = 2;\n    if (!size || i < size / 2) {\n      temp = new Array(i);\n      for (k = 0; k < i; k++) {\n        temp[k] = this._list[(this._head + k) & this._capacityMask];\n      }\n      if (count === 0) {\n        removed = [];\n        if (i > 0) {\n          this._head = (this._head + i + len) & this._capacityMask;\n        }\n      } else {\n        removed = this.remove(i, count);\n        this._head = (this._head + i + len) & this._capacityMask;\n      }\n      while (arg_len > arguments_index) {\n        this.unshift(arguments[--arg_len]);\n      }\n      for (k = i; k > 0; k--) {\n        this.unshift(temp[k - 1]);\n      }\n    } else {\n      temp = new Array(size - (i + count));\n      var leng = temp.length;\n      for (k = 0; k < leng; k++) {\n        temp[k] = this._list[(this._head + i + count + k) & this._capacityMask];\n      }\n      if (count === 0) {\n        removed = [];\n        if (i != size) {\n          this._tail = (this._head + i + len) & this._capacityMask;\n        }\n      } else {\n        removed = this.remove(i, count);\n        this._tail = (this._tail - leng + len) & this._capacityMask;\n      }\n      while (arguments_index < arg_len) {\n        this.push(arguments[arguments_index++]);\n      }\n      for (k = 0; k < leng; k++) {\n        this.push(temp[k]);\n      }\n    }\n    return removed;\n  } else {\n    return this.remove(i, count);\n  }\n};\n\n/**\n * Soft clear - does not reset capacity.\n */\nDenque.prototype.clear = function clear() {\n  this._list = new Array(this._list.length);\n  this._head = 0;\n  this._tail = 0;\n};\n\n/**\n * Returns true or false whether the list is empty.\n * @returns {boolean}\n */\nDenque.prototype.isEmpty = function isEmpty() {\n  return this._head === this._tail;\n};\n\n/**\n * Returns an array of all queue items.\n * @returns {Array}\n */\nDenque.prototype.toArray = function toArray() {\n  return this._copyArray(false);\n};\n\n/**\n * -------------\n *   INTERNALS\n * -------------\n */\n\n/**\n * Fills the queue with items from an array\n * For use in the constructor\n * @param array\n * @private\n */\nDenque.prototype._fromArray = function _fromArray(array) {\n  var length = array.length;\n  var capacity = this._nextPowerOf2(length);\n\n  this._list = new Array(capacity);\n  this._capacityMask = capacity - 1;\n  this._tail = length;\n\n  for (var i = 0; i < length; i++) this._list[i] = array[i];\n};\n\n/**\n *\n * @param fullCopy\n * @param size Initialize the array with a specific size. Will default to the current list size\n * @returns {Array}\n * @private\n */\nDenque.prototype._copyArray = function _copyArray(fullCopy, size) {\n  var src = this._list;\n  var capacity = src.length;\n  var length = this.length;\n  size = size | length;\n\n  // No prealloc requested and the buffer is contiguous\n  if (size == length && this._head < this._tail) {\n    // Simply do a fast slice copy\n    return this._list.slice(this._head, this._tail);\n  }\n\n  var dest = new Array(size);\n\n  var k = 0;\n  var i;\n  if (fullCopy || this._head > this._tail) {\n    for (i = this._head; i < capacity; i++) dest[k++] = src[i];\n    for (i = 0; i < this._tail; i++) dest[k++] = src[i];\n  } else {\n    for (i = this._head; i < this._tail; i++) dest[k++] = src[i];\n  }\n\n  return dest;\n}\n\n/**\n * Grows the internal list array.\n * @private\n */\nDenque.prototype._growArray = function _growArray() {\n  if (this._head != 0) {\n    // double array size and copy existing data, head to end, then beginning to tail.\n    var newList = this._copyArray(true, this._list.length << 1);\n\n    this._tail = this._list.length;\n    this._head = 0;\n\n    this._list = newList;\n  } else {\n    this._tail = this._list.length;\n    this._list.length <<= 1;\n  }\n\n  this._capacityMask = (this._capacityMask << 1) | 1;\n};\n\n/**\n * Shrinks the internal list array.\n * @private\n */\nDenque.prototype._shrinkArray = function _shrinkArray() {\n  this._list.length >>>= 1;\n  this._capacityMask >>>= 1;\n};\n\n/**\n * Find the next power of 2, at least 4\n * @private\n * @param {number} num \n * @returns {number}\n */\nDenque.prototype._nextPowerOf2 = function _nextPowerOf2(num) {\n  var log2 = Math.log(num) / Math.log(2);\n  var nextPow2 = 1 << (log2 + 1);\n\n  return Math.max(nextPow2, 4);\n}\n\nmodule.exports = Denque;\n", "'use strict';\n\nfunction isHighSurrogate(codePoint) {\n  return codePoint >= 0xd800 && codePoint <= 0xdbff;\n}\n\nfunction isLowSurrogate(codePoint) {\n  return codePoint >= 0xdc00 && codePoint <= 0xdfff;\n}\n\n// Truncate string by size in bytes\nmodule.exports = function truncate(getLength, string, byteLength) {\n  if (typeof string !== \"string\") {\n    throw new Error(\"Input must be string\");\n  }\n\n  var charLength = string.length;\n  var curByteLength = 0;\n  var codePoint;\n  var segment;\n\n  for (var i = 0; i < charLength; i += 1) {\n    codePoint = string.charCodeAt(i);\n    segment = string[i];\n\n    if (isHighSurrogate(codePoint) && isLowSurrogate(string.charCodeAt(i + 1))) {\n      i += 1;\n      segment += string[i];\n    }\n\n    curByteLength += getLength(segment);\n\n    if (curByteLength === byteLength) {\n      return string.slice(0, i + 1);\n    }\n    else if (curByteLength > byteLength) {\n      return string.slice(0, i - segment.length + 1);\n    }\n  }\n\n  return string;\n};\n\n", "'use strict';\n\nfunction isHighSurrogate(codePoint) {\n  return codePoint >= 0xd800 && codePoint <= 0xdbff;\n}\n\nfunction isLowSurrogate(codePoint) {\n  return codePoint >= 0xdc00 && codePoint <= 0xdfff;\n}\n\n// Truncate string by size in bytes\nmodule.exports = function getByteLength(string) {\n  if (typeof string !== \"string\") {\n    throw new Error(\"Input must be string\");\n  }\n\n  var charLength = string.length;\n  var byteLength = 0;\n  var codePoint = null;\n  var prevCodePoint = null;\n  for (var i = 0; i < charLength; i++) {\n    codePoint = string.charCodeAt(i);\n    // handle 4-byte non-BMP chars\n    // low surrogate\n    if (isLowSurrogate(codePoint)) {\n      // when parsing previous hi-surrogate, 3 is added to byteLength\n      if (prevCodePoint != null && isHighSurrogate(prevCodePoint)) {\n        byteLength += 1;\n      }\n      else {\n        byteLength += 3;\n      }\n    }\n    else if (codePoint <= 0x7f ) {\n      byteLength += 1;\n    }\n    else if (codePoint >= 0x80 && codePoint <= 0x7ff) {\n      byteLength += 2;\n    }\n    else if (codePoint >= 0x800 && codePoint <= 0xffff) {\n      byteLength += 3;\n    }\n    prevCodePoint = codePoint;\n  }\n\n  return byteLength;\n};\n", "'use strict';\n\nvar truncate = require(\"./lib/truncate\");\nvar getLength = require(\"utf8-byte-length/browser\");\nmodule.exports = truncate.bind(null, getLength);\n", "/*jshint node:true*/\n'use strict';\n\n/**\n * Replaces characters in strings that are illegal/unsafe for filenames.\n * Unsafe characters are either removed or replaced by a substitute set\n * in the optional `options` object.\n *\n * Illegal Characters on Various Operating Systems\n * / ? < > \\ : * | \"\n * https://kb.acronis.com/content/39790\n *\n * Unicode Control codes\n * C0 0x00-0x1f & C1 (0x80-0x9f)\n * http://en.wikipedia.org/wiki/C0_and_C1_control_codes\n *\n * Reserved filenames on Unix-based systems (\".\", \"..\")\n * Reserved filenames in Windows (\"CON\", \"PRN\", \"AUX\", \"NUL\", \"COM1\",\n * \"COM2\", \"COM3\", \"COM4\", \"COM5\", \"COM6\", \"COM7\", \"COM8\", \"COM9\",\n * \"LPT1\", \"LPT2\", \"LPT3\", \"LPT4\", \"LPT5\", \"LPT6\", \"LPT7\", \"LPT8\", and\n * \"LPT9\") case-insesitively and with or without filename extensions.\n *\n * Capped at 255 characters in length.\n * http://unix.stackexchange.com/questions/32795/what-is-the-maximum-allowed-filename-and-folder-size-with-ecryptfs\n *\n * @param  {String} input   Original filename\n * @param  {Object} options {replacement: String | Function }\n * @return {String}         Sanitized filename\n */\n\nvar truncate = require(\"truncate-utf8-bytes\");\n\nvar illegalRe = /[\\/\\?<>\\\\:\\*\\|\"]/g;\nvar controlRe = /[\\x00-\\x1f\\x80-\\x9f]/g;\nvar reservedRe = /^\\.+$/;\nvar windowsReservedRe = /^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\\..*)?$/i;\nvar windowsTrailingRe = /[\\. ]+$/;\n\nfunction sanitize(input, replacement) {\n  if (typeof input !== 'string') {\n    throw new Error('Input must be string');\n  }\n  var sanitized = input\n    .replace(illegalRe, replacement)\n    .replace(controlRe, replacement)\n    .replace(reservedRe, replacement)\n    .replace(windowsReservedRe, replacement)\n    .replace(windowsTrailingRe, replacement);\n  return truncate(sanitized, 255);\n}\n\nmodule.exports = function (input, options) {\n  var replacement = (options && options.replacement) || '';\n  var output = sanitize(input, replacement);\n  if (replacement === '') {\n    return output;\n  }\n  return sanitize(output, '');\n};\n", "'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n", "// Generated by CoffeeScript 1.12.7\n(function() {\n  var Netmask, atob, chr, chr0, chrA, chra, ip2long, long2ip;\n\n  long2ip = function(long) {\n    var a, b, c, d;\n    a = (long & (0xff << 24)) >>> 24;\n    b = (long & (0xff << 16)) >>> 16;\n    c = (long & (0xff << 8)) >>> 8;\n    d = long & 0xff;\n    return [a, b, c, d].join('.');\n  };\n\n  ip2long = function(ip) {\n    var b, c, i, j, n, ref;\n    b = [];\n    for (i = j = 0; j <= 3; i = ++j) {\n      if (ip.length === 0) {\n        break;\n      }\n      if (i > 0) {\n        if (ip[0] !== '.') {\n          throw new Error('Invalid IP');\n        }\n        ip = ip.substring(1);\n      }\n      ref = atob(ip), n = ref[0], c = ref[1];\n      ip = ip.substring(c);\n      b.push(n);\n    }\n    if (ip.length !== 0) {\n      throw new Error('Invalid IP');\n    }\n    switch (b.length) {\n      case 1:\n        if (b[0] > 0xFFFFFFFF) {\n          throw new Error('Invalid IP');\n        }\n        return b[0] >>> 0;\n      case 2:\n        if (b[0] > 0xFF || b[1] > 0xFFFFFF) {\n          throw new Error('Invalid IP');\n        }\n        return (b[0] << 24 | b[1]) >>> 0;\n      case 3:\n        if (b[0] > 0xFF || b[1] > 0xFF || b[2] > 0xFFFF) {\n          throw new Error('Invalid IP');\n        }\n        return (b[0] << 24 | b[1] << 16 | b[2]) >>> 0;\n      case 4:\n        if (b[0] > 0xFF || b[1] > 0xFF || b[2] > 0xFF || b[3] > 0xFF) {\n          throw new Error('Invalid IP');\n        }\n        return (b[0] << 24 | b[1] << 16 | b[2] << 8 | b[3]) >>> 0;\n      default:\n        throw new Error('Invalid IP');\n    }\n  };\n\n  chr = function(b) {\n    return b.charCodeAt(0);\n  };\n\n  chr0 = chr('0');\n\n  chra = chr('a');\n\n  chrA = chr('A');\n\n  atob = function(s) {\n    var base, dmax, i, n, start;\n    n = 0;\n    base = 10;\n    dmax = '9';\n    i = 0;\n    if (s.length > 1 && s[i] === '0') {\n      if (s[i + 1] === 'x' || s[i + 1] === 'X') {\n        i += 2;\n        base = 16;\n      } else if ('0' <= s[i + 1] && s[i + 1] <= '9') {\n        i++;\n        base = 8;\n        dmax = '7';\n      }\n    }\n    start = i;\n    while (i < s.length) {\n      if ('0' <= s[i] && s[i] <= dmax) {\n        n = (n * base + (chr(s[i]) - chr0)) >>> 0;\n      } else if (base === 16) {\n        if ('a' <= s[i] && s[i] <= 'f') {\n          n = (n * base + (10 + chr(s[i]) - chra)) >>> 0;\n        } else if ('A' <= s[i] && s[i] <= 'F') {\n          n = (n * base + (10 + chr(s[i]) - chrA)) >>> 0;\n        } else {\n          break;\n        }\n      } else {\n        break;\n      }\n      if (n > 0xFFFFFFFF) {\n        throw new Error('too large');\n      }\n      i++;\n    }\n    if (i === start) {\n      throw new Error('empty octet');\n    }\n    return [n, i];\n  };\n\n  Netmask = (function() {\n    function Netmask(net, mask) {\n      var error, i, j, ref;\n      if (typeof net !== 'string') {\n        throw new Error(\"Missing `net' parameter\");\n      }\n      if (!mask) {\n        ref = net.split('/', 2), net = ref[0], mask = ref[1];\n      }\n      if (!mask) {\n        mask = 32;\n      }\n      if (typeof mask === 'string' && mask.indexOf('.') > -1) {\n        try {\n          this.maskLong = ip2long(mask);\n        } catch (error1) {\n          error = error1;\n          throw new Error(\"Invalid mask: \" + mask);\n        }\n        for (i = j = 32; j >= 0; i = --j) {\n          if (this.maskLong === (0xffffffff << (32 - i)) >>> 0) {\n            this.bitmask = i;\n            break;\n          }\n        }\n      } else if (mask || mask === 0) {\n        this.bitmask = parseInt(mask, 10);\n        this.maskLong = 0;\n        if (this.bitmask > 0) {\n          this.maskLong = (0xffffffff << (32 - this.bitmask)) >>> 0;\n        }\n      } else {\n        throw new Error(\"Invalid mask: empty\");\n      }\n      try {\n        this.netLong = (ip2long(net) & this.maskLong) >>> 0;\n      } catch (error1) {\n        error = error1;\n        throw new Error(\"Invalid net address: \" + net);\n      }\n      if (!(this.bitmask <= 32)) {\n        throw new Error(\"Invalid mask for ip4: \" + mask);\n      }\n      this.size = Math.pow(2, 32 - this.bitmask);\n      this.base = long2ip(this.netLong);\n      this.mask = long2ip(this.maskLong);\n      this.hostmask = long2ip(~this.maskLong);\n      this.first = this.bitmask <= 30 ? long2ip(this.netLong + 1) : this.base;\n      this.last = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 2) : long2ip(this.netLong + this.size - 1);\n      this.broadcast = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 1) : void 0;\n    }\n\n    Netmask.prototype.contains = function(ip) {\n      if (typeof ip === 'string' && (ip.indexOf('/') > 0 || ip.split('.').length !== 4)) {\n        ip = new Netmask(ip);\n      }\n      if (ip instanceof Netmask) {\n        return this.contains(ip.base) && this.contains(ip.broadcast || ip.last);\n      } else {\n        return (ip2long(ip) & this.maskLong) >>> 0 === (this.netLong & this.maskLong) >>> 0;\n      }\n    };\n\n    Netmask.prototype.next = function(count) {\n      if (count == null) {\n        count = 1;\n      }\n      return new Netmask(long2ip(this.netLong + (this.size * count)), this.mask);\n    };\n\n    Netmask.prototype.forEach = function(fn) {\n      var index, lastLong, long;\n      long = ip2long(this.first);\n      lastLong = ip2long(this.last);\n      index = 0;\n      while (long <= lastLong) {\n        fn(long2ip(long), long, index);\n        index++;\n        long++;\n      }\n    };\n\n    Netmask.prototype.toString = function() {\n      return this.base + \"/\" + this.bitmask;\n    };\n\n    return Netmask;\n\n  })();\n\n  exports.ip2long = ip2long;\n\n  exports.long2ip = long2ip;\n\n  exports.Netmask = Netmask;\n\n}).call(this);\n", "(function (root) {\n    'use strict';\n    // A list of regular expressions that match arbitrary IPv4 addresses,\n    // for which a number of weird notations exist.\n    // Note that an address like 0010.0xa5.1.1 is considered legal.\n    const ipv4Part = '(0?\\\\d+|0x[a-f0-9]+)';\n    const ipv4Regexes = {\n        fourOctet: new RegExp(`^${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}$`, 'i'),\n        threeOctet: new RegExp(`^${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}$`, 'i'),\n        twoOctet: new RegExp(`^${ipv4Part}\\\\.${ipv4Part}$`, 'i'),\n        longValue: new RegExp(`^${ipv4Part}$`, 'i')\n    };\n\n    // Regular Expression for checking Octal numbers\n    const octalRegex = new RegExp(`^0[0-7]+$`, 'i');\n    const hexRegex = new RegExp(`^0x[a-f0-9]+$`, 'i');\n\n    const zoneIndex = '%[0-9a-z]{1,}';\n\n    // IPv6-matching regular expressions.\n    // For IPv6, the task is simpler: it is enough to match the colon-delimited\n    // hexadecimal IPv6 and a transitional variant with dotted-decimal IPv4 at\n    // the end.\n    const ipv6Part = '(?:[0-9a-f]+::?)+';\n    const ipv6Regexes = {\n        zoneIndex: new RegExp(zoneIndex, 'i'),\n        'native': new RegExp(`^(::)?(${ipv6Part})?([0-9a-f]+)?(::)?(${zoneIndex})?$`, 'i'),\n        deprecatedTransitional: new RegExp(`^(?:::)(${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}(${zoneIndex})?)$`, 'i'),\n        transitional: new RegExp(`^((?:${ipv6Part})|(?:::)(?:${ipv6Part})?)${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}(${zoneIndex})?$`, 'i')\n    };\n\n    // Expand :: in an IPv6 address or address part consisting of `parts` groups.\n    function expandIPv6 (string, parts) {\n        // More than one '::' means invalid adddress\n        if (string.indexOf('::') !== string.lastIndexOf('::')) {\n            return null;\n        }\n\n        let colonCount = 0;\n        let lastColon = -1;\n        let zoneId = (string.match(ipv6Regexes.zoneIndex) || [])[0];\n        let replacement, replacementCount;\n\n        // Remove zone index and save it for later\n        if (zoneId) {\n            zoneId = zoneId.substring(1);\n            string = string.replace(/%.+$/, '');\n        }\n\n        // How many parts do we already have?\n        while ((lastColon = string.indexOf(':', lastColon + 1)) >= 0) {\n            colonCount++;\n        }\n\n        // 0::0 is two parts more than ::\n        if (string.substr(0, 2) === '::') {\n            colonCount--;\n        }\n\n        if (string.substr(-2, 2) === '::') {\n            colonCount--;\n        }\n\n        // The following loop would hang if colonCount > parts\n        if (colonCount > parts) {\n            return null;\n        }\n\n        // replacement = ':' + '0:' * (parts - colonCount)\n        replacementCount = parts - colonCount;\n        replacement = ':';\n        while (replacementCount--) {\n            replacement += '0:';\n        }\n\n        // Insert the missing zeroes\n        string = string.replace('::', replacement);\n\n        // Trim any garbage which may be hanging around if :: was at the edge in\n        // the source strin\n        if (string[0] === ':') {\n            string = string.slice(1);\n        }\n\n        if (string[string.length - 1] === ':') {\n            string = string.slice(0, -1);\n        }\n\n        parts = (function () {\n            const ref = string.split(':');\n            const results = [];\n\n            for (let i = 0; i < ref.length; i++) {\n                results.push(parseInt(ref[i], 16));\n            }\n\n            return results;\n        })();\n\n        return {\n            parts: parts,\n            zoneId: zoneId\n        };\n    }\n\n    // A generic CIDR (Classless Inter-Domain Routing) RFC1518 range matcher.\n    function matchCIDR (first, second, partSize, cidrBits) {\n        if (first.length !== second.length) {\n            throw new Error('ipaddr: cannot match CIDR for objects with different lengths');\n        }\n\n        let part = 0;\n        let shift;\n\n        while (cidrBits > 0) {\n            shift = partSize - cidrBits;\n            if (shift < 0) {\n                shift = 0;\n            }\n\n            if (first[part] >> shift !== second[part] >> shift) {\n                return false;\n            }\n\n            cidrBits -= partSize;\n            part += 1;\n        }\n\n        return true;\n    }\n\n    function parseIntAuto (string) {\n        // Hexadedimal base 16 (0x#)\n        if (hexRegex.test(string)) {\n            return parseInt(string, 16);\n        }\n        // While octal representation is discouraged by ECMAScript 3\n        // and forbidden by ECMAScript 5, we silently allow it to\n        // work only if the rest of the string has numbers less than 8.\n        if (string[0] === '0' && !isNaN(parseInt(string[1], 10))) {\n        if (octalRegex.test(string)) {\n            return parseInt(string, 8);\n        }\n            throw new Error(`ipaddr: cannot parse ${string} as octal`);\n        }\n        // Always include the base 10 radix!\n        return parseInt(string, 10);\n    }\n\n    function padPart (part, length) {\n        while (part.length < length) {\n            part = `0${part}`;\n        }\n\n        return part;\n    }\n\n    const ipaddr = {};\n\n    // An IPv4 address (RFC791).\n    ipaddr.IPv4 = (function () {\n        // Constructs a new IPv4 address from an array of four octets\n        // in network order (MSB first)\n        // Verifies the input.\n        function IPv4 (octets) {\n            if (octets.length !== 4) {\n                throw new Error('ipaddr: ipv4 octet count should be 4');\n            }\n\n            let i, octet;\n\n            for (i = 0; i < octets.length; i++) {\n                octet = octets[i];\n                if (!((0 <= octet && octet <= 255))) {\n                    throw new Error('ipaddr: ipv4 octet should fit in 8 bits');\n                }\n            }\n\n            this.octets = octets;\n        }\n\n        // Special IPv4 address ranges.\n        // See also https://en.wikipedia.org/wiki/Reserved_IP_addresses\n        IPv4.prototype.SpecialRanges = {\n            unspecified: [[new IPv4([0, 0, 0, 0]), 8]],\n            broadcast: [[new IPv4([255, 255, 255, 255]), 32]],\n            // RFC3171\n            multicast: [[new IPv4([224, 0, 0, 0]), 4]],\n            // RFC3927\n            linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],\n            // RFC5735\n            loopback: [[new IPv4([127, 0, 0, 0]), 8]],\n            // RFC6598\n            carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],\n            // RFC1918\n            'private': [\n                [new IPv4([10, 0, 0, 0]), 8],\n                [new IPv4([172, 16, 0, 0]), 12],\n                [new IPv4([192, 168, 0, 0]), 16]\n            ],\n            // Reserved and testing-only ranges; RFCs 5735, 5737, 2544, 1700\n            reserved: [\n                [new IPv4([192, 0, 0, 0]), 24],\n                [new IPv4([192, 0, 2, 0]), 24],\n                [new IPv4([192, 88, 99, 0]), 24],\n                [new IPv4([198, 18, 0, 0]), 15],\n                [new IPv4([198, 51, 100, 0]), 24],\n                [new IPv4([203, 0, 113, 0]), 24],\n                [new IPv4([240, 0, 0, 0]), 4]\n            ]\n        };\n\n        // The 'kind' method exists on both IPv4 and IPv6 classes.\n        IPv4.prototype.kind = function () {\n            return 'ipv4';\n        };\n\n        // Checks if this address matches other one within given CIDR range.\n        IPv4.prototype.match = function (other, cidrRange) {\n            let ref;\n            if (cidrRange === undefined) {\n                ref = other;\n                other = ref[0];\n                cidrRange = ref[1];\n            }\n\n            if (other.kind() !== 'ipv4') {\n                throw new Error('ipaddr: cannot match ipv4 address with non-ipv4 one');\n            }\n\n            return matchCIDR(this.octets, other.octets, 8, cidrRange);\n        };\n\n        // returns a number of leading ones in IPv4 address, making sure that\n        // the rest is a solid sequence of 0's (valid netmask)\n        // returns either the CIDR length or null if mask is not valid\n        IPv4.prototype.prefixLengthFromSubnetMask = function () {\n            let cidr = 0;\n            // non-zero encountered stop scanning for zeroes\n            let stop = false;\n            // number of zeroes in octet\n            const zerotable = {\n                0: 8,\n                128: 7,\n                192: 6,\n                224: 5,\n                240: 4,\n                248: 3,\n                252: 2,\n                254: 1,\n                255: 0\n            };\n            let i, octet, zeros;\n\n            for (i = 3; i >= 0; i -= 1) {\n                octet = this.octets[i];\n                if (octet in zerotable) {\n                    zeros = zerotable[octet];\n                    if (stop && zeros !== 0) {\n                        return null;\n                    }\n\n                    if (zeros !== 8) {\n                        stop = true;\n                    }\n\n                    cidr += zeros;\n                } else {\n                    return null;\n                }\n            }\n\n            return 32 - cidr;\n        };\n\n        // Checks if the address corresponds to one of the special ranges.\n        IPv4.prototype.range = function () {\n            return ipaddr.subnetMatch(this, this.SpecialRanges);\n        };\n\n        // Returns an array of byte-sized values in network order (MSB first)\n        IPv4.prototype.toByteArray = function () {\n            return this.octets.slice(0);\n        };\n\n        // Converts this IPv4 address to an IPv4-mapped IPv6 address.\n        IPv4.prototype.toIPv4MappedAddress = function () {\n            return ipaddr.IPv6.parse(`::ffff:${this.toString()}`);\n        };\n\n        // Symmetrical method strictly for aligning with the IPv6 methods.\n        IPv4.prototype.toNormalizedString = function () {\n            return this.toString();\n        };\n\n        // Returns the address in convenient, decimal-dotted format.\n        IPv4.prototype.toString = function () {\n            return this.octets.join('.');\n        };\n\n        return IPv4;\n    })();\n\n    // A utility function to return broadcast address given the IPv4 interface and prefix length in CIDR notation\n    ipaddr.IPv4.broadcastAddressFromCIDR = function (string) {\n\n        try {\n            const cidr = this.parseCIDR(string);\n            const ipInterfaceOctets = cidr[0].toByteArray();\n            const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n            const octets = [];\n            let i = 0;\n            while (i < 4) {\n                // Broadcast address is bitwise OR between ip interface and inverted mask\n                octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);\n                i++;\n            }\n\n            return new this(octets);\n        } catch (e) {\n            throw new Error('ipaddr: the address does not have IPv4 CIDR format');\n        }\n    };\n\n    // Checks if a given string is formatted like IPv4 address.\n    ipaddr.IPv4.isIPv4 = function (string) {\n        return this.parser(string) !== null;\n    };\n\n    // Checks if a given string is a valid IPv4 address.\n    ipaddr.IPv4.isValid = function (string) {\n        try {\n            new this(this.parser(string));\n            return true;\n        } catch (e) {\n            return false;\n        }\n    };\n\n    // Checks if a given string is a full four-part IPv4 Address.\n    ipaddr.IPv4.isValidFourPartDecimal = function (string) {\n        if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\\d*)(\\.(0|[1-9]\\d*)){3}$/)) {\n            return true;\n        } else {\n            return false;\n        }\n    };\n\n    // A utility function to return network address given the IPv4 interface and prefix length in CIDR notation\n    ipaddr.IPv4.networkAddressFromCIDR = function (string) {\n        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;\n\n        try {\n            cidr = this.parseCIDR(string);\n            ipInterfaceOctets = cidr[0].toByteArray();\n            subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n            octets = [];\n            i = 0;\n            while (i < 4) {\n                // Network address is bitwise AND between ip interface and mask\n                octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));\n                i++;\n            }\n\n            return new this(octets);\n        } catch (e) {\n            throw new Error('ipaddr: the address does not have IPv4 CIDR format');\n        }\n    };\n\n    // Tries to parse and validate a string with IPv4 address.\n    // Throws an error if it fails.\n    ipaddr.IPv4.parse = function (string) {\n        const parts = this.parser(string);\n\n        if (parts === null) {\n            throw new Error('ipaddr: string is not formatted like an IPv4 Address');\n        }\n\n        return new this(parts);\n    };\n\n    // Parses the string as an IPv4 Address with CIDR Notation.\n    ipaddr.IPv4.parseCIDR = function (string) {\n        let match;\n\n        if ((match = string.match(/^(.+)\\/(\\d+)$/))) {\n            const maskLength = parseInt(match[2]);\n            if (maskLength >= 0 && maskLength <= 32) {\n                const parsed = [this.parse(match[1]), maskLength];\n                Object.defineProperty(parsed, 'toString', {\n                    value: function () {\n                        return this.join('/');\n                    }\n                });\n                return parsed;\n            }\n        }\n\n        throw new Error('ipaddr: string is not formatted like an IPv4 CIDR range');\n    };\n\n    // Classful variants (like a.b, where a is an octet, and b is a 24-bit\n    // value representing last three octets; this corresponds to a class C\n    // address) are omitted due to classless nature of modern Internet.\n    ipaddr.IPv4.parser = function (string) {\n        let match, part, value;\n\n        // parseInt recognizes all that octal & hexadecimal weirdness for us\n        if ((match = string.match(ipv4Regexes.fourOctet))) {\n            return (function () {\n                const ref = match.slice(1, 6);\n                const results = [];\n\n                for (let i = 0; i < ref.length; i++) {\n                    part = ref[i];\n                    results.push(parseIntAuto(part));\n                }\n\n                return results;\n            })();\n        } else if ((match = string.match(ipv4Regexes.longValue))) {\n            value = parseIntAuto(match[1]);\n            if (value > 0xffffffff || value < 0) {\n                throw new Error('ipaddr: address outside defined range');\n            }\n\n            return ((function () {\n                const results = [];\n                let shift;\n\n                for (shift = 0; shift <= 24; shift += 8) {\n                    results.push((value >> shift) & 0xff);\n                }\n\n                return results;\n            })()).reverse();\n        } else if ((match = string.match(ipv4Regexes.twoOctet))) {\n            return (function () {\n                const ref = match.slice(1, 4);\n                const results = [];\n\n                value = parseIntAuto(ref[1]);\n                if (value > 0xffffff || value < 0) {\n                    throw new Error('ipaddr: address outside defined range');\n                }\n\n                results.push(parseIntAuto(ref[0]));\n                results.push((value >> 16) & 0xff);\n                results.push((value >>  8) & 0xff);\n                results.push( value        & 0xff);\n\n                return results;\n            })();\n        } else if ((match = string.match(ipv4Regexes.threeOctet))) {\n            return (function () {\n                const ref = match.slice(1, 5);\n                const results = [];\n\n                value = parseIntAuto(ref[2]);\n                if (value > 0xffff || value < 0) {\n                    throw new Error('ipaddr: address outside defined range');\n                }\n\n                results.push(parseIntAuto(ref[0]));\n                results.push(parseIntAuto(ref[1]));\n                results.push((value >> 8) & 0xff);\n                results.push( value       & 0xff);\n\n                return results;\n            })();\n        } else {\n            return null;\n        }\n    };\n\n    // A utility function to return subnet mask in IPv4 format given the prefix length\n    ipaddr.IPv4.subnetMaskFromPrefixLength = function (prefix) {\n        prefix = parseInt(prefix);\n        if (prefix < 0 || prefix > 32) {\n            throw new Error('ipaddr: invalid IPv4 prefix length');\n        }\n\n        const octets = [0, 0, 0, 0];\n        let j = 0;\n        const filledOctetCount = Math.floor(prefix / 8);\n\n        while (j < filledOctetCount) {\n            octets[j] = 255;\n            j++;\n        }\n\n        if (filledOctetCount < 4) {\n            octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - (prefix % 8);\n        }\n\n        return new this(octets);\n    };\n\n    // An IPv6 address (RFC2460)\n    ipaddr.IPv6 = (function () {\n        // Constructs an IPv6 address from an array of eight 16 - bit parts\n        // or sixteen 8 - bit parts in network order(MSB first).\n        // Throws an error if the input is invalid.\n        function IPv6 (parts, zoneId) {\n            let i, part;\n\n            if (parts.length === 16) {\n                this.parts = [];\n                for (i = 0; i <= 14; i += 2) {\n                    this.parts.push((parts[i] << 8) | parts[i + 1]);\n                }\n            } else if (parts.length === 8) {\n                this.parts = parts;\n            } else {\n                throw new Error('ipaddr: ipv6 part count should be 8 or 16');\n            }\n\n            for (i = 0; i < this.parts.length; i++) {\n                part = this.parts[i];\n                if (!((0 <= part && part <= 0xffff))) {\n                    throw new Error('ipaddr: ipv6 part should fit in 16 bits');\n                }\n            }\n\n            if (zoneId) {\n                this.zoneId = zoneId;\n            }\n        }\n\n        // Special IPv6 ranges\n        IPv6.prototype.SpecialRanges = {\n            // RFC4291, here and after\n            unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],\n            linkLocal: [new IPv6([0xfe80, 0, 0, 0, 0, 0, 0, 0]), 10],\n            multicast: [new IPv6([0xff00, 0, 0, 0, 0, 0, 0, 0]), 8],\n            loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],\n            uniqueLocal: [new IPv6([0xfc00, 0, 0, 0, 0, 0, 0, 0]), 7],\n            ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 0xffff, 0, 0]), 96],\n            // RFC6145\n            rfc6145: [new IPv6([0, 0, 0, 0, 0xffff, 0, 0, 0]), 96],\n            // RFC6052\n            rfc6052: [new IPv6([0x64, 0xff9b, 0, 0, 0, 0, 0, 0]), 96],\n            // RFC3056\n            '6to4': [new IPv6([0x2002, 0, 0, 0, 0, 0, 0, 0]), 16],\n            // RFC6052, RFC6146\n            teredo: [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 32],\n            // RFC4291\n            reserved: [[new IPv6([0x2001, 0xdb8, 0, 0, 0, 0, 0, 0]), 32]],\n            benchmarking: [new IPv6([0x2001, 0x2, 0, 0, 0, 0, 0, 0]), 48],\n            amt: [new IPv6([0x2001, 0x3, 0, 0, 0, 0, 0, 0]), 32],\n            as112v6: [new IPv6([0x2001, 0x4, 0x112, 0, 0, 0, 0, 0]), 48],\n            deprecated: [new IPv6([0x2001, 0x10, 0, 0, 0, 0, 0, 0]), 28],\n            orchid2: [new IPv6([0x2001, 0x20, 0, 0, 0, 0, 0, 0]), 28]\n        };\n\n        // Checks if this address is an IPv4-mapped IPv6 address.\n        IPv6.prototype.isIPv4MappedAddress = function () {\n            return this.range() === 'ipv4Mapped';\n        };\n\n        // The 'kind' method exists on both IPv4 and IPv6 classes.\n        IPv6.prototype.kind = function () {\n            return 'ipv6';\n        };\n\n        // Checks if this address matches other one within given CIDR range.\n        IPv6.prototype.match = function (other, cidrRange) {\n            let ref;\n\n            if (cidrRange === undefined) {\n                ref = other;\n                other = ref[0];\n                cidrRange = ref[1];\n            }\n\n            if (other.kind() !== 'ipv6') {\n                throw new Error('ipaddr: cannot match ipv6 address with non-ipv6 one');\n            }\n\n            return matchCIDR(this.parts, other.parts, 16, cidrRange);\n        };\n\n        // returns a number of leading ones in IPv6 address, making sure that\n        // the rest is a solid sequence of 0's (valid netmask)\n        // returns either the CIDR length or null if mask is not valid\n        IPv6.prototype.prefixLengthFromSubnetMask = function () {\n            let cidr = 0;\n            // non-zero encountered stop scanning for zeroes\n            let stop = false;\n            // number of zeroes in octet\n            const zerotable = {\n                0: 16,\n                32768: 15,\n                49152: 14,\n                57344: 13,\n                61440: 12,\n                63488: 11,\n                64512: 10,\n                65024: 9,\n                65280: 8,\n                65408: 7,\n                65472: 6,\n                65504: 5,\n                65520: 4,\n                65528: 3,\n                65532: 2,\n                65534: 1,\n                65535: 0\n            };\n            let part, zeros;\n\n            for (let i = 7; i >= 0; i -= 1) {\n                part = this.parts[i];\n                if (part in zerotable) {\n                    zeros = zerotable[part];\n                    if (stop && zeros !== 0) {\n                        return null;\n                    }\n\n                    if (zeros !== 16) {\n                        stop = true;\n                    }\n\n                    cidr += zeros;\n                } else {\n                    return null;\n                }\n            }\n\n            return 128 - cidr;\n        };\n\n\n        // Checks if the address corresponds to one of the special ranges.\n        IPv6.prototype.range = function () {\n            return ipaddr.subnetMatch(this, this.SpecialRanges);\n        };\n\n        // Returns an array of byte-sized values in network order (MSB first)\n        IPv6.prototype.toByteArray = function () {\n            let part;\n            const bytes = [];\n            const ref = this.parts;\n            for (let i = 0; i < ref.length; i++) {\n                part = ref[i];\n                bytes.push(part >> 8);\n                bytes.push(part & 0xff);\n            }\n\n            return bytes;\n        };\n\n        // Returns the address in expanded format with all zeroes included, like\n        // 2001:0db8:0008:0066:0000:0000:0000:0001\n        IPv6.prototype.toFixedLengthString = function () {\n            const addr = ((function () {\n                const results = [];\n                for (let i = 0; i < this.parts.length; i++) {\n                    results.push(padPart(this.parts[i].toString(16), 4));\n                }\n\n                return results;\n            }).call(this)).join(':');\n\n            let suffix = '';\n\n            if (this.zoneId) {\n                suffix = `%${this.zoneId}`;\n            }\n\n            return addr + suffix;\n        };\n\n        // Converts this address to IPv4 address if it is an IPv4-mapped IPv6 address.\n        // Throws an error otherwise.\n        IPv6.prototype.toIPv4Address = function () {\n            if (!this.isIPv4MappedAddress()) {\n                throw new Error('ipaddr: trying to convert a generic ipv6 address to ipv4');\n            }\n\n            const ref = this.parts.slice(-2);\n            const high = ref[0];\n            const low = ref[1];\n\n            return new ipaddr.IPv4([high >> 8, high & 0xff, low >> 8, low & 0xff]);\n        };\n\n        // Returns the address in expanded format with all zeroes included, like\n        // 2001:db8:8:66:0:0:0:1\n        //\n        // Deprecated: use toFixedLengthString() instead.\n        IPv6.prototype.toNormalizedString = function () {\n            const addr = ((function () {\n                const results = [];\n\n                for (let i = 0; i < this.parts.length; i++) {\n                    results.push(this.parts[i].toString(16));\n                }\n\n                return results;\n            }).call(this)).join(':');\n\n            let suffix = '';\n\n            if (this.zoneId) {\n                suffix = `%${this.zoneId}`;\n            }\n\n            return addr + suffix;\n        };\n\n        // Returns the address in compact, human-readable format like\n        // 2001:db8:8:66::1\n        // in line with RFC 5952 (see https://tools.ietf.org/html/rfc5952#section-4)\n        IPv6.prototype.toRFC5952String = function () {\n            const regex = /((^|:)(0(:|$)){2,})/g;\n            const string = this.toNormalizedString();\n            let bestMatchIndex = 0;\n            let bestMatchLength = -1;\n            let match;\n\n            while ((match = regex.exec(string))) {\n                if (match[0].length > bestMatchLength) {\n                    bestMatchIndex = match.index;\n                    bestMatchLength = match[0].length;\n                }\n            }\n\n            if (bestMatchLength < 0) {\n                return string;\n            }\n\n            return `${string.substring(0, bestMatchIndex)}::${string.substring(bestMatchIndex + bestMatchLength)}`;\n        };\n\n        // Returns the address in compact, human-readable format like\n        // 2001:db8:8:66::1\n        // Calls toRFC5952String under the hood.\n        IPv6.prototype.toString = function () {\n            return this.toRFC5952String();\n        };\n\n        return IPv6;\n\n    })();\n\n    // A utility function to return broadcast address given the IPv6 interface and prefix length in CIDR notation\n    ipaddr.IPv6.broadcastAddressFromCIDR = function (string) {\n        try {\n            const cidr = this.parseCIDR(string);\n            const ipInterfaceOctets = cidr[0].toByteArray();\n            const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n            const octets = [];\n            let i = 0;\n            while (i < 16) {\n                // Broadcast address is bitwise OR between ip interface and inverted mask\n                octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);\n                i++;\n            }\n\n            return new this(octets);\n        } catch (e) {\n            throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);\n        }\n    };\n\n    // Checks if a given string is formatted like IPv6 address.\n    ipaddr.IPv6.isIPv6 = function (string) {\n        return this.parser(string) !== null;\n    };\n\n    // Checks to see if string is a valid IPv6 Address\n    ipaddr.IPv6.isValid = function (string) {\n\n        // Since IPv6.isValid is always called first, this shortcut\n        // provides a substantial performance gain.\n        if (typeof string === 'string' && string.indexOf(':') === -1) {\n            return false;\n        }\n\n        try {\n            const addr = this.parser(string);\n            new this(addr.parts, addr.zoneId);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    };\n\n    // A utility function to return network address given the IPv6 interface and prefix length in CIDR notation\n    ipaddr.IPv6.networkAddressFromCIDR = function (string) {\n        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;\n\n        try {\n            cidr = this.parseCIDR(string);\n            ipInterfaceOctets = cidr[0].toByteArray();\n            subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n            octets = [];\n            i = 0;\n            while (i < 16) {\n                // Network address is bitwise AND between ip interface and mask\n                octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));\n                i++;\n            }\n\n            return new this(octets);\n        } catch (e) {\n            throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);\n        }\n    };\n\n    // Tries to parse and validate a string with IPv6 address.\n    // Throws an error if it fails.\n    ipaddr.IPv6.parse = function (string) {\n        const addr = this.parser(string);\n\n        if (addr.parts === null) {\n            throw new Error('ipaddr: string is not formatted like an IPv6 Address');\n        }\n\n        return new this(addr.parts, addr.zoneId);\n    };\n\n    ipaddr.IPv6.parseCIDR = function (string) {\n        let maskLength, match, parsed;\n\n        if ((match = string.match(/^(.+)\\/(\\d+)$/))) {\n            maskLength = parseInt(match[2]);\n            if (maskLength >= 0 && maskLength <= 128) {\n                parsed = [this.parse(match[1]), maskLength];\n                Object.defineProperty(parsed, 'toString', {\n                    value: function () {\n                        return this.join('/');\n                    }\n                });\n                return parsed;\n            }\n        }\n\n        throw new Error('ipaddr: string is not formatted like an IPv6 CIDR range');\n    };\n\n    // Parse an IPv6 address.\n    ipaddr.IPv6.parser = function (string) {\n        let addr, i, match, octet, octets, zoneId;\n\n        if ((match = string.match(ipv6Regexes.deprecatedTransitional))) {\n            return this.parser(`::ffff:${match[1]}`);\n        }\n        if (ipv6Regexes.native.test(string)) {\n            return expandIPv6(string, 8);\n        }\n        if ((match = string.match(ipv6Regexes.transitional))) {\n            zoneId = match[6] || '';\n            addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);\n            if (addr.parts) {\n                octets = [\n                    parseInt(match[2]),\n                    parseInt(match[3]),\n                    parseInt(match[4]),\n                    parseInt(match[5])\n                ];\n                for (i = 0; i < octets.length; i++) {\n                    octet = octets[i];\n                    if (!((0 <= octet && octet <= 255))) {\n                        return null;\n                    }\n                }\n\n                addr.parts.push(octets[0] << 8 | octets[1]);\n                addr.parts.push(octets[2] << 8 | octets[3]);\n                return {\n                    parts: addr.parts,\n                    zoneId: addr.zoneId\n                };\n            }\n        }\n\n        return null;\n    };\n\n    // A utility function to return subnet mask in IPv6 format given the prefix length\n    ipaddr.IPv6.subnetMaskFromPrefixLength = function (prefix) {\n        prefix = parseInt(prefix);\n        if (prefix < 0 || prefix > 128) {\n            throw new Error('ipaddr: invalid IPv6 prefix length');\n        }\n\n        const octets = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        let j = 0;\n        const filledOctetCount = Math.floor(prefix / 8);\n\n        while (j < filledOctetCount) {\n            octets[j] = 255;\n            j++;\n        }\n\n        if (filledOctetCount < 16) {\n            octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - (prefix % 8);\n        }\n\n        return new this(octets);\n    };\n\n    // Try to parse an array in network order (MSB first) for IPv4 and IPv6\n    ipaddr.fromByteArray = function (bytes) {\n        const length = bytes.length;\n\n        if (length === 4) {\n            return new ipaddr.IPv4(bytes);\n        } else if (length === 16) {\n            return new ipaddr.IPv6(bytes);\n        } else {\n            throw new Error('ipaddr: the binary input is neither an IPv6 nor IPv4 address');\n        }\n    };\n\n    // Checks if the address is valid IP address\n    ipaddr.isValid = function (string) {\n        return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);\n    };\n\n\n    // Attempts to parse an IP Address, first through IPv6 then IPv4.\n    // Throws an error if it could not be parsed.\n    ipaddr.parse = function (string) {\n        if (ipaddr.IPv6.isValid(string)) {\n            return ipaddr.IPv6.parse(string);\n        } else if (ipaddr.IPv4.isValid(string)) {\n            return ipaddr.IPv4.parse(string);\n        } else {\n            throw new Error('ipaddr: the address has neither IPv6 nor IPv4 format');\n        }\n    };\n\n    // Attempt to parse CIDR notation, first through IPv6 then IPv4.\n    // Throws an error if it could not be parsed.\n    ipaddr.parseCIDR = function (string) {\n        try {\n            return ipaddr.IPv6.parseCIDR(string);\n        } catch (e) {\n            try {\n                return ipaddr.IPv4.parseCIDR(string);\n            } catch (e2) {\n                throw new Error('ipaddr: the address has neither IPv6 nor IPv4 CIDR format');\n            }\n        }\n    };\n\n    // Parse an address and return plain IPv4 address if it is an IPv4-mapped address\n    ipaddr.process = function (string) {\n        const addr = this.parse(string);\n\n        if (addr.kind() === 'ipv6' && addr.isIPv4MappedAddress()) {\n            return addr.toIPv4Address();\n        } else {\n            return addr;\n        }\n    };\n\n    // An utility function to ease named range matching. See examples below.\n    // rangeList can contain both IPv4 and IPv6 subnet entries and will not throw errors\n    // on matching IPv4 addresses to IPv6 ranges or vice versa.\n    ipaddr.subnetMatch = function (address, rangeList, defaultName) {\n        let i, rangeName, rangeSubnets, subnet;\n\n        if (defaultName === undefined || defaultName === null) {\n            defaultName = 'unicast';\n        }\n\n        for (rangeName in rangeList) {\n            if (Object.prototype.hasOwnProperty.call(rangeList, rangeName)) {\n                rangeSubnets = rangeList[rangeName];\n                // ECMA5 Array.isArray isn't available everywhere\n                if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {\n                    rangeSubnets = [rangeSubnets];\n                }\n\n                for (i = 0; i < rangeSubnets.length; i++) {\n                    subnet = rangeSubnets[i];\n                    if (address.kind() === subnet[0].kind() && address.match.apply(address, subnet)) {\n                        return rangeName;\n                    }\n                }\n            }\n        }\n\n        return defaultName;\n    };\n\n    // Export for both the CommonJS and browser-like environment\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = ipaddr;\n\n    } else {\n        root.ipaddr = ipaddr;\n    }\n\n}(this));\n", "/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n", "'use strict'\n\nmodule.exports = Receptacle\nvar toMS = require('ms')\nvar cache = Receptacle.prototype\nvar counter = new Date() % 1e9\n\nfunction getUID () { return (Math.random() * 1e9 >>> 0) + (counter++) }\n\n/**\n * Creates a cache with a maximum key size.\n *\n * @constructor\n * @param {Object} options\n * @param {Number} [options.max=Infinity] the maximum number of keys allowed in the cache (lru).\n * @param {Array} [options.items=[]] the default items in the cache.\n */\nfunction Receptacle (options) {\n  options = options || {}\n  this.id = options.id || getUID()\n  this.max = options.max || Infinity\n  this.items = options.items || []\n  this._lookup = {}\n  this.size = this.items.length\n  this.lastModified = new Date(options.lastModified || new Date())\n\n  // Setup initial timers and indexes for the cache.\n  for (var item, ttl, i = this.items.length; i--;) {\n    item = this.items[i]\n    ttl = new Date(item.expires) - new Date()\n    this._lookup[item.key] = item\n    if (ttl > 0) this.expire(item.key, ttl)\n    else if (ttl <= 0) this.delete(item.key)\n  }\n}\n\n/**\n * Tests if a key is currently in the cache.\n * Does not check if slot is empty.\n *\n * @param {String} key - the key to retrieve from the cache.\n * @return {Boolean}\n */\ncache.has = function (key) {\n  return key in this._lookup\n}\n\n/**\n * Retrieves a key from the cache and marks it as recently used.\n *\n * @param {String} key - the key to retrieve from the cache.\n * @return {*}\n */\ncache.get = function (key) {\n  if (!this.has(key)) return null\n  var record = this._lookup[key]\n  // Update expiry for \"refresh\" keys\n  if (record.refresh) this.expire(key, record.refresh)\n  // Move to front of the line.\n  this.items.splice(this.items.indexOf(record), 1)\n  this.items.push(record)\n  return record.value\n}\n\n/**\n * Retrieves user meta data for a cached item.\n *\n * @param {String} key - the key to retrieve meta data from the cache.\n * @return {*}\n */\ncache.meta = function (key) {\n  if (!this.has(key)) return null\n  var record = this._lookup[key]\n  if (!('meta' in record)) return null\n  return record.meta\n}\n\n/**\n * Puts a key into the cache with an optional expiry time.\n *\n * @param {String} key - the key for the value in the cache.\n * @param {*} value - the value to place at the key.\n * @param {Number} [options.ttl] - a time after which the key will be removed.\n * @return {Receptacle}\n */\ncache.set = function (key, value, options) {\n  var oldRecord = this._lookup[key]\n  var record = this._lookup[key] = { key: key, value: value }\n  // Mark cache as modified.\n  this.lastModified = new Date()\n\n  if (oldRecord) {\n    // Replace an old key.\n    clearTimeout(oldRecord.timeout)\n    this.items.splice(this.items.indexOf(oldRecord), 1, record)\n  } else {\n    // Remove least used item if needed.\n    if (this.size >= this.max) this.delete(this.items[0].key)\n    // Add a new key.\n    this.items.push(record)\n    this.size++\n  }\n\n  if (options) {\n    // Setup key expiry.\n    if ('ttl' in options) this.expire(key, options.ttl)\n    // Store user options in the record.\n    if ('meta' in options) record.meta = options.meta\n    // Mark a auto refresh key.\n    if (options.refresh) record.refresh = options.ttl\n  }\n\n  return this\n}\n\n/**\n * Deletes an item from the cache.\n *\n * @param {String} key - the key to remove.\n * @return {Receptacle}\n */\ncache.delete = function (key) {\n  var record = this._lookup[key]\n  if (!record) return false\n  this.lastModified = new Date()\n  this.items.splice(this.items.indexOf(record), 1)\n  clearTimeout(record.timeout)\n  delete this._lookup[key]\n  this.size--\n  return this\n}\n\n/**\n * Utility to register a key that will be removed after some time.\n *\n * @param {String} key - the key to remove.\n * @param {Number} [ms] - the timeout before removal.\n * @return {Receptacle}\n */\ncache.expire = function (key, ttl) {\n  var ms = ttl || 0\n  var record = this._lookup[key]\n  if (!record) return this\n  if (typeof ms === 'string') ms = toMS(ttl)\n  if (typeof ms !== 'number') throw new TypeError('Expiration time must be a string or number.')\n  clearTimeout(record.timeout)\n  record.timeout = setTimeout(this.delete.bind(this, record.key), ms)\n  record.expires = Number(new Date()) + ms\n  return this\n}\n\n/**\n * Deletes all items from the cache.\n * @return {Receptacle}\n */\ncache.clear = function () {\n  for (var i = this.items.length; i--;) this.delete(this.items[i].key)\n  return this\n}\n\n/**\n * Fixes serialization issues in polyfilled environments.\n * Ensures non-cyclical serialized object.\n */\ncache.toJSON = function () {\n  var items = new Array(this.items.length)\n  var item\n  for (var i = items.length; i--;) {\n    item = this.items[i]\n    items[i] = {\n      key: item.key,\n      meta: item.meta,\n      value: item.value,\n      expires: item.expires,\n      refresh: item.refresh\n    }\n  }\n\n  return {\n    id: this.id,\n    max: isFinite(this.max) ? this.max : undefined,\n    lastModified: this.lastModified,\n    items: items\n  }\n}\n", "export { DefaultUserAgent } from \"./lib/waku.js\";\nexport { DefaultPubSubTopic } from \"./lib/constants.js\";\nexport { createEncoder, createDecoder } from \"./lib/message/version_0.js\";\nexport type {\n  Encoder,\n  Decoder,\n  DecodedMessage\n} from \"./lib/message/version_0.js\";\nexport * as message from \"./lib/message/index.js\";\n\nexport * as waku from \"./lib/waku.js\";\nexport { WakuNode, WakuOptions } from \"./lib/waku.js\";\n\nexport * as waku_filter from \"./lib/filter/index.js\";\nexport { wakuFilter, FilterCodecs } from \"./lib/filter/index.js\";\n\nexport * as waku_light_push from \"./lib/light_push/index.js\";\nexport { wakuLightPush } from \"./lib/light_push/index.js\";\n\nexport * as waku_store from \"./lib/store/index.js\";\n\nexport { PageDirection, wakuStore, createCursor } from \"./lib/store/index.js\";\n\nexport { waitForRemotePeer } from \"./lib/wait_for_remote_peer.js\";\n\nexport { ConnectionManager } from \"./lib/connection_manager.js\";\n\nexport { KeepAliveManager } from \"./lib/keep_alive_manager.js\";\nexport { StreamManager } from \"./lib/stream_manager.js\";\n", "import type { Stream } from \"@libp2p/interface/connection\";\nimport { isPeerId, PeerId } from \"@libp2p/interface/peer-id\";\nimport { multiaddr, Multiaddr, MultiaddrInput } from \"@multiformats/multiaddr\";\nimport type {\n  IFilter,\n  ILightPush,\n  IRelay,\n  IStore,\n  Libp2p,\n  PubSubTopic,\n  Waku\n} from \"@waku/interfaces\";\nimport { Protocols } from \"@waku/interfaces\";\nimport { Logger } from \"@waku/utils\";\n\nimport { ConnectionManager } from \"./connection_manager.js\";\n\nexport const DefaultPingKeepAliveValueSecs = 5 * 60;\nexport const DefaultRelayKeepAliveValueSecs = 5 * 60;\nexport const DefaultUserAgent = \"js-waku\";\n\nconst log = new Logger(\"waku\");\n\nexport interface WakuOptions {\n  /**\n   * Set keep alive frequency in seconds: Waku will send a `/ipfs/ping/1.0.0`\n   * request to each peer after the set number of seconds. Set to 0 to disable.\n   *\n   * @default {@link @waku/core.DefaultPingKeepAliveValueSecs}\n   */\n  pingKeepAlive?: number;\n  /**\n   * Set keep alive frequency in seconds: Waku will send a ping message over\n   * relay to each peer after the set number of seconds. Set to 0 to disable.\n   *\n   * @default {@link @waku/core.DefaultRelayKeepAliveValueSecs}\n   */\n  relayKeepAlive?: number;\n  /**\n   * Set the user agent string to be used in identification of the node.\n   * @default {@link @waku/core.DefaultUserAgent}\n   */\n  userAgent?: string;\n}\n\nexport class WakuNode implements Waku {\n  public libp2p: Libp2p;\n  public relay?: IRelay;\n  public store?: IStore;\n  public filter?: IFilter;\n  public lightPush?: ILightPush;\n  public connectionManager: ConnectionManager;\n\n  constructor(\n    options: WakuOptions,\n    public readonly pubsubTopics: PubSubTopic[],\n    libp2p: Libp2p,\n    store?: (libp2p: Libp2p) => IStore,\n    lightPush?: (libp2p: Libp2p) => ILightPush,\n    filter?: (libp2p: Libp2p) => IFilter,\n    relay?: (libp2p: Libp2p) => IRelay\n  ) {\n    this.libp2p = libp2p;\n\n    if (store) {\n      this.store = store(libp2p);\n    }\n    if (filter) {\n      this.filter = filter(libp2p);\n    }\n    if (lightPush) {\n      this.lightPush = lightPush(libp2p);\n    }\n\n    if (relay) {\n      this.relay = relay(libp2p);\n    }\n\n    const pingKeepAlive =\n      options.pingKeepAlive || DefaultPingKeepAliveValueSecs;\n    const relayKeepAlive = this.relay\n      ? options.relayKeepAlive || DefaultRelayKeepAliveValueSecs\n      : 0;\n\n    const peerId = this.libp2p.peerId.toString();\n\n    this.connectionManager = ConnectionManager.create(\n      peerId,\n      libp2p,\n      { pingKeepAlive, relayKeepAlive },\n      pubsubTopics,\n      this.relay\n    );\n\n    log.info(\n      \"Waku node created\",\n      peerId,\n      `relay: ${!!this.relay}, store: ${!!this.store}, light push: ${!!this\n        .lightPush}, filter: ${!!this.filter}`\n    );\n  }\n\n  /**\n   * Dials to the provided peer.\n   *\n   * @param peer The peer to dial\n   * @param protocols Waku protocols we expect from the peer; Defaults to mounted protocols\n   */\n  async dial(\n    peer: PeerId | MultiaddrInput,\n    protocols?: Protocols[]\n  ): Promise<Stream> {\n    const _protocols = protocols ?? [];\n    const peerId = mapToPeerIdOrMultiaddr(peer);\n\n    if (typeof protocols === \"undefined\") {\n      this.relay && _protocols.push(Protocols.Relay);\n      this.store && _protocols.push(Protocols.Store);\n      this.filter && _protocols.push(Protocols.Filter);\n      this.lightPush && _protocols.push(Protocols.LightPush);\n    }\n\n    const codecs: string[] = [];\n    if (_protocols.includes(Protocols.Relay)) {\n      if (this.relay) {\n        this.relay.gossipSub.multicodecs.forEach((codec: string) =>\n          codecs.push(codec)\n        );\n      } else {\n        log.error(\n          \"Relay codec not included in dial codec: protocol not mounted locally\"\n        );\n      }\n    }\n    if (_protocols.includes(Protocols.Store)) {\n      if (this.store) {\n        codecs.push(this.store.multicodec);\n      } else {\n        log.error(\n          \"Store codec not included in dial codec: protocol not mounted locally\"\n        );\n      }\n    }\n    if (_protocols.includes(Protocols.LightPush)) {\n      if (this.lightPush) {\n        codecs.push(this.lightPush.multicodec);\n      } else {\n        log.error(\n          \"Light Push codec not included in dial codec: protocol not mounted locally\"\n        );\n      }\n    }\n    if (_protocols.includes(Protocols.Filter)) {\n      if (this.filter) {\n        codecs.push(this.filter.multicodec);\n      } else {\n        log.error(\n          \"Filter codec not included in dial codec: protocol not mounted locally\"\n        );\n      }\n    }\n\n    log.info(`Dialing to ${peerId.toString()} with protocols ${_protocols}`);\n\n    return this.libp2p.dialProtocol(peerId, codecs);\n  }\n\n  async start(): Promise<void> {\n    await this.libp2p.start();\n  }\n\n  async stop(): Promise<void> {\n    this.connectionManager.stop();\n    await this.libp2p.stop();\n  }\n\n  isStarted(): boolean {\n    return this.libp2p.isStarted();\n  }\n\n  /**\n   * Return the local multiaddr with peer id on which libp2p is listening.\n   *\n   * @throws if libp2p is not listening on localhost.\n   */\n  getLocalMultiaddrWithID(): string {\n    const localMultiaddr = this.libp2p\n      .getMultiaddrs()\n      .find((addr) => addr.toString().match(/127\\.0\\.0\\.1/));\n    if (!localMultiaddr || localMultiaddr.toString() === \"\") {\n      throw \"Not listening on localhost\";\n    }\n    return localMultiaddr + \"/p2p/\" + this.libp2p.peerId.toString();\n  }\n}\nfunction mapToPeerIdOrMultiaddr(\n  peerId: PeerId | MultiaddrInput\n): PeerId | Multiaddr {\n  return isPeerId(peerId) ? peerId : multiaddr(peerId);\n}\n", "import type { Libp2p } from \"@libp2p/interface\";\nimport type { PeerId } from \"@libp2p/interface/peer-id\";\nimport type { Peer, PeerStore } from \"@libp2p/interface/peer-store\";\nimport type { Libp2pOptions } from \"libp2p\";\n\nimport type { IDecodedMessage } from \"./message.js\";\nimport type { PubSubTopic } from \"./misc.js\";\n\nexport enum Protocols {\n  Relay = \"relay\",\n  Store = \"store\",\n  LightPush = \"lightpush\",\n  Filter = \"filter\"\n}\n\nexport interface IBaseProtocol {\n  multicodec: string;\n  peerStore: PeerStore;\n  peers: () => Promise<Peer[]>;\n  addLibp2pEventListener: Libp2p[\"addEventListener\"];\n  removeLibp2pEventListener: Libp2p[\"removeEventListener\"];\n}\n\nexport type ProtocolCreateOptions = {\n  /**\n   * Waku supports usage of multiple pubsub topics, but this is still in early stages.\n   * Waku implements sharding to achieve scalability\n   * The format of the sharded topic is `/waku/2/rs/<shard_cluster_index>/<shard_number>`\n   * To learn more about the sharding specifications implemented, see [Relay Sharding](https://rfc.vac.dev/spec/51/).\n   * The PubSub Topic to use. Defaults to {@link @waku/core!DefaultPubSubTopic }.\n   *\n   * If no pubsub topic is specified, the default pubsub topic is used.\n   * The set of pubsub topics that are used to initialize the Waku node, will need to be used by the protocols as well\n   * You cannot currently add or remove pubsub topics after initialization.\n   * This is used by:\n   * - WakuRelay to receive, route and send messages,\n   * - WakuLightPush to send messages,\n   * - WakuStore to retrieve messages.\n   * See [Waku v2 Topic Usage Recommendations](https://rfc.vac.dev/spec/23/) for details.\n   *\n   */\n  pubsubTopics?: PubSubTopic[];\n  /**\n   * You can pass options to the `Libp2p` instance used by {@link @waku/core!WakuNode} using the `libp2p` property.\n   * This property is the same type as the one passed to [`Libp2p.create`](https://github.com/libp2p/js-libp2p/blob/master/doc/API.md#create)\n   * apart that we made the `modules` property optional and partial,\n   * allowing its omission and letting Waku set good defaults.\n   * Notes that some values are overridden by {@link @waku/core!WakuNode} to ensure it implements the Waku protocol.\n   */\n  libp2p?: Partial<Libp2pOptions>;\n  /**\n   * Byte array used as key for the noise protocol used for connection encryption\n   * by [`Libp2p.create`](https://github.com/libp2p/js-libp2p/blob/master/doc/API.md#create)\n   * This is only used for test purposes to not run out of entropy during CI runs.\n   */\n  staticNoiseKey?: Uint8Array;\n  /**\n   * Use recommended bootstrap method to discovery and connect to new nodes.\n   */\n  defaultBootstrap?: boolean;\n};\n\nexport type Callback<T extends IDecodedMessage> = (\n  msg: T\n) => void | Promise<void>;\n\nexport enum SendError {\n  /** Could not determine the origin of the fault. Best to check connectivity and try again */\n  GENERIC_FAIL = \"Generic error\",\n  /**\n   * Failure to protobuf encode the message. This is not recoverable and needs\n   * further investigation.\n   */\n  ENCODE_FAILED = \"Failed to encode\",\n  /**\n   * Failure to protobuf decode the message. May be due to a remote peer issue,\n   * ensuring that messages are sent via several peer enable mitigation of this error.\n   */\n  DECODE_FAILED = \"Failed to decode\",\n  /**\n   * The message payload is empty, making the message invalid. Ensure that a non-empty\n   * payload is set on the outgoing message.\n   */\n  EMPTY_PAYLOAD = \"Payload is empty\",\n  /**\n   * The message size is above the maximum message size allowed on the Waku Network.\n   * Compressing the message or using an alternative strategy for large messages is recommended.\n   */\n  SIZE_TOO_BIG = \"Size is too big\",\n  /**\n   * The PubSubTopic passed to the send function is not configured on the Waku node.\n   * Please ensure that the PubSubTopic is used when initializing the Waku node.\n   */\n  TOPIC_NOT_CONFIGURED = \"Topic not configured\",\n  /**\n   * Failure to find a peer with suitable protocols. This may due to a connection issue.\n   * Mitigation can be: retrying after a given time period, display connectivity issue\n   * to user or listening for `peer:connected:bootstrap` or `peer:connected:peer-exchange`\n   * on the connection manager before retrying.\n   */\n  NO_PEER_AVAILABLE = \"No peer available\",\n  /**\n   * The remote peer did not behave as expected. Mitigation for `NO_PEER_AVAILABLE`\n   * or `DECODE_FAILED` can be used.\n   */\n  REMOTE_PEER_FAULT = \"Remote peer fault\",\n  /**\n   * The remote peer rejected the message. Information provided by the remote peer\n   * is logged. Review message validity, or mitigation for `NO_PEER_AVAILABLE`\n   * or `DECODE_FAILED` can be used.\n   */\n  REMOTE_PEER_REJECTED = \"Remote peer rejected\"\n}\n\nexport interface SendResult {\n  errors?: SendError[];\n  recipients: PeerId[];\n}\n", "import type { IDecodedMessage, IDecoder } from \"./message.js\";\nimport type { IBaseProtocol } from \"./protocols.js\";\n\nexport enum PageDirection {\n  BACKWARD = \"backward\",\n  FORWARD = \"forward\"\n}\n\nexport interface TimeFilter {\n  startTime: Date;\n  endTime: Date;\n}\n\nexport interface Cursor {\n  digest: Uint8Array;\n  receiverTime: bigint;\n  senderTime: bigint;\n  pubsubTopic: string;\n}\n\nexport type StoreQueryOptions = {\n  /**\n   * The direction in which pages are retrieved:\n   * - { @link PageDirection.BACKWARD }: Most recent page first.\n   * - { @link PageDirection.FORWARD }: Oldest page first.\n   *\n   * Note: This does not affect the ordering of messages with the page\n   * (the oldest message is always first).\n   *\n   * @default { @link PageDirection.BACKWARD }\n   */\n  pageDirection?: PageDirection;\n  /**\n   * The number of message per page.\n   */\n  pageSize?: number;\n  /**\n   * Retrieve messages with a timestamp within the provided values.\n   */\n  timeFilter?: TimeFilter;\n  /**\n   * Cursor as an index to start a query from. Must be generated from a Waku\n   * Message.\n   */\n  cursor?: Cursor;\n};\n\nexport interface IStore extends IBaseProtocol {\n  queryWithOrderedCallback: <T extends IDecodedMessage>(\n    decoders: IDecoder<T>[],\n    callback: (message: T) => Promise<void | boolean> | boolean | void,\n    options?: StoreQueryOptions\n  ) => Promise<void>;\n  queryWithPromiseCallback: <T extends IDecodedMessage>(\n    decoders: IDecoder<T>[],\n    callback: (\n      message: Promise<T | undefined>\n    ) => Promise<void | boolean> | boolean | void,\n    options?: StoreQueryOptions\n  ) => Promise<void>;\n  queryGenerator: <T extends IDecodedMessage>(\n    decoders: IDecoder<T>[],\n    options?: StoreQueryOptions\n  ) => AsyncGenerator<Promise<T | undefined>[]>;\n}\n", "import type { PeerId } from \"@libp2p/interface/peer-id\";\nimport type { Peer } from \"@libp2p/interface/peer-store\";\nimport type { EventEmitter } from \"@libp2p/interfaces/events\";\n\nexport enum Tags {\n  BOOTSTRAP = \"bootstrap\",\n  PEER_EXCHANGE = \"peer-exchange\"\n}\n\nexport interface ConnectionManagerOptions {\n  /**\n   * Number of attempts before a peer is considered non-dialable\n   * This is used to not spam a peer with dial attempts when it is not dialable\n   */\n  maxDialAttemptsForPeer: number;\n  /**\n   * Max number of bootstrap peers allowed to be connected to, initially\n   * This is used to increase intention of dialing non-bootstrap peers, found using other discovery mechanisms (like Peer Exchange)\n   */\n  maxBootstrapPeersAllowed: number;\n  /**\n   * Max number of parallel dials allowed\n   */\n  maxParallelDials: number;\n}\n\nexport enum EPeersByDiscoveryEvents {\n  PEER_DISCOVERY_BOOTSTRAP = \"peer:discovery:bootstrap\",\n  PEER_DISCOVERY_PEER_EXCHANGE = \"peer:discovery:peer-exchange\",\n  PEER_CONNECT_BOOTSTRAP = \"peer:connected:bootstrap\",\n  PEER_CONNECT_PEER_EXCHANGE = \"peer:connected:peer-exchange\"\n}\n\nexport interface IPeersByDiscoveryEvents {\n  [EPeersByDiscoveryEvents.PEER_DISCOVERY_BOOTSTRAP]: CustomEvent<PeerId>;\n  [EPeersByDiscoveryEvents.PEER_DISCOVERY_PEER_EXCHANGE]: CustomEvent<PeerId>;\n  [EPeersByDiscoveryEvents.PEER_CONNECT_BOOTSTRAP]: CustomEvent<PeerId>;\n  [EPeersByDiscoveryEvents.PEER_CONNECT_PEER_EXCHANGE]: CustomEvent<PeerId>;\n}\n\nexport interface PeersByDiscoveryResult {\n  DISCOVERED: {\n    [Tags.BOOTSTRAP]: Peer[];\n    [Tags.PEER_EXCHANGE]: Peer[];\n  };\n  CONNECTED: {\n    [Tags.BOOTSTRAP]: Peer[];\n    [Tags.PEER_EXCHANGE]: Peer[];\n  };\n}\n\nexport interface IConnectionManager\n  extends EventEmitter<IPeersByDiscoveryEvents> {\n  getPeersByDiscovery(): Promise<PeersByDiscoveryResult>;\n  stop(): void;\n}\n", "\nexport interface EventCallback<EventType> { (evt: EventType): void }\nexport interface EventObject<EventType> { handleEvent: EventCallback<EventType> }\nexport type EventHandler<EventType> = EventCallback<EventType> | EventObject<EventType>\n\ninterface Listener {\n  once: boolean\n  callback: any\n}\n\n/**\n * Adds types to the EventTarget class. Hopefully this won't be necessary forever.\n *\n * https://github.com/microsoft/TypeScript/issues/28357\n * https://github.com/microsoft/TypeScript/issues/43477\n * https://github.com/microsoft/TypeScript/issues/299\n * etc\n */\nexport class EventEmitter<EventMap extends Record<string, any>> extends EventTarget {\n  #listeners = new Map<any, Listener[]>()\n\n  listenerCount (type: string): number {\n    const listeners = this.#listeners.get(type)\n\n    if (listeners == null) {\n      return 0\n    }\n\n    return listeners.length\n  }\n\n  addEventListener<K extends keyof EventMap>(type: K, listener: EventHandler<EventMap[K]> | null, options?: boolean | AddEventListenerOptions): void\n  addEventListener (type: string, listener: EventHandler<Event>, options?: boolean | AddEventListenerOptions): void {\n    super.addEventListener(type, listener, options)\n\n    let list = this.#listeners.get(type)\n\n    if (list == null) {\n      list = []\n      this.#listeners.set(type, list)\n    }\n\n    list.push({\n      callback: listener,\n      once: (options !== true && options !== false && options?.once) ?? false\n    })\n  }\n\n  removeEventListener<K extends keyof EventMap>(type: K, listener?: EventHandler<EventMap[K]> | null, options?: boolean | EventListenerOptions): void\n  removeEventListener (type: string, listener?: EventHandler<Event>, options?: boolean | EventListenerOptions): void {\n    super.removeEventListener(type.toString(), listener ?? null, options)\n\n    let list = this.#listeners.get(type)\n\n    if (list == null) {\n      return\n    }\n\n    list = list.filter(({ callback }) => callback !== listener)\n    this.#listeners.set(type, list)\n  }\n\n  dispatchEvent (event: Event): boolean {\n    const result = super.dispatchEvent(event)\n\n    let list = this.#listeners.get(event.type)\n\n    if (list == null) {\n      return result\n    }\n\n    list = list.filter(({ once }) => !once)\n    this.#listeners.set(event.type, list)\n\n    return result\n  }\n\n  safeDispatchEvent<Detail>(type: keyof EventMap, detail: CustomEventInit<Detail>): boolean {\n    return this.dispatchEvent(new CustomEvent<Detail>(type as string, detail))\n  }\n}\n\n/**\n * CustomEvent is a standard event but it's not supported by node.\n *\n * Remove this when https://github.com/nodejs/node/issues/40678 is closed.\n *\n * Ref: https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent\n */\nclass CustomEventPolyfill<T = any> extends Event {\n  /** Returns any custom data event was created with. Typically used for synthetic events. */\n  public detail: T\n\n  constructor (message: string, data?: EventInit & { detail: T }) {\n    super(message, data)\n    // @ts-expect-error could be undefined\n    this.detail = data?.detail\n  }\n}\n\nexport const CustomEvent = globalThis.CustomEvent ?? CustomEventPolyfill\n", "import type {\n  EncoderOptions,\n  IDecodedMessage,\n  IDecoder,\n  IEncoder,\n  IMessage,\n  IMetaSetter,\n  IProtoMessage,\n  IRateLimitProof,\n  PubSubTopic\n} from \"@waku/interfaces\";\nimport { proto_message as proto } from \"@waku/proto\";\nimport { Logger } from \"@waku/utils\";\n\nimport { DefaultPubSubTopic } from \"../constants.js\";\n\nconst log = new Logger(\"message:version-0\");\nconst OneMillion = BigInt(1_000_000);\n\nexport const Version = 0;\nexport { proto };\n\nexport class DecodedMessage implements IDecodedMessage {\n  constructor(\n    public pubsubTopic: string,\n    protected proto: proto.WakuMessage\n  ) {}\n\n  get ephemeral(): boolean {\n    return Boolean(this.proto.ephemeral);\n  }\n\n  get payload(): Uint8Array {\n    return this.proto.payload;\n  }\n\n  get contentTopic(): string {\n    return this.proto.contentTopic;\n  }\n\n  get _rawTimestamp(): bigint | undefined {\n    return this.proto.timestamp;\n  }\n\n  get timestamp(): Date | undefined {\n    // In the case we receive a value that is bigger than JS's max number,\n    // we catch the error and return undefined.\n    try {\n      if (this.proto.timestamp) {\n        // nanoseconds 10^-9 to milliseconds 10^-3\n        const timestamp = this.proto.timestamp / OneMillion;\n        return new Date(Number(timestamp));\n      }\n      return;\n    } catch (e) {\n      return;\n    }\n  }\n\n  get meta(): Uint8Array | undefined {\n    return this.proto.meta;\n  }\n\n  get version(): number {\n    // https://rfc.vac.dev/spec/14/\n    // > If omitted, the value SHOULD be interpreted as version 0.\n    return this.proto.version ?? 0;\n  }\n\n  get rateLimitProof(): IRateLimitProof | undefined {\n    return this.proto.rateLimitProof;\n  }\n}\n\nexport class Encoder implements IEncoder {\n  constructor(\n    public contentTopic: string,\n    public ephemeral: boolean = false,\n    public pubsubTopic: PubSubTopic,\n    public metaSetter?: IMetaSetter\n  ) {\n    if (!contentTopic || contentTopic === \"\") {\n      throw new Error(\"Content topic must be specified\");\n    }\n  }\n\n  async toWire(message: IMessage): Promise<Uint8Array> {\n    return proto.WakuMessage.encode(await this.toProtoObj(message));\n  }\n\n  async toProtoObj(message: IMessage): Promise<IProtoMessage> {\n    const timestamp = message.timestamp ?? new Date();\n\n    const protoMessage = {\n      payload: message.payload,\n      version: Version,\n      contentTopic: this.contentTopic,\n      timestamp: BigInt(timestamp.valueOf()) * OneMillion,\n      meta: undefined,\n      rateLimitProof: message.rateLimitProof,\n      ephemeral: this.ephemeral\n    };\n\n    if (this.metaSetter) {\n      const meta = this.metaSetter(protoMessage);\n      return { ...protoMessage, meta };\n    }\n\n    return protoMessage;\n  }\n}\n\n/**\n * Creates an encoder that encode messages without Waku level encryption or signature.\n *\n * An encoder is used to encode messages in the [14/WAKU2-MESSAGE](https://rfc.vac.dev/spec/14/)\n * format to be sent over the Waku network. The resulting encoder can then be\n * pass to { @link @waku/interfaces!ISender.send } to automatically encode outgoing\n * messages.\n */\nexport function createEncoder({\n  pubsubTopic = DefaultPubSubTopic,\n  contentTopic,\n  ephemeral,\n  metaSetter\n}: EncoderOptions): Encoder {\n  return new Encoder(contentTopic, ephemeral, pubsubTopic, metaSetter);\n}\n\nexport class Decoder implements IDecoder<DecodedMessage> {\n  constructor(\n    public pubsubTopic: PubSubTopic,\n    public contentTopic: string\n  ) {\n    if (!contentTopic || contentTopic === \"\") {\n      throw new Error(\"Content topic must be specified\");\n    }\n  }\n\n  fromWireToProtoObj(bytes: Uint8Array): Promise<IProtoMessage | undefined> {\n    const protoMessage = proto.WakuMessage.decode(bytes);\n    return Promise.resolve({\n      payload: protoMessage.payload,\n      contentTopic: protoMessage.contentTopic,\n      version: protoMessage.version ?? undefined,\n      timestamp: protoMessage.timestamp ?? undefined,\n      meta: protoMessage.meta ?? undefined,\n      rateLimitProof: protoMessage.rateLimitProof ?? undefined,\n      ephemeral: protoMessage.ephemeral ?? false\n    });\n  }\n\n  async fromProtoObj(\n    pubsubTopic: string,\n    proto: IProtoMessage\n  ): Promise<DecodedMessage | undefined> {\n    // https://rfc.vac.dev/spec/14/\n    // > If omitted, the value SHOULD be interpreted as version 0.\n    if (proto.version ?? 0 !== Version) {\n      log.error(\n        \"Failed to decode due to incorrect version, expected:\",\n        Version,\n        \", actual:\",\n        proto.version\n      );\n      return Promise.resolve(undefined);\n    }\n\n    return new DecodedMessage(pubsubTopic, proto);\n  }\n}\n\n/**\n * Creates a decoder that decode messages without Waku level encryption.\n *\n * A decoder is used to decode messages from the [14/WAKU2-MESSAGE](https://rfc.vac.dev/spec/14/)\n * format when received from the Waku network. The resulting decoder can then be\n * pass to { @link @waku/interfaces!IReceiver.subscribe } to automatically decode incoming\n * messages.\n *\n * @param contentTopic The resulting decoder will only decode messages with this content topic.\n */\nexport function createDecoder(\n  contentTopic: string,\n  pubsubTopic: PubSubTopic = DefaultPubSubTopic\n): Decoder {\n  return new Decoder(pubsubTopic, contentTopic);\n}\n", "/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nimport { encodeMessage, decodeMessage, message } from \"protons-runtime\";\nimport type { Codec } from \"protons-runtime\";\nimport type { Uint8ArrayList } from \"uint8arraylist\";\n\nexport interface RateLimitProof {\n  proof: Uint8Array;\n  merkleRoot: Uint8Array;\n  epoch: Uint8Array;\n  shareX: Uint8Array;\n  shareY: Uint8Array;\n  nullifier: Uint8Array;\n  rlnIdentifier: Uint8Array;\n}\n\nexport namespace RateLimitProof {\n  let _codec: Codec<RateLimitProof>;\n\n  export const codec = (): Codec<RateLimitProof> => {\n    if (_codec == null) {\n      _codec = message<RateLimitProof>(\n        (obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork();\n          }\n\n          if (obj.proof != null && obj.proof.byteLength > 0) {\n            w.uint32(10);\n            w.bytes(obj.proof);\n          }\n\n          if (obj.merkleRoot != null && obj.merkleRoot.byteLength > 0) {\n            w.uint32(18);\n            w.bytes(obj.merkleRoot);\n          }\n\n          if (obj.epoch != null && obj.epoch.byteLength > 0) {\n            w.uint32(26);\n            w.bytes(obj.epoch);\n          }\n\n          if (obj.shareX != null && obj.shareX.byteLength > 0) {\n            w.uint32(34);\n            w.bytes(obj.shareX);\n          }\n\n          if (obj.shareY != null && obj.shareY.byteLength > 0) {\n            w.uint32(42);\n            w.bytes(obj.shareY);\n          }\n\n          if (obj.nullifier != null && obj.nullifier.byteLength > 0) {\n            w.uint32(50);\n            w.bytes(obj.nullifier);\n          }\n\n          if (obj.rlnIdentifier != null && obj.rlnIdentifier.byteLength > 0) {\n            w.uint32(58);\n            w.bytes(obj.rlnIdentifier);\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim();\n          }\n        },\n        (reader, length) => {\n          const obj: any = {\n            proof: new Uint8Array(0),\n            merkleRoot: new Uint8Array(0),\n            epoch: new Uint8Array(0),\n            shareX: new Uint8Array(0),\n            shareY: new Uint8Array(0),\n            nullifier: new Uint8Array(0),\n            rlnIdentifier: new Uint8Array(0),\n          };\n\n          const end = length == null ? reader.len : reader.pos + length;\n\n          while (reader.pos < end) {\n            const tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                obj.proof = reader.bytes();\n                break;\n              case 2:\n                obj.merkleRoot = reader.bytes();\n                break;\n              case 3:\n                obj.epoch = reader.bytes();\n                break;\n              case 4:\n                obj.shareX = reader.bytes();\n                break;\n              case 5:\n                obj.shareY = reader.bytes();\n                break;\n              case 6:\n                obj.nullifier = reader.bytes();\n                break;\n              case 7:\n                obj.rlnIdentifier = reader.bytes();\n                break;\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return obj;\n        }\n      );\n    }\n\n    return _codec;\n  };\n\n  export const encode = (obj: Partial<RateLimitProof>): Uint8Array => {\n    return encodeMessage(obj, RateLimitProof.codec());\n  };\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): RateLimitProof => {\n    return decodeMessage(buf, RateLimitProof.codec());\n  };\n}\n\nexport interface WakuMessage {\n  payload: Uint8Array;\n  contentTopic: string;\n  version?: number;\n  timestamp?: bigint;\n  meta?: Uint8Array;\n  rateLimitProof?: RateLimitProof;\n  ephemeral?: boolean;\n}\n\nexport namespace WakuMessage {\n  let _codec: Codec<WakuMessage>;\n\n  export const codec = (): Codec<WakuMessage> => {\n    if (_codec == null) {\n      _codec = message<WakuMessage>(\n        (obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork();\n          }\n\n          if (obj.payload != null && obj.payload.byteLength > 0) {\n            w.uint32(10);\n            w.bytes(obj.payload);\n          }\n\n          if (obj.contentTopic != null && obj.contentTopic !== \"\") {\n            w.uint32(18);\n            w.string(obj.contentTopic);\n          }\n\n          if (obj.version != null) {\n            w.uint32(24);\n            w.uint32(obj.version);\n          }\n\n          if (obj.timestamp != null) {\n            w.uint32(80);\n            w.sint64(obj.timestamp);\n          }\n\n          if (obj.meta != null) {\n            w.uint32(90);\n            w.bytes(obj.meta);\n          }\n\n          if (obj.rateLimitProof != null) {\n            w.uint32(170);\n            RateLimitProof.codec().encode(obj.rateLimitProof, w);\n          }\n\n          if (obj.ephemeral != null) {\n            w.uint32(248);\n            w.bool(obj.ephemeral);\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim();\n          }\n        },\n        (reader, length) => {\n          const obj: any = {\n            payload: new Uint8Array(0),\n            contentTopic: \"\",\n          };\n\n          const end = length == null ? reader.len : reader.pos + length;\n\n          while (reader.pos < end) {\n            const tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                obj.payload = reader.bytes();\n                break;\n              case 2:\n                obj.contentTopic = reader.string();\n                break;\n              case 3:\n                obj.version = reader.uint32();\n                break;\n              case 10:\n                obj.timestamp = reader.sint64();\n                break;\n              case 11:\n                obj.meta = reader.bytes();\n                break;\n              case 21:\n                obj.rateLimitProof = RateLimitProof.codec().decode(\n                  reader,\n                  reader.uint32()\n                );\n                break;\n              case 31:\n                obj.ephemeral = reader.bool();\n                break;\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return obj;\n        }\n      );\n    }\n\n    return _codec;\n  };\n\n  export const encode = (obj: Partial<WakuMessage>): Uint8Array => {\n    return encodeMessage(obj, WakuMessage.codec());\n  };\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): WakuMessage => {\n    return decodeMessage(buf, WakuMessage.codec());\n  };\n}\n", "/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nimport { encodeMessage, decodeMessage, message } from \"protons-runtime\";\nimport type { Codec } from \"protons-runtime\";\nimport type { Uint8ArrayList } from \"uint8arraylist\";\n\nexport interface FilterRequest {\n  subscribe: boolean;\n  topic: string;\n  contentFilters: FilterRequest.ContentFilter[];\n}\n\nexport namespace FilterRequest {\n  export interface ContentFilter {\n    contentTopic: string;\n  }\n\n  export namespace ContentFilter {\n    let _codec: Codec<ContentFilter>;\n\n    export const codec = (): Codec<ContentFilter> => {\n      if (_codec == null) {\n        _codec = message<ContentFilter>(\n          (obj, w, opts = {}) => {\n            if (opts.lengthDelimited !== false) {\n              w.fork();\n            }\n\n            if (obj.contentTopic != null && obj.contentTopic !== \"\") {\n              w.uint32(10);\n              w.string(obj.contentTopic);\n            }\n\n            if (opts.lengthDelimited !== false) {\n              w.ldelim();\n            }\n          },\n          (reader, length) => {\n            const obj: any = {\n              contentTopic: \"\",\n            };\n\n            const end = length == null ? reader.len : reader.pos + length;\n\n            while (reader.pos < end) {\n              const tag = reader.uint32();\n\n              switch (tag >>> 3) {\n                case 1:\n                  obj.contentTopic = reader.string();\n                  break;\n                default:\n                  reader.skipType(tag & 7);\n                  break;\n              }\n            }\n\n            return obj;\n          }\n        );\n      }\n\n      return _codec;\n    };\n\n    export const encode = (obj: Partial<ContentFilter>): Uint8Array => {\n      return encodeMessage(obj, ContentFilter.codec());\n    };\n\n    export const decode = (buf: Uint8Array | Uint8ArrayList): ContentFilter => {\n      return decodeMessage(buf, ContentFilter.codec());\n    };\n  }\n\n  let _codec: Codec<FilterRequest>;\n\n  export const codec = (): Codec<FilterRequest> => {\n    if (_codec == null) {\n      _codec = message<FilterRequest>(\n        (obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork();\n          }\n\n          if (obj.subscribe != null && obj.subscribe !== false) {\n            w.uint32(8);\n            w.bool(obj.subscribe);\n          }\n\n          if (obj.topic != null && obj.topic !== \"\") {\n            w.uint32(18);\n            w.string(obj.topic);\n          }\n\n          if (obj.contentFilters != null) {\n            for (const value of obj.contentFilters) {\n              w.uint32(26);\n              FilterRequest.ContentFilter.codec().encode(value, w);\n            }\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim();\n          }\n        },\n        (reader, length) => {\n          const obj: any = {\n            subscribe: false,\n            topic: \"\",\n            contentFilters: [],\n          };\n\n          const end = length == null ? reader.len : reader.pos + length;\n\n          while (reader.pos < end) {\n            const tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                obj.subscribe = reader.bool();\n                break;\n              case 2:\n                obj.topic = reader.string();\n                break;\n              case 3:\n                obj.contentFilters.push(\n                  FilterRequest.ContentFilter.codec().decode(\n                    reader,\n                    reader.uint32()\n                  )\n                );\n                break;\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return obj;\n        }\n      );\n    }\n\n    return _codec;\n  };\n\n  export const encode = (obj: Partial<FilterRequest>): Uint8Array => {\n    return encodeMessage(obj, FilterRequest.codec());\n  };\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): FilterRequest => {\n    return decodeMessage(buf, FilterRequest.codec());\n  };\n}\n\nexport interface MessagePush {\n  messages: WakuMessage[];\n}\n\nexport namespace MessagePush {\n  let _codec: Codec<MessagePush>;\n\n  export const codec = (): Codec<MessagePush> => {\n    if (_codec == null) {\n      _codec = message<MessagePush>(\n        (obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork();\n          }\n\n          if (obj.messages != null) {\n            for (const value of obj.messages) {\n              w.uint32(10);\n              WakuMessage.codec().encode(value, w);\n            }\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim();\n          }\n        },\n        (reader, length) => {\n          const obj: any = {\n            messages: [],\n          };\n\n          const end = length == null ? reader.len : reader.pos + length;\n\n          while (reader.pos < end) {\n            const tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                obj.messages.push(\n                  WakuMessage.codec().decode(reader, reader.uint32())\n                );\n                break;\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return obj;\n        }\n      );\n    }\n\n    return _codec;\n  };\n\n  export const encode = (obj: Partial<MessagePush>): Uint8Array => {\n    return encodeMessage(obj, MessagePush.codec());\n  };\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): MessagePush => {\n    return decodeMessage(buf, MessagePush.codec());\n  };\n}\n\nexport interface FilterRpc {\n  requestId: string;\n  request?: FilterRequest;\n  push?: MessagePush;\n}\n\nexport namespace FilterRpc {\n  let _codec: Codec<FilterRpc>;\n\n  export const codec = (): Codec<FilterRpc> => {\n    if (_codec == null) {\n      _codec = message<FilterRpc>(\n        (obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork();\n          }\n\n          if (obj.requestId != null && obj.requestId !== \"\") {\n            w.uint32(10);\n            w.string(obj.requestId);\n          }\n\n          if (obj.request != null) {\n            w.uint32(18);\n            FilterRequest.codec().encode(obj.request, w);\n          }\n\n          if (obj.push != null) {\n            w.uint32(26);\n            MessagePush.codec().encode(obj.push, w);\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim();\n          }\n        },\n        (reader, length) => {\n          const obj: any = {\n            requestId: \"\",\n          };\n\n          const end = length == null ? reader.len : reader.pos + length;\n\n          while (reader.pos < end) {\n            const tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                obj.requestId = reader.string();\n                break;\n              case 2:\n                obj.request = FilterRequest.codec().decode(\n                  reader,\n                  reader.uint32()\n                );\n                break;\n              case 3:\n                obj.push = MessagePush.codec().decode(reader, reader.uint32());\n                break;\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return obj;\n        }\n      );\n    }\n\n    return _codec;\n  };\n\n  export const encode = (obj: Partial<FilterRpc>): Uint8Array => {\n    return encodeMessage(obj, FilterRpc.codec());\n  };\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): FilterRpc => {\n    return decodeMessage(buf, FilterRpc.codec());\n  };\n}\n\nexport interface RateLimitProof {\n  proof: Uint8Array;\n  merkleRoot: Uint8Array;\n  epoch: Uint8Array;\n  shareX: Uint8Array;\n  shareY: Uint8Array;\n  nullifier: Uint8Array;\n  rlnIdentifier: Uint8Array;\n}\n\nexport namespace RateLimitProof {\n  let _codec: Codec<RateLimitProof>;\n\n  export const codec = (): Codec<RateLimitProof> => {\n    if (_codec == null) {\n      _codec = message<RateLimitProof>(\n        (obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork();\n          }\n\n          if (obj.proof != null && obj.proof.byteLength > 0) {\n            w.uint32(10);\n            w.bytes(obj.proof);\n          }\n\n          if (obj.merkleRoot != null && obj.merkleRoot.byteLength > 0) {\n            w.uint32(18);\n            w.bytes(obj.merkleRoot);\n          }\n\n          if (obj.epoch != null && obj.epoch.byteLength > 0) {\n            w.uint32(26);\n            w.bytes(obj.epoch);\n          }\n\n          if (obj.shareX != null && obj.shareX.byteLength > 0) {\n            w.uint32(34);\n            w.bytes(obj.shareX);\n          }\n\n          if (obj.shareY != null && obj.shareY.byteLength > 0) {\n            w.uint32(42);\n            w.bytes(obj.shareY);\n          }\n\n          if (obj.nullifier != null && obj.nullifier.byteLength > 0) {\n            w.uint32(50);\n            w.bytes(obj.nullifier);\n          }\n\n          if (obj.rlnIdentifier != null && obj.rlnIdentifier.byteLength > 0) {\n            w.uint32(58);\n            w.bytes(obj.rlnIdentifier);\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim();\n          }\n        },\n        (reader, length) => {\n          const obj: any = {\n            proof: new Uint8Array(0),\n            merkleRoot: new Uint8Array(0),\n            epoch: new Uint8Array(0),\n            shareX: new Uint8Array(0),\n            shareY: new Uint8Array(0),\n            nullifier: new Uint8Array(0),\n            rlnIdentifier: new Uint8Array(0),\n          };\n\n          const end = length == null ? reader.len : reader.pos + length;\n\n          while (reader.pos < end) {\n            const tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                obj.proof = reader.bytes();\n                break;\n              case 2:\n                obj.merkleRoot = reader.bytes();\n                break;\n              case 3:\n                obj.epoch = reader.bytes();\n                break;\n              case 4:\n                obj.shareX = reader.bytes();\n                break;\n              case 5:\n                obj.shareY = reader.bytes();\n                break;\n              case 6:\n                obj.nullifier = reader.bytes();\n                break;\n              case 7:\n                obj.rlnIdentifier = reader.bytes();\n                break;\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return obj;\n        }\n      );\n    }\n\n    return _codec;\n  };\n\n  export const encode = (obj: Partial<RateLimitProof>): Uint8Array => {\n    return encodeMessage(obj, RateLimitProof.codec());\n  };\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): RateLimitProof => {\n    return decodeMessage(buf, RateLimitProof.codec());\n  };\n}\n\nexport interface WakuMessage {\n  payload: Uint8Array;\n  contentTopic: string;\n  version?: number;\n  timestamp?: bigint;\n  meta?: Uint8Array;\n  rateLimitProof?: RateLimitProof;\n  ephemeral?: boolean;\n}\n\nexport namespace WakuMessage {\n  let _codec: Codec<WakuMessage>;\n\n  export const codec = (): Codec<WakuMessage> => {\n    if (_codec == null) {\n      _codec = message<WakuMessage>(\n        (obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork();\n          }\n\n          if (obj.payload != null && obj.payload.byteLength > 0) {\n            w.uint32(10);\n            w.bytes(obj.payload);\n          }\n\n          if (obj.contentTopic != null && obj.contentTopic !== \"\") {\n            w.uint32(18);\n            w.string(obj.contentTopic);\n          }\n\n          if (obj.version != null) {\n            w.uint32(24);\n            w.uint32(obj.version);\n          }\n\n          if (obj.timestamp != null) {\n            w.uint32(80);\n            w.sint64(obj.timestamp);\n          }\n\n          if (obj.meta != null) {\n            w.uint32(90);\n            w.bytes(obj.meta);\n          }\n\n          if (obj.rateLimitProof != null) {\n            w.uint32(170);\n            RateLimitProof.codec().encode(obj.rateLimitProof, w);\n          }\n\n          if (obj.ephemeral != null) {\n            w.uint32(248);\n            w.bool(obj.ephemeral);\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim();\n          }\n        },\n        (reader, length) => {\n          const obj: any = {\n            payload: new Uint8Array(0),\n            contentTopic: \"\",\n          };\n\n          const end = length == null ? reader.len : reader.pos + length;\n\n          while (reader.pos < end) {\n            const tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                obj.payload = reader.bytes();\n                break;\n              case 2:\n                obj.contentTopic = reader.string();\n                break;\n              case 3:\n                obj.version = reader.uint32();\n                break;\n              case 10:\n                obj.timestamp = reader.sint64();\n                break;\n              case 11:\n                obj.meta = reader.bytes();\n                break;\n              case 21:\n                obj.rateLimitProof = RateLimitProof.codec().decode(\n                  reader,\n                  reader.uint32()\n                );\n                break;\n              case 31:\n                obj.ephemeral = reader.bool();\n                break;\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return obj;\n        }\n      );\n    }\n\n    return _codec;\n  };\n\n  export const encode = (obj: Partial<WakuMessage>): Uint8Array => {\n    return encodeMessage(obj, WakuMessage.codec());\n  };\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): WakuMessage => {\n    return decodeMessage(buf, WakuMessage.codec());\n  };\n}\n", "/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nimport { encodeMessage, decodeMessage, message } from \"protons-runtime\";\nimport type { Codec } from \"protons-runtime\";\nimport type { Uint8ArrayList } from \"uint8arraylist\";\n\nexport interface TopicOnlyMessage {\n  contentTopic: string;\n}\n\nexport namespace TopicOnlyMessage {\n  let _codec: Codec<TopicOnlyMessage>;\n\n  export const codec = (): Codec<TopicOnlyMessage> => {\n    if (_codec == null) {\n      _codec = message<TopicOnlyMessage>(\n        (obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork();\n          }\n\n          if (obj.contentTopic != null && obj.contentTopic !== \"\") {\n            w.uint32(18);\n            w.string(obj.contentTopic);\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim();\n          }\n        },\n        (reader, length) => {\n          const obj: any = {\n            contentTopic: \"\",\n          };\n\n          const end = length == null ? reader.len : reader.pos + length;\n\n          while (reader.pos < end) {\n            const tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 2:\n                obj.contentTopic = reader.string();\n                break;\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return obj;\n        }\n      );\n    }\n\n    return _codec;\n  };\n\n  export const encode = (obj: Partial<TopicOnlyMessage>): Uint8Array => {\n    return encodeMessage(obj, TopicOnlyMessage.codec());\n  };\n\n  export const decode = (\n    buf: Uint8Array | Uint8ArrayList\n  ): TopicOnlyMessage => {\n    return decodeMessage(buf, TopicOnlyMessage.codec());\n  };\n}\n", "/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nimport {\n  enumeration,\n  encodeMessage,\n  decodeMessage,\n  message,\n} from \"protons-runtime\";\nimport type { Codec } from \"protons-runtime\";\nimport type { Uint8ArrayList } from \"uint8arraylist\";\n\nexport interface FilterSubscribeRequest {\n  requestId: string;\n  filterSubscribeType: FilterSubscribeRequest.FilterSubscribeType;\n  pubsubTopic?: string;\n  contentTopics: string[];\n}\n\nexport namespace FilterSubscribeRequest {\n  export enum FilterSubscribeType {\n    SUBSCRIBER_PING = \"SUBSCRIBER_PING\",\n    SUBSCRIBE = \"SUBSCRIBE\",\n    UNSUBSCRIBE = \"UNSUBSCRIBE\",\n    UNSUBSCRIBE_ALL = \"UNSUBSCRIBE_ALL\",\n  }\n\n  enum __FilterSubscribeTypeValues {\n    SUBSCRIBER_PING = 0,\n    SUBSCRIBE = 1,\n    UNSUBSCRIBE = 2,\n    UNSUBSCRIBE_ALL = 3,\n  }\n\n  export namespace FilterSubscribeType {\n    export const codec = (): Codec<FilterSubscribeType> => {\n      return enumeration<FilterSubscribeType>(__FilterSubscribeTypeValues);\n    };\n  }\n\n  let _codec: Codec<FilterSubscribeRequest>;\n\n  export const codec = (): Codec<FilterSubscribeRequest> => {\n    if (_codec == null) {\n      _codec = message<FilterSubscribeRequest>(\n        (obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork();\n          }\n\n          if (obj.requestId != null && obj.requestId !== \"\") {\n            w.uint32(10);\n            w.string(obj.requestId);\n          }\n\n          if (\n            obj.filterSubscribeType != null &&\n            __FilterSubscribeTypeValues[obj.filterSubscribeType] !== 0\n          ) {\n            w.uint32(16);\n            FilterSubscribeRequest.FilterSubscribeType.codec().encode(\n              obj.filterSubscribeType,\n              w\n            );\n          }\n\n          if (obj.pubsubTopic != null) {\n            w.uint32(82);\n            w.string(obj.pubsubTopic);\n          }\n\n          if (obj.contentTopics != null) {\n            for (const value of obj.contentTopics) {\n              w.uint32(90);\n              w.string(value);\n            }\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim();\n          }\n        },\n        (reader, length) => {\n          const obj: any = {\n            requestId: \"\",\n            filterSubscribeType: FilterSubscribeType.SUBSCRIBER_PING,\n            contentTopics: [],\n          };\n\n          const end = length == null ? reader.len : reader.pos + length;\n\n          while (reader.pos < end) {\n            const tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                obj.requestId = reader.string();\n                break;\n              case 2:\n                obj.filterSubscribeType =\n                  FilterSubscribeRequest.FilterSubscribeType.codec().decode(\n                    reader\n                  );\n                break;\n              case 10:\n                obj.pubsubTopic = reader.string();\n                break;\n              case 11:\n                obj.contentTopics.push(reader.string());\n                break;\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return obj;\n        }\n      );\n    }\n\n    return _codec;\n  };\n\n  export const encode = (obj: Partial<FilterSubscribeRequest>): Uint8Array => {\n    return encodeMessage(obj, FilterSubscribeRequest.codec());\n  };\n\n  export const decode = (\n    buf: Uint8Array | Uint8ArrayList\n  ): FilterSubscribeRequest => {\n    return decodeMessage(buf, FilterSubscribeRequest.codec());\n  };\n}\n\nexport interface FilterSubscribeResponse {\n  requestId: string;\n  statusCode: number;\n  statusDesc?: string;\n}\n\nexport namespace FilterSubscribeResponse {\n  let _codec: Codec<FilterSubscribeResponse>;\n\n  export const codec = (): Codec<FilterSubscribeResponse> => {\n    if (_codec == null) {\n      _codec = message<FilterSubscribeResponse>(\n        (obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork();\n          }\n\n          if (obj.requestId != null && obj.requestId !== \"\") {\n            w.uint32(10);\n            w.string(obj.requestId);\n          }\n\n          if (obj.statusCode != null && obj.statusCode !== 0) {\n            w.uint32(80);\n            w.uint32(obj.statusCode);\n          }\n\n          if (obj.statusDesc != null) {\n            w.uint32(90);\n            w.string(obj.statusDesc);\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim();\n          }\n        },\n        (reader, length) => {\n          const obj: any = {\n            requestId: \"\",\n            statusCode: 0,\n          };\n\n          const end = length == null ? reader.len : reader.pos + length;\n\n          while (reader.pos < end) {\n            const tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                obj.requestId = reader.string();\n                break;\n              case 10:\n                obj.statusCode = reader.uint32();\n                break;\n              case 11:\n                obj.statusDesc = reader.string();\n                break;\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return obj;\n        }\n      );\n    }\n\n    return _codec;\n  };\n\n  export const encode = (obj: Partial<FilterSubscribeResponse>): Uint8Array => {\n    return encodeMessage(obj, FilterSubscribeResponse.codec());\n  };\n\n  export const decode = (\n    buf: Uint8Array | Uint8ArrayList\n  ): FilterSubscribeResponse => {\n    return decodeMessage(buf, FilterSubscribeResponse.codec());\n  };\n}\n\nexport interface MessagePush {\n  wakuMessage?: WakuMessage;\n  pubsubTopic?: string;\n}\n\nexport namespace MessagePush {\n  let _codec: Codec<MessagePush>;\n\n  export const codec = (): Codec<MessagePush> => {\n    if (_codec == null) {\n      _codec = message<MessagePush>(\n        (obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork();\n          }\n\n          if (obj.wakuMessage != null) {\n            w.uint32(10);\n            WakuMessage.codec().encode(obj.wakuMessage, w);\n          }\n\n          if (obj.pubsubTopic != null) {\n            w.uint32(18);\n            w.string(obj.pubsubTopic);\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim();\n          }\n        },\n        (reader, length) => {\n          const obj: any = {};\n\n          const end = length == null ? reader.len : reader.pos + length;\n\n          while (reader.pos < end) {\n            const tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                obj.wakuMessage = WakuMessage.codec().decode(\n                  reader,\n                  reader.uint32()\n                );\n                break;\n              case 2:\n                obj.pubsubTopic = reader.string();\n                break;\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return obj;\n        }\n      );\n    }\n\n    return _codec;\n  };\n\n  export const encode = (obj: Partial<MessagePush>): Uint8Array => {\n    return encodeMessage(obj, MessagePush.codec());\n  };\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): MessagePush => {\n    return decodeMessage(buf, MessagePush.codec());\n  };\n}\n\nexport interface RateLimitProof {\n  proof: Uint8Array;\n  merkleRoot: Uint8Array;\n  epoch: Uint8Array;\n  shareX: Uint8Array;\n  shareY: Uint8Array;\n  nullifier: Uint8Array;\n  rlnIdentifier: Uint8Array;\n}\n\nexport namespace RateLimitProof {\n  let _codec: Codec<RateLimitProof>;\n\n  export const codec = (): Codec<RateLimitProof> => {\n    if (_codec == null) {\n      _codec = message<RateLimitProof>(\n        (obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork();\n          }\n\n          if (obj.proof != null && obj.proof.byteLength > 0) {\n            w.uint32(10);\n            w.bytes(obj.proof);\n          }\n\n          if (obj.merkleRoot != null && obj.merkleRoot.byteLength > 0) {\n            w.uint32(18);\n            w.bytes(obj.merkleRoot);\n          }\n\n          if (obj.epoch != null && obj.epoch.byteLength > 0) {\n            w.uint32(26);\n            w.bytes(obj.epoch);\n          }\n\n          if (obj.shareX != null && obj.shareX.byteLength > 0) {\n            w.uint32(34);\n            w.bytes(obj.shareX);\n          }\n\n          if (obj.shareY != null && obj.shareY.byteLength > 0) {\n            w.uint32(42);\n            w.bytes(obj.shareY);\n          }\n\n          if (obj.nullifier != null && obj.nullifier.byteLength > 0) {\n            w.uint32(50);\n            w.bytes(obj.nullifier);\n          }\n\n          if (obj.rlnIdentifier != null && obj.rlnIdentifier.byteLength > 0) {\n            w.uint32(58);\n            w.bytes(obj.rlnIdentifier);\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim();\n          }\n        },\n        (reader, length) => {\n          const obj: any = {\n            proof: new Uint8Array(0),\n            merkleRoot: new Uint8Array(0),\n            epoch: new Uint8Array(0),\n            shareX: new Uint8Array(0),\n            shareY: new Uint8Array(0),\n            nullifier: new Uint8Array(0),\n            rlnIdentifier: new Uint8Array(0),\n          };\n\n          const end = length == null ? reader.len : reader.pos + length;\n\n          while (reader.pos < end) {\n            const tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                obj.proof = reader.bytes();\n                break;\n              case 2:\n                obj.merkleRoot = reader.bytes();\n                break;\n              case 3:\n                obj.epoch = reader.bytes();\n                break;\n              case 4:\n                obj.shareX = reader.bytes();\n                break;\n              case 5:\n                obj.shareY = reader.bytes();\n                break;\n              case 6:\n                obj.nullifier = reader.bytes();\n                break;\n              case 7:\n                obj.rlnIdentifier = reader.bytes();\n                break;\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return obj;\n        }\n      );\n    }\n\n    return _codec;\n  };\n\n  export const encode = (obj: Partial<RateLimitProof>): Uint8Array => {\n    return encodeMessage(obj, RateLimitProof.codec());\n  };\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): RateLimitProof => {\n    return decodeMessage(buf, RateLimitProof.codec());\n  };\n}\n\nexport interface WakuMessage {\n  payload: Uint8Array;\n  contentTopic: string;\n  version?: number;\n  timestamp?: bigint;\n  meta?: Uint8Array;\n  rateLimitProof?: RateLimitProof;\n  ephemeral?: boolean;\n}\n\nexport namespace WakuMessage {\n  let _codec: Codec<WakuMessage>;\n\n  export const codec = (): Codec<WakuMessage> => {\n    if (_codec == null) {\n      _codec = message<WakuMessage>(\n        (obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork();\n          }\n\n          if (obj.payload != null && obj.payload.byteLength > 0) {\n            w.uint32(10);\n            w.bytes(obj.payload);\n          }\n\n          if (obj.contentTopic != null && obj.contentTopic !== \"\") {\n            w.uint32(18);\n            w.string(obj.contentTopic);\n          }\n\n          if (obj.version != null) {\n            w.uint32(24);\n            w.uint32(obj.version);\n          }\n\n          if (obj.timestamp != null) {\n            w.uint32(80);\n            w.sint64(obj.timestamp);\n          }\n\n          if (obj.meta != null) {\n            w.uint32(90);\n            w.bytes(obj.meta);\n          }\n\n          if (obj.rateLimitProof != null) {\n            w.uint32(170);\n            RateLimitProof.codec().encode(obj.rateLimitProof, w);\n          }\n\n          if (obj.ephemeral != null) {\n            w.uint32(248);\n            w.bool(obj.ephemeral);\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim();\n          }\n        },\n        (reader, length) => {\n          const obj: any = {\n            payload: new Uint8Array(0),\n            contentTopic: \"\",\n          };\n\n          const end = length == null ? reader.len : reader.pos + length;\n\n          while (reader.pos < end) {\n            const tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                obj.payload = reader.bytes();\n                break;\n              case 2:\n                obj.contentTopic = reader.string();\n                break;\n              case 3:\n                obj.version = reader.uint32();\n                break;\n              case 10:\n                obj.timestamp = reader.sint64();\n                break;\n              case 11:\n                obj.meta = reader.bytes();\n                break;\n              case 21:\n                obj.rateLimitProof = RateLimitProof.codec().decode(\n                  reader,\n                  reader.uint32()\n                );\n                break;\n              case 31:\n                obj.ephemeral = reader.bool();\n                break;\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return obj;\n        }\n      );\n    }\n\n    return _codec;\n  };\n\n  export const encode = (obj: Partial<WakuMessage>): Uint8Array => {\n    return encodeMessage(obj, WakuMessage.codec());\n  };\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): WakuMessage => {\n    return decodeMessage(buf, WakuMessage.codec());\n  };\n}\n", "/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nimport { encodeMessage, decodeMessage, message } from \"protons-runtime\";\nimport type { Codec } from \"protons-runtime\";\nimport type { Uint8ArrayList } from \"uint8arraylist\";\n\nexport interface PushRequest {\n  pubsubTopic: string;\n  message?: WakuMessage;\n}\n\nexport namespace PushRequest {\n  let _codec: Codec<PushRequest>;\n\n  export const codec = (): Codec<PushRequest> => {\n    if (_codec == null) {\n      _codec = message<PushRequest>(\n        (obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork();\n          }\n\n          if (obj.pubsubTopic != null && obj.pubsubTopic !== \"\") {\n            w.uint32(10);\n            w.string(obj.pubsubTopic);\n          }\n\n          if (obj.message != null) {\n            w.uint32(18);\n            WakuMessage.codec().encode(obj.message, w);\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim();\n          }\n        },\n        (reader, length) => {\n          const obj: any = {\n            pubsubTopic: \"\",\n          };\n\n          const end = length == null ? reader.len : reader.pos + length;\n\n          while (reader.pos < end) {\n            const tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                obj.pubsubTopic = reader.string();\n                break;\n              case 2:\n                obj.message = WakuMessage.codec().decode(\n                  reader,\n                  reader.uint32()\n                );\n                break;\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return obj;\n        }\n      );\n    }\n\n    return _codec;\n  };\n\n  export const encode = (obj: Partial<PushRequest>): Uint8Array => {\n    return encodeMessage(obj, PushRequest.codec());\n  };\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): PushRequest => {\n    return decodeMessage(buf, PushRequest.codec());\n  };\n}\n\nexport interface PushResponse {\n  isSuccess: boolean;\n  info?: string;\n}\n\nexport namespace PushResponse {\n  let _codec: Codec<PushResponse>;\n\n  export const codec = (): Codec<PushResponse> => {\n    if (_codec == null) {\n      _codec = message<PushResponse>(\n        (obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork();\n          }\n\n          if (obj.isSuccess != null && obj.isSuccess !== false) {\n            w.uint32(8);\n            w.bool(obj.isSuccess);\n          }\n\n          if (obj.info != null) {\n            w.uint32(18);\n            w.string(obj.info);\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim();\n          }\n        },\n        (reader, length) => {\n          const obj: any = {\n            isSuccess: false,\n          };\n\n          const end = length == null ? reader.len : reader.pos + length;\n\n          while (reader.pos < end) {\n            const tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                obj.isSuccess = reader.bool();\n                break;\n              case 2:\n                obj.info = reader.string();\n                break;\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return obj;\n        }\n      );\n    }\n\n    return _codec;\n  };\n\n  export const encode = (obj: Partial<PushResponse>): Uint8Array => {\n    return encodeMessage(obj, PushResponse.codec());\n  };\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): PushResponse => {\n    return decodeMessage(buf, PushResponse.codec());\n  };\n}\n\nexport interface PushRpc {\n  requestId: string;\n  request?: PushRequest;\n  response?: PushResponse;\n}\n\nexport namespace PushRpc {\n  let _codec: Codec<PushRpc>;\n\n  export const codec = (): Codec<PushRpc> => {\n    if (_codec == null) {\n      _codec = message<PushRpc>(\n        (obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork();\n          }\n\n          if (obj.requestId != null && obj.requestId !== \"\") {\n            w.uint32(10);\n            w.string(obj.requestId);\n          }\n\n          if (obj.request != null) {\n            w.uint32(18);\n            PushRequest.codec().encode(obj.request, w);\n          }\n\n          if (obj.response != null) {\n            w.uint32(26);\n            PushResponse.codec().encode(obj.response, w);\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim();\n          }\n        },\n        (reader, length) => {\n          const obj: any = {\n            requestId: \"\",\n          };\n\n          const end = length == null ? reader.len : reader.pos + length;\n\n          while (reader.pos < end) {\n            const tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                obj.requestId = reader.string();\n                break;\n              case 2:\n                obj.request = PushRequest.codec().decode(\n                  reader,\n                  reader.uint32()\n                );\n                break;\n              case 3:\n                obj.response = PushResponse.codec().decode(\n                  reader,\n                  reader.uint32()\n                );\n                break;\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return obj;\n        }\n      );\n    }\n\n    return _codec;\n  };\n\n  export const encode = (obj: Partial<PushRpc>): Uint8Array => {\n    return encodeMessage(obj, PushRpc.codec());\n  };\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): PushRpc => {\n    return decodeMessage(buf, PushRpc.codec());\n  };\n}\n\nexport interface RateLimitProof {\n  proof: Uint8Array;\n  merkleRoot: Uint8Array;\n  epoch: Uint8Array;\n  shareX: Uint8Array;\n  shareY: Uint8Array;\n  nullifier: Uint8Array;\n  rlnIdentifier: Uint8Array;\n}\n\nexport namespace RateLimitProof {\n  let _codec: Codec<RateLimitProof>;\n\n  export const codec = (): Codec<RateLimitProof> => {\n    if (_codec == null) {\n      _codec = message<RateLimitProof>(\n        (obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork();\n          }\n\n          if (obj.proof != null && obj.proof.byteLength > 0) {\n            w.uint32(10);\n            w.bytes(obj.proof);\n          }\n\n          if (obj.merkleRoot != null && obj.merkleRoot.byteLength > 0) {\n            w.uint32(18);\n            w.bytes(obj.merkleRoot);\n          }\n\n          if (obj.epoch != null && obj.epoch.byteLength > 0) {\n            w.uint32(26);\n            w.bytes(obj.epoch);\n          }\n\n          if (obj.shareX != null && obj.shareX.byteLength > 0) {\n            w.uint32(34);\n            w.bytes(obj.shareX);\n          }\n\n          if (obj.shareY != null && obj.shareY.byteLength > 0) {\n            w.uint32(42);\n            w.bytes(obj.shareY);\n          }\n\n          if (obj.nullifier != null && obj.nullifier.byteLength > 0) {\n            w.uint32(50);\n            w.bytes(obj.nullifier);\n          }\n\n          if (obj.rlnIdentifier != null && obj.rlnIdentifier.byteLength > 0) {\n            w.uint32(58);\n            w.bytes(obj.rlnIdentifier);\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim();\n          }\n        },\n        (reader, length) => {\n          const obj: any = {\n            proof: new Uint8Array(0),\n            merkleRoot: new Uint8Array(0),\n            epoch: new Uint8Array(0),\n            shareX: new Uint8Array(0),\n            shareY: new Uint8Array(0),\n            nullifier: new Uint8Array(0),\n            rlnIdentifier: new Uint8Array(0),\n          };\n\n          const end = length == null ? reader.len : reader.pos + length;\n\n          while (reader.pos < end) {\n            const tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                obj.proof = reader.bytes();\n                break;\n              case 2:\n                obj.merkleRoot = reader.bytes();\n                break;\n              case 3:\n                obj.epoch = reader.bytes();\n                break;\n              case 4:\n                obj.shareX = reader.bytes();\n                break;\n              case 5:\n                obj.shareY = reader.bytes();\n                break;\n              case 6:\n                obj.nullifier = reader.bytes();\n                break;\n              case 7:\n                obj.rlnIdentifier = reader.bytes();\n                break;\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return obj;\n        }\n      );\n    }\n\n    return _codec;\n  };\n\n  export const encode = (obj: Partial<RateLimitProof>): Uint8Array => {\n    return encodeMessage(obj, RateLimitProof.codec());\n  };\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): RateLimitProof => {\n    return decodeMessage(buf, RateLimitProof.codec());\n  };\n}\n\nexport interface WakuMessage {\n  payload: Uint8Array;\n  contentTopic: string;\n  version?: number;\n  timestamp?: bigint;\n  meta?: Uint8Array;\n  rateLimitProof?: RateLimitProof;\n  ephemeral?: boolean;\n}\n\nexport namespace WakuMessage {\n  let _codec: Codec<WakuMessage>;\n\n  export const codec = (): Codec<WakuMessage> => {\n    if (_codec == null) {\n      _codec = message<WakuMessage>(\n        (obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork();\n          }\n\n          if (obj.payload != null && obj.payload.byteLength > 0) {\n            w.uint32(10);\n            w.bytes(obj.payload);\n          }\n\n          if (obj.contentTopic != null && obj.contentTopic !== \"\") {\n            w.uint32(18);\n            w.string(obj.contentTopic);\n          }\n\n          if (obj.version != null) {\n            w.uint32(24);\n            w.uint32(obj.version);\n          }\n\n          if (obj.timestamp != null) {\n            w.uint32(80);\n            w.sint64(obj.timestamp);\n          }\n\n          if (obj.meta != null) {\n            w.uint32(90);\n            w.bytes(obj.meta);\n          }\n\n          if (obj.rateLimitProof != null) {\n            w.uint32(170);\n            RateLimitProof.codec().encode(obj.rateLimitProof, w);\n          }\n\n          if (obj.ephemeral != null) {\n            w.uint32(248);\n            w.bool(obj.ephemeral);\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim();\n          }\n        },\n        (reader, length) => {\n          const obj: any = {\n            payload: new Uint8Array(0),\n            contentTopic: \"\",\n          };\n\n          const end = length == null ? reader.len : reader.pos + length;\n\n          while (reader.pos < end) {\n            const tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                obj.payload = reader.bytes();\n                break;\n              case 2:\n                obj.contentTopic = reader.string();\n                break;\n              case 3:\n                obj.version = reader.uint32();\n                break;\n              case 10:\n                obj.timestamp = reader.sint64();\n                break;\n              case 11:\n                obj.meta = reader.bytes();\n                break;\n              case 21:\n                obj.rateLimitProof = RateLimitProof.codec().decode(\n                  reader,\n                  reader.uint32()\n                );\n                break;\n              case 31:\n                obj.ephemeral = reader.bool();\n                break;\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return obj;\n        }\n      );\n    }\n\n    return _codec;\n  };\n\n  export const encode = (obj: Partial<WakuMessage>): Uint8Array => {\n    return encodeMessage(obj, WakuMessage.codec());\n  };\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): WakuMessage => {\n    return decodeMessage(buf, WakuMessage.codec());\n  };\n}\n", "/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nimport {\n  encodeMessage,\n  decodeMessage,\n  message,\n  enumeration,\n} from \"protons-runtime\";\nimport type { Codec } from \"protons-runtime\";\nimport type { Uint8ArrayList } from \"uint8arraylist\";\n\nexport interface Index {\n  digest: Uint8Array;\n  receiverTime: bigint;\n  senderTime: bigint;\n  pubsubTopic: string;\n}\n\nexport namespace Index {\n  let _codec: Codec<Index>;\n\n  export const codec = (): Codec<Index> => {\n    if (_codec == null) {\n      _codec = message<Index>(\n        (obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork();\n          }\n\n          if (obj.digest != null && obj.digest.byteLength > 0) {\n            w.uint32(10);\n            w.bytes(obj.digest);\n          }\n\n          if (obj.receiverTime != null && obj.receiverTime !== 0n) {\n            w.uint32(16);\n            w.sint64(obj.receiverTime);\n          }\n\n          if (obj.senderTime != null && obj.senderTime !== 0n) {\n            w.uint32(24);\n            w.sint64(obj.senderTime);\n          }\n\n          if (obj.pubsubTopic != null && obj.pubsubTopic !== \"\") {\n            w.uint32(34);\n            w.string(obj.pubsubTopic);\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim();\n          }\n        },\n        (reader, length) => {\n          const obj: any = {\n            digest: new Uint8Array(0),\n            receiverTime: 0n,\n            senderTime: 0n,\n            pubsubTopic: \"\",\n          };\n\n          const end = length == null ? reader.len : reader.pos + length;\n\n          while (reader.pos < end) {\n            const tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                obj.digest = reader.bytes();\n                break;\n              case 2:\n                obj.receiverTime = reader.sint64();\n                break;\n              case 3:\n                obj.senderTime = reader.sint64();\n                break;\n              case 4:\n                obj.pubsubTopic = reader.string();\n                break;\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return obj;\n        }\n      );\n    }\n\n    return _codec;\n  };\n\n  export const encode = (obj: Partial<Index>): Uint8Array => {\n    return encodeMessage(obj, Index.codec());\n  };\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): Index => {\n    return decodeMessage(buf, Index.codec());\n  };\n}\n\nexport interface PagingInfo {\n  pageSize?: bigint;\n  cursor?: Index;\n  direction?: PagingInfo.Direction;\n}\n\nexport namespace PagingInfo {\n  export enum Direction {\n    BACKWARD = \"BACKWARD\",\n    FORWARD = \"FORWARD\",\n  }\n\n  enum __DirectionValues {\n    BACKWARD = 0,\n    FORWARD = 1,\n  }\n\n  export namespace Direction {\n    export const codec = (): Codec<Direction> => {\n      return enumeration<Direction>(__DirectionValues);\n    };\n  }\n\n  let _codec: Codec<PagingInfo>;\n\n  export const codec = (): Codec<PagingInfo> => {\n    if (_codec == null) {\n      _codec = message<PagingInfo>(\n        (obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork();\n          }\n\n          if (obj.pageSize != null) {\n            w.uint32(8);\n            w.uint64(obj.pageSize);\n          }\n\n          if (obj.cursor != null) {\n            w.uint32(18);\n            Index.codec().encode(obj.cursor, w);\n          }\n\n          if (obj.direction != null) {\n            w.uint32(24);\n            PagingInfo.Direction.codec().encode(obj.direction, w);\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim();\n          }\n        },\n        (reader, length) => {\n          const obj: any = {};\n\n          const end = length == null ? reader.len : reader.pos + length;\n\n          while (reader.pos < end) {\n            const tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                obj.pageSize = reader.uint64();\n                break;\n              case 2:\n                obj.cursor = Index.codec().decode(reader, reader.uint32());\n                break;\n              case 3:\n                obj.direction = PagingInfo.Direction.codec().decode(reader);\n                break;\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return obj;\n        }\n      );\n    }\n\n    return _codec;\n  };\n\n  export const encode = (obj: Partial<PagingInfo>): Uint8Array => {\n    return encodeMessage(obj, PagingInfo.codec());\n  };\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): PagingInfo => {\n    return decodeMessage(buf, PagingInfo.codec());\n  };\n}\n\nexport interface ContentFilter {\n  contentTopic: string;\n}\n\nexport namespace ContentFilter {\n  let _codec: Codec<ContentFilter>;\n\n  export const codec = (): Codec<ContentFilter> => {\n    if (_codec == null) {\n      _codec = message<ContentFilter>(\n        (obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork();\n          }\n\n          if (obj.contentTopic != null && obj.contentTopic !== \"\") {\n            w.uint32(10);\n            w.string(obj.contentTopic);\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim();\n          }\n        },\n        (reader, length) => {\n          const obj: any = {\n            contentTopic: \"\",\n          };\n\n          const end = length == null ? reader.len : reader.pos + length;\n\n          while (reader.pos < end) {\n            const tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                obj.contentTopic = reader.string();\n                break;\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return obj;\n        }\n      );\n    }\n\n    return _codec;\n  };\n\n  export const encode = (obj: Partial<ContentFilter>): Uint8Array => {\n    return encodeMessage(obj, ContentFilter.codec());\n  };\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): ContentFilter => {\n    return decodeMessage(buf, ContentFilter.codec());\n  };\n}\n\nexport interface HistoryQuery {\n  pubsubTopic?: string;\n  contentFilters: ContentFilter[];\n  pagingInfo?: PagingInfo;\n  startTime?: bigint;\n  endTime?: bigint;\n}\n\nexport namespace HistoryQuery {\n  let _codec: Codec<HistoryQuery>;\n\n  export const codec = (): Codec<HistoryQuery> => {\n    if (_codec == null) {\n      _codec = message<HistoryQuery>(\n        (obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork();\n          }\n\n          if (obj.pubsubTopic != null) {\n            w.uint32(18);\n            w.string(obj.pubsubTopic);\n          }\n\n          if (obj.contentFilters != null) {\n            for (const value of obj.contentFilters) {\n              w.uint32(26);\n              ContentFilter.codec().encode(value, w);\n            }\n          }\n\n          if (obj.pagingInfo != null) {\n            w.uint32(34);\n            PagingInfo.codec().encode(obj.pagingInfo, w);\n          }\n\n          if (obj.startTime != null) {\n            w.uint32(40);\n            w.sint64(obj.startTime);\n          }\n\n          if (obj.endTime != null) {\n            w.uint32(48);\n            w.sint64(obj.endTime);\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim();\n          }\n        },\n        (reader, length) => {\n          const obj: any = {\n            contentFilters: [],\n          };\n\n          const end = length == null ? reader.len : reader.pos + length;\n\n          while (reader.pos < end) {\n            const tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 2:\n                obj.pubsubTopic = reader.string();\n                break;\n              case 3:\n                obj.contentFilters.push(\n                  ContentFilter.codec().decode(reader, reader.uint32())\n                );\n                break;\n              case 4:\n                obj.pagingInfo = PagingInfo.codec().decode(\n                  reader,\n                  reader.uint32()\n                );\n                break;\n              case 5:\n                obj.startTime = reader.sint64();\n                break;\n              case 6:\n                obj.endTime = reader.sint64();\n                break;\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return obj;\n        }\n      );\n    }\n\n    return _codec;\n  };\n\n  export const encode = (obj: Partial<HistoryQuery>): Uint8Array => {\n    return encodeMessage(obj, HistoryQuery.codec());\n  };\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): HistoryQuery => {\n    return decodeMessage(buf, HistoryQuery.codec());\n  };\n}\n\nexport interface HistoryResponse {\n  messages: WakuMessage[];\n  pagingInfo?: PagingInfo;\n  error: HistoryResponse.HistoryError;\n}\n\nexport namespace HistoryResponse {\n  export enum HistoryError {\n    NONE = \"NONE\",\n    INVALID_CURSOR = \"INVALID_CURSOR\",\n  }\n\n  enum __HistoryErrorValues {\n    NONE = 0,\n    INVALID_CURSOR = 1,\n  }\n\n  export namespace HistoryError {\n    export const codec = (): Codec<HistoryError> => {\n      return enumeration<HistoryError>(__HistoryErrorValues);\n    };\n  }\n\n  let _codec: Codec<HistoryResponse>;\n\n  export const codec = (): Codec<HistoryResponse> => {\n    if (_codec == null) {\n      _codec = message<HistoryResponse>(\n        (obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork();\n          }\n\n          if (obj.messages != null) {\n            for (const value of obj.messages) {\n              w.uint32(18);\n              WakuMessage.codec().encode(value, w);\n            }\n          }\n\n          if (obj.pagingInfo != null) {\n            w.uint32(26);\n            PagingInfo.codec().encode(obj.pagingInfo, w);\n          }\n\n          if (obj.error != null && __HistoryErrorValues[obj.error] !== 0) {\n            w.uint32(32);\n            HistoryResponse.HistoryError.codec().encode(obj.error, w);\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim();\n          }\n        },\n        (reader, length) => {\n          const obj: any = {\n            messages: [],\n            error: HistoryError.NONE,\n          };\n\n          const end = length == null ? reader.len : reader.pos + length;\n\n          while (reader.pos < end) {\n            const tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 2:\n                obj.messages.push(\n                  WakuMessage.codec().decode(reader, reader.uint32())\n                );\n                break;\n              case 3:\n                obj.pagingInfo = PagingInfo.codec().decode(\n                  reader,\n                  reader.uint32()\n                );\n                break;\n              case 4:\n                obj.error = HistoryResponse.HistoryError.codec().decode(reader);\n                break;\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return obj;\n        }\n      );\n    }\n\n    return _codec;\n  };\n\n  export const encode = (obj: Partial<HistoryResponse>): Uint8Array => {\n    return encodeMessage(obj, HistoryResponse.codec());\n  };\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): HistoryResponse => {\n    return decodeMessage(buf, HistoryResponse.codec());\n  };\n}\n\nexport interface HistoryRpc {\n  requestId: string;\n  query?: HistoryQuery;\n  response?: HistoryResponse;\n}\n\nexport namespace HistoryRpc {\n  let _codec: Codec<HistoryRpc>;\n\n  export const codec = (): Codec<HistoryRpc> => {\n    if (_codec == null) {\n      _codec = message<HistoryRpc>(\n        (obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork();\n          }\n\n          if (obj.requestId != null && obj.requestId !== \"\") {\n            w.uint32(10);\n            w.string(obj.requestId);\n          }\n\n          if (obj.query != null) {\n            w.uint32(18);\n            HistoryQuery.codec().encode(obj.query, w);\n          }\n\n          if (obj.response != null) {\n            w.uint32(26);\n            HistoryResponse.codec().encode(obj.response, w);\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim();\n          }\n        },\n        (reader, length) => {\n          const obj: any = {\n            requestId: \"\",\n          };\n\n          const end = length == null ? reader.len : reader.pos + length;\n\n          while (reader.pos < end) {\n            const tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                obj.requestId = reader.string();\n                break;\n              case 2:\n                obj.query = HistoryQuery.codec().decode(\n                  reader,\n                  reader.uint32()\n                );\n                break;\n              case 3:\n                obj.response = HistoryResponse.codec().decode(\n                  reader,\n                  reader.uint32()\n                );\n                break;\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return obj;\n        }\n      );\n    }\n\n    return _codec;\n  };\n\n  export const encode = (obj: Partial<HistoryRpc>): Uint8Array => {\n    return encodeMessage(obj, HistoryRpc.codec());\n  };\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): HistoryRpc => {\n    return decodeMessage(buf, HistoryRpc.codec());\n  };\n}\n\nexport interface RateLimitProof {\n  proof: Uint8Array;\n  merkleRoot: Uint8Array;\n  epoch: Uint8Array;\n  shareX: Uint8Array;\n  shareY: Uint8Array;\n  nullifier: Uint8Array;\n  rlnIdentifier: Uint8Array;\n}\n\nexport namespace RateLimitProof {\n  let _codec: Codec<RateLimitProof>;\n\n  export const codec = (): Codec<RateLimitProof> => {\n    if (_codec == null) {\n      _codec = message<RateLimitProof>(\n        (obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork();\n          }\n\n          if (obj.proof != null && obj.proof.byteLength > 0) {\n            w.uint32(10);\n            w.bytes(obj.proof);\n          }\n\n          if (obj.merkleRoot != null && obj.merkleRoot.byteLength > 0) {\n            w.uint32(18);\n            w.bytes(obj.merkleRoot);\n          }\n\n          if (obj.epoch != null && obj.epoch.byteLength > 0) {\n            w.uint32(26);\n            w.bytes(obj.epoch);\n          }\n\n          if (obj.shareX != null && obj.shareX.byteLength > 0) {\n            w.uint32(34);\n            w.bytes(obj.shareX);\n          }\n\n          if (obj.shareY != null && obj.shareY.byteLength > 0) {\n            w.uint32(42);\n            w.bytes(obj.shareY);\n          }\n\n          if (obj.nullifier != null && obj.nullifier.byteLength > 0) {\n            w.uint32(50);\n            w.bytes(obj.nullifier);\n          }\n\n          if (obj.rlnIdentifier != null && obj.rlnIdentifier.byteLength > 0) {\n            w.uint32(58);\n            w.bytes(obj.rlnIdentifier);\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim();\n          }\n        },\n        (reader, length) => {\n          const obj: any = {\n            proof: new Uint8Array(0),\n            merkleRoot: new Uint8Array(0),\n            epoch: new Uint8Array(0),\n            shareX: new Uint8Array(0),\n            shareY: new Uint8Array(0),\n            nullifier: new Uint8Array(0),\n            rlnIdentifier: new Uint8Array(0),\n          };\n\n          const end = length == null ? reader.len : reader.pos + length;\n\n          while (reader.pos < end) {\n            const tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                obj.proof = reader.bytes();\n                break;\n              case 2:\n                obj.merkleRoot = reader.bytes();\n                break;\n              case 3:\n                obj.epoch = reader.bytes();\n                break;\n              case 4:\n                obj.shareX = reader.bytes();\n                break;\n              case 5:\n                obj.shareY = reader.bytes();\n                break;\n              case 6:\n                obj.nullifier = reader.bytes();\n                break;\n              case 7:\n                obj.rlnIdentifier = reader.bytes();\n                break;\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return obj;\n        }\n      );\n    }\n\n    return _codec;\n  };\n\n  export const encode = (obj: Partial<RateLimitProof>): Uint8Array => {\n    return encodeMessage(obj, RateLimitProof.codec());\n  };\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): RateLimitProof => {\n    return decodeMessage(buf, RateLimitProof.codec());\n  };\n}\n\nexport interface WakuMessage {\n  payload: Uint8Array;\n  contentTopic: string;\n  version?: number;\n  timestamp?: bigint;\n  meta?: Uint8Array;\n  rateLimitProof?: RateLimitProof;\n  ephemeral?: boolean;\n}\n\nexport namespace WakuMessage {\n  let _codec: Codec<WakuMessage>;\n\n  export const codec = (): Codec<WakuMessage> => {\n    if (_codec == null) {\n      _codec = message<WakuMessage>(\n        (obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork();\n          }\n\n          if (obj.payload != null && obj.payload.byteLength > 0) {\n            w.uint32(10);\n            w.bytes(obj.payload);\n          }\n\n          if (obj.contentTopic != null && obj.contentTopic !== \"\") {\n            w.uint32(18);\n            w.string(obj.contentTopic);\n          }\n\n          if (obj.version != null) {\n            w.uint32(24);\n            w.uint32(obj.version);\n          }\n\n          if (obj.timestamp != null) {\n            w.uint32(80);\n            w.sint64(obj.timestamp);\n          }\n\n          if (obj.meta != null) {\n            w.uint32(90);\n            w.bytes(obj.meta);\n          }\n\n          if (obj.rateLimitProof != null) {\n            w.uint32(170);\n            RateLimitProof.codec().encode(obj.rateLimitProof, w);\n          }\n\n          if (obj.ephemeral != null) {\n            w.uint32(248);\n            w.bool(obj.ephemeral);\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim();\n          }\n        },\n        (reader, length) => {\n          const obj: any = {\n            payload: new Uint8Array(0),\n            contentTopic: \"\",\n          };\n\n          const end = length == null ? reader.len : reader.pos + length;\n\n          while (reader.pos < end) {\n            const tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                obj.payload = reader.bytes();\n                break;\n              case 2:\n                obj.contentTopic = reader.string();\n                break;\n              case 3:\n                obj.version = reader.uint32();\n                break;\n              case 10:\n                obj.timestamp = reader.sint64();\n                break;\n              case 11:\n                obj.meta = reader.bytes();\n                break;\n              case 21:\n                obj.rateLimitProof = RateLimitProof.codec().decode(\n                  reader,\n                  reader.uint32()\n                );\n                break;\n              case 31:\n                obj.ephemeral = reader.bool();\n                break;\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return obj;\n        }\n      );\n    }\n\n    return _codec;\n  };\n\n  export const encode = (obj: Partial<WakuMessage>): Uint8Array => {\n    return encodeMessage(obj, WakuMessage.codec());\n  };\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): WakuMessage => {\n    return decodeMessage(buf, WakuMessage.codec());\n  };\n}\n", "/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nimport { encodeMessage, decodeMessage, message } from \"protons-runtime\";\nimport type { Codec } from \"protons-runtime\";\nimport type { Uint8ArrayList } from \"uint8arraylist\";\n\nexport interface PeerInfo {\n  enr?: Uint8Array;\n}\n\nexport namespace PeerInfo {\n  let _codec: Codec<PeerInfo>;\n\n  export const codec = (): Codec<PeerInfo> => {\n    if (_codec == null) {\n      _codec = message<PeerInfo>(\n        (obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork();\n          }\n\n          if (obj.enr != null) {\n            w.uint32(10);\n            w.bytes(obj.enr);\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim();\n          }\n        },\n        (reader, length) => {\n          const obj: any = {};\n\n          const end = length == null ? reader.len : reader.pos + length;\n\n          while (reader.pos < end) {\n            const tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                obj.enr = reader.bytes();\n                break;\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return obj;\n        }\n      );\n    }\n\n    return _codec;\n  };\n\n  export const encode = (obj: Partial<PeerInfo>): Uint8Array => {\n    return encodeMessage(obj, PeerInfo.codec());\n  };\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): PeerInfo => {\n    return decodeMessage(buf, PeerInfo.codec());\n  };\n}\n\nexport interface PeerExchangeQuery {\n  numPeers?: bigint;\n}\n\nexport namespace PeerExchangeQuery {\n  let _codec: Codec<PeerExchangeQuery>;\n\n  export const codec = (): Codec<PeerExchangeQuery> => {\n    if (_codec == null) {\n      _codec = message<PeerExchangeQuery>(\n        (obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork();\n          }\n\n          if (obj.numPeers != null) {\n            w.uint32(8);\n            w.uint64(obj.numPeers);\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim();\n          }\n        },\n        (reader, length) => {\n          const obj: any = {};\n\n          const end = length == null ? reader.len : reader.pos + length;\n\n          while (reader.pos < end) {\n            const tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                obj.numPeers = reader.uint64();\n                break;\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return obj;\n        }\n      );\n    }\n\n    return _codec;\n  };\n\n  export const encode = (obj: Partial<PeerExchangeQuery>): Uint8Array => {\n    return encodeMessage(obj, PeerExchangeQuery.codec());\n  };\n\n  export const decode = (\n    buf: Uint8Array | Uint8ArrayList\n  ): PeerExchangeQuery => {\n    return decodeMessage(buf, PeerExchangeQuery.codec());\n  };\n}\n\nexport interface PeerExchangeResponse {\n  peerInfos: PeerInfo[];\n}\n\nexport namespace PeerExchangeResponse {\n  let _codec: Codec<PeerExchangeResponse>;\n\n  export const codec = (): Codec<PeerExchangeResponse> => {\n    if (_codec == null) {\n      _codec = message<PeerExchangeResponse>(\n        (obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork();\n          }\n\n          if (obj.peerInfos != null) {\n            for (const value of obj.peerInfos) {\n              w.uint32(10);\n              PeerInfo.codec().encode(value, w);\n            }\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim();\n          }\n        },\n        (reader, length) => {\n          const obj: any = {\n            peerInfos: [],\n          };\n\n          const end = length == null ? reader.len : reader.pos + length;\n\n          while (reader.pos < end) {\n            const tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                obj.peerInfos.push(\n                  PeerInfo.codec().decode(reader, reader.uint32())\n                );\n                break;\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return obj;\n        }\n      );\n    }\n\n    return _codec;\n  };\n\n  export const encode = (obj: Partial<PeerExchangeResponse>): Uint8Array => {\n    return encodeMessage(obj, PeerExchangeResponse.codec());\n  };\n\n  export const decode = (\n    buf: Uint8Array | Uint8ArrayList\n  ): PeerExchangeResponse => {\n    return decodeMessage(buf, PeerExchangeResponse.codec());\n  };\n}\n\nexport interface PeerExchangeRPC {\n  query?: PeerExchangeQuery;\n  response?: PeerExchangeResponse;\n}\n\nexport namespace PeerExchangeRPC {\n  let _codec: Codec<PeerExchangeRPC>;\n\n  export const codec = (): Codec<PeerExchangeRPC> => {\n    if (_codec == null) {\n      _codec = message<PeerExchangeRPC>(\n        (obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork();\n          }\n\n          if (obj.query != null) {\n            w.uint32(10);\n            PeerExchangeQuery.codec().encode(obj.query, w);\n          }\n\n          if (obj.response != null) {\n            w.uint32(18);\n            PeerExchangeResponse.codec().encode(obj.response, w);\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim();\n          }\n        },\n        (reader, length) => {\n          const obj: any = {};\n\n          const end = length == null ? reader.len : reader.pos + length;\n\n          while (reader.pos < end) {\n            const tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                obj.query = PeerExchangeQuery.codec().decode(\n                  reader,\n                  reader.uint32()\n                );\n                break;\n              case 2:\n                obj.response = PeerExchangeResponse.codec().decode(\n                  reader,\n                  reader.uint32()\n                );\n                break;\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return obj;\n        }\n      );\n    }\n\n    return _codec;\n  };\n\n  export const encode = (obj: Partial<PeerExchangeRPC>): Uint8Array => {\n    return encodeMessage(obj, PeerExchangeRPC.codec());\n  };\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): PeerExchangeRPC => {\n    return decodeMessage(buf, PeerExchangeRPC.codec());\n  };\n}\n", "/**\n * DefaultPubSubTopic is the default gossipsub topic to use for Waku.\n */\nexport const DefaultPubSubTopic = \"/waku/2/default-waku/proto\";\n", "import type { PeerId } from \"@libp2p/interface/peer-id\";\nimport type { PeerStore } from \"@libp2p/interface/peer-store\";\nimport type { IRelay, PeerIdStr } from \"@waku/interfaces\";\nimport type { KeepAliveOptions } from \"@waku/interfaces\";\nimport { Logger } from \"@waku/utils\";\nimport { utf8ToBytes } from \"@waku/utils/bytes\";\nimport type { PingService } from \"libp2p/ping\";\n\nimport { createEncoder } from \"./message/version_0.js\";\n\nexport const RelayPingContentTopic = \"/relay-ping/1/ping/null\";\nconst log = new Logger(\"keep-alive\");\n\nexport class KeepAliveManager {\n  private pingKeepAliveTimers: Map<string, ReturnType<typeof setInterval>>;\n  private relayKeepAliveTimers: Map<PeerId, ReturnType<typeof setInterval>[]>;\n  private options: KeepAliveOptions;\n  private relay?: IRelay;\n\n  constructor(options: KeepAliveOptions, relay?: IRelay) {\n    this.pingKeepAliveTimers = new Map();\n    this.relayKeepAliveTimers = new Map();\n    this.options = options;\n    this.relay = relay;\n  }\n\n  public start(\n    peerId: PeerId,\n    libp2pPing: PingService,\n    peerStore: PeerStore\n  ): void {\n    // Just in case a timer already exists for this peer\n    this.stop(peerId);\n\n    const { pingKeepAlive: pingPeriodSecs, relayKeepAlive: relayPeriodSecs } =\n      this.options;\n\n    const peerIdStr = peerId.toString();\n\n    // Ping the peer every pingPeriodSecs seconds\n    // if pingPeriodSecs is 0, don't ping the peer\n    if (pingPeriodSecs !== 0) {\n      const interval = setInterval(() => {\n        void (async () => {\n          let ping: number;\n          try {\n            // ping the peer for keep alive\n            // also update the peer store with the latency\n            try {\n              ping = await libp2pPing.ping(peerId);\n              log.info(`Ping succeeded (${peerIdStr})`, ping);\n            } catch (error) {\n              log.error(`Ping failed for peer (${peerIdStr}).\n                Next ping will be attempted in ${pingPeriodSecs} seconds.\n              `);\n              return;\n            }\n\n            try {\n              await peerStore.patch(peerId, {\n                metadata: {\n                  ping: utf8ToBytes(ping.toString())\n                }\n              });\n            } catch (e) {\n              log.error(\"Failed to update ping\", e);\n            }\n          } catch (e) {\n            log.error(`Ping failed (${peerIdStr})`, e);\n          }\n        })();\n      }, pingPeriodSecs * 1000);\n\n      this.pingKeepAliveTimers.set(peerIdStr, interval);\n    }\n\n    const relay = this.relay;\n    if (relay && relayPeriodSecs !== 0) {\n      const intervals = this.scheduleRelayPings(\n        relay,\n        relayPeriodSecs,\n        peerId.toString()\n      );\n      this.relayKeepAliveTimers.set(peerId, intervals);\n    }\n  }\n\n  public stop(peerId: PeerId): void {\n    const peerIdStr = peerId.toString();\n\n    if (this.pingKeepAliveTimers.has(peerIdStr)) {\n      clearInterval(this.pingKeepAliveTimers.get(peerIdStr));\n      this.pingKeepAliveTimers.delete(peerIdStr);\n    }\n\n    if (this.relayKeepAliveTimers.has(peerId)) {\n      this.relayKeepAliveTimers.get(peerId)?.map(clearInterval);\n      this.relayKeepAliveTimers.delete(peerId);\n    }\n  }\n\n  public stopAll(): void {\n    for (const timer of [\n      ...Object.values(this.pingKeepAliveTimers),\n      ...Object.values(this.relayKeepAliveTimers)\n    ]) {\n      clearInterval(timer);\n    }\n\n    this.pingKeepAliveTimers.clear();\n    this.relayKeepAliveTimers.clear();\n  }\n\n  private scheduleRelayPings(\n    relay: IRelay,\n    relayPeriodSecs: number,\n    peerIdStr: PeerIdStr\n  ): NodeJS.Timeout[] {\n    // send a ping message to each PubSubTopic the peer is part of\n    const intervals: NodeJS.Timeout[] = [];\n    for (const topic of relay.pubsubTopics) {\n      const meshPeers = relay.getMeshPeers(topic);\n      if (!meshPeers.includes(peerIdStr)) continue;\n\n      const encoder = createEncoder({\n        pubsubTopic: topic,\n        contentTopic: RelayPingContentTopic,\n        ephemeral: true\n      });\n      const interval = setInterval(() => {\n        log.info(\"Sending Waku Relay ping message\");\n        relay\n          .send(encoder, { payload: new Uint8Array([1]) })\n          .catch((e) => log.error(\"Failed to send relay ping\", e));\n      }, relayPeriodSecs * 1000);\n      intervals.push(interval);\n    }\n\n    return intervals;\n  }\n}\n", "import type { PeerId } from \"@libp2p/interface/peer-id\";\nimport type { PeerInfo } from \"@libp2p/interface/peer-info\";\nimport type { Peer } from \"@libp2p/interface/peer-store\";\nimport type { PeerStore } from \"@libp2p/interface/peer-store\";\nimport { CustomEvent, EventEmitter } from \"@libp2p/interfaces/events\";\nimport { decodeRelayShard } from \"@waku/enr\";\nimport {\n  ConnectionManagerOptions,\n  EPeersByDiscoveryEvents,\n  IConnectionManager,\n  IPeersByDiscoveryEvents,\n  IRelay,\n  KeepAliveOptions,\n  PeersByDiscoveryResult,\n  PubSubTopic,\n  ShardInfo\n} from \"@waku/interfaces\";\nimport { Libp2p, Tags } from \"@waku/interfaces\";\nimport { shardInfoToPubSubTopics } from \"@waku/utils\";\nimport { Logger } from \"@waku/utils\";\n\nimport { KeepAliveManager } from \"./keep_alive_manager.js\";\n\nconst log = new Logger(\"connection-manager\");\n\nexport const DEFAULT_MAX_BOOTSTRAP_PEERS_ALLOWED = 1;\nexport const DEFAULT_MAX_DIAL_ATTEMPTS_FOR_PEER = 3;\nexport const DEFAULT_MAX_PARALLEL_DIALS = 3;\n\nexport class ConnectionManager\n  extends EventEmitter<IPeersByDiscoveryEvents>\n  implements IConnectionManager\n{\n  private static instances = new Map<string, ConnectionManager>();\n  private keepAliveManager: KeepAliveManager;\n  private options: ConnectionManagerOptions;\n  private libp2p: Libp2p;\n  private dialAttemptsForPeer: Map<string, number> = new Map();\n  private dialErrorsForPeer: Map<string, any> = new Map();\n\n  private currentActiveParallelDialCount = 0;\n  private pendingPeerDialQueue: Array<PeerId> = [];\n\n  public static create(\n    peerId: string,\n    libp2p: Libp2p,\n    keepAliveOptions: KeepAliveOptions,\n    pubsubTopics: PubSubTopic[],\n    relay?: IRelay,\n    options?: ConnectionManagerOptions\n  ): ConnectionManager {\n    let instance = ConnectionManager.instances.get(peerId);\n    if (!instance) {\n      instance = new ConnectionManager(\n        libp2p,\n        keepAliveOptions,\n        pubsubTopics,\n        relay,\n        options\n      );\n      ConnectionManager.instances.set(peerId, instance);\n    }\n\n    return instance;\n  }\n\n  public async getPeersByDiscovery(): Promise<PeersByDiscoveryResult> {\n    const peersDiscovered = await this.libp2p.peerStore.all();\n    const peersConnected = this.libp2p\n      .getConnections()\n      .map((conn) => conn.remotePeer);\n\n    const peersDiscoveredByBootstrap: Peer[] = [];\n    const peersDiscoveredByPeerExchange: Peer[] = [];\n    const peersConnectedByBootstrap: Peer[] = [];\n    const peersConnectedByPeerExchange: Peer[] = [];\n\n    for (const peer of peersDiscovered) {\n      const tags = await this.getTagNamesForPeer(peer.id);\n\n      if (tags.includes(Tags.BOOTSTRAP)) {\n        peersDiscoveredByBootstrap.push(peer);\n      } else if (tags.includes(Tags.PEER_EXCHANGE)) {\n        peersDiscoveredByPeerExchange.push(peer);\n      }\n    }\n\n    for (const peerId of peersConnected) {\n      const peer = await this.libp2p.peerStore.get(peerId);\n      const tags = await this.getTagNamesForPeer(peerId);\n\n      if (tags.includes(Tags.BOOTSTRAP)) {\n        peersConnectedByBootstrap.push(peer);\n      } else if (tags.includes(Tags.PEER_EXCHANGE)) {\n        peersConnectedByPeerExchange.push(peer);\n      }\n    }\n\n    return {\n      DISCOVERED: {\n        [Tags.BOOTSTRAP]: peersDiscoveredByBootstrap,\n        [Tags.PEER_EXCHANGE]: peersDiscoveredByPeerExchange\n      },\n      CONNECTED: {\n        [Tags.BOOTSTRAP]: peersConnectedByBootstrap,\n        [Tags.PEER_EXCHANGE]: peersConnectedByPeerExchange\n      }\n    };\n  }\n\n  private constructor(\n    libp2p: Libp2p,\n    keepAliveOptions: KeepAliveOptions,\n    private configuredPubSubTopics: PubSubTopic[],\n    relay?: IRelay,\n    options?: Partial<ConnectionManagerOptions>\n  ) {\n    super();\n    this.libp2p = libp2p;\n    this.configuredPubSubTopics = configuredPubSubTopics;\n    this.options = {\n      maxDialAttemptsForPeer: DEFAULT_MAX_DIAL_ATTEMPTS_FOR_PEER,\n      maxBootstrapPeersAllowed: DEFAULT_MAX_BOOTSTRAP_PEERS_ALLOWED,\n      maxParallelDials: DEFAULT_MAX_PARALLEL_DIALS,\n      ...options\n    };\n\n    this.keepAliveManager = new KeepAliveManager(keepAliveOptions, relay);\n\n    this.run()\n      .then(() => log.info(`Connection Manager is now running`))\n      .catch((error) =>\n        log.error(`Unexpected error while running service`, error)\n      );\n\n    // libp2p emits `peer:discovery` events during its initialization\n    // which means that before the ConnectionManager is initialized, some peers may have been discovered\n    // we will dial the peers in peerStore ONCE before we start to listen to the `peer:discovery` events within the ConnectionManager\n    this.dialPeerStorePeers().catch((error) =>\n      log.error(`Unexpected error while dialing peer store peers`, error)\n    );\n  }\n\n  private async dialPeerStorePeers(): Promise<void> {\n    const peerInfos = await this.libp2p.peerStore.all();\n    const dialPromises = [];\n    for (const peerInfo of peerInfos) {\n      if (\n        this.libp2p.getConnections().find((c) => c.remotePeer === peerInfo.id)\n      )\n        continue;\n\n      dialPromises.push(this.attemptDial(peerInfo.id));\n    }\n    try {\n      await Promise.all(dialPromises);\n    } catch (error) {\n      log.error(`Unexpected error while dialing peer store peers`, error);\n    }\n  }\n\n  private async run(): Promise<void> {\n    // start event listeners\n    this.startPeerDiscoveryListener();\n    this.startPeerConnectionListener();\n    this.startPeerDisconnectionListener();\n  }\n\n  stop(): void {\n    this.keepAliveManager.stopAll();\n    this.libp2p.removeEventListener(\n      \"peer:connect\",\n      this.onEventHandlers[\"peer:connect\"]\n    );\n    this.libp2p.removeEventListener(\n      \"peer:disconnect\",\n      this.onEventHandlers[\"peer:disconnect\"]\n    );\n    this.libp2p.removeEventListener(\n      \"peer:discovery\",\n      this.onEventHandlers[\"peer:discovery\"]\n    );\n  }\n\n  private async dialPeer(peerId: PeerId): Promise<void> {\n    this.currentActiveParallelDialCount += 1;\n    let dialAttempt = 0;\n    while (dialAttempt < this.options.maxDialAttemptsForPeer) {\n      try {\n        log.info(\n          `Dialing peer ${peerId.toString()} on attempt ${dialAttempt + 1}`\n        );\n        await this.libp2p.dial(peerId);\n\n        const tags = await this.getTagNamesForPeer(peerId);\n        // add tag to connection describing discovery mechanism\n        // don't add duplicate tags\n        this.libp2p.getConnections(peerId).forEach((conn) => {\n          conn.tags = Array.from(new Set([...conn.tags, ...tags]));\n        });\n\n        // instead of deleting the peer from the peer store, we set the dial attempt to -1\n        // this helps us keep track of peers that have been dialed before\n        this.dialAttemptsForPeer.set(peerId.toString(), -1);\n\n        // Dialing succeeded, break the loop\n        break;\n      } catch (error) {\n        if (error instanceof AggregateError) {\n          // Handle AggregateError\n          log.error(\n            `Error dialing peer ${peerId.toString()} - ${error.errors}`\n          );\n        } else {\n          // Handle generic error\n          log.error(\n            `Error dialing peer ${peerId.toString()} - ${\n              (error as any).message\n            }`\n          );\n        }\n        this.dialErrorsForPeer.set(peerId.toString(), error);\n\n        dialAttempt++;\n        this.dialAttemptsForPeer.set(peerId.toString(), dialAttempt);\n      }\n    }\n\n    // Always decrease the active dial count and process the dial queue\n    this.currentActiveParallelDialCount--;\n    this.processDialQueue();\n\n    // If max dial attempts reached and dialing failed, delete the peer\n    if (dialAttempt === this.options.maxDialAttemptsForPeer) {\n      try {\n        const error = this.dialErrorsForPeer.get(peerId.toString());\n\n        if (error) {\n          let errorMessage;\n          if (error instanceof AggregateError) {\n            if (!error.errors) {\n              log.warn(`No errors array found for AggregateError`);\n            } else if (error.errors.length === 0) {\n              log.warn(`Errors array is empty for AggregateError`);\n            } else {\n              errorMessage = JSON.stringify(error.errors[0]);\n            }\n          } else {\n            errorMessage = error.message;\n          }\n\n          log.info(\n            `Deleting undialable peer ${peerId.toString()} from peer store. Reason: ${errorMessage}`\n          );\n        }\n\n        this.dialErrorsForPeer.delete(peerId.toString());\n        await this.libp2p.peerStore.delete(peerId);\n      } catch (error) {\n        throw new Error(\n          `Error deleting undialable peer ${peerId.toString()} from peer store - ${error}`\n        );\n      }\n    }\n  }\n\n  private async dropConnection(peerId: PeerId): Promise<void> {\n    try {\n      this.keepAliveManager.stop(peerId);\n      await this.libp2p.hangUp(peerId);\n      log.info(`Dropped connection with peer ${peerId.toString()}`);\n    } catch (error) {\n      log.error(\n        `Error dropping connection with peer ${peerId.toString()} - ${error}`\n      );\n    }\n  }\n\n  private processDialQueue(): void {\n    if (\n      this.pendingPeerDialQueue.length > 0 &&\n      this.currentActiveParallelDialCount < this.options.maxParallelDials\n    ) {\n      const peerId = this.pendingPeerDialQueue.shift();\n      if (!peerId) return;\n      this.attemptDial(peerId).catch((error) => {\n        log.error(error);\n      });\n    }\n  }\n\n  private startPeerDiscoveryListener(): void {\n    this.libp2p.addEventListener(\n      \"peer:discovery\",\n      this.onEventHandlers[\"peer:discovery\"]\n    );\n  }\n\n  private startPeerConnectionListener(): void {\n    this.libp2p.addEventListener(\n      \"peer:connect\",\n      this.onEventHandlers[\"peer:connect\"]\n    );\n  }\n\n  private startPeerDisconnectionListener(): void {\n    // TODO: ensure that these following issues are updated and confirmed\n    /**\n     * NOTE: Event is not being emitted on closing nor losing a connection.\n     * @see https://github.com/libp2p/js-libp2p/issues/939\n     * @see https://github.com/status-im/js-waku/issues/252\n     *\n     * >This event will be triggered anytime we are disconnected from another peer,\n     * >regardless of the circumstances of that disconnection.\n     * >If we happen to have multiple connections to a peer,\n     * >this event will **only** be triggered when the last connection is closed.\n     * @see https://github.com/libp2p/js-libp2p/blob/bad9e8c0ff58d60a78314077720c82ae331cc55b/doc/API.md?plain=1#L2100\n     */\n    this.libp2p.addEventListener(\n      \"peer:disconnect\",\n      this.onEventHandlers[\"peer:disconnect\"]\n    );\n  }\n\n  private async attemptDial(peerId: PeerId): Promise<void> {\n    if (!(await this.shouldDialPeer(peerId))) return;\n\n    if (this.currentActiveParallelDialCount >= this.options.maxParallelDials) {\n      this.pendingPeerDialQueue.push(peerId);\n      return;\n    }\n\n    this.dialPeer(peerId).catch((err) => {\n      log.error(`Error dialing peer ${peerId.toString()} : ${err}`);\n    });\n  }\n\n  private onEventHandlers = {\n    \"peer:discovery\": (evt: CustomEvent<PeerInfo>): void => {\n      void (async () => {\n        const { id: peerId } = evt.detail;\n\n        await this.dispatchDiscoveryEvent(peerId);\n\n        try {\n          await this.attemptDial(peerId);\n        } catch (error) {\n          log.error(`Error dialing peer ${peerId.toString()} : ${error}`);\n        }\n      })();\n    },\n    \"peer:connect\": (evt: CustomEvent<PeerId>): void => {\n      void (async () => {\n        const peerId = evt.detail;\n\n        this.keepAliveManager.start(\n          peerId,\n          this.libp2p.services.ping,\n          this.libp2p.peerStore\n        );\n\n        const isBootstrap = (await this.getTagNamesForPeer(peerId)).includes(\n          Tags.BOOTSTRAP\n        );\n\n        if (isBootstrap) {\n          const bootstrapConnections = this.libp2p\n            .getConnections()\n            .filter((conn) => conn.tags.includes(Tags.BOOTSTRAP));\n\n          // If we have too many bootstrap connections, drop one\n          if (\n            bootstrapConnections.length > this.options.maxBootstrapPeersAllowed\n          ) {\n            await this.dropConnection(peerId);\n          } else {\n            this.dispatchEvent(\n              new CustomEvent<PeerId>(\n                EPeersByDiscoveryEvents.PEER_CONNECT_BOOTSTRAP,\n                {\n                  detail: peerId\n                }\n              )\n            );\n          }\n        } else {\n          this.dispatchEvent(\n            new CustomEvent<PeerId>(\n              EPeersByDiscoveryEvents.PEER_CONNECT_PEER_EXCHANGE,\n              {\n                detail: peerId\n              }\n            )\n          );\n        }\n      })();\n    },\n    \"peer:disconnect\": () => {\n      return (evt: CustomEvent<PeerId>): void => {\n        this.keepAliveManager.stop(evt.detail);\n      };\n    }\n  };\n\n  /**\n   * Checks if the peer should be dialed based on the following conditions:\n   * 1. If the peer is already connected, don't dial\n   * 2. If the peer is not part of any of the configured pubsub topics, don't dial\n   * 3. If the peer is not dialable based on bootstrap status, don't dial\n   * 4. If the peer is already has an active dial attempt, or has been dialed before, don't dial it\n   * @returns true if the peer should be dialed, false otherwise\n   */\n  private async shouldDialPeer(peerId: PeerId): Promise<boolean> {\n    // if we're already connected to the peer, don't dial\n    const isConnected = this.libp2p.getConnections(peerId).length > 0;\n    if (isConnected) {\n      log.warn(`Already connected to peer ${peerId.toString()}. Not dialing.`);\n      return false;\n    }\n\n    // if the peer is not part of any of the configured pubsub topics, don't dial\n    if (!(await this.isPeerTopicConfigured(peerId))) {\n      const shardInfo = await this.getPeerShardInfo(\n        peerId,\n        this.libp2p.peerStore\n      );\n      log.warn(\n        `Discovered peer ${peerId.toString()} with ShardInfo ${shardInfo} is not part of any of the configured pubsub topics (${\n          this.configuredPubSubTopics\n        }). \n            Not dialing.`\n      );\n      return false;\n    }\n\n    // if the peer is not dialable based on bootstrap status, don't dial\n    if (!(await this.isPeerDialableBasedOnBootstrapStatus(peerId))) {\n      log.warn(\n        `Peer ${peerId.toString()} is not dialable based on bootstrap status. Not dialing.`\n      );\n      return false;\n    }\n\n    // If the peer is already already has an active dial attempt, or has been dialed before, don't dial it\n    if (this.dialAttemptsForPeer.has(peerId.toString())) {\n      log.warn(\n        `Peer ${peerId.toString()} has already been attempted dial before, or already has a dial attempt in progress, skipping dial`\n      );\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Checks if the peer is dialable based on the following conditions:\n   * 1. If the peer is a bootstrap peer, it is only dialable if the number of current bootstrap connections is less than the max allowed.\n   * 2. If the peer is not a bootstrap peer\n   */\n  private async isPeerDialableBasedOnBootstrapStatus(\n    peerId: PeerId\n  ): Promise<boolean> {\n    const tagNames = await this.getTagNamesForPeer(peerId);\n\n    const isBootstrap = tagNames.some((tagName) => tagName === Tags.BOOTSTRAP);\n\n    if (isBootstrap) {\n      const currentBootstrapConnections = this.libp2p\n        .getConnections()\n        .filter((conn) => {\n          return conn.tags.find((name) => name === Tags.BOOTSTRAP);\n        }).length;\n      if (currentBootstrapConnections < this.options.maxBootstrapPeersAllowed)\n        return true;\n    } else {\n      return true;\n    }\n\n    return false;\n  }\n\n  private async dispatchDiscoveryEvent(peerId: PeerId): Promise<void> {\n    const isBootstrap = (await this.getTagNamesForPeer(peerId)).includes(\n      Tags.BOOTSTRAP\n    );\n\n    this.dispatchEvent(\n      new CustomEvent<PeerId>(\n        isBootstrap\n          ? EPeersByDiscoveryEvents.PEER_DISCOVERY_BOOTSTRAP\n          : EPeersByDiscoveryEvents.PEER_DISCOVERY_PEER_EXCHANGE,\n        {\n          detail: peerId\n        }\n      )\n    );\n  }\n\n  /**\n   * Fetches the tag names for a given peer\n   */\n  private async getTagNamesForPeer(peerId: PeerId): Promise<string[]> {\n    try {\n      const peer = await this.libp2p.peerStore.get(peerId);\n      return Array.from(peer.tags.keys());\n    } catch (error) {\n      log.error(`Failed to get peer ${peerId}, error: ${error}`);\n      return [];\n    }\n  }\n\n  private async isPeerTopicConfigured(peerId: PeerId): Promise<boolean> {\n    const shardInfo = await this.getPeerShardInfo(\n      peerId,\n      this.libp2p.peerStore\n    );\n\n    // If there's no shard information, simply return true\n    if (!shardInfo) return true;\n\n    const pubsubTopics = shardInfoToPubSubTopics(shardInfo);\n\n    const isTopicConfigured = pubsubTopics.some((topic) =>\n      this.configuredPubSubTopics.includes(topic)\n    );\n    return isTopicConfigured;\n  }\n\n  private async getPeerShardInfo(\n    peerId: PeerId,\n    peerStore: PeerStore\n  ): Promise<ShardInfo | undefined> {\n    const peer = await peerStore.get(peerId);\n    const shardInfoBytes = peer.metadata.get(\"shardInfo\");\n    if (!shardInfoBytes) return undefined;\n    return decodeRelayShard(shardInfoBytes);\n  }\n}\n", "export * as version_0 from \"./version_0.js\";\n", "import { Stream } from \"@libp2p/interface/connection\";\nimport type { Peer } from \"@libp2p/interface/peer-store\";\nimport type { IncomingStreamData } from \"@libp2p/interface-internal/registrar\";\nimport type {\n  Callback,\n  ContentTopic,\n  IAsyncIterator,\n  IDecodedMessage,\n  IDecoder,\n  IFilter,\n  IProtoMessage,\n  IReceiver,\n  Libp2p,\n  PeerIdStr,\n  ProtocolCreateOptions,\n  PubSubTopic,\n  Unsubscribe\n} from \"@waku/interfaces\";\nimport { WakuMessage } from \"@waku/proto\";\nimport {\n  ensurePubsubTopicIsConfigured,\n  groupByContentTopic,\n  toAsyncIterator\n} from \"@waku/utils\";\nimport { Logger } from \"@waku/utils\";\nimport all from \"it-all\";\nimport * as lp from \"it-length-prefixed\";\nimport { pipe } from \"it-pipe\";\n\nimport { BaseProtocol } from \"../base_protocol.js\";\nimport { DefaultPubSubTopic } from \"../constants.js\";\n\nimport {\n  FilterPushRpc,\n  FilterSubscribeResponse,\n  FilterSubscribeRpc\n} from \"./filter_rpc.js\";\n\nconst log = new Logger(\"filter:v2\");\n\ntype SubscriptionCallback<T extends IDecodedMessage> = {\n  decoders: IDecoder<T>[];\n  callback: Callback<T>;\n};\n\nexport const FilterCodecs = {\n  SUBSCRIBE: \"/vac/waku/filter-subscribe/2.0.0-beta1\",\n  PUSH: \"/vac/waku/filter-push/2.0.0-beta1\"\n};\n\nclass Subscription {\n  private readonly peer: Peer;\n  private readonly pubsubTopic: PubSubTopic;\n  private newStream: (peer: Peer) => Promise<Stream>;\n\n  private subscriptionCallbacks: Map<\n    ContentTopic,\n    SubscriptionCallback<IDecodedMessage>\n  >;\n\n  constructor(\n    pubsubTopic: PubSubTopic,\n    remotePeer: Peer,\n    newStream: (peer: Peer) => Promise<Stream>\n  ) {\n    this.peer = remotePeer;\n    this.pubsubTopic = pubsubTopic;\n    this.newStream = newStream;\n    this.subscriptionCallbacks = new Map();\n  }\n\n  async subscribe<T extends IDecodedMessage>(\n    decoders: IDecoder<T> | IDecoder<T>[],\n    callback: Callback<T>\n  ): Promise<void> {\n    const decodersArray = Array.isArray(decoders) ? decoders : [decoders];\n\n    // check that all decoders are configured for the same pubsub topic as this subscription\n    decodersArray.forEach((decoder) => {\n      if (decoder.pubsubTopic !== this.pubsubTopic) {\n        throw new Error(\n          `Pubsub topic not configured: decoder is configured for pubsub topic ${decoder.pubsubTopic} but this subscription is for pubsub topic ${this.pubsubTopic}. Please create a new Subscription for the different pubsub topic.`\n        );\n      }\n    });\n\n    const decodersGroupedByCT = groupByContentTopic(decodersArray);\n    const contentTopics = Array.from(decodersGroupedByCT.keys());\n\n    const stream = await this.newStream(this.peer);\n\n    const request = FilterSubscribeRpc.createSubscribeRequest(\n      this.pubsubTopic,\n      contentTopics\n    );\n\n    try {\n      const res = await pipe(\n        [request.encode()],\n        lp.encode,\n        stream,\n        lp.decode,\n        async (source) => await all(source)\n      );\n\n      if (!res || !res.length) {\n        throw Error(\n          `No response received for request ${request.requestId}: ${res}`\n        );\n      }\n\n      const { statusCode, requestId, statusDesc } =\n        FilterSubscribeResponse.decode(res[0].slice());\n\n      if (statusCode < 200 || statusCode >= 300) {\n        throw new Error(\n          `Filter subscribe request ${requestId} failed with status code ${statusCode}: ${statusDesc}`\n        );\n      }\n\n      log.info(\n        \"Subscribed to peer \",\n        this.peer.id.toString(),\n        \"for content topics\",\n        contentTopics\n      );\n    } catch (e) {\n      throw new Error(\n        \"Error subscribing to peer: \" +\n          this.peer.id.toString() +\n          \" for content topics: \" +\n          contentTopics +\n          \": \" +\n          e\n      );\n    }\n\n    // Save the callback functions by content topics so they\n    // can easily be removed (reciprocally replaced) if `unsubscribe` (reciprocally `subscribe`)\n    // is called for those content topics\n    decodersGroupedByCT.forEach((decoders, contentTopic) => {\n      // Cast the type because a given `subscriptionCallbacks` map may hold\n      // Decoder that decode to different implementations of `IDecodedMessage`\n      const subscriptionCallback = {\n        decoders,\n        callback\n      } as unknown as SubscriptionCallback<IDecodedMessage>;\n\n      // The callback and decoder may override previous values, this is on\n      // purpose as the user may call `subscribe` to refresh the subscription\n      this.subscriptionCallbacks.set(contentTopic, subscriptionCallback);\n    });\n  }\n\n  async unsubscribe(contentTopics: ContentTopic[]): Promise<void> {\n    const stream = await this.newStream(this.peer);\n    const unsubscribeRequest = FilterSubscribeRpc.createUnsubscribeRequest(\n      this.pubsubTopic,\n      contentTopics\n    );\n\n    try {\n      await pipe([unsubscribeRequest.encode()], lp.encode, stream.sink);\n    } catch (error) {\n      throw new Error(\"Error subscribing: \" + error);\n    }\n\n    contentTopics.forEach((contentTopic: string) => {\n      this.subscriptionCallbacks.delete(contentTopic);\n    });\n  }\n\n  async ping(): Promise<void> {\n    const stream = await this.newStream(this.peer);\n\n    const request = FilterSubscribeRpc.createSubscriberPingRequest();\n\n    try {\n      const res = await pipe(\n        [request.encode()],\n        lp.encode,\n        stream,\n        lp.decode,\n        async (source) => await all(source)\n      );\n\n      if (!res || !res.length) {\n        throw Error(\n          `No response received for request ${request.requestId}: ${res}`\n        );\n      }\n\n      const { statusCode, requestId, statusDesc } =\n        FilterSubscribeResponse.decode(res[0].slice());\n\n      if (statusCode < 200 || statusCode >= 300) {\n        throw new Error(\n          `Filter ping request ${requestId} failed with status code ${statusCode}: ${statusDesc}`\n        );\n      }\n\n      log.info(\"Ping successful\");\n    } catch (error) {\n      log.error(\"Error pinging: \", error);\n      throw new Error(\"Error pinging: \" + error);\n    }\n  }\n\n  async unsubscribeAll(): Promise<void> {\n    const stream = await this.newStream(this.peer);\n\n    const request = FilterSubscribeRpc.createUnsubscribeAllRequest(\n      this.pubsubTopic\n    );\n\n    try {\n      const res = await pipe(\n        [request.encode()],\n        lp.encode,\n        stream,\n        lp.decode,\n        async (source) => await all(source)\n      );\n\n      if (!res || !res.length) {\n        throw Error(\n          `No response received for request ${request.requestId}: ${res}`\n        );\n      }\n\n      const { statusCode, requestId, statusDesc } =\n        FilterSubscribeResponse.decode(res[0].slice());\n\n      if (statusCode < 200 || statusCode >= 300) {\n        throw new Error(\n          `Filter unsubscribe all request ${requestId} failed with status code ${statusCode}: ${statusDesc}`\n        );\n      }\n\n      this.subscriptionCallbacks.clear();\n      log.info(\"Unsubscribed from all content topics\");\n    } catch (error) {\n      throw new Error(\"Error unsubscribing from all content topics: \" + error);\n    }\n  }\n\n  async processMessage(message: WakuMessage): Promise<void> {\n    const contentTopic = message.contentTopic;\n    const subscriptionCallback = this.subscriptionCallbacks.get(contentTopic);\n    if (!subscriptionCallback) {\n      log.error(\"No subscription callback available for \", contentTopic);\n      return;\n    }\n    await pushMessage(subscriptionCallback, this.pubsubTopic, message);\n  }\n}\n\nclass Filter extends BaseProtocol implements IReceiver {\n  private readonly pubsubTopics: PubSubTopic[] = [];\n  private activeSubscriptions = new Map<string, Subscription>();\n  private readonly NUM_PEERS_PROTOCOL = 1;\n\n  private getActiveSubscription(\n    pubsubTopic: PubSubTopic,\n    peerIdStr: PeerIdStr\n  ): Subscription | undefined {\n    return this.activeSubscriptions.get(`${pubsubTopic}_${peerIdStr}`);\n  }\n\n  private setActiveSubscription(\n    pubsubTopic: PubSubTopic,\n    peerIdStr: PeerIdStr,\n    subscription: Subscription\n  ): Subscription {\n    this.activeSubscriptions.set(`${pubsubTopic}_${peerIdStr}`, subscription);\n    return subscription;\n  }\n\n  constructor(libp2p: Libp2p, options?: ProtocolCreateOptions) {\n    super(FilterCodecs.SUBSCRIBE, libp2p.components);\n\n    this.pubsubTopics = options?.pubsubTopics || [DefaultPubSubTopic];\n\n    libp2p.handle(FilterCodecs.PUSH, this.onRequest.bind(this)).catch((e) => {\n      log.error(\"Failed to register \", FilterCodecs.PUSH, e);\n    });\n\n    this.activeSubscriptions = new Map();\n  }\n\n  async createSubscription(\n    pubsubTopic: string = DefaultPubSubTopic\n  ): Promise<Subscription> {\n    ensurePubsubTopicIsConfigured(pubsubTopic, this.pubsubTopics);\n\n    //TODO: get a relevant peer for the topic/shard\n    // https://github.com/waku-org/js-waku/pull/1586#discussion_r1336428230\n    const peer = (\n      await this.getPeers({\n        maxBootstrapPeers: 1,\n        numPeers: this.NUM_PEERS_PROTOCOL\n      })\n    )[0];\n\n    const subscription =\n      this.getActiveSubscription(pubsubTopic, peer.id.toString()) ??\n      this.setActiveSubscription(\n        pubsubTopic,\n        peer.id.toString(),\n        new Subscription(pubsubTopic, peer, this.getStream.bind(this, peer))\n      );\n\n    return subscription;\n  }\n\n  public toSubscriptionIterator<T extends IDecodedMessage>(\n    decoders: IDecoder<T> | IDecoder<T>[]\n  ): Promise<IAsyncIterator<T>> {\n    return toAsyncIterator(this, decoders);\n  }\n\n  /**\n   * This method is used to satisfy the `IReceiver` interface.\n   *\n   * @hidden\n   *\n   * @param decoders The decoders to use for the subscription.\n   * @param callback The callback function to use for the subscription.\n   * @param opts Optional protocol options for the subscription.\n   *\n   * @returns A Promise that resolves to a function that unsubscribes from the subscription.\n   *\n   * @remarks\n   * This method should not be used directly.\n   * Instead, use `createSubscription` to create a new subscription.\n   */\n  async subscribe<T extends IDecodedMessage>(\n    decoders: IDecoder<T> | IDecoder<T>[],\n    callback: Callback<T>\n  ): Promise<Unsubscribe> {\n    const subscription = await this.createSubscription();\n\n    await subscription.subscribe(decoders, callback);\n\n    const contentTopics = Array.from(\n      groupByContentTopic(\n        Array.isArray(decoders) ? decoders : [decoders]\n      ).keys()\n    );\n\n    return async () => {\n      await subscription.unsubscribe(contentTopics);\n    };\n  }\n\n  private onRequest(streamData: IncomingStreamData): void {\n    try {\n      pipe(streamData.stream, lp.decode, async (source) => {\n        for await (const bytes of source) {\n          const response = FilterPushRpc.decode(bytes.slice());\n\n          const { pubsubTopic, wakuMessage } = response;\n\n          if (!wakuMessage) {\n            log.error(\"Received empty message\");\n            return;\n          }\n\n          if (!pubsubTopic) {\n            log.error(\"PubSub topic missing from push message\");\n            return;\n          }\n\n          const peerIdStr = streamData.connection.remotePeer.toString();\n          const subscription = this.getActiveSubscription(\n            pubsubTopic,\n            peerIdStr\n          );\n\n          if (!subscription) {\n            log.error(\n              `No subscription locally registered for topic ${pubsubTopic}`\n            );\n            return;\n          }\n\n          await subscription.processMessage(wakuMessage);\n        }\n      }).then(\n        () => {\n          log.info(\"Receiving pipe closed.\");\n        },\n        (e) => {\n          log.error(\"Error with receiving pipe\", e);\n        }\n      );\n    } catch (e) {\n      log.error(\"Error decoding message\", e);\n    }\n  }\n}\n\nexport function wakuFilter(\n  init: Partial<ProtocolCreateOptions> = {}\n): (libp2p: Libp2p) => IFilter {\n  return (libp2p: Libp2p) => new Filter(libp2p, init);\n}\n\nasync function pushMessage<T extends IDecodedMessage>(\n  subscriptionCallback: SubscriptionCallback<T>,\n  pubsubTopic: PubSubTopic,\n  message: WakuMessage\n): Promise<void> {\n  const { decoders, callback } = subscriptionCallback;\n\n  const { contentTopic } = message;\n  if (!contentTopic) {\n    log.warn(\"Message has no content topic, skipping\");\n    return;\n  }\n\n  try {\n    const decodePromises = decoders.map((dec) =>\n      dec\n        .fromProtoObj(pubsubTopic, message as IProtoMessage)\n        .then((decoded) => decoded || Promise.reject(\"Decoding failed\"))\n    );\n\n    const decodedMessage = await Promise.any(decodePromises);\n\n    await callback(decodedMessage);\n  } catch (e) {\n    log.error(\"Error decoding message\", e);\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * For when you need a one-liner to collect iterable values.\n *\n * @example\n *\n * ```javascript\n * import all from 'it-all'\n *\n * // This can also be an iterator, etc\n * const values = function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const arr = all(values)\n *\n * console.info(arr) // 0, 1, 2, 3, 4\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const arr = await all(values())\n *\n * console.info(arr) // 0, 1, 2, 3, 4\n * ```\n */\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\n/**\n * Collects all values from an (async) iterable and returns them as an array\n */\nfunction all <T> (source: Iterable<T>): T[]\nfunction all <T> (source: Iterable<T> | AsyncIterable<T>): Promise<T[]>\nfunction all <T> (source: Iterable<T> | AsyncIterable<T>): Promise<T[]> | T[] {\n  if (isAsyncIterable(source)) {\n    return (async () => {\n      const arr = []\n\n      for await (const entry of source) {\n        arr.push(entry)\n      }\n\n      return arr\n    })()\n  }\n\n  const arr = []\n\n  for (const entry of source) {\n    arr.push(entry)\n  }\n\n  return arr\n}\n\nexport default all\n", "import { concat } from 'uint8arrays/concat'\nimport { equals } from 'uint8arrays/equals'\nimport { allocUnsafe, alloc } from 'uint8arrays/alloc'\n\nconst symbol = Symbol.for('@achingbrain/uint8arraylist')\n\nexport type Appendable = Uint8ArrayList | Uint8Array\n\nfunction findBufAndOffset (bufs: Uint8Array[], index: number) {\n  if (index == null || index < 0) {\n    throw new RangeError('index is out of bounds')\n  }\n\n  let offset = 0\n\n  for (const buf of bufs) {\n    const bufEnd = offset + buf.byteLength\n\n    if (index < bufEnd) {\n      return {\n        buf,\n        index: index - offset\n      }\n    }\n\n    offset = bufEnd\n  }\n\n  throw new RangeError('index is out of bounds')\n}\n\n/**\n * Check if object is a CID instance\n *\n * @example\n *\n * ```js\n * import { isUint8ArrayList, Uint8ArrayList } from 'uint8arraylist'\n *\n * isUint8ArrayList(true) // false\n * isUint8ArrayList([]) // false\n * isUint8ArrayList(new Uint8ArrayList()) // true\n * ```\n */\nexport function isUint8ArrayList (value: any): value is Uint8ArrayList {\n  return Boolean(value?.[symbol])\n}\n\nexport class Uint8ArrayList implements Iterable<Uint8Array> {\n  private bufs: Uint8Array[]\n  public length: number\n\n  constructor (...data: Appendable[]) {\n    // Define symbol\n    Object.defineProperty(this, symbol, { value: true })\n\n    this.bufs = []\n    this.length = 0\n\n    if (data.length > 0) {\n      this.appendAll(data)\n    }\n  }\n\n  * [Symbol.iterator] () {\n    yield * this.bufs\n  }\n\n  get byteLength () {\n    return this.length\n  }\n\n  /**\n   * Add one or more `bufs` to the end of this Uint8ArrayList\n   */\n  append (...bufs: Appendable[]) {\n    this.appendAll(bufs)\n  }\n\n  /**\n   * Add all `bufs` to the end of this Uint8ArrayList\n   */\n  appendAll (bufs: Appendable[]) {\n    let length = 0\n\n    for (const buf of bufs) {\n      if (buf instanceof Uint8Array) {\n        length += buf.byteLength\n        this.bufs.push(buf)\n      } else if (isUint8ArrayList(buf)) {\n        length += buf.byteLength\n        this.bufs.push(...buf.bufs)\n      } else {\n        throw new Error('Could not append value, must be an Uint8Array or a Uint8ArrayList')\n      }\n    }\n\n    this.length += length\n  }\n\n  /**\n   * Add one or more `bufs` to the start of this Uint8ArrayList\n   */\n  prepend (...bufs: Appendable[]) {\n    this.prependAll(bufs)\n  }\n\n  /**\n   * Add all `bufs` to the start of this Uint8ArrayList\n   */\n  prependAll (bufs: Appendable[]) {\n    let length = 0\n\n    for (const buf of bufs.reverse()) {\n      if (buf instanceof Uint8Array) {\n        length += buf.byteLength\n        this.bufs.unshift(buf)\n      } else if (isUint8ArrayList(buf)) {\n        length += buf.byteLength\n        this.bufs.unshift(...buf.bufs)\n      } else {\n        throw new Error('Could not prepend value, must be an Uint8Array or a Uint8ArrayList')\n      }\n    }\n\n    this.length += length\n  }\n\n  /**\n   * Read the value at `index`\n   */\n  get (index: number) {\n    const res = findBufAndOffset(this.bufs, index)\n\n    return res.buf[res.index]\n  }\n\n  /**\n   * Set the value at `index` to `value`\n   */\n  set (index: number, value: number) {\n    const res = findBufAndOffset(this.bufs, index)\n\n    res.buf[res.index] = value\n  }\n\n  /**\n   * Copy bytes from `buf` to the index specified by `offset`\n   */\n  write (buf: Appendable, offset: number = 0) {\n    if (buf instanceof Uint8Array) {\n      for (let i = 0; i < buf.length; i++) {\n        this.set(offset + i, buf[i])\n      }\n    } else if (isUint8ArrayList(buf)) {\n      for (let i = 0; i < buf.length; i++) {\n        this.set(offset + i, buf.get(i))\n      }\n    } else {\n      throw new Error('Could not write value, must be an Uint8Array or a Uint8ArrayList')\n    }\n  }\n\n  /**\n   * Remove bytes from the front of the pool\n   */\n  consume (bytes: number) {\n    // first, normalize the argument, in accordance with how Buffer does it\n    bytes = Math.trunc(bytes)\n\n    // do nothing if not a positive number\n    if (Number.isNaN(bytes) || bytes <= 0) {\n      return\n    }\n\n    // if consuming all bytes, skip iterating\n    if (bytes === this.byteLength) {\n      this.bufs = []\n      this.length = 0\n      return\n    }\n\n    while (this.bufs.length > 0) {\n      if (bytes >= this.bufs[0].byteLength) {\n        bytes -= this.bufs[0].byteLength\n        this.length -= this.bufs[0].byteLength\n        this.bufs.shift()\n      } else {\n        this.bufs[0] = this.bufs[0].subarray(bytes)\n        this.length -= bytes\n        break\n      }\n    }\n  }\n\n  /**\n   * Extracts a section of an array and returns a new array.\n   *\n   * This is a copy operation as it is with Uint8Arrays and Arrays\n   * - note this is different to the behaviour of Node Buffers.\n   */\n  slice (beginInclusive?: number, endExclusive?: number): Uint8Array {\n    const { bufs, length } = this._subList(beginInclusive, endExclusive)\n\n    return concat(bufs, length)\n  }\n\n  /**\n   * Returns a alloc from the given start and end element index.\n   *\n   * In the best case where the data extracted comes from a single Uint8Array\n   * internally this is a no-copy operation otherwise it is a copy operation.\n   */\n  subarray (beginInclusive?: number, endExclusive?: number): Uint8Array {\n    const { bufs, length } = this._subList(beginInclusive, endExclusive)\n\n    if (bufs.length === 1) {\n      return bufs[0]\n    }\n\n    return concat(bufs, length)\n  }\n\n  /**\n   * Returns a allocList from the given start and end element index.\n   *\n   * This is a no-copy operation.\n   */\n  sublist (beginInclusive?: number, endExclusive?: number): Uint8ArrayList {\n    const { bufs, length } = this._subList(beginInclusive, endExclusive)\n\n    const list = new Uint8ArrayList()\n    list.length = length\n    // don't loop, just set the bufs\n    list.bufs = bufs\n\n    return list\n  }\n\n  private _subList (beginInclusive?: number, endExclusive?: number) {\n    beginInclusive = beginInclusive ?? 0\n    endExclusive = endExclusive ?? this.length\n\n    if (beginInclusive < 0) {\n      beginInclusive = this.length + beginInclusive\n    }\n\n    if (endExclusive < 0) {\n      endExclusive = this.length + endExclusive\n    }\n\n    if (beginInclusive < 0 || endExclusive > this.length) {\n      throw new RangeError('index is out of bounds')\n    }\n\n    if (beginInclusive === endExclusive) {\n      return { bufs: [], length: 0 }\n    }\n\n    if (beginInclusive === 0 && endExclusive === this.length) {\n      return { bufs: [...this.bufs], length: this.length }\n    }\n\n    const bufs: Uint8Array[] = []\n    let offset = 0\n\n    for (let i = 0; i < this.bufs.length; i++) {\n      const buf = this.bufs[i]\n      const bufStart = offset\n      const bufEnd = bufStart + buf.byteLength\n\n      // for next loop\n      offset = bufEnd\n\n      if (beginInclusive >= bufEnd) {\n        // start after this buf\n        continue\n      }\n\n      const sliceStartInBuf = beginInclusive >= bufStart && beginInclusive < bufEnd\n      const sliceEndsInBuf = endExclusive > bufStart && endExclusive <= bufEnd\n\n      if (sliceStartInBuf && sliceEndsInBuf) {\n        // slice is wholly contained within this buffer\n        if (beginInclusive === bufStart && endExclusive === bufEnd) {\n          // requested whole buffer\n          bufs.push(buf)\n          break\n        }\n\n        // requested part of buffer\n        const start = beginInclusive - bufStart\n        bufs.push(buf.subarray(start, start + (endExclusive - beginInclusive)))\n        break\n      }\n\n      if (sliceStartInBuf) {\n        // slice starts in this buffer\n        if (beginInclusive === 0) {\n          // requested whole buffer\n          bufs.push(buf)\n          continue\n        }\n\n        // requested part of buffer\n        bufs.push(buf.subarray(beginInclusive - bufStart))\n        continue\n      }\n\n      if (sliceEndsInBuf) {\n        if (endExclusive === bufEnd) {\n          // requested whole buffer\n          bufs.push(buf)\n          break\n        }\n\n        // requested part of buffer\n        bufs.push(buf.subarray(0, endExclusive - bufStart))\n        break\n      }\n\n      // slice started before this buffer and ends after it\n      bufs.push(buf)\n    }\n\n    return { bufs, length: endExclusive - beginInclusive }\n  }\n\n  indexOf (search: Uint8ArrayList | Uint8Array, offset: number = 0): number {\n    if (!isUint8ArrayList(search) && !(search instanceof Uint8Array)) {\n      throw new TypeError('The \"value\" argument must be a Uint8ArrayList or Uint8Array')\n    }\n\n    const needle = search instanceof Uint8Array ? search : search.subarray()\n\n    offset = Number(offset ?? 0)\n\n    if (isNaN(offset)) {\n      offset = 0\n    }\n\n    if (offset < 0) {\n      offset = this.length + offset\n    }\n\n    if (offset < 0) {\n      offset = 0\n    }\n\n    if (search.length === 0) {\n      return offset > this.length ? this.length : offset\n    }\n\n    // https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm\n    const M: number = needle.byteLength\n\n    if (M === 0) {\n      throw new TypeError('search must be at least 1 byte long')\n    }\n\n    // radix\n    const radix: number = 256\n    const rightmostPositions: Int32Array = new Int32Array(radix)\n\n    // position of the rightmost occurrence of the byte c in the pattern\n    for (let c: number = 0; c < radix; c++) {\n      // -1 for bytes not in pattern\n      rightmostPositions[c] = -1\n    }\n\n    for (let j = 0; j < M; j++) {\n      // rightmost position for bytes in pattern\n      rightmostPositions[needle[j]] = j\n    }\n\n    // Return offset of first match, -1 if no match\n    const right = rightmostPositions\n    const lastIndex = this.byteLength - needle.byteLength\n    const lastPatIndex = needle.byteLength - 1\n    let skip: number\n\n    for (let i = offset; i <= lastIndex; i += skip) {\n      skip = 0\n\n      for (let j = lastPatIndex; j >= 0; j--) {\n        const char: number = this.get(i + j)\n\n        if (needle[j] !== char) {\n          skip = Math.max(1, j - right[char])\n          break\n        }\n      }\n\n      if (skip === 0) {\n        return i\n      }\n    }\n\n    return -1\n  }\n\n  getInt8 (byteOffset: number): number {\n    const buf = this.subarray(byteOffset, byteOffset + 1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getInt8(0)\n  }\n\n  setInt8 (byteOffset: number, value: number): void {\n    const buf = allocUnsafe(1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setInt8(0, value)\n\n    this.write(buf, byteOffset)\n  }\n\n  getInt16 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getInt16(0, littleEndian)\n  }\n\n  setInt16 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setInt16(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getInt32 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getInt32(0, littleEndian)\n  }\n\n  setInt32 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setInt32(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getBigInt64 (byteOffset: number, littleEndian?: boolean): bigint {\n    const buf = this.subarray(byteOffset, byteOffset + 8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getBigInt64(0, littleEndian)\n  }\n\n  setBigInt64 (byteOffset: number, value: bigint, littleEndian?: boolean): void {\n    const buf = alloc(8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setBigInt64(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getUint8 (byteOffset: number): number {\n    const buf = this.subarray(byteOffset, byteOffset + 1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getUint8(0)\n  }\n\n  setUint8 (byteOffset: number, value: number): void {\n    const buf = allocUnsafe(1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setUint8(0, value)\n\n    this.write(buf, byteOffset)\n  }\n\n  getUint16 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getUint16(0, littleEndian)\n  }\n\n  setUint16 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setUint16(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getUint32 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getUint32(0, littleEndian)\n  }\n\n  setUint32 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setUint32(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getBigUint64 (byteOffset: number, littleEndian?: boolean): bigint {\n    const buf = this.subarray(byteOffset, byteOffset + 8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getBigUint64(0, littleEndian)\n  }\n\n  setBigUint64 (byteOffset: number, value: bigint, littleEndian?: boolean): void {\n    const buf = alloc(8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setBigUint64(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getFloat32 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getFloat32(0, littleEndian)\n  }\n\n  setFloat32 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setFloat32(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getFloat64 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getFloat64(0, littleEndian)\n  }\n\n  setFloat64 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setFloat64(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  equals (other: any): other is Uint8ArrayList {\n    if (other == null) {\n      return false\n    }\n\n    if (!(other instanceof Uint8ArrayList)) {\n      return false\n    }\n\n    if (other.bufs.length !== this.bufs.length) {\n      return false\n    }\n\n    for (let i = 0; i < this.bufs.length; i++) {\n      if (!equals(this.bufs[i], other.bufs[i])) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  /**\n   * Create a Uint8ArrayList from a pre-existing list of Uint8Arrays.  Use this\n   * method if you know the total size of all the Uint8Arrays ahead of time.\n   */\n  static fromUint8Arrays (bufs: Uint8Array[], length?: number): Uint8ArrayList {\n    const list = new Uint8ArrayList()\n    list.bufs = bufs\n\n    if (length == null) {\n      length = bufs.reduce((acc, curr) => acc + curr.byteLength, 0)\n    }\n\n    list.length = length\n\n    return list\n  }\n}\n\n/*\nfunction indexOf (needle: Uint8Array, haystack: Uint8Array, offset = 0) {\n  for (let i = offset; i < haystack.byteLength; i++) {\n    for (let j = 0; j < needle.length; j++) {\n      if (haystack[i + j] !== needle[j]) {\n        break\n      }\n\n      if (j === needle.byteLength -1) {\n        return i\n      }\n    }\n\n    if (haystack.byteLength - i < needle.byteLength) {\n      break\n    }\n  }\n\n  return -1\n}\n*/\n", "export function isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n", "import * as varint from 'uint8-varint'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { allocUnsafe } from 'uint8arrays/alloc'\nimport { isAsyncIterable } from './utils.js'\nimport type { LengthEncoderFunction } from './index.js'\nimport type { Source } from 'it-stream-types'\n\ninterface EncoderOptions {\n  lengthEncoder?: LengthEncoderFunction\n}\n\nconst defaultEncoder: LengthEncoderFunction = (length) => {\n  const lengthLength = varint.encodingLength(length)\n  const lengthBuf = allocUnsafe(lengthLength)\n\n  varint.encode(length, lengthBuf)\n\n  defaultEncoder.bytes = lengthLength\n\n  return lengthBuf\n}\ndefaultEncoder.bytes = 0\n\nexport function encode (source: Iterable<Uint8ArrayList | Uint8Array>, options?: EncoderOptions): Generator<Uint8Array, void, undefined>\nexport function encode (source: Source<Uint8ArrayList | Uint8Array>, options?: EncoderOptions): AsyncGenerator<Uint8Array, void, undefined>\nexport function encode (source: Source<Uint8ArrayList | Uint8Array>, options?: EncoderOptions): Generator<Uint8Array, void, undefined> | AsyncGenerator<Uint8Array, void, undefined> {\n  options = options ?? {}\n\n  const encodeLength = options.lengthEncoder ?? defaultEncoder\n\n  function * maybeYield (chunk: Uint8Array | Uint8ArrayList): Generator<Uint8Array, void, undefined> {\n    // length + data\n    const length = encodeLength(chunk.byteLength)\n\n    // yield only Uint8Arrays\n    if (length instanceof Uint8Array) {\n      yield length\n    } else {\n      yield * length\n    }\n\n    // yield only Uint8Arrays\n    if (chunk instanceof Uint8Array) {\n      yield chunk\n    } else {\n      yield * chunk\n    }\n  }\n\n  if (isAsyncIterable(source)) {\n    return (async function * () {\n      for await (const chunk of source) {\n        yield * maybeYield(chunk)\n      }\n    })()\n  }\n\n  return (function * () {\n    for (const chunk of source) {\n      yield * maybeYield(chunk)\n    }\n  })()\n}\n\nencode.single = (chunk: Uint8ArrayList | Uint8Array, options?: EncoderOptions) => {\n  options = options ?? {}\n  const encodeLength = options.lengthEncoder ?? defaultEncoder\n\n  return new Uint8ArrayList(\n    encodeLength(chunk.byteLength),\n    chunk\n  )\n}\n", "/* eslint max-depth: [\"error\", 6] */\n\nimport errCode from 'err-code'\nimport * as varint from 'uint8-varint'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { isAsyncIterable } from './utils.js'\nimport type { LengthDecoderFunction } from './index.js'\nimport type { Reader } from 'it-reader'\nimport type { Source } from 'it-stream-types'\n\nexport interface ReadState {\n  dataLength: number\n}\n\nexport interface DecoderOptions {\n  lengthDecoder?: LengthDecoderFunction\n  onData?: (data: Uint8ArrayList) => void\n  onLength?: (length: number) => void\n  maxLengthLength?: number\n  maxDataLength?: number\n}\n\nexport interface ReadResult {\n  mode: string\n  chunk?: Uint8ArrayList\n  buffer: Uint8ArrayList\n  state?: ReadState\n  data?: Uint8ArrayList\n}\n\n// Maximum length of the length section of the message\nexport const MAX_LENGTH_LENGTH = 8 // Varint.encode(Number.MAX_SAFE_INTEGER).length\n// Maximum length of the data section of the message\nexport const MAX_DATA_LENGTH = 1024 * 1024 * 4\n\nenum ReadMode {\n  LENGTH,\n  DATA\n}\n\nconst defaultDecoder: LengthDecoderFunction = (buf) => {\n  const length = varint.decode(buf)\n  defaultDecoder.bytes = varint.encodingLength(length)\n\n  return length\n}\ndefaultDecoder.bytes = 0\n\nexport function decode (source: Iterable<Uint8ArrayList | Uint8Array>, options?: DecoderOptions): Generator<Uint8ArrayList, void, unknown>\nexport function decode (source: Source<Uint8ArrayList | Uint8Array>, options?: DecoderOptions): AsyncGenerator<Uint8ArrayList, void, unknown>\nexport function decode (source: Source<Uint8ArrayList | Uint8Array>, options?: DecoderOptions): Generator<Uint8ArrayList, void, unknown> | AsyncGenerator<Uint8ArrayList, void, unknown> {\n  const buffer = new Uint8ArrayList()\n  let mode = ReadMode.LENGTH\n  let dataLength = -1\n\n  const lengthDecoder = options?.lengthDecoder ?? defaultDecoder\n  const maxLengthLength = options?.maxLengthLength ?? MAX_LENGTH_LENGTH\n  const maxDataLength = options?.maxDataLength ?? MAX_DATA_LENGTH\n\n  function * maybeYield (): Generator<Uint8ArrayList> {\n    while (buffer.byteLength > 0) {\n      if (mode === ReadMode.LENGTH) {\n        // read length, ignore errors for short reads\n        try {\n          dataLength = lengthDecoder(buffer)\n\n          if (dataLength < 0) {\n            throw errCode(new Error('invalid message length'), 'ERR_INVALID_MSG_LENGTH')\n          }\n\n          if (dataLength > maxDataLength) {\n            throw errCode(new Error('message length too long'), 'ERR_MSG_DATA_TOO_LONG')\n          }\n\n          const dataLengthLength = lengthDecoder.bytes\n          buffer.consume(dataLengthLength)\n\n          if (options?.onLength != null) {\n            options.onLength(dataLength)\n          }\n\n          mode = ReadMode.DATA\n        } catch (err: any) {\n          if (err instanceof RangeError) {\n            if (buffer.byteLength > maxLengthLength) {\n              throw errCode(new Error('message length length too long'), 'ERR_MSG_LENGTH_TOO_LONG')\n            }\n\n            break\n          }\n\n          throw err\n        }\n      }\n\n      if (mode === ReadMode.DATA) {\n        if (buffer.byteLength < dataLength) {\n          // not enough data, wait for more\n          break\n        }\n\n        const data = buffer.sublist(0, dataLength)\n        buffer.consume(dataLength)\n\n        if (options?.onData != null) {\n          options.onData(data)\n        }\n\n        yield data\n\n        mode = ReadMode.LENGTH\n      }\n    }\n  }\n\n  if (isAsyncIterable(source)) {\n    return (async function * () {\n      for await (const buf of source) {\n        buffer.append(buf)\n\n        yield * maybeYield()\n      }\n\n      if (buffer.byteLength > 0) {\n        throw errCode(new Error('unexpected end of input'), 'ERR_UNEXPECTED_EOF')\n      }\n    })()\n  }\n\n  return (function * () {\n    for (const buf of source) {\n      buffer.append(buf)\n\n      yield * maybeYield()\n    }\n\n    if (buffer.byteLength > 0) {\n      throw errCode(new Error('unexpected end of input'), 'ERR_UNEXPECTED_EOF')\n    }\n  })()\n}\n\ndecode.fromReader = (reader: Reader, options?: DecoderOptions) => {\n  let byteLength = 1 // Read single byte chunks until the length is known\n\n  const varByteSource = (async function * () {\n    while (true) {\n      try {\n        const { done, value } = await reader.next(byteLength)\n\n        if (done === true) {\n          return\n        }\n\n        if (value != null) {\n          yield value\n        }\n      } catch (err: any) {\n        if (err.code === 'ERR_UNDER_READ') {\n          return { done: true, value: null }\n        }\n        throw err\n      } finally {\n        // Reset the byteLength so we continue to check for varints\n        byteLength = 1\n      }\n    }\n  }())\n\n  /**\n   * Once the length has been parsed, read chunk for that length\n   */\n  const onLength = (l: number): void => { byteLength = l }\n  return decode(varByteSource, {\n    ...(options ?? {}),\n    onLength\n  })\n}\n", "export default function pDefer() {\n\tconst deferred = {};\n\n\tdeferred.promise = new Promise((resolve, reject) => {\n\t\tdeferred.resolve = resolve;\n\t\tdeferred.reject = reject;\n\t});\n\n\treturn deferred;\n}\n", "// ported from https://www.npmjs.com/package/fast-fifo\n\nexport interface Next<T> {\n  done?: boolean\n  error?: Error\n  value?: T\n}\n\nclass FixedFIFO<T> {\n  public buffer: Array<Next<T> | undefined>\n  private readonly mask: number\n  private top: number\n  private btm: number\n  public next: FixedFIFO<T> | null\n\n  constructor (hwm: number) {\n    if (!(hwm > 0) || ((hwm - 1) & hwm) !== 0) {\n      throw new Error('Max size for a FixedFIFO should be a power of two')\n    }\n\n    this.buffer = new Array(hwm)\n    this.mask = hwm - 1\n    this.top = 0\n    this.btm = 0\n    this.next = null\n  }\n\n  push (data: Next<T>): boolean {\n    if (this.buffer[this.top] !== undefined) {\n      return false\n    }\n\n    this.buffer[this.top] = data\n    this.top = (this.top + 1) & this.mask\n\n    return true\n  }\n\n  shift (): Next<T> | undefined {\n    const last = this.buffer[this.btm]\n\n    if (last === undefined) {\n      return undefined\n    }\n\n    this.buffer[this.btm] = undefined\n    this.btm = (this.btm + 1) & this.mask\n    return last\n  }\n\n  isEmpty (): boolean {\n    return this.buffer[this.btm] === undefined\n  }\n}\n\nexport interface FIFOOptions {\n  /**\n   * When the queue reaches this size, it will be split into head/tail parts\n   */\n  splitLimit?: number\n}\n\nexport class FIFO<T> {\n  public size: number\n  private readonly hwm: number\n  private head: FixedFIFO<T>\n  private tail: FixedFIFO<T>\n\n  constructor (options: FIFOOptions = {}) {\n    this.hwm = options.splitLimit ?? 16\n    this.head = new FixedFIFO<T>(this.hwm)\n    this.tail = this.head\n    this.size = 0\n  }\n\n  calculateSize (obj: any): number {\n    if (obj?.byteLength != null) {\n      return obj.byteLength\n    }\n\n    return 1\n  }\n\n  push (val: Next<T>): void {\n    if (val?.value != null) {\n      this.size += this.calculateSize(val.value)\n    }\n\n    if (!this.head.push(val)) {\n      const prev = this.head\n      this.head = prev.next = new FixedFIFO<T>(2 * this.head.buffer.length)\n      this.head.push(val)\n    }\n  }\n\n  shift (): Next<T> | undefined {\n    let val = this.tail.shift()\n\n    if (val === undefined && (this.tail.next != null)) {\n      const next = this.tail.next\n      this.tail.next = null\n      this.tail = next\n      val = this.tail.shift()\n    }\n\n    if (val?.value != null) {\n      this.size -= this.calculateSize(val.value)\n    }\n\n    return val\n  }\n\n  isEmpty (): boolean {\n    return this.head.isEmpty()\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * An iterable that you can push values into.\n *\n * @example\n *\n * ```js\n * import { pushable } from 'it-pushable'\n *\n * const source = pushable()\n *\n * setTimeout(() => source.push('hello'), 100)\n * setTimeout(() => source.push('world'), 200)\n * setTimeout(() => source.end(), 300)\n *\n * const start = Date.now()\n *\n * for await (const value of source) {\n *   console.log(`got \"${value}\" after ${Date.now() - start}ms`)\n * }\n * console.log(`done after ${Date.now() - start}ms`)\n *\n * // Output:\n * // got \"hello\" after 105ms\n * // got \"world\" after 207ms\n * // done after 309ms\n * ```\n *\n * @example\n *\n * ```js\n * import { pushableV } from 'it-pushable'\n * import all from 'it-all'\n *\n * const source = pushableV()\n *\n * source.push(1)\n * source.push(2)\n * source.push(3)\n * source.end()\n *\n * console.info(await all(source))\n *\n * // Output:\n * // [ [1, 2, 3] ]\n * ```\n */\n\nimport deferred from 'p-defer'\nimport { FIFO, type Next } from './fifo.js'\n\nexport class AbortError extends Error {\n  type: string\n  code: string\n\n  constructor (message?: string, code?: string) {\n    super(message ?? 'The operation was aborted')\n    this.type = 'aborted'\n    this.code = code ?? 'ABORT_ERR'\n  }\n}\n\nexport interface AbortOptions {\n  signal?: AbortSignal\n}\n\ninterface BasePushable<T> {\n  /**\n   * End the iterable after all values in the buffer (if any) have been yielded. If an\n   * error is passed the buffer is cleared immediately and the next iteration will\n   * throw the passed error\n   */\n  end(err?: Error): this\n\n  /**\n   * Push a value into the iterable. Values are yielded from the iterable in the order\n   * they are pushed. Values not yet consumed from the iterable are buffered.\n   */\n  push(value: T): this\n\n  /**\n   * Returns a promise that resolves when the underlying queue becomes empty (e.g.\n   * this.readableLength === 0).\n   *\n   * If an AbortSignal is passed as an option and that signal aborts, it only\n   * causes the returned promise to reject - it does not end the pushable.\n   */\n  onEmpty(options?: AbortOptions): Promise<void>\n\n  /**\n   * This property contains the number of bytes (or objects) in the queue ready to be read.\n   *\n   * If `objectMode` is true, this is the number of objects in the queue, if false it's the\n   * total number of bytes in the queue.\n   */\n  readableLength: number\n}\n\n/**\n * An iterable that you can push values into.\n */\nexport interface Pushable<T, R = void, N = unknown> extends AsyncGenerator<T, R, N>, BasePushable<T> {}\n\n/**\n * Similar to `pushable`, except it yields multiple buffered chunks at a time. All values yielded from the iterable will be arrays.\n */\nexport interface PushableV<T, R = void, N = unknown> extends AsyncGenerator<T[], R, N>, BasePushable<T> {}\n\nexport interface Options {\n  /**\n   * A boolean value that means non-`Uint8Array`s will be passed to `.push`, default: `false`\n   */\n  objectMode?: boolean\n\n  /**\n   * A function called after *all* values have been yielded from the iterator (including\n   * buffered values). In the case when the iterator is ended with an error it will be\n   * passed the error as a parameter.\n   */\n  onEnd?(err?: Error): void\n}\n\nexport interface DoneResult { done: true }\nexport interface ValueResult<T> { done: false, value: T }\nexport type NextResult<T> = ValueResult<T> | DoneResult\n\ninterface getNext<T, V = T> { (buffer: FIFO<T>): NextResult<V> }\n\nexport interface ObjectPushableOptions extends Options {\n  objectMode: true\n}\n\nexport interface BytePushableOptions extends Options {\n  objectMode?: false\n}\n\n/**\n * Create a new async iterable. The values yielded from calls to `.next()`\n * or when used in a `for await of`loop are \"pushed\" into the iterable.\n * Returns an async iterable object with additional methods.\n */\nexport function pushable<T extends { byteLength: number } = Uint8Array> (options?: BytePushableOptions): Pushable<T>\nexport function pushable<T> (options: ObjectPushableOptions): Pushable<T>\nexport function pushable<T> (options: Options = {}): Pushable<T> {\n  const getNext = (buffer: FIFO<T>): NextResult<T> => {\n    const next: Next<T> | undefined = buffer.shift()\n\n    if (next == null) {\n      return { done: true }\n    }\n\n    if (next.error != null) {\n      throw next.error\n    }\n\n    return {\n      done: next.done === true,\n      // @ts-expect-error if done is false, value will be present\n      value: next.value\n    }\n  }\n\n  return _pushable<T, T, Pushable<T>>(getNext, options)\n}\n\nexport function pushableV<T extends { byteLength: number } = Uint8Array> (options?: BytePushableOptions): PushableV<T>\nexport function pushableV<T> (options: ObjectPushableOptions): PushableV<T>\nexport function pushableV<T> (options: Options = {}): PushableV<T> {\n  const getNext = (buffer: FIFO<T>): NextResult<T[]> => {\n    let next: Next<T> | undefined\n    const values: T[] = []\n\n    while (!buffer.isEmpty()) {\n      next = buffer.shift()\n\n      if (next == null) {\n        break\n      }\n\n      if (next.error != null) {\n        throw next.error\n      }\n\n      if (next.done === false) {\n        // @ts-expect-error if done is false value should be pushed\n        values.push(next.value)\n      }\n    }\n\n    if (next == null) {\n      return { done: true }\n    }\n\n    return {\n      done: next.done === true,\n      value: values\n    }\n  }\n\n  return _pushable<T, T[], PushableV<T>>(getNext, options)\n}\n\nfunction _pushable<PushType, ValueType, ReturnType> (getNext: getNext<PushType, ValueType>, options?: Options): ReturnType {\n  options = options ?? {}\n  let onEnd = options.onEnd\n  let buffer = new FIFO<PushType>()\n  let pushable: any\n  let onNext: ((next: Next<PushType>) => ReturnType) | null\n  let ended: boolean\n  let drain = deferred()\n\n  const waitNext = async (): Promise<NextResult<ValueType>> => {\n    try {\n      if (!buffer.isEmpty()) {\n        return getNext(buffer)\n      }\n\n      if (ended) {\n        return { done: true }\n      }\n\n      return await new Promise<NextResult<ValueType>>((resolve, reject) => {\n        onNext = (next: Next<PushType>) => {\n          onNext = null\n          buffer.push(next)\n\n          try {\n            resolve(getNext(buffer))\n          } catch (err) {\n            reject(err)\n          }\n\n          return pushable\n        }\n      })\n    } finally {\n      if (buffer.isEmpty()) {\n        // settle promise in the microtask queue to give consumers a chance to\n        // await after calling .push\n        queueMicrotask(() => {\n          drain.resolve()\n          drain = deferred()\n        })\n      }\n    }\n  }\n\n  const bufferNext = (next: Next<PushType>): ReturnType => {\n    if (onNext != null) {\n      return onNext(next)\n    }\n\n    buffer.push(next)\n    return pushable\n  }\n\n  const bufferError = (err: Error): ReturnType => {\n    buffer = new FIFO()\n\n    if (onNext != null) {\n      return onNext({ error: err })\n    }\n\n    buffer.push({ error: err })\n    return pushable\n  }\n\n  const push = (value: PushType): ReturnType => {\n    if (ended) {\n      return pushable\n    }\n\n    // @ts-expect-error `byteLength` is not declared on PushType\n    if (options?.objectMode !== true && value?.byteLength == null) {\n      throw new Error('objectMode was not true but tried to push non-Uint8Array value')\n    }\n\n    return bufferNext({ done: false, value })\n  }\n  const end = (err?: Error): ReturnType => {\n    if (ended) return pushable\n    ended = true\n\n    return (err != null) ? bufferError(err) : bufferNext({ done: true })\n  }\n  const _return = (): DoneResult => {\n    buffer = new FIFO()\n    end()\n\n    return { done: true }\n  }\n  const _throw = (err: Error): DoneResult => {\n    end(err)\n\n    return { done: true }\n  }\n\n  pushable = {\n    [Symbol.asyncIterator] () { return this },\n    next: waitNext,\n    return: _return,\n    throw: _throw,\n    push,\n    end,\n    get readableLength (): number {\n      return buffer.size\n    },\n    onEmpty: async (options?: AbortOptions) => {\n      const signal = options?.signal\n      signal?.throwIfAborted()\n\n      if (buffer.isEmpty()) {\n        return\n      }\n\n      let cancel: Promise<void> | undefined\n      let listener: (() => void) | undefined\n\n      if (signal != null) {\n        cancel = new Promise((resolve, reject) => {\n          listener = () => {\n            reject(new AbortError())\n          }\n\n          signal.addEventListener('abort', listener)\n        })\n      }\n\n      try {\n        await Promise.race([\n          drain.promise,\n          cancel\n        ])\n      } finally {\n        if (listener != null && signal != null) {\n          signal?.removeEventListener('abort', listener)\n        }\n      }\n    }\n  }\n\n  if (onEnd == null) {\n    return pushable\n  }\n\n  const _pushable = pushable\n\n  pushable = {\n    [Symbol.asyncIterator] () { return this },\n    next () {\n      return _pushable.next()\n    },\n    throw (err: Error) {\n      _pushable.throw(err)\n\n      if (onEnd != null) {\n        onEnd(err)\n        onEnd = undefined\n      }\n\n      return { done: true }\n    },\n    return () {\n      _pushable.return()\n\n      if (onEnd != null) {\n        onEnd()\n        onEnd = undefined\n      }\n\n      return { done: true }\n    },\n    push,\n    end (err: Error) {\n      _pushable.end(err)\n\n      if (onEnd != null) {\n        onEnd(err)\n        onEnd = undefined\n      }\n\n      return pushable\n    },\n    get readableLength () {\n      return _pushable.readableLength\n    },\n    onEmpty: (opts?: AbortOptions) => {\n      return _pushable.onEmpty(opts)\n    }\n  }\n\n  return pushable\n}\n", "/**\n * @packageDocumentation\n *\n * Merge several (async)iterables into one, yield values as they arrive.\n *\n * Nb. sources are iterated over in parallel so the order of emitted items is not guaranteed.\n *\n * @example\n *\n * ```javascript\n * import merge from 'it-merge'\n * import all from 'it-all'\n *\n * // This can also be an iterator, generator, etc\n * const values1 = [0, 1, 2, 3, 4]\n * const values2 = [5, 6, 7, 8, 9]\n *\n * const arr = all(merge(values1, values2))\n *\n * console.info(arr) // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import merge from 'it-merge'\n * import all from 'it-all'\n *\n * // This can also be an iterator, async iterator, generator, etc\n * const values1 = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n * const values2 = async function * () {\n *   yield * [5, 6, 7, 8, 9]\n * }\n *\n * const arr = await all(merge(values1(), values2()))\n *\n * console.info(arr) // 0, 1, 5, 6, 2, 3, 4, 7, 8, 9  <- nb. order is not guaranteed\n * ```\n */\n\nimport { pushable } from 'it-pushable'\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\n/**\n * Treat one or more iterables as a single iterable.\n *\n * Nb. sources are iterated over in parallel so the\n * order of emitted items is not guaranteed.\n */\nfunction merge <T> (...sources: Array<Iterable<T>>): Generator<T, void, undefined>\nfunction merge <T> (...sources: Array<AsyncIterable<T> | Iterable<T>>): AsyncGenerator<T, void, undefined>\nfunction merge <T> (...sources: Array<AsyncIterable<T> | Iterable<T>>): AsyncGenerator<T, void, undefined> | Generator<T, void, undefined> {\n  const syncSources: Array<Iterable<T>> = []\n\n  for (const source of sources) {\n    if (!isAsyncIterable(source)) {\n      syncSources.push(source)\n    }\n  }\n\n  if (syncSources.length === sources.length) {\n    // all sources are synchronous\n    return (function * () {\n      for (const source of syncSources) {\n        yield * source\n      }\n    })()\n  }\n\n  return (async function * () {\n    const output = pushable<T>({\n      objectMode: true\n    })\n\n    void Promise.resolve().then(async () => {\n      try {\n        await Promise.all(\n          sources.map(async (source) => {\n            for await (const item of source) {\n              output.push(item)\n            }\n          })\n        )\n\n        output.end()\n      } catch (err: any) {\n        output.end(err)\n      }\n    })\n\n    yield * output\n  })()\n}\n\nexport default merge\n", "import { pushable } from 'it-pushable'\nimport merge from 'it-merge'\nimport type { Duplex, Transform, Sink } from 'it-stream-types'\n\ninterface SourceFn<A = any> { (): A }\n\ntype PipeSource<A = any> =\n  Iterable<A> |\n  AsyncIterable<A> |\n  SourceFn<A> |\n  Duplex<A, any, any>\n\ntype PipeTransform<A = any, B = any> =\n  Transform<A, B> |\n  Duplex<B, A>\n\ntype PipeSink<A = any, B = any> =\n  Sink<A, B> |\n  Duplex<any, A, B>\n\ntype PipeOutput<A> =\n  A extends Sink<any> ? ReturnType<A> :\n    A extends Duplex<any, any, any> ? ReturnType<A['sink']> :\n      never\n\n// single item pipe output includes pipe source types\ntype SingleItemPipeOutput<A> =\n  A extends Iterable<any> ? A :\n    A extends AsyncIterable<any> ? A :\n      A extends SourceFn ? ReturnType<A> :\n        A extends Duplex<any, any, any> ? A['source'] :\n          PipeOutput<A>\n\ntype PipeFnInput<A> =\n  A extends Iterable<any> ? A :\n    A extends AsyncIterable<any> ? A :\n      A extends SourceFn ? ReturnType<A> :\n        A extends Transform<any, any> ? ReturnType<A> :\n          A extends Duplex<any, any, any> ? A['source'] :\n            never\n\n// one item, just a pass-through\nexport function pipe<\n  A extends PipeSource\n> (\n  source: A\n): SingleItemPipeOutput<A>\n\n// two items, source to sink\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeSink<PipeFnInput<A>>\n> (\n  source: A,\n  sink: B\n): PipeOutput<B>\n\n// three items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeSink<PipeFnInput<B>>\n> (\n  source: A,\n  transform1: B,\n  sink: C\n): PipeOutput<C>\n\n// many items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeSink<PipeFnInput<C>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  sink: D\n): PipeOutput<D>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeSink<PipeFnInput<D>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  sink: E\n): PipeOutput<E>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeSink<PipeFnInput<E>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  sink: F\n): PipeOutput<F>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeSink<PipeFnInput<F>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  sink: G\n): PipeOutput<G>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeSink<PipeFnInput<G>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  sink: H\n): PipeOutput<H>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeTransform<PipeFnInput<G>>,\n  I extends PipeSink<PipeFnInput<H>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  transform7: H,\n  sink: I\n): PipeOutput<I>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeTransform<PipeFnInput<G>>,\n  I extends PipeTransform<PipeFnInput<H>>,\n  J extends PipeSink<PipeFnInput<I>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  transform7: H,\n  transform8: I,\n  sink: J\n): PipeOutput<J>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeTransform<PipeFnInput<G>>,\n  I extends PipeTransform<PipeFnInput<H>>,\n  J extends PipeTransform<PipeFnInput<I>>,\n  K extends PipeSink<PipeFnInput<J>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  transform7: H,\n  transform8: I,\n  transform9: J,\n  sink: K\n): PipeOutput<K>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeTransform<PipeFnInput<G>>,\n  I extends PipeTransform<PipeFnInput<H>>,\n  J extends PipeTransform<PipeFnInput<I>>,\n  K extends PipeTransform<PipeFnInput<J>>,\n  L extends PipeSink<PipeFnInput<K>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  transform7: H,\n  transform8: I,\n  transform9: J,\n  transform10: K,\n  sink: L\n): PipeOutput<L>\n\nexport function pipe (first: any, ...rest: any[]): any {\n  if (first == null) {\n    throw new Error('Empty pipeline')\n  }\n\n  // Duplex at start: wrap in function and return duplex source\n  if (isDuplex(first)) {\n    const duplex = first\n    first = () => duplex.source\n  // Iterable at start: wrap in function\n  } else if (isIterable(first) || isAsyncIterable(first)) {\n    const source = first\n    first = () => source\n  }\n\n  const fns = [first, ...rest]\n\n  if (fns.length > 1) {\n    // Duplex at end: use duplex sink\n    if (isDuplex(fns[fns.length - 1])) {\n      fns[fns.length - 1] = fns[fns.length - 1].sink\n    }\n  }\n\n  if (fns.length > 2) {\n    // Duplex in the middle, consume source with duplex sink and return duplex source\n    for (let i = 1; i < fns.length - 1; i++) {\n      if (isDuplex(fns[i])) {\n        fns[i] = duplexPipelineFn(fns[i])\n      }\n    }\n  }\n\n  return rawPipe(...fns)\n}\n\nexport const rawPipe = (...fns: any): any => {\n  let res\n  while (fns.length > 0) {\n    res = fns.shift()(res)\n  }\n  return res\n}\n\nconst isAsyncIterable = (obj: any): obj is AsyncIterable<unknown> => {\n  return obj?.[Symbol.asyncIterator] != null\n}\n\nconst isIterable = (obj: any): obj is Iterable<unknown> => {\n  return obj?.[Symbol.iterator] != null\n}\n\nconst isDuplex = (obj: any): obj is Duplex => {\n  if (obj == null) {\n    return false\n  }\n\n  return obj.sink != null && obj.source != null\n}\n\nconst duplexPipelineFn = (duplex: Duplex<any, any, any>) => {\n  return (source: any) => {\n    const p = duplex.sink(source)\n\n    if (p?.then != null) {\n      const stream = pushable<any>({\n        objectMode: true\n      })\n      p.then(() => {\n        stream.end()\n      }, (err: Error) => {\n        stream.end(err)\n      })\n\n      let sourceWrap: () => Iterable<any> | AsyncIterable<any>\n      const source = duplex.source\n\n      if (isAsyncIterable(source)) {\n        sourceWrap = async function * () {\n          yield * source\n          stream.end()\n        }\n      } else if (isIterable(source)) {\n        sourceWrap = function * () {\n          yield * source\n          stream.end()\n        }\n      } else {\n        throw new Error('Unknown duplex source type - must be Iterable or AsyncIterable')\n      }\n\n      return merge(stream, sourceWrap())\n    }\n\n    return duplex.source\n  }\n}\n", "import type { Connection } from \"@libp2p/interface/connection\";\nimport type { PeerId } from \"@libp2p/interface/peer-id\";\nimport type { Peer, PeerStore } from \"@libp2p/interface/peer-store\";\n\nimport { bytesToUtf8 } from \"../bytes/index.js\";\n\n/**\n * Returns a pseudo-random peer that supports the given protocol.\n * Useful for protocols such as store and light push\n */\nexport function selectRandomPeer(peers: Peer[]): Peer | undefined {\n  if (peers.length === 0) return;\n\n  const index = Math.round(Math.random() * (peers.length - 1));\n  return peers[index];\n}\n\n/**\n * Returns the peer with the lowest latency.\n * @param peerStore - The Libp2p PeerStore\n * @param peers - The list of peers to choose from\n * @returns The peer with the lowest latency, or undefined if no peer could be reached\n */\nexport async function selectLowestLatencyPeer(\n  peerStore: PeerStore,\n  peers: Peer[]\n): Promise<Peer | undefined> {\n  if (peers.length === 0) return;\n\n  const results = await Promise.all(\n    peers.map(async (peer) => {\n      const pingBytes = (await peerStore.get(peer.id)).metadata.get(\"ping\");\n      if (!pingBytes) return { peer, ping: Infinity };\n\n      const ping = Number(bytesToUtf8(pingBytes)) ?? Infinity;\n      return { peer, ping };\n    })\n  );\n\n  const lowestLatencyResult = results.sort((a, b) => a.ping - b.ping)[0];\n  if (!lowestLatencyResult) {\n    return undefined;\n  }\n\n  return lowestLatencyResult.ping !== Infinity\n    ? lowestLatencyResult.peer\n    : undefined;\n}\n\n/**\n * Returns the list of peers that supports the given protocol.\n */\nexport async function getPeersForProtocol(\n  peerStore: PeerStore,\n  protocols: string[]\n): Promise<Peer[]> {\n  const peers: Peer[] = [];\n  await peerStore.forEach((peer) => {\n    for (let i = 0; i < protocols.length; i++) {\n      if (peer.protocols.includes(protocols[i])) {\n        peers.push(peer);\n        break;\n      }\n    }\n  });\n  return peers;\n}\n\n/**\n * Returns a peer that supports the given protocol.\n * If peerId is provided, the peer with that id is returned.\n * Otherwise, the peer with the lowest latency is returned.\n * If no peer is found from the above criteria, a random peer is returned.\n */\nexport async function selectPeerForProtocol(\n  peerStore: PeerStore,\n  protocols: string[],\n  peerId?: PeerId\n): Promise<{ peer: Peer; protocol: string }> {\n  let peer: Peer | undefined;\n  if (peerId) {\n    peer = await peerStore.get(peerId);\n    if (!peer) {\n      throw new Error(\n        `Failed to retrieve connection details for provided peer in peer store: ${peerId.toString()}`\n      );\n    }\n  } else {\n    const peers = await getPeersForProtocol(peerStore, protocols);\n    peer = await selectLowestLatencyPeer(peerStore, peers);\n    if (!peer) {\n      peer = selectRandomPeer(peers);\n      if (!peer)\n        throw new Error(\n          `Failed to find known peer that registers protocols: ${protocols}`\n        );\n    }\n  }\n\n  let protocol;\n  for (const codec of protocols) {\n    if (peer.protocols.includes(codec)) {\n      protocol = codec;\n      // Do not break as we want to keep the last value\n    }\n  }\n  if (!protocol) {\n    throw new Error(\n      `Peer does not register required protocols (${peer.id.toString()}): ${protocols}`\n    );\n  }\n\n  return { peer, protocol };\n}\n\nexport function selectConnection(\n  connections: Connection[]\n): Connection | undefined {\n  if (!connections.length) return;\n  if (connections.length === 1) return connections[0];\n\n  let latestConnection: Connection | undefined;\n\n  connections.forEach((connection) => {\n    if (connection.status === \"open\") {\n      if (!latestConnection) {\n        latestConnection = connection;\n      } else if (connection.timeline.open > latestConnection.timeline.open) {\n        latestConnection = connection;\n      }\n    }\n  });\n\n  return latestConnection;\n}\n", "import { Peer } from \"@libp2p/interface/peer-store\";\nimport { Tags } from \"@waku/interfaces\";\n\n/**\n * Retrieves a list of peers based on the specified criteria.\n *\n * @param peers - The list of peers to filter from.\n * @param numPeers - The total number of peers to retrieve. If 0, all peers are returned.\n * @param maxBootstrapPeers - The maximum number of bootstrap peers to retrieve.\n * @returns A Promise that resolves to an array of peers based on the specified criteria.\n */\nexport async function filterPeers(\n  peers: Peer[],\n  numPeers: number,\n  maxBootstrapPeers: number\n): Promise<Peer[]> {\n  // Collect the bootstrap peers up to the specified maximum\n  const bootstrapPeers = peers\n    .filter((peer) => peer.tags.has(Tags.BOOTSTRAP))\n    .slice(0, maxBootstrapPeers);\n\n  // Collect non-bootstrap peers\n  const nonBootstrapPeers = peers.filter(\n    (peer) => !peer.tags.has(Tags.BOOTSTRAP)\n  );\n\n  // If numPeers is 0, return all peers\n  if (numPeers === 0) {\n    return [...bootstrapPeers, ...nonBootstrapPeers];\n  }\n\n  // Initialize the list of selected peers with the bootstrap peers\n  const selectedPeers: Peer[] = [...bootstrapPeers];\n\n  // Fill up to numPeers with remaining random peers if needed\n  while (selectedPeers.length < numPeers && nonBootstrapPeers.length > 0) {\n    const randomIndex = Math.floor(Math.random() * nonBootstrapPeers.length);\n    const randomPeer = nonBootstrapPeers.splice(randomIndex, 1)[0];\n    selectedPeers.push(randomPeer);\n  }\n\n  return selectedPeers;\n}\n", "import type { PeerUpdate } from \"@libp2p/interface\";\nimport type { Stream } from \"@libp2p/interface/connection\";\nimport { Peer } from \"@libp2p/interface/peer-store\";\nimport { Libp2p } from \"@waku/interfaces\";\nimport { Logger } from \"@waku/utils\";\nimport { selectConnection } from \"@waku/utils/libp2p\";\n\nexport class StreamManager {\n  private streamPool: Map<string, Promise<Stream | void>>;\n  private readonly log: Logger;\n\n  constructor(\n    public multicodec: string,\n    public getConnections: Libp2p[\"getConnections\"],\n    public addEventListener: Libp2p[\"addEventListener\"]\n  ) {\n    this.log = new Logger(`stream-manager:${multicodec}`);\n    this.addEventListener(\n      \"peer:update\",\n      this.handlePeerUpdateStreamPool.bind(this)\n    );\n    this.getStream = this.getStream.bind(this);\n    this.streamPool = new Map();\n  }\n\n  public async getStream(peer: Peer): Promise<Stream> {\n    const peerIdStr = peer.id.toString();\n    const streamPromise = this.streamPool.get(peerIdStr);\n\n    if (!streamPromise) {\n      return this.newStream(peer); // fallback by creating a new stream on the spot\n    }\n\n    // We have the stream, let's remove it from the map\n    this.streamPool.delete(peerIdStr);\n\n    this.prepareNewStream(peer);\n\n    const stream = await streamPromise;\n\n    if (!stream || stream.status === \"closed\") {\n      return this.newStream(peer); // fallback by creating a new stream on the spot\n    }\n\n    return stream;\n  }\n\n  private async newStream(peer: Peer): Promise<Stream> {\n    const connections = this.getConnections(peer.id);\n    const connection = selectConnection(connections);\n    if (!connection) {\n      throw new Error(\"Failed to get a connection to the peer\");\n    }\n    return connection.newStream(this.multicodec);\n  }\n\n  private prepareNewStream(peer: Peer): void {\n    const streamPromise = this.newStream(peer).catch(() => {\n      // No error thrown as this call is not triggered by the user\n      this.log.error(\n        `Failed to prepare a new stream for ${peer.id.toString()}`\n      );\n    });\n    this.streamPool.set(peer.id.toString(), streamPromise);\n  }\n\n  private handlePeerUpdateStreamPool = (evt: CustomEvent<PeerUpdate>): void => {\n    const peer = evt.detail.peer;\n    if (peer.protocols.includes(this.multicodec)) {\n      this.log.info(`Preemptively opening a stream to ${peer.id.toString()}`);\n      this.prepareNewStream(peer);\n    }\n  };\n}\n", "import type { Libp2p } from \"@libp2p/interface\";\nimport type { Stream } from \"@libp2p/interface/connection\";\nimport type { PeerId } from \"@libp2p/interface/peer-id\";\nimport { Peer, PeerStore } from \"@libp2p/interface/peer-store\";\nimport type { IBaseProtocol, Libp2pComponents } from \"@waku/interfaces\";\nimport { getPeersForProtocol, selectPeerForProtocol } from \"@waku/utils/libp2p\";\n\nimport { filterPeers } from \"./filterPeers.js\";\nimport { StreamManager } from \"./stream_manager.js\";\n\n/**\n * A class with predefined helpers, to be used as a base to implement Waku\n * Protocols.\n */\nexport class BaseProtocol implements IBaseProtocol {\n  public readonly addLibp2pEventListener: Libp2p[\"addEventListener\"];\n  public readonly removeLibp2pEventListener: Libp2p[\"removeEventListener\"];\n  protected streamManager: StreamManager;\n\n  constructor(\n    public multicodec: string,\n    private components: Libp2pComponents\n  ) {\n    this.addLibp2pEventListener = components.events.addEventListener.bind(\n      components.events\n    );\n    this.removeLibp2pEventListener = components.events.removeEventListener.bind(\n      components.events\n    );\n\n    this.streamManager = new StreamManager(\n      multicodec,\n      components.connectionManager.getConnections.bind(\n        components.connectionManager\n      ),\n      this.addLibp2pEventListener\n    );\n  }\n  protected async getStream(peer: Peer): Promise<Stream> {\n    return this.streamManager.getStream(peer);\n  }\n\n  public get peerStore(): PeerStore {\n    return this.components.peerStore;\n  }\n\n  /**\n   * Returns known peers from the address book (`libp2p.peerStore`) that support\n   * the class protocol. Waku may or may not be currently connected to these\n   * peers.\n   */\n  public async peers(): Promise<Peer[]> {\n    return getPeersForProtocol(this.peerStore, [this.multicodec]);\n  }\n\n  protected async getPeer(peerId?: PeerId): Promise<Peer> {\n    const { peer } = await selectPeerForProtocol(\n      this.peerStore,\n      [this.multicodec],\n      peerId\n    );\n    return peer;\n  }\n\n  /**\n   * Retrieves a list of peers based on the specified criteria.\n   *\n   * @param numPeers - The total number of peers to retrieve. If 0, all peers are returned.\n   * @param maxBootstrapPeers - The maximum number of bootstrap peers to retrieve.\n   * @returns A Promise that resolves to an array of peers based on the specified criteria.\n   */\n  protected async getPeers(\n    {\n      numPeers,\n      maxBootstrapPeers\n    }: {\n      numPeers: number;\n      maxBootstrapPeers: number;\n    } = {\n      maxBootstrapPeers: 1,\n      numPeers: 0\n    }\n  ): Promise<Peer[]> {\n    // Retrieve all peers that support the protocol\n    const allPeersForProtocol = await getPeersForProtocol(this.peerStore, [\n      this.multicodec\n    ]);\n\n    // Filter the peers based on the specified criteria\n    return filterPeers(allPeersForProtocol, numPeers, maxBootstrapPeers);\n  }\n}\n", "// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}", "export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;", "import REGEX from './regex.js';\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && REGEX.test(uuid);\n}\n\nexport default validate;", "import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;", "import validate from './validate.js';\n\nfunction parse(uuid) {\n  if (!validate(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  let v;\n  const arr = new Uint8Array(16); // Parse ########-....-....-....-............\n\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff; // Parse ........-####-....-....-............\n\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff; // Parse ........-....-####-....-............\n\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff; // Parse ........-....-....-####-............\n\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff; // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n\nexport default parse;", "import { unsafeStringify } from './stringify.js';\nimport parse from './parse.js';\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  const bytes = [];\n\n  for (let i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n\n  return bytes;\n}\n\nexport const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nexport const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nexport default function v35(name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    var _namespace;\n\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n\n    if (typeof namespace === 'string') {\n      namespace = parse(namespace);\n    }\n\n    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    } // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n\n\n    let bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n\n    if (buf) {\n      offset = offset || 0;\n\n      for (let i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n\n      return buf;\n    }\n\n    return unsafeStringify(bytes);\n  } // Function#name is not settable on some platforms (#270)\n\n\n  try {\n    generateUUID.name = name; // eslint-disable-next-line no-empty\n  } catch (err) {} // For CommonJS default export support\n\n\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}", "/*\n * Browser-compatible JavaScript MD5\n *\n * Modification of JavaScript MD5\n * https://github.com/blueimp/JavaScript-MD5\n *\n * Copyright 2011, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n *\n * Based on\n * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n * Digest Algorithm, as defined in RFC 1321.\n * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for more info.\n */\nfunction md5(bytes) {\n  if (typeof bytes === 'string') {\n    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = new Uint8Array(msg.length);\n\n    for (let i = 0; i < msg.length; ++i) {\n      bytes[i] = msg.charCodeAt(i);\n    }\n  }\n\n  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));\n}\n/*\n * Convert an array of little-endian words to an array of bytes\n */\n\n\nfunction md5ToHexEncodedArray(input) {\n  const output = [];\n  const length32 = input.length * 32;\n  const hexTab = '0123456789abcdef';\n\n  for (let i = 0; i < length32; i += 8) {\n    const x = input[i >> 5] >>> i % 32 & 0xff;\n    const hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);\n    output.push(hex);\n  }\n\n  return output;\n}\n/**\n * Calculate output length with padding and bit length\n */\n\n\nfunction getOutputLength(inputLength8) {\n  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;\n}\n/*\n * Calculate the MD5 of an array of little-endian words, and a bit length.\n */\n\n\nfunction wordsToMd5(x, len) {\n  /* append padding */\n  x[len >> 5] |= 0x80 << len % 32;\n  x[getOutputLength(len) - 1] = len;\n  let a = 1732584193;\n  let b = -271733879;\n  let c = -1732584194;\n  let d = 271733878;\n\n  for (let i = 0; i < x.length; i += 16) {\n    const olda = a;\n    const oldb = b;\n    const oldc = c;\n    const oldd = d;\n    a = md5ff(a, b, c, d, x[i], 7, -680876936);\n    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);\n    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);\n    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);\n    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);\n    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);\n    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);\n    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);\n    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);\n    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);\n    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);\n    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);\n    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);\n    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);\n    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);\n    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);\n    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);\n    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);\n    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);\n    b = md5gg(b, c, d, a, x[i], 20, -373897302);\n    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);\n    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);\n    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);\n    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);\n    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);\n    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);\n    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);\n    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);\n    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);\n    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);\n    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);\n    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);\n    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);\n    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);\n    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);\n    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);\n    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);\n    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);\n    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);\n    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);\n    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);\n    d = md5hh(d, a, b, c, x[i], 11, -358537222);\n    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);\n    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);\n    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);\n    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);\n    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);\n    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);\n    a = md5ii(a, b, c, d, x[i], 6, -198630844);\n    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);\n    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);\n    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);\n    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);\n    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);\n    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);\n    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);\n    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);\n    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);\n    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);\n    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);\n    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);\n    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);\n    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);\n    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);\n    a = safeAdd(a, olda);\n    b = safeAdd(b, oldb);\n    c = safeAdd(c, oldc);\n    d = safeAdd(d, oldd);\n  }\n\n  return [a, b, c, d];\n}\n/*\n * Convert an array bytes to an array of little-endian words\n * Characters >255 have their high-byte silently ignored.\n */\n\n\nfunction bytesToWords(input) {\n  if (input.length === 0) {\n    return [];\n  }\n\n  const length8 = input.length * 8;\n  const output = new Uint32Array(getOutputLength(length8));\n\n  for (let i = 0; i < length8; i += 8) {\n    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;\n  }\n\n  return output;\n}\n/*\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n * to work around bugs in some JS interpreters.\n */\n\n\nfunction safeAdd(x, y) {\n  const lsw = (x & 0xffff) + (y & 0xffff);\n  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return msw << 16 | lsw & 0xffff;\n}\n/*\n * Bitwise rotate a 32-bit number to the left.\n */\n\n\nfunction bitRotateLeft(num, cnt) {\n  return num << cnt | num >>> 32 - cnt;\n}\n/*\n * These functions implement the four basic operations the algorithm uses.\n */\n\n\nfunction md5cmn(q, a, b, x, s, t) {\n  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);\n}\n\nfunction md5ff(a, b, c, d, x, s, t) {\n  return md5cmn(b & c | ~b & d, a, b, x, s, t);\n}\n\nfunction md5gg(a, b, c, d, x, s, t) {\n  return md5cmn(b & d | c & ~d, a, b, x, s, t);\n}\n\nfunction md5hh(a, b, c, d, x, s, t) {\n  return md5cmn(b ^ c ^ d, a, b, x, s, t);\n}\n\nfunction md5ii(a, b, c, d, x, s, t) {\n  return md5cmn(c ^ (b | ~d), a, b, x, s, t);\n}\n\nexport default md5;", "import v35 from './v35.js';\nimport md5 from './md5.js';\nconst v3 = v35('v3', 0x30, md5);\nexport default v3;", "const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default {\n  randomUUID\n};", "import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return unsafeStringify(rnds);\n}\n\nexport default v4;", "// Adapted from Chris Veness' SHA1 code at\n// http://www.movable-type.co.uk/scripts/sha1.html\nfunction f(s, x, y, z) {\n  switch (s) {\n    case 0:\n      return x & y ^ ~x & z;\n\n    case 1:\n      return x ^ y ^ z;\n\n    case 2:\n      return x & y ^ x & z ^ y & z;\n\n    case 3:\n      return x ^ y ^ z;\n  }\n}\n\nfunction ROTL(x, n) {\n  return x << n | x >>> 32 - n;\n}\n\nfunction sha1(bytes) {\n  const K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];\n  const H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];\n\n  if (typeof bytes === 'string') {\n    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = [];\n\n    for (let i = 0; i < msg.length; ++i) {\n      bytes.push(msg.charCodeAt(i));\n    }\n  } else if (!Array.isArray(bytes)) {\n    // Convert Array-like to Array\n    bytes = Array.prototype.slice.call(bytes);\n  }\n\n  bytes.push(0x80);\n  const l = bytes.length / 4 + 2;\n  const N = Math.ceil(l / 16);\n  const M = new Array(N);\n\n  for (let i = 0; i < N; ++i) {\n    const arr = new Uint32Array(16);\n\n    for (let j = 0; j < 16; ++j) {\n      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];\n    }\n\n    M[i] = arr;\n  }\n\n  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);\n  M[N - 1][14] = Math.floor(M[N - 1][14]);\n  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;\n\n  for (let i = 0; i < N; ++i) {\n    const W = new Uint32Array(80);\n\n    for (let t = 0; t < 16; ++t) {\n      W[t] = M[i][t];\n    }\n\n    for (let t = 16; t < 80; ++t) {\n      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);\n    }\n\n    let a = H[0];\n    let b = H[1];\n    let c = H[2];\n    let d = H[3];\n    let e = H[4];\n\n    for (let t = 0; t < 80; ++t) {\n      const s = Math.floor(t / 20);\n      const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;\n      e = d;\n      d = c;\n      c = ROTL(b, 30) >>> 0;\n      b = a;\n      a = T;\n    }\n\n    H[0] = H[0] + a >>> 0;\n    H[1] = H[1] + b >>> 0;\n    H[2] = H[2] + c >>> 0;\n    H[3] = H[3] + d >>> 0;\n    H[4] = H[4] + e >>> 0;\n  }\n\n  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];\n}\n\nexport default sha1;", "import v35 from './v35.js';\nimport sha1 from './sha1.js';\nconst v5 = v35('v5', 0x50, sha1);\nexport default v5;", "import { proto_filter_v2 as proto, WakuMessage } from \"@waku/proto\";\nimport { v4 as uuid } from \"uuid\";\n\n/**\n * FilterPushRPC represents a message conforming to the Waku FilterPush protocol.\n * Protocol documentation: https://rfc.vac.dev/spec/12/\n */\nexport class FilterPushRpc {\n  public constructor(public proto: proto.MessagePush) {}\n\n  static decode(bytes: Uint8Array): FilterPushRpc {\n    const res = proto.MessagePush.decode(bytes);\n    return new FilterPushRpc(res);\n  }\n\n  encode(): Uint8Array {\n    return proto.MessagePush.encode(this.proto);\n  }\n\n  get wakuMessage(): WakuMessage | undefined {\n    return this.proto.wakuMessage;\n  }\n\n  /**\n   * Get the pubsub topic from the FilterPushRpc object.\n   * @returns string\n   */\n  get pubsubTopic(): string | undefined {\n    return this.proto.pubsubTopic;\n  }\n}\n\nexport class FilterSubscribeRpc {\n  public constructor(public proto: proto.FilterSubscribeRequest) {}\n\n  static createSubscribeRequest(\n    pubsubTopic: string,\n    contentTopics: string[]\n  ): FilterSubscribeRpc {\n    return new FilterSubscribeRpc({\n      requestId: uuid(),\n      filterSubscribeType:\n        proto.FilterSubscribeRequest.FilterSubscribeType.SUBSCRIBE,\n      pubsubTopic,\n      contentTopics\n    });\n  }\n\n  static createUnsubscribeRequest(\n    pubsubTopic: string,\n    contentTopics: string[]\n  ): FilterSubscribeRpc {\n    return new FilterSubscribeRpc({\n      requestId: uuid(),\n      filterSubscribeType:\n        proto.FilterSubscribeRequest.FilterSubscribeType.UNSUBSCRIBE,\n      pubsubTopic,\n      contentTopics\n    });\n  }\n\n  static createUnsubscribeAllRequest(pubsubTopic: string): FilterSubscribeRpc {\n    return new FilterSubscribeRpc({\n      requestId: uuid(),\n      filterSubscribeType:\n        proto.FilterSubscribeRequest.FilterSubscribeType.UNSUBSCRIBE_ALL,\n      pubsubTopic,\n      contentTopics: []\n    });\n  }\n\n  static createSubscriberPingRequest(): FilterSubscribeRpc {\n    return new FilterSubscribeRpc({\n      requestId: uuid(),\n      filterSubscribeType:\n        proto.FilterSubscribeRequest.FilterSubscribeType.SUBSCRIBER_PING,\n      pubsubTopic: \"\",\n      contentTopics: []\n    });\n  }\n\n  static decode(bytes: Uint8Array): FilterSubscribeRpc {\n    const res = proto.FilterSubscribeRequest.decode(bytes);\n    return new FilterSubscribeRpc(res);\n  }\n\n  encode(): Uint8Array {\n    return proto.FilterSubscribeRequest.encode(this.proto);\n  }\n\n  get filterSubscribeType(): proto.FilterSubscribeRequest.FilterSubscribeType {\n    return this.proto.filterSubscribeType;\n  }\n\n  get requestId(): string {\n    return this.proto.requestId;\n  }\n\n  get pubsubTopic(): string | undefined {\n    return this.proto.pubsubTopic;\n  }\n\n  get contentTopics(): string[] {\n    return this.proto.contentTopics;\n  }\n}\n\nexport class FilterSubscribeResponse {\n  public constructor(public proto: proto.FilterSubscribeResponse) {}\n\n  static decode(bytes: Uint8Array): FilterSubscribeResponse {\n    const res = proto.FilterSubscribeResponse.decode(bytes);\n    return new FilterSubscribeResponse(res);\n  }\n\n  encode(): Uint8Array {\n    return proto.FilterSubscribeResponse.encode(this.proto);\n  }\n\n  get statusCode(): number {\n    return this.proto.statusCode;\n  }\n\n  get statusDesc(): string | undefined {\n    return this.proto.statusDesc;\n  }\n\n  get requestId(): string {\n    return this.proto.requestId;\n  }\n}\n", "import type { Stream } from \"@libp2p/interface/connection\";\nimport type { PeerId } from \"@libp2p/interface/peer-id\";\nimport {\n  IEncoder,\n  ILightPush,\n  IMessage,\n  Libp2p,\n  ProtocolCreateOptions,\n  PubSubTopic,\n  SendError,\n  SendResult\n} from \"@waku/interfaces\";\nimport { PushResponse } from \"@waku/proto\";\nimport {\n  ensurePubsubTopicIsConfigured,\n  isMessageSizeUnderCap\n} from \"@waku/utils\";\nimport { Logger } from \"@waku/utils\";\nimport all from \"it-all\";\nimport * as lp from \"it-length-prefixed\";\nimport { pipe } from \"it-pipe\";\nimport { Uint8ArrayList } from \"uint8arraylist\";\n\nimport { BaseProtocol } from \"../base_protocol.js\";\nimport { DefaultPubSubTopic } from \"../constants.js\";\n\nimport { PushRpc } from \"./push_rpc.js\";\n\nconst log = new Logger(\"light-push\");\n\nexport const LightPushCodec = \"/vac/waku/lightpush/2.0.0-beta1\";\nexport { PushResponse };\n\ntype PreparePushMessageResult =\n  | {\n      query: PushRpc;\n      error: null;\n    }\n  | {\n      query: null;\n      error: SendError;\n    };\n\n/**\n * Implements the [Waku v2 Light Push protocol](https://rfc.vac.dev/spec/19/).\n */\nclass LightPush extends BaseProtocol implements ILightPush {\n  private readonly pubsubTopics: PubSubTopic[];\n  private readonly NUM_PEERS_PROTOCOL = 1;\n\n  constructor(libp2p: Libp2p, options?: ProtocolCreateOptions) {\n    super(LightPushCodec, libp2p.components);\n    this.pubsubTopics = options?.pubsubTopics ?? [DefaultPubSubTopic];\n  }\n\n  private async preparePushMessage(\n    encoder: IEncoder,\n    message: IMessage,\n    pubsubTopic: string\n  ): Promise<PreparePushMessageResult> {\n    try {\n      if (!message.payload || message.payload.length === 0) {\n        log.error(\"Failed to send waku light push: payload is empty\");\n        return { query: null, error: SendError.EMPTY_PAYLOAD };\n      }\n\n      if (!(await isMessageSizeUnderCap(encoder, message))) {\n        log.error(\"Failed to send waku light push: message is bigger than 1MB\");\n        return { query: null, error: SendError.SIZE_TOO_BIG };\n      }\n\n      const protoMessage = await encoder.toProtoObj(message);\n      if (!protoMessage) {\n        log.error(\"Failed to encode to protoMessage, aborting push\");\n        return {\n          query: null,\n          error: SendError.ENCODE_FAILED\n        };\n      }\n\n      const query = PushRpc.createRequest(protoMessage, pubsubTopic);\n      return { query, error: null };\n    } catch (error) {\n      log.error(\"Failed to prepare push message\", error);\n\n      return {\n        query: null,\n        error: SendError.GENERIC_FAIL\n      };\n    }\n  }\n\n  async send(encoder: IEncoder, message: IMessage): Promise<SendResult> {\n    const { pubsubTopic } = encoder;\n    ensurePubsubTopicIsConfigured(pubsubTopic, this.pubsubTopics);\n\n    const recipients: PeerId[] = [];\n\n    const { query, error: preparationError } = await this.preparePushMessage(\n      encoder,\n      message,\n      pubsubTopic\n    );\n\n    if (preparationError || !query) {\n      return {\n        recipients,\n        errors: [preparationError]\n      };\n    }\n\n    //TODO: get a relevant peer for the topic/shard\n    const peers = await this.getPeers({\n      maxBootstrapPeers: 1,\n      numPeers: this.NUM_PEERS_PROTOCOL\n    });\n\n    if (!peers.length) {\n      return {\n        recipients,\n        errors: [SendError.NO_PEER_AVAILABLE]\n      };\n    }\n\n    const promises = peers.map(async (peer) => {\n      let stream: Stream | undefined;\n      try {\n        stream = await this.getStream(peer);\n      } catch (err) {\n        log.error(\n          `Failed to get a stream for remote peer${peer.id.toString()}`,\n          err\n        );\n        return { recipients, error: SendError.REMOTE_PEER_FAULT };\n      }\n\n      let res: Uint8ArrayList[] | undefined;\n      try {\n        res = await pipe(\n          [query.encode()],\n          lp.encode,\n          stream,\n          lp.decode,\n          async (source) => await all(source)\n        );\n      } catch (err) {\n        log.error(\"Failed to send waku light push request\", err);\n        return { recipients, error: SendError.GENERIC_FAIL };\n      }\n\n      const bytes = new Uint8ArrayList();\n      res.forEach((chunk) => {\n        bytes.append(chunk);\n      });\n\n      let response: PushResponse | undefined;\n      try {\n        response = PushRpc.decode(bytes).response;\n      } catch (err) {\n        log.error(\"Failed to decode push reply\", err);\n        return { recipients, error: SendError.DECODE_FAILED };\n      }\n\n      if (!response) {\n        log.error(\"Remote peer fault: No response in PushRPC\");\n        return { recipients, error: SendError.REMOTE_PEER_FAULT };\n      }\n\n      if (!response.isSuccess) {\n        log.error(\"Remote peer rejected the message: \", response.info);\n        return { recipients, error: SendError.REMOTE_PEER_REJECTED };\n      }\n\n      recipients.some((recipient) => recipient.equals(peer.id)) ||\n        recipients.push(peer.id);\n\n      return { recipients };\n    });\n\n    const results = await Promise.allSettled(promises);\n    const errors = results\n      .filter(\n        (\n          result\n        ): result is PromiseFulfilledResult<{\n          recipients: PeerId[];\n          error: SendError | undefined;\n        }> => result.status === \"fulfilled\"\n      )\n      .map((result) => result.value.error)\n      .filter((error) => error !== undefined) as SendError[];\n\n    return {\n      recipients,\n      errors\n    };\n  }\n}\n\nexport function wakuLightPush(\n  init: Partial<ProtocolCreateOptions> = {}\n): (libp2p: Libp2p) => ILightPush {\n  return (libp2p: Libp2p) => new LightPush(libp2p, init);\n}\n", "import { proto_lightpush as proto } from \"@waku/proto\";\nimport type { Uint8ArrayList } from \"uint8arraylist\";\nimport { v4 as uuid } from \"uuid\";\n\nexport class PushRpc {\n  public constructor(public proto: proto.PushRpc) {}\n\n  static createRequest(\n    message: proto.WakuMessage,\n    pubsubTopic: string\n  ): PushRpc {\n    return new PushRpc({\n      requestId: uuid(),\n      request: {\n        message: message,\n        pubsubTopic: pubsubTopic\n      },\n      response: undefined\n    });\n  }\n\n  static decode(bytes: Uint8ArrayList): PushRpc {\n    const res = proto.PushRpc.decode(bytes);\n    return new PushRpc(res);\n  }\n\n  encode(): Uint8Array {\n    return proto.PushRpc.encode(this.proto);\n  }\n\n  get query(): proto.PushRequest | undefined {\n    return this.proto.request;\n  }\n\n  get response(): proto.PushResponse | undefined {\n    return this.proto.response;\n  }\n}\n", "import type { Stream } from \"@libp2p/interface/connection\";\nimport { sha256 } from \"@noble/hashes/sha256\";\nimport {\n  Cursor,\n  IDecodedMessage,\n  IDecoder,\n  IStore,\n  Libp2p,\n  ProtocolCreateOptions,\n  PubSubTopic\n} from \"@waku/interfaces\";\nimport { proto_store as proto } from \"@waku/proto\";\nimport { ensurePubsubTopicIsConfigured, isDefined } from \"@waku/utils\";\nimport { Logger } from \"@waku/utils\";\nimport { concat, utf8ToBytes } from \"@waku/utils/bytes\";\nimport all from \"it-all\";\nimport * as lp from \"it-length-prefixed\";\nimport { pipe } from \"it-pipe\";\nimport { Uint8ArrayList } from \"uint8arraylist\";\n\nimport { BaseProtocol } from \"../base_protocol.js\";\nimport { DefaultPubSubTopic } from \"../constants.js\";\nimport { toProtoMessage } from \"../to_proto_message.js\";\n\nimport { HistoryRpc, PageDirection, Params } from \"./history_rpc.js\";\n\nimport HistoryError = proto.HistoryResponse.HistoryError;\n\nconst log = new Logger(\"store\");\n\nexport const StoreCodec = \"/vac/waku/store/2.0.0-beta4\";\n\nexport const DefaultPageSize = 10;\n\nexport { PageDirection };\n\nexport interface TimeFilter {\n  startTime: Date;\n  endTime: Date;\n}\n\nexport interface QueryOptions {\n  /**\n   * The direction in which pages are retrieved:\n   * - { @link PageDirection.BACKWARD }: Most recent page first.\n   * - { @link PageDirection.FORWARD }: Oldest page first.\n   *\n   * Note: This does not affect the ordering of messages with the page\n   * (the oldest message is always first).\n   *\n   * @default { @link PageDirection.BACKWARD }\n   */\n  pageDirection?: PageDirection;\n  /**\n   * The number of message per page.\n   *\n   * @default { @link DefaultPageSize }\n   */\n  pageSize?: number;\n  /**\n   * Retrieve messages with a timestamp within the provided values.\n   */\n  timeFilter?: TimeFilter;\n  /**\n   * Cursor as an index to start a query from.\n   * The cursor index will be exclusive (i.e. the message at the cursor index will not be included in the result).\n   * If undefined, the query will start from the beginning or end of the history, depending on the page direction.\n   */\n  cursor?: Cursor;\n}\n\n/**\n * Implements the [Waku v2 Store protocol](https://rfc.vac.dev/spec/13/).\n *\n * The Waku Store protocol can be used to retrieved historical messages.\n */\nclass Store extends BaseProtocol implements IStore {\n  private readonly pubsubTopics: PubSubTopic[];\n  private readonly NUM_PEERS_PROTOCOL = 1;\n\n  constructor(libp2p: Libp2p, options?: ProtocolCreateOptions) {\n    super(StoreCodec, libp2p.components);\n    this.pubsubTopics = options?.pubsubTopics ?? [DefaultPubSubTopic];\n  }\n\n  /**\n   * Processes messages based on the provided callback and options.\n   * @private\n   */\n  private async processMessages<T extends IDecodedMessage>(\n    messages: Promise<T | undefined>[],\n    callback: (message: T) => Promise<void | boolean> | boolean | void,\n    options?: QueryOptions\n  ): Promise<boolean> {\n    let abort = false;\n    const messagesOrUndef: Array<T | undefined> = await Promise.all(messages);\n    let processedMessages: Array<T> = messagesOrUndef.filter(isDefined);\n\n    if (this.shouldReverseOrder(options)) {\n      processedMessages = processedMessages.reverse();\n    }\n\n    await Promise.all(\n      processedMessages.map(async (msg) => {\n        if (msg && !abort) {\n          abort = Boolean(await callback(msg));\n        }\n      })\n    );\n\n    return abort;\n  }\n\n  /**\n   * Determines whether to reverse the order of messages based on the provided options.\n   *\n   * Messages in pages are ordered from oldest (first) to most recent (last).\n   * https://github.com/vacp2p/rfc/issues/533\n   *\n   * @private\n   */\n  private shouldReverseOrder(options?: QueryOptions): boolean {\n    return (\n      typeof options?.pageDirection === \"undefined\" ||\n      options?.pageDirection === PageDirection.BACKWARD\n    );\n  }\n\n  /**\n   * @deprecated Use `queryWithOrderedCallback` instead\n   **/\n  queryOrderedCallback = this.queryWithOrderedCallback;\n\n  /**\n   * Do a query to a Waku Store to retrieve historical/missed messages.\n   *\n   * The callback function takes a `WakuMessage` in input,\n   * messages are processed in order:\n   * - oldest to latest if `options.pageDirection` == { @link PageDirection.FORWARD }\n   * - latest to oldest if `options.pageDirection` == { @link PageDirection.BACKWARD }\n   *\n   * The ordering may affect performance.\n   * The ordering depends on the behavior of the remote store node.\n   * If strong ordering is needed, you may need to handle this at application level\n   * and set your own timestamps too (the WakuMessage timestamps are not certified).\n   *\n   * @throws If not able to reach a Waku Store peer to query,\n   * or if an error is encountered when processing the reply,\n   * or if two decoders with the same content topic are passed.\n   */\n  async queryWithOrderedCallback<T extends IDecodedMessage>(\n    decoders: IDecoder<T>[],\n    callback: (message: T) => Promise<void | boolean> | boolean | void,\n    options?: QueryOptions\n  ): Promise<void> {\n    for await (const promises of this.queryGenerator(decoders, options)) {\n      if (await this.processMessages(promises, callback, options)) break;\n    }\n  }\n\n  /**\n   * Do a query to a Waku Store to retrieve historical/missed messages.\n   * The callback function takes a `Promise<WakuMessage>` in input,\n   * useful if messages need to be decrypted and performance matters.\n   *\n   * The order of the messages passed to the callback is as follows:\n   * - within a page, messages are expected to be ordered from oldest to most recent\n   * - pages direction depends on { @link QueryOptions.pageDirection }\n   *\n   * Do note that the resolution of the `Promise<WakuMessage | undefined` may\n   * break the order as it may rely on the browser decryption API, which in turn,\n   * may have a different speed depending on the type of decryption.\n   *\n   * @throws If not able to reach a Waku Store peer to query,\n   * or if an error is encountered when processing the reply,\n   * or if two decoders with the same content topic are passed.\n   */\n  async queryWithPromiseCallback<T extends IDecodedMessage>(\n    decoders: IDecoder<T>[],\n    callback: (\n      message: Promise<T | undefined>\n    ) => Promise<void | boolean> | boolean | void,\n    options?: QueryOptions\n  ): Promise<void> {\n    let abort = false;\n    for await (const page of this.queryGenerator(decoders, options)) {\n      const _promises = page.map(async (msgPromise) => {\n        if (abort) return;\n        abort = Boolean(await callback(msgPromise));\n      });\n\n      await Promise.all(_promises);\n      if (abort) break;\n    }\n  }\n\n  /**\n   * Do a query to a Waku Store to retrieve historical/missed messages.\n   *\n   * This is a generator, useful if you want most control on how messages\n   * are processed.\n   *\n   * The order of the messages returned by the remote Waku node SHOULD BE\n   * as follows:\n   * - within a page, messages SHOULD be ordered from oldest to most recent\n   * - pages direction depends on { @link QueryOptions.pageDirection }\n   * @throws If not able to reach a Waku Store peer to query,\n   * or if an error is encountered when processing the reply,\n   * or if two decoders with the same content topic are passed.\n   *\n   * This API only supports querying a single pubsub topic at a time.\n   * If multiple decoders are provided, they must all have the same pubsub topic.\n   * @throws If multiple decoders with different pubsub topics are provided.\n   * @throws If no decoders are provided.\n   * @throws If no decoders are found for the provided pubsub topic.\n   */\n  async *queryGenerator<T extends IDecodedMessage>(\n    decoders: IDecoder<T>[],\n    options?: QueryOptions\n  ): AsyncGenerator<Promise<T | undefined>[]> {\n    if (decoders.length === 0) {\n      throw new Error(\"No decoders provided\");\n    }\n\n    let startTime, endTime;\n\n    if (options?.timeFilter) {\n      startTime = options.timeFilter.startTime;\n      endTime = options.timeFilter.endTime;\n    }\n\n    // convert array to set to remove duplicates\n    const uniquePubSubTopicsInQuery = Array.from(\n      new Set(decoders.map((decoder) => decoder.pubsubTopic))\n    );\n\n    // If multiple pubsub topics are provided, throw an error\n    if (uniquePubSubTopicsInQuery.length > 1) {\n      throw new Error(\n        \"API does not support querying multiple pubsub topics at once\"\n      );\n    }\n\n    // we can be certain that there is only one pubsub topic in the query\n    const pubSubTopicForQuery = uniquePubSubTopicsInQuery[0];\n\n    ensurePubsubTopicIsConfigured(pubSubTopicForQuery, this.pubsubTopics);\n\n    // check that the pubsubTopic from the Cursor and Decoder match\n    if (\n      options?.cursor?.pubsubTopic &&\n      options.cursor.pubsubTopic !== pubSubTopicForQuery\n    ) {\n      throw new Error(\n        `Cursor pubsub topic (${options?.cursor?.pubsubTopic}) does not match decoder pubsub topic (${pubSubTopicForQuery})`\n      );\n    }\n\n    const decodersAsMap = new Map();\n    decoders.forEach((dec) => {\n      if (decodersAsMap.has(dec.contentTopic)) {\n        throw new Error(\n          \"API does not support different decoder per content topic\"\n        );\n      }\n      decodersAsMap.set(dec.contentTopic, dec);\n    });\n\n    const contentTopics = decoders\n      .filter((decoder) => decoder.pubsubTopic === pubSubTopicForQuery)\n      .map((dec) => dec.contentTopic);\n\n    if (contentTopics.length === 0) {\n      throw new Error(\"No decoders found for topic \" + pubSubTopicForQuery);\n    }\n\n    const queryOpts = Object.assign(\n      {\n        pubsubTopic: pubSubTopicForQuery,\n        pageDirection: PageDirection.BACKWARD,\n        pageSize: DefaultPageSize\n      },\n      options,\n      { contentTopics, startTime, endTime }\n    );\n\n    const peer = (\n      await this.getPeers({\n        numPeers: this.NUM_PEERS_PROTOCOL,\n        maxBootstrapPeers: 1\n      })\n    )[0];\n\n    for await (const messages of paginate<T>(\n      this.getStream.bind(this, peer),\n      queryOpts,\n      decodersAsMap,\n      options?.cursor\n    )) {\n      yield messages;\n    }\n  }\n}\n\nasync function* paginate<T extends IDecodedMessage>(\n  streamFactory: () => Promise<Stream>,\n  queryOpts: Params,\n  decoders: Map<string, IDecoder<T>>,\n  cursor?: Cursor\n): AsyncGenerator<Promise<T | undefined>[]> {\n  if (\n    queryOpts.contentTopics.toString() !==\n    Array.from(decoders.keys()).toString()\n  ) {\n    throw new Error(\n      \"Internal error, the decoders should match the query's content topics\"\n    );\n  }\n\n  let currentCursor = cursor;\n  while (true) {\n    queryOpts.cursor = currentCursor;\n\n    const historyRpcQuery = HistoryRpc.createQuery(queryOpts);\n\n    log.info(\n      \"Querying store peer\",\n      `for (${queryOpts.pubsubTopic})`,\n      queryOpts.contentTopics\n    );\n\n    const stream = await streamFactory();\n\n    const res = await pipe(\n      [historyRpcQuery.encode()],\n      lp.encode,\n      stream,\n      lp.decode,\n      async (source) => await all(source)\n    );\n\n    const bytes = new Uint8ArrayList();\n    res.forEach((chunk) => {\n      bytes.append(chunk);\n    });\n\n    const reply = historyRpcQuery.decode(bytes);\n\n    if (!reply.response) {\n      log.warn(\"Stopping pagination due to store `response` field missing\");\n      break;\n    }\n\n    const response = reply.response as proto.HistoryResponse;\n\n    if (response.error && response.error !== HistoryError.NONE) {\n      throw \"History response contains an Error: \" + response.error;\n    }\n\n    if (!response.messages || !response.messages.length) {\n      log.warn(\n        \"Stopping pagination due to store `response.messages` field missing or empty\"\n      );\n      break;\n    }\n\n    log.error(`${response.messages.length} messages retrieved from store`);\n\n    yield response.messages.map((protoMsg) => {\n      const contentTopic = protoMsg.contentTopic;\n      if (typeof contentTopic !== \"undefined\") {\n        const decoder = decoders.get(contentTopic);\n        if (decoder) {\n          return decoder.fromProtoObj(\n            queryOpts.pubsubTopic,\n            toProtoMessage(protoMsg)\n          );\n        }\n      }\n      return Promise.resolve(undefined);\n    });\n\n    const nextCursor = response.pagingInfo?.cursor;\n    if (typeof nextCursor === \"undefined\") {\n      // If the server does not return cursor then there is an issue,\n      // Need to abort, or we end up in an infinite loop\n      log.warn(\n        \"Stopping pagination due to `response.pagingInfo.cursor` missing from store response\"\n      );\n      break;\n    }\n\n    currentCursor = nextCursor;\n\n    const responsePageSize = response.pagingInfo?.pageSize;\n    const queryPageSize = historyRpcQuery.query?.pagingInfo?.pageSize;\n    if (\n      // Response page size smaller than query, meaning this is the last page\n      responsePageSize &&\n      queryPageSize &&\n      responsePageSize < queryPageSize\n    ) {\n      break;\n    }\n  }\n}\n\nexport async function createCursor(message: IDecodedMessage): Promise<Cursor> {\n  if (\n    !message ||\n    !message.timestamp ||\n    !message.payload ||\n    !message.contentTopic\n  ) {\n    throw new Error(\"Message is missing required fields\");\n  }\n\n  const contentTopicBytes = utf8ToBytes(message.contentTopic);\n\n  const digest = sha256(concat([contentTopicBytes, message.payload]));\n\n  const messageTime = BigInt(message.timestamp.getTime()) * BigInt(1000000);\n\n  return {\n    digest,\n    pubsubTopic: message.pubsubTopic,\n    senderTime: messageTime,\n    receiverTime: messageTime\n  };\n}\n\nexport function wakuStore(\n  init: Partial<ProtocolCreateOptions> = {}\n): (libp2p: Libp2p) => IStore {\n  return (libp2p: Libp2p) => new Store(libp2p, init);\n}\n", "import { IProtoMessage } from \"@waku/interfaces\";\nimport { WakuMessage as WakuMessageProto } from \"@waku/proto\";\n\nconst EmptyMessage: IProtoMessage = {\n  payload: new Uint8Array(),\n  contentTopic: \"\",\n  version: undefined,\n  timestamp: undefined,\n  meta: undefined,\n  rateLimitProof: undefined,\n  ephemeral: undefined\n};\n\nexport function toProtoMessage(wire: WakuMessageProto): IProtoMessage {\n  return { ...EmptyMessage, ...wire };\n}\n", "import { proto_store as proto } from \"@waku/proto\";\nimport type { Uint8ArrayList } from \"uint8arraylist\";\nimport { v4 as uuid } from \"uuid\";\n\nconst OneMillion = BigInt(1_000_000);\n\nexport enum PageDirection {\n  BACKWARD = \"backward\",\n  FORWARD = \"forward\"\n}\n\nexport interface Params {\n  contentTopics: string[];\n  pubsubTopic: string;\n  pageDirection: PageDirection;\n  pageSize: number;\n  startTime?: Date;\n  endTime?: Date;\n  cursor?: proto.Index;\n}\n\nexport class HistoryRpc {\n  private constructor(public readonly proto: proto.HistoryRpc) {}\n\n  get query(): proto.HistoryQuery | undefined {\n    return this.proto.query;\n  }\n\n  get response(): proto.HistoryResponse | undefined {\n    return this.proto.response;\n  }\n\n  /**\n   * Create History Query.\n   */\n  static createQuery(params: Params): HistoryRpc {\n    const contentFilters = params.contentTopics.map((contentTopic) => {\n      return { contentTopic };\n    });\n\n    const direction = directionToProto(params.pageDirection);\n\n    const pagingInfo = {\n      pageSize: BigInt(params.pageSize),\n      cursor: params.cursor,\n      direction\n    } as proto.PagingInfo;\n\n    let startTime, endTime;\n    if (params.startTime) {\n      // milliseconds 10^-3 to nanoseconds 10^-9\n      startTime = BigInt(params.startTime.valueOf()) * OneMillion;\n    }\n\n    if (params.endTime) {\n      // milliseconds 10^-3 to nanoseconds 10^-9\n      endTime = BigInt(params.endTime.valueOf()) * OneMillion;\n    }\n    return new HistoryRpc({\n      requestId: uuid(),\n      query: {\n        pubsubTopic: params.pubsubTopic,\n        contentFilters,\n        pagingInfo,\n        startTime,\n        endTime\n      },\n      response: undefined\n    });\n  }\n\n  decode(bytes: Uint8ArrayList): HistoryRpc {\n    const res = proto.HistoryRpc.decode(bytes);\n    return new HistoryRpc(res);\n  }\n\n  encode(): Uint8Array {\n    return proto.HistoryRpc.encode(this.proto);\n  }\n}\n\nfunction directionToProto(\n  pageDirection: PageDirection\n): proto.PagingInfo.Direction {\n  switch (pageDirection) {\n    case PageDirection.BACKWARD:\n      return proto.PagingInfo.Direction.BACKWARD;\n    case PageDirection.FORWARD:\n      return proto.PagingInfo.Direction.FORWARD;\n    default:\n      return proto.PagingInfo.Direction.BACKWARD;\n  }\n}\n", "export class TimeoutError extends Error {\n\tconstructor(message) {\n\t\tsuper(message);\n\t\tthis.name = 'TimeoutError';\n\t}\n}\n\n/**\nAn error to be thrown when the request is aborted by AbortController.\nDOMException is thrown instead of this Error when DOMException is available.\n*/\nexport class AbortError extends Error {\n\tconstructor(message) {\n\t\tsuper();\n\t\tthis.name = 'AbortError';\n\t\tthis.message = message;\n\t}\n}\n\n/**\nTODO: Remove AbortError and just throw DOMException when targeting Node 18.\n*/\nconst getDOMException = errorMessage => globalThis.DOMException === undefined\n\t? new AbortError(errorMessage)\n\t: new DOMException(errorMessage);\n\n/**\nTODO: Remove below function and just 'reject(signal.reason)' when targeting Node 18.\n*/\nconst getAbortedReason = signal => {\n\tconst reason = signal.reason === undefined\n\t\t? getDOMException('This operation was aborted.')\n\t\t: signal.reason;\n\n\treturn reason instanceof Error ? reason : getDOMException(reason);\n};\n\nexport default function pTimeout(promise, options) {\n\tconst {\n\t\tmilliseconds,\n\t\tfallback,\n\t\tmessage,\n\t\tcustomTimers = {setTimeout, clearTimeout},\n\t} = options;\n\n\tlet timer;\n\n\tconst wrappedPromise = new Promise((resolve, reject) => {\n\t\tif (typeof milliseconds !== 'number' || Math.sign(milliseconds) !== 1) {\n\t\t\tthrow new TypeError(`Expected \\`milliseconds\\` to be a positive number, got \\`${milliseconds}\\``);\n\t\t}\n\n\t\tif (options.signal) {\n\t\t\tconst {signal} = options;\n\t\t\tif (signal.aborted) {\n\t\t\t\treject(getAbortedReason(signal));\n\t\t\t}\n\n\t\t\tsignal.addEventListener('abort', () => {\n\t\t\t\treject(getAbortedReason(signal));\n\t\t\t});\n\t\t}\n\n\t\tif (milliseconds === Number.POSITIVE_INFINITY) {\n\t\t\tpromise.then(resolve, reject);\n\t\t\treturn;\n\t\t}\n\n\t\t// We create the error outside of `setTimeout` to preserve the stack trace.\n\t\tconst timeoutError = new TimeoutError();\n\n\t\ttimer = customTimers.setTimeout.call(undefined, () => {\n\t\t\tif (fallback) {\n\t\t\t\ttry {\n\t\t\t\t\tresolve(fallback());\n\t\t\t\t} catch (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (typeof promise.cancel === 'function') {\n\t\t\t\tpromise.cancel();\n\t\t\t}\n\n\t\t\tif (message === false) {\n\t\t\t\tresolve();\n\t\t\t} else if (message instanceof Error) {\n\t\t\t\treject(message);\n\t\t\t} else {\n\t\t\t\ttimeoutError.message = message ?? `Promise timed out after ${milliseconds} milliseconds`;\n\t\t\t\treject(timeoutError);\n\t\t\t}\n\t\t}, milliseconds);\n\n\t\t(async () => {\n\t\t\ttry {\n\t\t\t\tresolve(await promise);\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t}\n\t\t})();\n\t});\n\n\tconst cancelablePromise = wrappedPromise.finally(() => {\n\t\tcancelablePromise.clear();\n\t});\n\n\tcancelablePromise.clear = () => {\n\t\tcustomTimers.clearTimeout.call(undefined, timer);\n\t\ttimer = undefined;\n\t};\n\n\treturn cancelablePromise;\n}\n", "import pTimeout from 'p-timeout';\n\nconst normalizeEmitter = emitter => {\n\tconst addListener = emitter.on || emitter.addListener || emitter.addEventListener;\n\tconst removeListener = emitter.off || emitter.removeListener || emitter.removeEventListener;\n\n\tif (!addListener || !removeListener) {\n\t\tthrow new TypeError('Emitter is not compatible');\n\t}\n\n\treturn {\n\t\taddListener: addListener.bind(emitter),\n\t\tremoveListener: removeListener.bind(emitter),\n\t};\n};\n\nexport function pEventMultiple(emitter, event, options) {\n\tlet cancel;\n\tconst returnValue = new Promise((resolve, reject) => {\n\t\toptions = {\n\t\t\trejectionEvents: ['error'],\n\t\t\tmultiArgs: false,\n\t\t\tresolveImmediately: false,\n\t\t\t...options,\n\t\t};\n\n\t\tif (!(options.count >= 0 && (options.count === Number.POSITIVE_INFINITY || Number.isInteger(options.count)))) {\n\t\t\tthrow new TypeError('The `count` option should be at least 0 or more');\n\t\t}\n\n\t\toptions.signal?.throwIfAborted();\n\n\t\t// Allow multiple events\n\t\tconst events = [event].flat();\n\n\t\tconst items = [];\n\t\tconst {addListener, removeListener} = normalizeEmitter(emitter);\n\n\t\tconst onItem = (...arguments_) => {\n\t\t\tconst value = options.multiArgs ? arguments_ : arguments_[0];\n\n\t\t\t// eslint-disable-next-line unicorn/no-array-callback-reference\n\t\t\tif (options.filter && !options.filter(value)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\titems.push(value);\n\n\t\t\tif (options.count === items.length) {\n\t\t\t\tcancel();\n\t\t\t\tresolve(items);\n\t\t\t}\n\t\t};\n\n\t\tconst rejectHandler = error => {\n\t\t\tcancel();\n\t\t\treject(error);\n\t\t};\n\n\t\tcancel = () => {\n\t\t\tfor (const event of events) {\n\t\t\t\tremoveListener(event, onItem);\n\t\t\t}\n\n\t\t\tfor (const rejectionEvent of options.rejectionEvents) {\n\t\t\t\tremoveListener(rejectionEvent, rejectHandler);\n\t\t\t}\n\t\t};\n\n\t\tfor (const event of events) {\n\t\t\taddListener(event, onItem);\n\t\t}\n\n\t\tfor (const rejectionEvent of options.rejectionEvents) {\n\t\t\taddListener(rejectionEvent, rejectHandler);\n\t\t}\n\n\t\tif (options.signal) {\n\t\t\toptions.signal.addEventListener('abort', () => {\n\t\t\t\trejectHandler(options.signal.reason);\n\t\t\t}, {once: true});\n\t\t}\n\n\t\tif (options.resolveImmediately) {\n\t\t\tresolve(items);\n\t\t}\n\t});\n\n\treturnValue.cancel = cancel;\n\n\tif (typeof options.timeout === 'number') {\n\t\tconst timeout = pTimeout(returnValue, {milliseconds: options.timeout});\n\t\ttimeout.cancel = cancel;\n\t\treturn timeout;\n\t}\n\n\treturn returnValue;\n}\n\nexport function pEvent(emitter, event, options) {\n\tif (typeof options === 'function') {\n\t\toptions = {filter: options};\n\t}\n\n\toptions = {\n\t\t...options,\n\t\tcount: 1,\n\t\tresolveImmediately: false,\n\t};\n\n\tconst arrayPromise = pEventMultiple(emitter, event, options);\n\tconst promise = arrayPromise.then(array => array[0]);\n\tpromise.cancel = arrayPromise.cancel;\n\n\treturn promise;\n}\n\nexport function pEventIterator(emitter, event, options) {\n\tif (typeof options === 'function') {\n\t\toptions = {filter: options};\n\t}\n\n\t// Allow multiple events\n\tconst events = [event].flat();\n\n\toptions = {\n\t\trejectionEvents: ['error'],\n\t\tresolutionEvents: [],\n\t\tlimit: Number.POSITIVE_INFINITY,\n\t\tmultiArgs: false,\n\t\t...options,\n\t};\n\n\tconst {limit} = options;\n\tconst isValidLimit = limit >= 0 && (limit === Number.POSITIVE_INFINITY || Number.isInteger(limit));\n\tif (!isValidLimit) {\n\t\tthrow new TypeError('The `limit` option should be a non-negative integer or Infinity');\n\t}\n\n\toptions.signal?.throwIfAborted();\n\n\tif (limit === 0) {\n\t\t// Return an empty async iterator to avoid any further cost\n\t\treturn {\n\t\t\t[Symbol.asyncIterator]() {\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tasync next() {\n\t\t\t\treturn {\n\t\t\t\t\tdone: true,\n\t\t\t\t\tvalue: undefined,\n\t\t\t\t};\n\t\t\t},\n\t\t};\n\t}\n\n\tconst {addListener, removeListener} = normalizeEmitter(emitter);\n\n\tlet isDone = false;\n\tlet error;\n\tlet hasPendingError = false;\n\tconst nextQueue = [];\n\tconst valueQueue = [];\n\tlet eventCount = 0;\n\tlet isLimitReached = false;\n\n\tconst valueHandler = (...arguments_) => {\n\t\teventCount++;\n\t\tisLimitReached = eventCount === limit;\n\n\t\tconst value = options.multiArgs ? arguments_ : arguments_[0];\n\n\t\tif (nextQueue.length > 0) {\n\t\t\tconst {resolve} = nextQueue.shift();\n\n\t\t\tresolve({done: false, value});\n\n\t\t\tif (isLimitReached) {\n\t\t\t\tcancel();\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tvalueQueue.push(value);\n\n\t\tif (isLimitReached) {\n\t\t\tcancel();\n\t\t}\n\t};\n\n\tconst cancel = () => {\n\t\tisDone = true;\n\n\t\tfor (const event of events) {\n\t\t\tremoveListener(event, valueHandler);\n\t\t}\n\n\t\tfor (const rejectionEvent of options.rejectionEvents) {\n\t\t\tremoveListener(rejectionEvent, rejectHandler);\n\t\t}\n\n\t\tfor (const resolutionEvent of options.resolutionEvents) {\n\t\t\tremoveListener(resolutionEvent, resolveHandler);\n\t\t}\n\n\t\twhile (nextQueue.length > 0) {\n\t\t\tconst {resolve} = nextQueue.shift();\n\t\t\tresolve({done: true, value: undefined});\n\t\t}\n\t};\n\n\tconst rejectHandler = (...arguments_) => {\n\t\terror = options.multiArgs ? arguments_ : arguments_[0];\n\n\t\tif (nextQueue.length > 0) {\n\t\t\tconst {reject} = nextQueue.shift();\n\t\t\treject(error);\n\t\t} else {\n\t\t\thasPendingError = true;\n\t\t}\n\n\t\tcancel();\n\t};\n\n\tconst resolveHandler = (...arguments_) => {\n\t\tconst value = options.multiArgs ? arguments_ : arguments_[0];\n\n\t\t// eslint-disable-next-line unicorn/no-array-callback-reference\n\t\tif (options.filter && !options.filter(value)) {\n\t\t\tcancel();\n\t\t\treturn;\n\t\t}\n\n\t\tif (nextQueue.length > 0) {\n\t\t\tconst {resolve} = nextQueue.shift();\n\t\t\tresolve({done: true, value});\n\t\t} else {\n\t\t\tvalueQueue.push(value);\n\t\t}\n\n\t\tcancel();\n\t};\n\n\tfor (const event of events) {\n\t\taddListener(event, valueHandler);\n\t}\n\n\tfor (const rejectionEvent of options.rejectionEvents) {\n\t\taddListener(rejectionEvent, rejectHandler);\n\t}\n\n\tfor (const resolutionEvent of options.resolutionEvents) {\n\t\taddListener(resolutionEvent, resolveHandler);\n\t}\n\n\tif (options.signal) {\n\t\toptions.signal.addEventListener('abort', () => {\n\t\t\trejectHandler(options.signal.reason);\n\t\t}, {once: true});\n\t}\n\n\treturn {\n\t\t[Symbol.asyncIterator]() {\n\t\t\treturn this;\n\t\t},\n\t\tasync next() {\n\t\t\tif (valueQueue.length > 0) {\n\t\t\t\tconst value = valueQueue.shift();\n\t\t\t\treturn {\n\t\t\t\t\tdone: isDone && valueQueue.length === 0 && !isLimitReached,\n\t\t\t\t\tvalue,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (hasPendingError) {\n\t\t\t\thasPendingError = false;\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\tif (isDone) {\n\t\t\t\treturn {\n\t\t\t\t\tdone: true,\n\t\t\t\t\tvalue: undefined,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tnextQueue.push({resolve, reject});\n\t\t\t});\n\t\t},\n\t\tasync return(value) {\n\t\t\tcancel();\n\t\t\treturn {\n\t\t\t\tdone: isDone,\n\t\t\t\tvalue,\n\t\t\t};\n\t\t},\n\t};\n}\n\nexport {TimeoutError} from 'p-timeout';\n", "import type { IdentifyResult } from \"@libp2p/interface\";\nimport type { IBaseProtocol, IRelay, Waku } from \"@waku/interfaces\";\nimport { Protocols } from \"@waku/interfaces\";\nimport { Logger } from \"@waku/utils\";\nimport { pEvent } from \"p-event\";\n\nconst log = new Logger(\"wait-for-remote-peer\");\n\n/**\n * Wait for a remote peer to be ready given the passed protocols.\n * Must be used after attempting to connect to nodes, using\n * {@link @waku/core!WakuNode.dial} or a bootstrap method with\n * {@link @waku/sdk!createLightNode}.\n *\n * If the passed protocols is a GossipSub protocol, then it resolves only once\n * a peer is in a mesh, to help ensure that other peers will send and receive\n * message to us.\n *\n * @param waku The Waku Node\n * @param protocols The protocols that need to be enabled by remote peers.\n * @param timeoutMs A timeout value in milliseconds..\n *\n * @returns A promise that **resolves** if all desired protocols are fulfilled by\n * remote nodes, **rejects** if the timeoutMs is reached.\n * @throws If passing a protocol that is not mounted\n * @default Wait for remote peers with protocols enabled locally and no time out is applied.\n */\nexport async function waitForRemotePeer(\n  waku: Waku,\n  protocols?: Protocols[],\n  timeoutMs?: number\n): Promise<void> {\n  protocols = protocols ?? getEnabledProtocols(waku);\n\n  if (!waku.isStarted()) return Promise.reject(\"Waku node is not started\");\n\n  const promises = [];\n\n  if (protocols.includes(Protocols.Relay)) {\n    if (!waku.relay)\n      throw new Error(\"Cannot wait for Relay peer: protocol not mounted\");\n    promises.push(waitForGossipSubPeerInMesh(waku.relay));\n  }\n\n  if (protocols.includes(Protocols.Store)) {\n    if (!waku.store)\n      throw new Error(\"Cannot wait for Store peer: protocol not mounted\");\n    promises.push(waitForConnectedPeer(waku.store));\n  }\n\n  if (protocols.includes(Protocols.LightPush)) {\n    if (!waku.lightPush)\n      throw new Error(\"Cannot wait for LightPush peer: protocol not mounted\");\n    promises.push(waitForConnectedPeer(waku.lightPush));\n  }\n\n  if (protocols.includes(Protocols.Filter)) {\n    if (!waku.filter)\n      throw new Error(\"Cannot wait for Filter peer: protocol not mounted\");\n    promises.push(waitForConnectedPeer(waku.filter));\n  }\n\n  if (timeoutMs) {\n    await rejectOnTimeout(\n      Promise.all(promises),\n      timeoutMs,\n      \"Timed out waiting for a remote peer.\"\n    );\n  } else {\n    await Promise.all(promises);\n  }\n}\n\n/**\n * Wait for a peer with the given protocol to be connected.\n */\nasync function waitForConnectedPeer(protocol: IBaseProtocol): Promise<void> {\n  const codec = protocol.multicodec;\n  const peers = await protocol.peers();\n\n  if (peers.length) {\n    log.info(`${codec} peer found: `, peers[0].id.toString());\n    return;\n  }\n\n  await new Promise<void>((resolve) => {\n    const cb = (evt: CustomEvent<IdentifyResult>): void => {\n      if (evt.detail?.protocols?.includes(codec)) {\n        protocol.removeLibp2pEventListener(\"peer:identify\", cb);\n        resolve();\n      }\n    };\n    protocol.addLibp2pEventListener(\"peer:identify\", cb);\n  });\n}\n\n/**\n * Wait for at least one peer with the given protocol to be connected and in the gossipsub\n * mesh for all pubsubTopics.\n */\nasync function waitForGossipSubPeerInMesh(waku: IRelay): Promise<void> {\n  let peers = waku.getMeshPeers();\n  const pubsubTopics = waku.pubsubTopics;\n\n  for (const topic of pubsubTopics) {\n    while (peers.length == 0) {\n      await pEvent(waku.gossipSub, \"gossipsub:heartbeat\");\n      peers = waku.getMeshPeers(topic);\n    }\n  }\n}\n\nconst awaitTimeout = (ms: number, rejectReason: string): Promise<void> =>\n  new Promise((_resolve, reject) => setTimeout(() => reject(rejectReason), ms));\n\nasync function rejectOnTimeout<T>(\n  promise: Promise<T>,\n  timeoutMs: number,\n  rejectReason: string\n): Promise<void> {\n  await Promise.race([promise, awaitTimeout(timeoutMs, rejectReason)]);\n}\n\nfunction getEnabledProtocols(waku: Waku): Protocols[] {\n  const protocols = [];\n\n  if (waku.relay) {\n    protocols.push(Protocols.Relay);\n  }\n\n  if (waku.filter) {\n    protocols.push(Protocols.Filter);\n  }\n\n  if (waku.store) {\n    protocols.push(Protocols.Store);\n  }\n\n  if (waku.lightPush) {\n    protocols.push(Protocols.LightPush);\n  }\n\n  return protocols;\n}\n", "/**\n * An abort error class that extends error\n */\nexport class AbortError extends Error {\n  public type: string\n  public code: string | string\n\n  constructor (message?: string, code?: string) {\n    super(message ?? 'The operation was aborted')\n    this.type = 'aborted'\n    this.name = 'AbortError'\n    this.code = code ?? 'ABORT_ERR'\n  }\n}\n\nexport interface RaceSignalOptions {\n  /**\n   * The message for the error thrown if the signal aborts\n   */\n  errorMessage?: string\n\n  /**\n   * The code for the error thrown if the signal aborts\n   */\n  errorCode?: string\n}\n\n/**\n * Race a promise against an abort signal\n */\nexport async function raceSignal <T> (promise: Promise<T>, signal?: AbortSignal, opts?: RaceSignalOptions): Promise<T> {\n  if (signal == null) {\n    return promise\n  }\n\n  if (signal.aborted) {\n    return Promise.reject(new AbortError(opts?.errorMessage, opts?.errorCode))\n  }\n\n  let listener\n\n  // create the error here so we have more context in the stack trace\n  const error = new AbortError(opts?.errorMessage, opts?.errorCode)\n\n  try {\n    return await Promise.race([\n      promise,\n      new Promise<T>((resolve, reject) => {\n        listener = () => {\n          reject(error)\n        }\n        signal.addEventListener('abort', listener)\n      })\n    ])\n  } finally {\n    if (listener != null) {\n      signal.removeEventListener('abort', listener)\n    }\n  }\n}\n", "import deferred, { type DeferredPromise } from 'p-defer'\nimport { raceSignal, type RaceSignalOptions } from 'race-signal'\nimport { type AbortOptions } from './index.js'\n\nexport interface Pushable<T> extends AsyncGenerator<T, void, unknown> {\n  /**\n   * End the iterable after all values in the buffer (if any) have been yielded. If an\n   * error is passed the buffer is cleared immediately and the next iteration will\n   * throw the passed error\n   */\n  end(err?: Error, options?: AbortOptions & RaceSignalOptions): Promise<void>\n\n  /**\n   * Push a value into the iterable. Values are yielded from the iterable in the order\n   * they are pushed. Values not yet consumed from the iterable are buffered.\n   */\n  push(value: T, options?: AbortOptions & RaceSignalOptions): Promise<void>\n}\n\nclass QueuelessPushable <T> implements Pushable<T> {\n  private needNext: DeferredPromise<void>\n  private haveNext: DeferredPromise<void>\n  private ended: boolean\n  private nextResult: IteratorResult<T> | undefined\n\n  constructor () {\n    this.ended = false\n\n    this.needNext = deferred()\n    this.needNext.resolve()\n\n    this.haveNext = deferred()\n  }\n\n  [Symbol.asyncIterator] (): AsyncGenerator<T, void, unknown> {\n    return this\n  }\n\n  async next (): Promise<IteratorResult<T, void>> {\n    if (this.nextResult == null) {\n      // wait for the supplier to push a value\n      await this.haveNext.promise\n    }\n\n    if (this.nextResult == null) {\n      throw new Error('Have next but next was undefined')\n    }\n\n    const nextResult = this.nextResult\n    this.nextResult = undefined\n\n    // signal to the supplier that we have read the value\n    this.needNext.resolve()\n    this.needNext = deferred()\n\n    return nextResult\n  }\n\n  async throw (err?: Error): Promise<IteratorReturnResult<undefined>> {\n    this.ended = true\n\n    if (err != null) {\n      this.haveNext.reject(err)\n    }\n\n    const result: IteratorReturnResult<undefined> = {\n      done: true,\n      value: undefined\n    }\n\n    return result\n  }\n\n  async return (): Promise<IteratorResult<T>> {\n    const result: IteratorReturnResult<undefined> = {\n      done: true,\n      value: undefined\n    }\n\n    await this._push(undefined)\n\n    return result\n  }\n\n  async push (value: T, options?: AbortOptions & RaceSignalOptions): Promise<void> {\n    await this._push(value, options)\n  }\n\n  async end (err?: Error, options?: AbortOptions & RaceSignalOptions): Promise<void> {\n    if (err != null) {\n      await this.throw(err)\n    } else {\n      // abortable return\n      await this._push(undefined, options)\n    }\n  }\n\n  private async _push (value?: T, options?: AbortOptions & RaceSignalOptions): Promise<void> {\n    if (value != null && this.ended) {\n      throw new Error('Cannot push value onto an ended pushable')\n    }\n\n    // already have a value, wait for it to be read\n    if (this.nextResult != null) {\n      await this.needNext.promise\n    }\n\n    if (value != null) {\n      this.nextResult = { done: false, value }\n    } else {\n      this.ended = true\n      this.nextResult = { done: true, value: undefined }\n    }\n\n    // let the consumer know we have a new value\n    this.haveNext.resolve()\n    this.haveNext = deferred()\n\n    // wait for the consumer to read the value or for the passed signal\n    // to abort the waiting\n    await raceSignal(\n      this.needNext.promise,\n      options?.signal,\n      options\n    )\n  }\n}\n\nexport function pushable <T> (): Pushable<T> {\n  return new QueuelessPushable<T>()\n}\n", "/**\n * @packageDocumentation\n *\n * This module makes it easy to send and receive bytes over streams.\n *\n * @example\n *\n * ```typescript\n * import { byteStream } from 'it-byte-stream'\n *\n * const stream = byteStream(duplex)\n *\n * // read the next chunk\n * const bytes = await stream.read()\n *\n * // read the next five bytes\n * const fiveBytes = await stream.read(5)\n *\n * // write bytes into the stream\n * await stream.write(Uint8Array.from([0, 1, 2, 3, 4]))\n * ```\n */\n\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { pushable } from './pushable.js'\nimport type { Duplex } from 'it-stream-types'\n\nexport class CodeError extends Error {\n  public readonly code: string\n\n  constructor (message: string, code: string) {\n    super(message)\n    this.code = code\n  }\n}\n\nexport class AbortError extends CodeError {\n  public readonly type: string\n\n  constructor (message: string) {\n    super(message, 'ABORT_ERR')\n    this.type = 'aborted'\n  }\n}\n\nexport interface AbortOptions {\n  signal?: AbortSignal\n}\n\nexport interface ByteStream <Stream = unknown> {\n  /**\n   * Read a set number of bytes from the stream\n   */\n  read(bytes?: number, options?: AbortOptions): Promise<Uint8ArrayList>\n\n  /**\n   * Write the passed bytes to the stream\n   */\n  write(input: Uint8Array | Uint8ArrayList, options?: AbortOptions): Promise<void>\n\n  /**\n   * Returns the underlying stream\n   */\n  unwrap(): Stream\n}\n\nexport function byteStream <Stream extends Duplex<any, any, any>> (duplex: Stream): ByteStream<Stream> {\n  const write = pushable()\n\n  duplex.sink(write).catch(async (err: Error) => {\n    await write.end(err)\n  })\n\n  duplex.sink = async (source: any) => {\n    for await (const buf of source) {\n      await write.push(buf)\n    }\n\n    await write.end()\n  }\n\n  let source = duplex.source\n\n  if (duplex.source[Symbol.iterator] != null) {\n    source = duplex.source[Symbol.iterator]()\n  } else if (duplex.source[Symbol.asyncIterator] != null) {\n    source = duplex.source[Symbol.asyncIterator]()\n  }\n\n  const readBuffer = new Uint8ArrayList()\n\n  const W: ByteStream<Stream> = {\n    read: async (bytes?: number, options?: AbortOptions) => {\n      options?.signal?.throwIfAborted()\n\n      let listener: EventListener | undefined\n\n      const abortPromise = new Promise((resolve, reject) => {\n        listener = () => {\n          reject(new AbortError('Read aborted'))\n        }\n\n        options?.signal?.addEventListener('abort', listener)\n      })\n\n      try {\n        if (bytes == null) {\n          // just read whatever arrives\n          const { done, value } = await Promise.race([\n            source.next(),\n            abortPromise\n          ])\n\n          if (done === true) {\n            return new Uint8ArrayList()\n          }\n\n          return value\n        }\n\n        while (readBuffer.byteLength < bytes) {\n          const { value, done } = await Promise.race([\n            source.next(),\n            abortPromise\n          ])\n\n          if (done === true) {\n            throw new CodeError('unexpected end of input', 'ERR_UNEXPECTED_EOF')\n          }\n\n          readBuffer.append(value)\n        }\n\n        const buf = readBuffer.sublist(0, bytes)\n        readBuffer.consume(bytes)\n\n        return buf\n      } finally {\n        if (listener != null) {\n          options?.signal?.removeEventListener('abort', listener)\n        }\n      }\n    },\n    write: async (data, options?: AbortOptions) => {\n      options?.signal?.throwIfAborted()\n\n      // just write\n      if (data instanceof Uint8Array) {\n        await write.push(data, options)\n      } else {\n        await write.push(data.subarray(), options)\n      }\n    },\n    unwrap: () => {\n      const originalStream = duplex.source\n      duplex.source = (async function * () {\n        yield * readBuffer\n        yield * originalStream\n      }())\n\n      return duplex\n    }\n  }\n\n  return W\n}\n", "/**\n * @packageDocumentation\n *\n * This module makes it easy to send and receive length-prefixed byte arrays over streams.\n *\n * @example\n *\n * ```typescript\n * import { lpStream } from 'it-length-prefixed-stream'\n *\n * const stream = lpStream(duplex)\n *\n * // read the next length-prefixed chunk\n * const bytes = await stream.read()\n *\n * // write a length-prefixed chunk\n * await stream.write(Uint8Array.from([0, 1, 2, 3, 4]))\n *\n * // write several chunks, all individually length-prefixed\n * await stream.writeV([\n *   Uint8Array.from([0, 1, 2, 3, 4]),\n *   Uint8Array.from([5, 6, 7, 8, 9])\n * ])\n * ```\n */\nimport { byteStream } from 'it-byte-stream'\nimport * as lp from 'it-length-prefixed'\nimport * as varint from 'uint8-varint'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport type { Duplex } from 'it-stream-types'\n\nclass CodeError extends Error {\n  public readonly code: string\n\n  constructor (message: string, code: string) {\n    super(message)\n    this.code = code\n  }\n}\n\nexport interface AbortOptions {\n  signal?: AbortSignal\n}\n\nexport interface LengthPrefixedStream <Stream = unknown> {\n  /**\n   * Read the next length-prefixed number of bytes from the stream\n   */\n  read(options?: AbortOptions): Promise<Uint8ArrayList>\n\n  /**\n   * Write the passed bytes to the stream prefixed by their length\n   */\n  write(input: Uint8Array | Uint8ArrayList, options?: AbortOptions): Promise<void>\n\n  /**\n   * Write passed list of bytes, prefix by their individual lengths to the stream as a single write\n   */\n  writeV(input: Array<Uint8Array | Uint8ArrayList>, options?: AbortOptions): Promise<void>\n\n  /**\n   * Returns the underlying stream\n   */\n  unwrap(): Stream\n}\n\nexport interface LengthPrefixedStreamOpts {\n  // encoding opts\n  lengthEncoder: lp.LengthEncoderFunction\n\n  // decoding opts\n  lengthDecoder: lp.LengthDecoderFunction\n  maxLengthLength: number\n  maxDataLength: number\n}\n\nconst defaultLengthDecoder: lp.LengthDecoderFunction = (buf) => {\n  return varint.decode(buf)\n}\ndefaultLengthDecoder.bytes = 0\n\nexport function lpStream <Stream extends Duplex<any, any, any>> (duplex: Stream, opts?: Partial<LengthPrefixedStreamOpts>): LengthPrefixedStream<Stream> {\n  const bytes = byteStream(duplex)\n\n  const W: LengthPrefixedStream<Stream> = {\n    read: async (options?: AbortOptions) => {\n      let dataLength: number = -1\n      const lengthBuffer = new Uint8ArrayList()\n      const decodeLength = opts?.lengthDecoder ?? defaultLengthDecoder\n\n      while (true) {\n        // read one byte at a time until we can decode a varint\n        lengthBuffer.append(await bytes.read(1, options))\n\n        try {\n          dataLength = decodeLength(lengthBuffer)\n        } catch (err) {\n          if (err instanceof RangeError) {\n            continue\n          }\n\n          throw err\n        }\n\n        if (dataLength > -1) {\n          break\n        }\n\n        if (opts?.maxLengthLength != null && lengthBuffer.byteLength > opts.maxLengthLength) {\n          throw new CodeError('message length length too long', 'ERR_MSG_LENGTH_TOO_LONG')\n        }\n      }\n\n      if (opts?.maxDataLength != null && dataLength > opts.maxDataLength) {\n        throw new CodeError('message length too long', 'ERR_MSG_DATA_TOO_LONG')\n      }\n\n      return bytes.read(dataLength, options)\n    },\n    write: async (data, options?: AbortOptions) => {\n      // encode, write\n      await bytes.write(lp.encode.single(data, opts), options)\n    },\n    writeV: async (data, options?: AbortOptions) => {\n      const list = new Uint8ArrayList(\n        ...data.map(buf => lp.encode.single(buf, opts))\n      )\n\n      // encode, write\n      await bytes.write(list, options)\n    },\n    unwrap: () => {\n      return bytes.unwrap()\n    }\n  }\n\n  return W\n}\n", "import defer from 'p-defer'\nimport type { Source, Duplex } from 'it-stream-types'\n\n/**\n * A pair of streams where one drains from the other\n */\nexport function pair <T> (): Duplex<AsyncGenerator<T>, Source<T>, Promise<void>> {\n  const deferred = defer<Source<T>>()\n  let piped = false\n\n  return {\n    sink: async source => {\n      if (piped) {\n        throw new Error('already piped')\n      }\n\n      piped = true\n      deferred.resolve(source)\n    },\n    source: (async function * () {\n      const source = await deferred.promise\n\n      yield * source\n    }())\n  }\n}\n", "import { pair } from './index.js'\nimport type { Duplex, Source } from 'it-stream-types'\n\n/**\n * Two duplex streams that are attached to each other\n */\nexport function duplexPair <T> (): [Duplex<AsyncGenerator<T>, Source<T>, Promise<void>>, Duplex<AsyncGenerator<T>, Source<T>, Promise<void>>] {\n  const a = pair<T>()\n  const b = pair<T>()\n  return [\n    {\n      source: a.source,\n      sink: b.sink\n    },\n    {\n      source: b.source,\n      sink: a.sink\n    }\n  ]\n}\n", "export const NOISE_MSG_MAX_LENGTH_BYTES = 65535\nexport const NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG = NOISE_MSG_MAX_LENGTH_BYTES - 16\n\nexport const DUMP_SESSION_KEYS = Boolean(globalThis.process?.env?.DUMP_SESSION_KEYS)\n", "/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */\n\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\nconst u8a = (a: any): a is Uint8Array => a instanceof Uint8Array;\n// Cast array to different type\nexport const u8 = (arr: TypedArray) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u16 = (arr: TypedArray) =>\n  new Uint16Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 2));\nexport const u32 = (arr: TypedArray) =>\n  new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n\n// Cast array to view\nexport const createView = (arr: TypedArray) =>\n  new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n\n// big-endian hardware is rare. Just in case someone still decides to run ciphers:\n// early-throw an error because we don't support BE yet.\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE) throw new Error('Non little-endian hardware is not supported');\n\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  if (!u8a(bytes)) throw new Error('Uint8Array expected');\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 } as const;\nfunction asciiToBase16(char: number): number | undefined {\n  if (char >= asciis._0 && char <= asciis._9) return char - asciis._0;\n  if (char >= asciis._A && char <= asciis._F) return char - (asciis._A - 10);\n  if (char >= asciis._a && char <= asciis._f) return char - (asciis._a - 10);\n  return;\n}\n\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2;\n  }\n  return array;\n}\n\nexport function hexToNumber(hex: string): bigint {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // Big Endian\n  return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\n\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes: Uint8Array): bigint {\n  return hexToNumber(bytesToHex(bytes));\n}\n\nexport function numberToBytesBE(n: number | bigint, len: number): Uint8Array {\n  return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\n\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => {};\n\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters: number, tick: number, cb: (i: number) => void) {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\ndeclare const TextDecoder: any;\n\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\nexport function bytesToUtf8(bytes: Uint8Array): string {\n  return new TextDecoder().decode(bytes);\n}\n\nexport type Input = Uint8Array | string;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  else if (u8a(data)) data = data.slice();\n  else throw new Error(`expected Uint8Array, got ${typeof data}`);\n  return data;\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n  let pad = 0; // walk through each item, ensure they have proper type\n  arrays.forEach((a) => {\n    if (!u8a(a)) throw new Error('Uint8Array expected');\n    r.set(a, pad);\n    pad += a.length;\n  });\n  return r;\n}\n\n// Check if object doens't have custom constructor (like Uint8Array/Array)\nconst isPlainObject = (obj: any) =>\n  Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;\n\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && (typeof opts !== 'object' || !isPlainObject(opts)))\n    throw new Error('options must be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\nexport function ensureBytes(b: any, len?: number) {\n  if (!(b instanceof Uint8Array)) throw new Error('Uint8Array expected');\n  if (typeof len === 'number')\n    if (b.length !== len) throw new Error(`Uint8Array length ${len} expected`);\n}\n\n// Constant-time equality\nexport function equalBytes(a: Uint8Array, b: Uint8Array): boolean {\n  // Should not happen\n  if (a.length !== b.length) throw new Error('equalBytes: Different size of Uint8Arrays');\n  let isSame = true;\n  for (let i = 0; i < a.length; i++) isSame &&= a[i] === b[i]; // Lets hope JIT won't optimize away.\n  return isSame;\n}\n\n// For runtime check if class implements interface\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n}\n\n// This will allow to re-use with composable things like packed & base encoders\n// Also, we probably can make tags composable\nexport type Cipher = {\n  encrypt(plaintext: Uint8Array): Uint8Array;\n  decrypt(ciphertext: Uint8Array): Uint8Array;\n};\n\nexport type AsyncCipher = {\n  encrypt(plaintext: Uint8Array): Promise<Uint8Array>;\n  decrypt(ciphertext: Uint8Array): Promise<Uint8Array>;\n};\n\nexport type CipherWithOutput = Cipher & {\n  encrypt(plaintext: Uint8Array, output?: Uint8Array): Uint8Array;\n  decrypt(ciphertext: Uint8Array, output?: Uint8Array): Uint8Array;\n};\n\n// Params is outside return type, so it is accessible before calling constructor\n// If function support multiple nonceLength's, we return best one\nexport type CipherParams = { blockSize: number; nonceLength?: number; tagLength?: number };\nexport type CipherCons<T extends any[]> = (key: Uint8Array, ...args: T) => Cipher;\nexport const wrapCipher = <C extends CipherCons<any>, P extends CipherParams>(\n  params: P,\n  c: C\n): C & P => {\n  Object.assign(c, params);\n  return c as C & P;\n};\n\nexport type XorStream = (\n  key: Uint8Array,\n  nonce: Uint8Array,\n  data: Uint8Array,\n  output?: Uint8Array,\n  counter?: number\n) => Uint8Array;\n\n// Polyfill for Safari 14\nexport function setBigUint64(\n  view: DataView,\n  byteOffset: number,\n  value: bigint,\n  isLE: boolean\n): void {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number((value >> _32n) & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n\nexport function u64Lengths(ciphertext: Uint8Array, AAD?: Uint8Array) {\n  const num = new Uint8Array(16);\n  const view = createView(num);\n  setBigUint64(view, 0, BigInt(AAD ? AAD.length : 0), true);\n  setBigUint64(view, 8, BigInt(ciphertext.length), true);\n  return num;\n}\n", "function number(n: number) {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error(`Wrong positive integer: ${n}`);\n}\n\nfunction bool(b: boolean) {\n  if (typeof b !== 'boolean') throw new Error(`Expected boolean, not ${b}`);\n}\n\nfunction bytes(b: Uint8Array | undefined, ...lengths: number[]) {\n  if (!(b instanceof Uint8Array)) throw new Error('Expected Uint8Array');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\n\nexport type Hash = {\n  (data: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\nfunction hash(hash: Hash) {\n  if (typeof hash !== 'function' || typeof hash.create !== 'function')\n    throw new Error('hash must be wrapped by utils.wrapConstructor');\n  number(hash.outputLen);\n  number(hash.blockLen);\n}\n\nfunction exists(instance: any, checkFinished = true) {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\nfunction output(out: any, instance: any) {\n  bytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n  }\n}\n\nexport { number, bool, bytes, hash, exists, output };\nconst assert = { number, bool, bytes, hash, exists, output };\nexport default assert;\n", "import { exists as aexists, output as aoutput } from './_assert.js';\nimport { Input, ensureBytes, toBytes, Hash } from './utils.js';\n\n// Poly1305 is a fast and parallel secret-key message-authentication code.\n// https://cr.yp.to/mac.html, https://cr.yp.to/mac/poly1305-20050329.pdf\n// https://datatracker.ietf.org/doc/html/rfc8439\n\n// Based on Public Domain poly1305-donna https://github.com/floodyberry/poly1305-donna\nconst u8to16 = (a: Uint8Array, i: number) => (a[i++] & 0xff) | ((a[i++] & 0xff) << 8);\nclass Poly1305 implements Hash<Poly1305> {\n  readonly blockLen = 16;\n  readonly outputLen = 16;\n  private buffer = new Uint8Array(16);\n  private r = new Uint16Array(10);\n  private h = new Uint16Array(10);\n  private pad = new Uint16Array(8);\n  private pos = 0;\n  protected finished = false;\n\n  constructor(key: Input) {\n    key = toBytes(key);\n    ensureBytes(key, 32);\n    const t0 = u8to16(key, 0);\n    const t1 = u8to16(key, 2);\n    const t2 = u8to16(key, 4);\n    const t3 = u8to16(key, 6);\n    const t4 = u8to16(key, 8);\n    const t5 = u8to16(key, 10);\n    const t6 = u8to16(key, 12);\n    const t7 = u8to16(key, 14);\n\n    // https://github.com/floodyberry/poly1305-donna/blob/e6ad6e091d30d7f4ec2d4f978be1fcfcbce72781/poly1305-donna-16.h#L47\n    this.r[0] = t0 & 0x1fff;\n    this.r[1] = ((t0 >>> 13) | (t1 << 3)) & 0x1fff;\n    this.r[2] = ((t1 >>> 10) | (t2 << 6)) & 0x1f03;\n    this.r[3] = ((t2 >>> 7) | (t3 << 9)) & 0x1fff;\n    this.r[4] = ((t3 >>> 4) | (t4 << 12)) & 0x00ff;\n    this.r[5] = (t4 >>> 1) & 0x1ffe;\n    this.r[6] = ((t4 >>> 14) | (t5 << 2)) & 0x1fff;\n    this.r[7] = ((t5 >>> 11) | (t6 << 5)) & 0x1f81;\n    this.r[8] = ((t6 >>> 8) | (t7 << 8)) & 0x1fff;\n    this.r[9] = (t7 >>> 5) & 0x007f;\n    for (let i = 0; i < 8; i++) this.pad[i] = u8to16(key, 16 + 2 * i);\n  }\n\n  private process(data: Uint8Array, offset: number, isLast = false) {\n    const hibit = isLast ? 0 : 1 << 11;\n    const { h, r } = this;\n    const r0 = r[0];\n    const r1 = r[1];\n    const r2 = r[2];\n    const r3 = r[3];\n    const r4 = r[4];\n    const r5 = r[5];\n    const r6 = r[6];\n    const r7 = r[7];\n    const r8 = r[8];\n    const r9 = r[9];\n\n    const t0 = u8to16(data, offset + 0);\n    const t1 = u8to16(data, offset + 2);\n    const t2 = u8to16(data, offset + 4);\n    const t3 = u8to16(data, offset + 6);\n    const t4 = u8to16(data, offset + 8);\n    const t5 = u8to16(data, offset + 10);\n    const t6 = u8to16(data, offset + 12);\n    const t7 = u8to16(data, offset + 14);\n\n    let h0 = h[0] + (t0 & 0x1fff);\n    let h1 = h[1] + (((t0 >>> 13) | (t1 << 3)) & 0x1fff);\n    let h2 = h[2] + (((t1 >>> 10) | (t2 << 6)) & 0x1fff);\n    let h3 = h[3] + (((t2 >>> 7) | (t3 << 9)) & 0x1fff);\n    let h4 = h[4] + (((t3 >>> 4) | (t4 << 12)) & 0x1fff);\n    let h5 = h[5] + ((t4 >>> 1) & 0x1fff);\n    let h6 = h[6] + (((t4 >>> 14) | (t5 << 2)) & 0x1fff);\n    let h7 = h[7] + (((t5 >>> 11) | (t6 << 5)) & 0x1fff);\n    let h8 = h[8] + (((t6 >>> 8) | (t7 << 8)) & 0x1fff);\n    let h9 = h[9] + ((t7 >>> 5) | hibit);\n\n    let c = 0;\n\n    let d0 = c + h0 * r0 + h1 * (5 * r9) + h2 * (5 * r8) + h3 * (5 * r7) + h4 * (5 * r6);\n    c = d0 >>> 13;\n    d0 &= 0x1fff;\n    d0 += h5 * (5 * r5) + h6 * (5 * r4) + h7 * (5 * r3) + h8 * (5 * r2) + h9 * (5 * r1);\n    c += d0 >>> 13;\n    d0 &= 0x1fff;\n\n    let d1 = c + h0 * r1 + h1 * r0 + h2 * (5 * r9) + h3 * (5 * r8) + h4 * (5 * r7);\n    c = d1 >>> 13;\n    d1 &= 0x1fff;\n    d1 += h5 * (5 * r6) + h6 * (5 * r5) + h7 * (5 * r4) + h8 * (5 * r3) + h9 * (5 * r2);\n    c += d1 >>> 13;\n    d1 &= 0x1fff;\n\n    let d2 = c + h0 * r2 + h1 * r1 + h2 * r0 + h3 * (5 * r9) + h4 * (5 * r8);\n    c = d2 >>> 13;\n    d2 &= 0x1fff;\n    d2 += h5 * (5 * r7) + h6 * (5 * r6) + h7 * (5 * r5) + h8 * (5 * r4) + h9 * (5 * r3);\n    c += d2 >>> 13;\n    d2 &= 0x1fff;\n\n    let d3 = c + h0 * r3 + h1 * r2 + h2 * r1 + h3 * r0 + h4 * (5 * r9);\n    c = d3 >>> 13;\n    d3 &= 0x1fff;\n    d3 += h5 * (5 * r8) + h6 * (5 * r7) + h7 * (5 * r6) + h8 * (5 * r5) + h9 * (5 * r4);\n    c += d3 >>> 13;\n    d3 &= 0x1fff;\n\n    let d4 = c + h0 * r4 + h1 * r3 + h2 * r2 + h3 * r1 + h4 * r0;\n    c = d4 >>> 13;\n    d4 &= 0x1fff;\n    d4 += h5 * (5 * r9) + h6 * (5 * r8) + h7 * (5 * r7) + h8 * (5 * r6) + h9 * (5 * r5);\n    c += d4 >>> 13;\n    d4 &= 0x1fff;\n\n    let d5 = c + h0 * r5 + h1 * r4 + h2 * r3 + h3 * r2 + h4 * r1;\n    c = d5 >>> 13;\n    d5 &= 0x1fff;\n    d5 += h5 * r0 + h6 * (5 * r9) + h7 * (5 * r8) + h8 * (5 * r7) + h9 * (5 * r6);\n    c += d5 >>> 13;\n    d5 &= 0x1fff;\n\n    let d6 = c + h0 * r6 + h1 * r5 + h2 * r4 + h3 * r3 + h4 * r2;\n    c = d6 >>> 13;\n    d6 &= 0x1fff;\n    d6 += h5 * r1 + h6 * r0 + h7 * (5 * r9) + h8 * (5 * r8) + h9 * (5 * r7);\n    c += d6 >>> 13;\n    d6 &= 0x1fff;\n\n    let d7 = c + h0 * r7 + h1 * r6 + h2 * r5 + h3 * r4 + h4 * r3;\n    c = d7 >>> 13;\n    d7 &= 0x1fff;\n    d7 += h5 * r2 + h6 * r1 + h7 * r0 + h8 * (5 * r9) + h9 * (5 * r8);\n    c += d7 >>> 13;\n    d7 &= 0x1fff;\n\n    let d8 = c + h0 * r8 + h1 * r7 + h2 * r6 + h3 * r5 + h4 * r4;\n    c = d8 >>> 13;\n    d8 &= 0x1fff;\n    d8 += h5 * r3 + h6 * r2 + h7 * r1 + h8 * r0 + h9 * (5 * r9);\n    c += d8 >>> 13;\n    d8 &= 0x1fff;\n\n    let d9 = c + h0 * r9 + h1 * r8 + h2 * r7 + h3 * r6 + h4 * r5;\n    c = d9 >>> 13;\n    d9 &= 0x1fff;\n    d9 += h5 * r4 + h6 * r3 + h7 * r2 + h8 * r1 + h9 * r0;\n    c += d9 >>> 13;\n    d9 &= 0x1fff;\n\n    c = ((c << 2) + c) | 0;\n    c = (c + d0) | 0;\n    d0 = c & 0x1fff;\n    c = c >>> 13;\n    d1 += c;\n\n    h[0] = d0;\n    h[1] = d1;\n    h[2] = d2;\n    h[3] = d3;\n    h[4] = d4;\n    h[5] = d5;\n    h[6] = d6;\n    h[7] = d7;\n    h[8] = d8;\n    h[9] = d9;\n  }\n\n  private finalize() {\n    const { h, pad } = this;\n    const g = new Uint16Array(10);\n    let c = h[1] >>> 13;\n    h[1] &= 0x1fff;\n    for (let i = 2; i < 10; i++) {\n      h[i] += c;\n      c = h[i] >>> 13;\n      h[i] &= 0x1fff;\n    }\n    h[0] += c * 5;\n    c = h[0] >>> 13;\n    h[0] &= 0x1fff;\n    h[1] += c;\n    c = h[1] >>> 13;\n    h[1] &= 0x1fff;\n    h[2] += c;\n\n    g[0] = h[0] + 5;\n    c = g[0] >>> 13;\n    g[0] &= 0x1fff;\n    for (let i = 1; i < 10; i++) {\n      g[i] = h[i] + c;\n      c = g[i] >>> 13;\n      g[i] &= 0x1fff;\n    }\n    g[9] -= 1 << 13;\n\n    let mask = (c ^ 1) - 1;\n    for (let i = 0; i < 10; i++) g[i] &= mask;\n    mask = ~mask;\n    for (let i = 0; i < 10; i++) h[i] = (h[i] & mask) | g[i];\n    h[0] = (h[0] | (h[1] << 13)) & 0xffff;\n    h[1] = ((h[1] >>> 3) | (h[2] << 10)) & 0xffff;\n    h[2] = ((h[2] >>> 6) | (h[3] << 7)) & 0xffff;\n    h[3] = ((h[3] >>> 9) | (h[4] << 4)) & 0xffff;\n    h[4] = ((h[4] >>> 12) | (h[5] << 1) | (h[6] << 14)) & 0xffff;\n    h[5] = ((h[6] >>> 2) | (h[7] << 11)) & 0xffff;\n    h[6] = ((h[7] >>> 5) | (h[8] << 8)) & 0xffff;\n    h[7] = ((h[8] >>> 8) | (h[9] << 5)) & 0xffff;\n\n    let f = h[0] + pad[0];\n    h[0] = f & 0xffff;\n    for (let i = 1; i < 8; i++) {\n      f = (((h[i] + pad[i]) | 0) + (f >>> 16)) | 0;\n      h[i] = f & 0xffff;\n    }\n  }\n  update(data: Input): this {\n    aexists(this);\n    const { buffer, blockLen } = this;\n    data = toBytes(data);\n    const len = data.length;\n\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input\n      if (take === blockLen) {\n        for (; blockLen <= len - pos; pos += blockLen) this.process(data, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(buffer, 0, false);\n        this.pos = 0;\n      }\n    }\n    return this;\n  }\n  destroy() {\n    this.h.fill(0);\n    this.r.fill(0);\n    this.buffer.fill(0);\n    this.pad.fill(0);\n  }\n  digestInto(out: Uint8Array) {\n    aexists(this);\n    aoutput(out, this);\n    this.finished = true;\n    const { buffer, h } = this;\n    let { pos } = this;\n    if (pos) {\n      buffer[pos++] = 1;\n      // buffer.subarray(pos).fill(0);\n      for (; pos < 16; pos++) buffer[pos] = 0;\n      this.process(buffer, 0, true);\n    }\n    this.finalize();\n    let opos = 0;\n    for (let i = 0; i < 8; i++) {\n      out[opos++] = h[i] >>> 0;\n      out[opos++] = h[i] >>> 8;\n    }\n    return out;\n  }\n  digest(): Uint8Array {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n}\n\nexport type CHash = ReturnType<typeof wrapConstructorWithKey>;\nexport function wrapConstructorWithKey<H extends Hash<H>>(hashCons: (key: Input) => Hash<H>) {\n  const hashC = (msg: Input, key: Input): Uint8Array => hashCons(key).update(toBytes(msg)).digest();\n  const tmp = hashCons(new Uint8Array(32));\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (key: Input) => hashCons(key);\n  return hashC;\n}\n\nexport const poly1305 = wrapConstructorWithKey((key) => new Poly1305(key));\n", "// Basic utils for ARX (add-rotate-xor) salsa and chacha ciphers.\nimport { number as anumber, bytes as abytes, bool as abool } from './_assert.js';\nimport { XorStream, checkOpts, u32, utf8ToBytes } from './utils.js';\n\n/*\nRFC8439 requires multi-step cipher stream, where\nauthKey starts with counter: 0, actual msg with counter: 1.\n\nFor this, we need a way to re-use nonce / counter:\n\n    const counter = new Uint8Array(4);\n    chacha(..., counter, ...); // counter is now 1\n    chacha(..., counter, ...); // counter is now 2\n\nThis is complicated:\n\n- 32-bit counters are enough, no need for 64-bit: max ArrayBuffer size in JS is 4GB\n- Original papers don't allow mutating counters\n- Counter overflow is undefined [^1]\n- Idea A: allow providing (nonce | counter) instead of just nonce, re-use it\n- Caveat: Cannot be re-used through all cases:\n- * chacha has (counter | nonce)\n- * xchacha has (nonce16 | counter | nonce16)\n- Idea B: separate nonce / counter and provide separate API for counter re-use\n- Caveat: there are different counter sizes depending on an algorithm.\n- salsa & chacha also differ in structures of key & sigma:\n  salsa20:      s[0] | k(4) | s[1] | nonce(2) | ctr(2) | s[2] | k(4) | s[3]\n  chacha:       s(4) | k(8) | ctr(1) | nonce(3)\n  chacha20orig: s(4) | k(8) | ctr(2) | nonce(2)\n- Idea C: helper method such as `setSalsaState(key, nonce, sigma, data)`\n- Caveat: we can't re-use counter array\n\nxchacha [^2] uses the subkey and remaining 8 byte nonce with ChaCha20 as normal\n(prefixed by 4 NUL bytes, since [RFC8439] specifies a 12-byte nonce).\n\n[^1]: https://mailarchive.ietf.org/arch/msg/cfrg/gsOnTJzcbgG6OqD8Sc0GO5aR_tU/\n[^2]: https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha#appendix-A.2\n*/\n\nconst sigma16 = utf8ToBytes('expand 16-byte k');\nconst sigma32 = utf8ToBytes('expand 32-byte k');\nconst sigma16_32 = u32(sigma16);\nconst sigma32_32 = u32(sigma32);\n\nexport function rotl(a: number, b: number): number {\n  return (a << b) | (a >>> (32 - b));\n}\n\nexport type CipherCoreFn = (\n  sigma: Uint32Array,\n  key: Uint32Array,\n  nonce: Uint32Array,\n  output: Uint32Array,\n  counter: number,\n  rounds?: number\n) => void;\n\nexport type ExtendNonceFn = (\n  sigma: Uint32Array,\n  key: Uint32Array,\n  input: Uint32Array,\n  output: Uint32Array\n) => void;\n\nexport type CipherOpts = {\n  allowShortKeys?: boolean; // Original salsa / chacha allow 16-byte keys\n  extendNonceFn?: ExtendNonceFn;\n  counterLength?: number;\n  counterRight?: boolean; // right: nonce|counter; left: counter|nonce\n  rounds?: number;\n};\n\n// Is byte array aligned to 4 byte offset (u32)?\nfunction isAligned32(b: Uint8Array) {\n  return b.byteOffset % 4 === 0;\n}\n\n// Salsa and Chacha block length is always 512-bit\nconst BLOCK_LEN = 64;\nconst BLOCK_LEN32 = 16;\n\n// new Uint32Array([2**32])   // => Uint32Array(1) [ 0 ]\n// new Uint32Array([2**32-1]) // => Uint32Array(1) [ 4294967295 ]\nconst MAX_COUNTER = 2 ** 32 - 1;\n\nconst U32_EMPTY = new Uint32Array();\nfunction runCipher(\n  core: CipherCoreFn,\n  sigma: Uint32Array,\n  key: Uint32Array,\n  nonce: Uint32Array,\n  data: Uint8Array,\n  output: Uint8Array,\n  counter: number,\n  rounds: number\n): void {\n  const len = data.length;\n  const block = new Uint8Array(BLOCK_LEN);\n  const b32 = u32(block);\n  // Make sure that buffers aligned to 4 bytes\n  const isAligned = isAligned32(data) && isAligned32(output);\n  const d32 = isAligned ? u32(data) : U32_EMPTY;\n  const o32 = isAligned ? u32(output) : U32_EMPTY;\n  for (let pos = 0; pos < len; counter++) {\n    core(sigma, key, nonce, b32, counter, rounds);\n    if (counter >= MAX_COUNTER) throw new Error('arx: counter overflow');\n    const take = Math.min(BLOCK_LEN, len - pos);\n    // aligned to 4 bytes\n    if (isAligned && take === BLOCK_LEN) {\n      const pos32 = pos / 4;\n      if (pos % 4 !== 0) throw new Error('arx: invalid block position');\n      for (let j = 0, posj: number; j < BLOCK_LEN32; j++) {\n        posj = pos32 + j;\n        o32[posj] = d32[posj] ^ b32[j];\n      }\n      pos += BLOCK_LEN;\n      continue;\n    }\n    for (let j = 0, posj; j < take; j++) {\n      posj = pos + j;\n      output[posj] = data[posj] ^ block[j];\n    }\n    pos += take;\n  }\n}\n\nexport function createCipher(core: CipherCoreFn, opts: CipherOpts): XorStream {\n  const { allowShortKeys, extendNonceFn, counterLength, counterRight, rounds } = checkOpts(\n    { allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 },\n    opts\n  );\n  if (typeof core !== 'function') throw new Error('core must be a function');\n  anumber(counterLength);\n  anumber(rounds);\n  abool(counterRight);\n  abool(allowShortKeys);\n  return (\n    key: Uint8Array,\n    nonce: Uint8Array,\n    data: Uint8Array,\n    output?: Uint8Array,\n    counter = 0\n  ): Uint8Array => {\n    abytes(key);\n    abytes(nonce);\n    abytes(data);\n    const len = data.length;\n    if (!output) output = new Uint8Array(len);\n    abytes(output);\n    anumber(counter);\n    if (counter < 0 || counter >= MAX_COUNTER) throw new Error('arx: counter overflow');\n    if (output.length < len)\n      throw new Error(`arx: output (${output.length}) is shorter than data (${len})`);\n    const toClean = [];\n\n    // Key & sigma\n    // key=16 -> sigma16, k=key|key\n    // key=32 -> sigma32, k=key\n    let l = key.length,\n      k: Uint8Array,\n      sigma: Uint32Array;\n    if (l === 32) {\n      k = key.slice();\n      toClean.push(k);\n      sigma = sigma32_32;\n    } else if (l === 16 && allowShortKeys) {\n      k = new Uint8Array(32);\n      k.set(key);\n      k.set(key, 16);\n      sigma = sigma16_32;\n      toClean.push(k);\n    } else {\n      throw new Error(`arx: invalid 32-byte key, got length=${l}`);\n    }\n\n    // Nonce\n    // salsa20:      8   (8-byte counter)\n    // chacha20orig: 8   (8-byte counter)\n    // chacha20:     12  (4-byte counter)\n    // xsalsa20:     24  (16 -> hsalsa,  8 -> old nonce)\n    // xchacha20:    24  (16 -> hchacha, 8 -> old nonce)\n    // Align nonce to 4 bytes\n    if (!isAligned32(nonce)) {\n      nonce = nonce.slice();\n      toClean.push(nonce);\n    }\n\n    const k32 = u32(k);\n    // hsalsa & hchacha: handle extended nonce\n    if (extendNonceFn) {\n      if (nonce.length !== 24) throw new Error(`arx: extended nonce must be 24 bytes`);\n      extendNonceFn(sigma, k32, u32(nonce.subarray(0, 16)), k32);\n      nonce = nonce.subarray(16);\n    }\n\n    // Handle nonce counter\n    const nonceNcLen = 16 - counterLength;\n    if (nonceNcLen !== nonce.length)\n      throw new Error(`arx: nonce must be ${nonceNcLen} or 16 bytes`);\n\n    // Pad counter when nonce is 64 bit\n    if (nonceNcLen !== 12) {\n      const nc = new Uint8Array(12);\n      nc.set(nonce, counterRight ? 0 : 12 - nonce.length);\n      nonce = nc;\n      toClean.push(nonce);\n    }\n    const n32 = u32(nonce);\n    runCipher(core, sigma, k32, n32, data, output, counter, rounds);\n    while (toClean.length > 0) toClean.pop()!.fill(0);\n    return output;\n  };\n}\n", "import {\n  wrapCipher,\n  CipherWithOutput,\n  XorStream,\n  createView,\n  ensureBytes,\n  equalBytes,\n  setBigUint64,\n} from './utils.js';\nimport { poly1305 } from './_poly1305.js';\nimport { createCipher, rotl } from './_arx.js';\n\n// ChaCha20 stream cipher was released in 2008. ChaCha aims to increase\n// the diffusion per round, but had slightly less cryptanalysis.\n// https://cr.yp.to/chacha.html, http://cr.yp.to/chacha/chacha-20080128.pdf\n\n/**\n * ChaCha core function.\n */\n// prettier-ignore\nfunction chachaCore(\n  s: Uint32Array, k: Uint32Array, n: Uint32Array, out: Uint32Array, cnt: number, rounds = 20\n): void {\n  let y00 = s[0], y01 = s[1], y02 = s[2], y03 = s[3], // \"expa\"   \"nd 3\"  \"2-by\"  \"te k\"\n      y04 = k[0], y05 = k[1], y06 = k[2], y07 = k[3], // Key      Key     Key     Key\n      y08 = k[4], y09 = k[5], y10 = k[6], y11 = k[7], // Key      Key     Key     Key\n      y12 = cnt,  y13 = n[0], y14 = n[1], y15 = n[2]; // Counter  Counter\tNonce   Nonce\n  // Save state to temporary variables\n  let x00 = y00, x01 = y01, x02 = y02, x03 = y03,\n      x04 = y04, x05 = y05, x06 = y06, x07 = y07,\n      x08 = y08, x09 = y09, x10 = y10, x11 = y11,\n      x12 = y12, x13 = y13, x14 = y14, x15 = y15;\n  for (let r = 0; r < rounds; r += 2) {\n    x00 = (x00 + x04) | 0; x12 = rotl(x12 ^ x00, 16);\n    x08 = (x08 + x12) | 0; x04 = rotl(x04 ^ x08, 12);\n    x00 = (x00 + x04) | 0; x12 = rotl(x12 ^ x00, 8);\n    x08 = (x08 + x12) | 0; x04 = rotl(x04 ^ x08, 7);\n\n    x01 = (x01 + x05) | 0; x13 = rotl(x13 ^ x01, 16);\n    x09 = (x09 + x13) | 0; x05 = rotl(x05 ^ x09, 12);\n    x01 = (x01 + x05) | 0; x13 = rotl(x13 ^ x01, 8);\n    x09 = (x09 + x13) | 0; x05 = rotl(x05 ^ x09, 7);\n\n    x02 = (x02 + x06) | 0; x14 = rotl(x14 ^ x02, 16);\n    x10 = (x10 + x14) | 0; x06 = rotl(x06 ^ x10, 12);\n    x02 = (x02 + x06) | 0; x14 = rotl(x14 ^x02, 8);\n    x10 = (x10 + x14) | 0; x06 = rotl(x06 ^ x10, 7);\n\n    x03 = (x03 + x07) | 0; x15 = rotl(x15 ^ x03, 16);\n    x11 = (x11 + x15) | 0; x07 = rotl(x07 ^ x11, 12);\n    x03 = (x03 + x07) | 0; x15 = rotl(x15 ^ x03, 8)\n    x11 = (x11 + x15) | 0; x07 = rotl(x07 ^ x11, 7);\n\n    x00 = (x00 + x05) | 0; x15 = rotl(x15 ^ x00, 16);\n    x10 = (x10 + x15) | 0; x05 = rotl(x05 ^ x10, 12);\n    x00 = (x00 + x05) | 0; x15 = rotl(x15 ^ x00, 8);\n    x10 = (x10 + x15) | 0; x05 = rotl(x05 ^ x10, 7);\n\n    x01 = (x01 + x06) | 0; x12 = rotl(x12 ^ x01, 16);\n    x11 = (x11 + x12) | 0; x06 = rotl(x06 ^ x11, 12);\n    x01 = (x01 + x06) | 0; x12 = rotl(x12 ^ x01, 8);\n    x11 = (x11 + x12) | 0; x06 = rotl(x06 ^ x11, 7);\n\n    x02 = (x02 + x07) | 0; x13 = rotl(x13 ^ x02, 16);\n    x08 = (x08 + x13) | 0; x07 = rotl(x07 ^ x08, 12);\n    x02 = (x02 + x07) | 0; x13 = rotl(x13 ^ x02, 8);\n    x08 = (x08 + x13) | 0; x07 = rotl(x07 ^ x08, 7);\n\n    x03 = (x03 + x04) | 0; x14 = rotl(x14 ^ x03, 16)\n    x09 = (x09 + x14) | 0; x04 = rotl(x04 ^ x09, 12);\n    x03 = (x03 + x04) | 0; x14 = rotl(x14 ^ x03, 8);\n    x09 = (x09 + x14) | 0; x04 = rotl(x04 ^ x09, 7);\n  }\n  // Write output\n  let oi = 0;\n  out[oi++] = (y00 + x00) | 0; out[oi++] = (y01 + x01) | 0;\n  out[oi++] = (y02 + x02) | 0; out[oi++] = (y03 + x03) | 0;\n  out[oi++] = (y04 + x04) | 0; out[oi++] = (y05 + x05) | 0;\n  out[oi++] = (y06 + x06) | 0; out[oi++] = (y07 + x07) | 0;\n  out[oi++] = (y08 + x08) | 0; out[oi++] = (y09 + x09) | 0;\n  out[oi++] = (y10 + x10) | 0; out[oi++] = (y11 + x11) | 0;\n  out[oi++] = (y12 + x12) | 0; out[oi++] = (y13 + x13) | 0;\n  out[oi++] = (y14 + x14) | 0; out[oi++] = (y15 + x15) | 0;\n}\n/**\n * hchacha helper method, used primarily in xchacha, to hash\n * key and nonce into key' and nonce'.\n * Same as chachaCore, but there doesn't seem to be a way to move the block\n * out without 25% performance hit.\n */\n// prettier-ignore\nexport function hchacha(\n  s: Uint32Array, k: Uint32Array, i: Uint32Array, o32: Uint32Array\n) {\n  let x00 = s[0], x01 = s[1], x02 = s[2], x03 = s[3],\n      x04 = k[0], x05 = k[1], x06 = k[2], x07 = k[3],\n      x08 = k[4], x09 = k[5], x10 = k[6], x11 = k[7],\n      x12 = i[0], x13 = i[1], x14 = i[2], x15 = i[3];\n  for (let r = 0; r < 20; r += 2) {\n    x00 = (x00 + x04) | 0; x12 = rotl(x12 ^ x00, 16);\n    x08 = (x08 + x12) | 0; x04 = rotl(x04 ^ x08, 12);\n    x00 = (x00 + x04) | 0; x12 = rotl(x12 ^ x00, 8);\n    x08 = (x08 + x12) | 0; x04 = rotl(x04 ^ x08, 7);\n\n    x01 = (x01 + x05) | 0; x13 = rotl(x13 ^ x01, 16);\n    x09 = (x09 + x13) | 0; x05 = rotl(x05 ^ x09, 12);\n    x01 = (x01 + x05) | 0; x13 = rotl(x13 ^ x01, 8);\n    x09 = (x09 + x13) | 0; x05 = rotl(x05 ^ x09, 7);\n\n    x02 = (x02 + x06) | 0; x14 = rotl(x14 ^ x02, 16);\n    x10 = (x10 + x14) | 0; x06 = rotl(x06 ^ x10, 12);\n    x02 = (x02 + x06) | 0; x14 = rotl(x14 ^ x02, 8);\n    x10 = (x10 + x14) | 0; x06 = rotl(x06 ^ x10, 7);\n\n    x03 = (x03 + x07) | 0; x15 = rotl(x15 ^ x03, 16);\n    x11 = (x11 + x15) | 0; x07 = rotl(x07 ^ x11, 12);\n    x03 = (x03 + x07) | 0; x15 = rotl(x15 ^ x03, 8)\n    x11 = (x11 + x15) | 0; x07 = rotl(x07 ^ x11, 7);\n\n    x00 = (x00 + x05) | 0; x15 = rotl(x15 ^ x00, 16);\n    x10 = (x10 + x15) | 0; x05 = rotl(x05 ^ x10, 12);\n    x00 = (x00 + x05) | 0; x15 = rotl(x15 ^ x00, 8);\n    x10 = (x10 + x15) | 0; x05 = rotl(x05 ^ x10, 7);\n\n    x01 = (x01 + x06) | 0; x12 = rotl(x12 ^ x01, 16);\n    x11 = (x11 + x12) | 0; x06 = rotl(x06 ^ x11, 12);\n    x01 = (x01 + x06) | 0; x12 = rotl(x12 ^ x01, 8);\n    x11 = (x11 + x12) | 0; x06 = rotl(x06 ^ x11, 7);\n\n    x02 = (x02 + x07) | 0; x13 = rotl(x13 ^ x02, 16);\n    x08 = (x08 + x13) | 0; x07 = rotl(x07 ^ x08, 12);\n    x02 = (x02 + x07) | 0; x13 = rotl(x13 ^ x02, 8);\n    x08 = (x08 + x13) | 0; x07 = rotl(x07 ^ x08, 7);\n\n    x03 = (x03 + x04) | 0; x14 = rotl(x14 ^ x03, 16)\n    x09 = (x09 + x14) | 0; x04 = rotl(x04 ^ x09, 12);\n    x03 = (x03 + x04) | 0; x14 = rotl(x14 ^ x03, 8);\n    x09 = (x09 + x14) | 0; x04 = rotl(x04 ^ x09, 7);\n  }\n  let oi = 0;\n  o32[oi++] = x00; o32[oi++] = x01;\n  o32[oi++] = x02; o32[oi++] = x03;\n  o32[oi++] = x12; o32[oi++] = x13;\n  o32[oi++] = x14; o32[oi++] = x15;\n}\n/**\n * Original, non-RFC chacha20 from DJB. 8-byte nonce, 8-byte counter.\n */\nexport const chacha20orig = /* @__PURE__ */ createCipher(chachaCore, {\n  counterRight: false,\n  counterLength: 8,\n  allowShortKeys: true,\n});\n/**\n * ChaCha stream cipher. Conforms to RFC 8439 (IETF, TLS). 12-byte nonce, 4-byte counter.\n * With 12-byte nonce, it's not safe to use fill it with random (CSPRNG), due to collision chance.\n */\nexport const chacha20 = /* @__PURE__ */ createCipher(chachaCore, {\n  counterRight: false,\n  counterLength: 4,\n  allowShortKeys: false,\n});\n\n/**\n * XChaCha eXtended-nonce ChaCha. 24-byte nonce.\n * With 24-byte nonce, it's safe to use fill it with random (CSPRNG).\n * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha\n */\nexport const xchacha20 = /* @__PURE__ */ createCipher(chachaCore, {\n  counterRight: false,\n  counterLength: 8,\n  extendNonceFn: hchacha,\n  allowShortKeys: false,\n});\n\n/**\n * Reduced 8-round chacha, described in original paper.\n */\nexport const chacha8 = /* @__PURE__ */ createCipher(chachaCore, {\n  counterRight: false,\n  counterLength: 4,\n  rounds: 8,\n});\n\n/**\n * Reduced 12-round chacha, described in original paper.\n */\nexport const chacha12 = /* @__PURE__ */ createCipher(chachaCore, {\n  counterRight: false,\n  counterLength: 4,\n  rounds: 12,\n});\n\nconst ZEROS16 = /* @__PURE__ */ new Uint8Array(16);\n// Pad to digest size with zeros\nconst updatePadded = (h: ReturnType<typeof poly1305.create>, msg: Uint8Array) => {\n  h.update(msg);\n  const left = msg.length % 16;\n  if (left) h.update(ZEROS16.subarray(left));\n};\n\nconst ZEROS32 = /* @__PURE__ */ new Uint8Array(32);\nfunction computeTag(\n  fn: XorStream,\n  key: Uint8Array,\n  nonce: Uint8Array,\n  data: Uint8Array,\n  AAD?: Uint8Array\n): Uint8Array {\n  const authKey = fn(key, nonce, ZEROS32);\n  const h = poly1305.create(authKey);\n  if (AAD) updatePadded(h, AAD);\n  updatePadded(h, data);\n  const num = new Uint8Array(16);\n  const view = createView(num);\n  setBigUint64(view, 0, BigInt(AAD ? AAD.length : 0), true);\n  setBigUint64(view, 8, BigInt(data.length), true);\n  h.update(num);\n  const res = h.digest();\n  authKey.fill(0);\n  return res;\n}\n\n/**\n * AEAD algorithm from RFC 8439.\n * Salsa20 and chacha (RFC 8439) use poly1305 differently.\n * We could have composed them similar to:\n * https://github.com/paulmillr/scure-base/blob/b266c73dde977b1dd7ef40ef7a23cc15aab526b3/index.ts#L250\n * But it's hard because of authKey:\n * In salsa20, authKey changes position in salsa stream.\n * In chacha, authKey can't be computed inside computeTag, it modifies the counter.\n */\nexport const _poly1305_aead =\n  (xorStream: XorStream) =>\n  (key: Uint8Array, nonce: Uint8Array, AAD?: Uint8Array): CipherWithOutput => {\n    const tagLength = 16;\n    ensureBytes(key, 32);\n    ensureBytes(nonce);\n    return {\n      encrypt: (plaintext: Uint8Array, output?: Uint8Array) => {\n        const plength = plaintext.length;\n        const clength = plength + tagLength;\n        if (output) {\n          ensureBytes(output, clength);\n        } else {\n          output = new Uint8Array(clength);\n        }\n        xorStream(key, nonce, plaintext, output, 1);\n        const tag = computeTag(xorStream, key, nonce, output.subarray(0, -tagLength), AAD);\n        output.set(tag, plength); // append tag\n        return output;\n      },\n      decrypt: (ciphertext: Uint8Array, output?: Uint8Array) => {\n        const clength = ciphertext.length;\n        const plength = clength - tagLength;\n        if (clength < tagLength)\n          throw new Error(`encrypted data must be at least ${tagLength} bytes`);\n        if (output) {\n          ensureBytes(output, plength);\n        } else {\n          output = new Uint8Array(plength);\n        }\n        const data = ciphertext.subarray(0, -tagLength);\n        const passedTag = ciphertext.subarray(-tagLength);\n        const tag = computeTag(xorStream, key, nonce, data, AAD);\n        if (!equalBytes(passedTag, tag)) throw new Error('invalid tag');\n        xorStream(key, nonce, data, output, 1);\n        return output;\n      },\n    };\n  };\n\n/**\n * ChaCha20-Poly1305 from RFC 8439.\n * With 12-byte nonce, it's not safe to use fill it with random (CSPRNG), due to collision chance.\n */\nexport const chacha20poly1305 = /* @__PURE__ */ wrapCipher(\n  { blockSize: 64, nonceLength: 12, tagLength: 16 },\n  _poly1305_aead(chacha20)\n);\n/**\n * XChaCha20-Poly1305 extended-nonce chacha.\n * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha\n * With 24-byte nonce, it's safe to use fill it with random (CSPRNG).\n */\nexport const xchacha20poly1305 = /* @__PURE__ */ wrapCipher(\n  { blockSize: 64, nonceLength: 24, tagLength: 16 },\n  _poly1305_aead(xchacha20)\n);\n", "import { SHA2 } from './_sha2.js';\nimport u64 from './_u64.js';\nimport { wrapConstructor } from './utils.js';\n\n// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):\n// prettier-ignore\nconst [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => u64.split([\n  '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n  '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n  '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n  '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n  '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n  '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n  '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n  '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n  '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n  '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n  '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n  '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n  '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n  '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n  '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n  '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n  '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n  '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n  '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n  '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\n\n// Temporary buffer, not used to store anything between runs\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nexport class SHA512 extends SHA2<SHA512> {\n  // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.\n  // Also looks cleaner and easier to verify with spec.\n  // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n  // h -- high 32 bits, l -- low 32 bits\n  Ah = 0x6a09e667 | 0;\n  Al = 0xf3bcc908 | 0;\n  Bh = 0xbb67ae85 | 0;\n  Bl = 0x84caa73b | 0;\n  Ch = 0x3c6ef372 | 0;\n  Cl = 0xfe94f82b | 0;\n  Dh = 0xa54ff53a | 0;\n  Dl = 0x5f1d36f1 | 0;\n  Eh = 0x510e527f | 0;\n  El = 0xade682d1 | 0;\n  Fh = 0x9b05688c | 0;\n  Fl = 0x2b3e6c1f | 0;\n  Gh = 0x1f83d9ab | 0;\n  Gl = 0xfb41bd6b | 0;\n  Hh = 0x5be0cd19 | 0;\n  Hl = 0x137e2179 | 0;\n\n  constructor() {\n    super(128, 64, 16, false);\n  }\n  // prettier-ignore\n  protected get(): [\n    number, number, number, number, number, number, number, number,\n    number, number, number, number, number, number, number, number\n  ] {\n    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n  }\n  // prettier-ignore\n  protected set(\n    Ah: number, Al: number, Bh: number, Bl: number, Ch: number, Cl: number, Dh: number, Dl: number,\n    Eh: number, El: number, Fh: number, Fl: number, Gh: number, Gl: number, Hh: number, Hl: number\n  ) {\n    this.Ah = Ah | 0;\n    this.Al = Al | 0;\n    this.Bh = Bh | 0;\n    this.Bl = Bl | 0;\n    this.Ch = Ch | 0;\n    this.Cl = Cl | 0;\n    this.Dh = Dh | 0;\n    this.Dl = Dl | 0;\n    this.Eh = Eh | 0;\n    this.El = El | 0;\n    this.Fh = Fh | 0;\n    this.Fl = Fl | 0;\n    this.Gh = Gh | 0;\n    this.Gl = Gl | 0;\n    this.Hh = Hh | 0;\n    this.Hl = Hl | 0;\n  }\n  protected process(view: DataView, offset: number) {\n    // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) {\n      SHA512_W_H[i] = view.getUint32(offset);\n      SHA512_W_L[i] = view.getUint32((offset += 4));\n    }\n    for (let i = 16; i < 80; i++) {\n      // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n      const W15h = SHA512_W_H[i - 15] | 0;\n      const W15l = SHA512_W_L[i - 15] | 0;\n      const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n      const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n      // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n      const W2h = SHA512_W_H[i - 2] | 0;\n      const W2l = SHA512_W_L[i - 2] | 0;\n      const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n      const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n      // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n      const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n      const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n      SHA512_W_H[i] = SUMh | 0;\n      SHA512_W_L[i] = SUMl | 0;\n    }\n    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    // Compression function main loop, 80 rounds\n    for (let i = 0; i < 80; i++) {\n      // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n      const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n      const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n      //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n      const CHIl = (El & Fl) ^ (~El & Gl);\n      // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n      // prettier-ignore\n      const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n      const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n      const T1l = T1ll | 0;\n      // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n      const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n      const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n      const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n      const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n      Hh = Gh | 0;\n      Hl = Gl | 0;\n      Gh = Fh | 0;\n      Gl = Fl | 0;\n      Fh = Eh | 0;\n      Fl = El | 0;\n      ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n      Dh = Ch | 0;\n      Dl = Cl | 0;\n      Ch = Bh | 0;\n      Cl = Bl | 0;\n      Bh = Ah | 0;\n      Bl = Al | 0;\n      const All = u64.add3L(T1l, sigma0l, MAJl);\n      Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n      Al = All | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n    ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n    ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n    ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n    ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n    ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n    ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n    ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n  }\n  protected roundClean() {\n    SHA512_W_H.fill(0);\n    SHA512_W_L.fill(0);\n  }\n  destroy() {\n    this.buffer.fill(0);\n    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n  }\n}\n\nclass SHA512_224 extends SHA512 {\n  // h -- high 32 bits, l -- low 32 bits\n  Ah = 0x8c3d37c8 | 0;\n  Al = 0x19544da2 | 0;\n  Bh = 0x73e19966 | 0;\n  Bl = 0x89dcd4d6 | 0;\n  Ch = 0x1dfab7ae | 0;\n  Cl = 0x32ff9c82 | 0;\n  Dh = 0x679dd514 | 0;\n  Dl = 0x582f9fcf | 0;\n  Eh = 0x0f6d2b69 | 0;\n  El = 0x7bd44da8 | 0;\n  Fh = 0x77e36f73 | 0;\n  Fl = 0x04c48942 | 0;\n  Gh = 0x3f9d85a8 | 0;\n  Gl = 0x6a1d36c8 | 0;\n  Hh = 0x1112e6ad | 0;\n  Hl = 0x91d692a1 | 0;\n\n  constructor() {\n    super();\n    this.outputLen = 28;\n  }\n}\n\nclass SHA512_256 extends SHA512 {\n  // h -- high 32 bits, l -- low 32 bits\n  Ah = 0x22312194 | 0;\n  Al = 0xfc2bf72c | 0;\n  Bh = 0x9f555fa3 | 0;\n  Bl = 0xc84c64c2 | 0;\n  Ch = 0x2393b86b | 0;\n  Cl = 0x6f53b151 | 0;\n  Dh = 0x96387719 | 0;\n  Dl = 0x5940eabd | 0;\n  Eh = 0x96283ee2 | 0;\n  El = 0xa88effe3 | 0;\n  Fh = 0xbe5e1e25 | 0;\n  Fl = 0x53863992 | 0;\n  Gh = 0x2b0199fc | 0;\n  Gl = 0x2c85b8aa | 0;\n  Hh = 0x0eb72ddc | 0;\n  Hl = 0x81c52ca2 | 0;\n\n  constructor() {\n    super();\n    this.outputLen = 32;\n  }\n}\n\nclass SHA384 extends SHA512 {\n  // h -- high 32 bits, l -- low 32 bits\n  Ah = 0xcbbb9d5d | 0;\n  Al = 0xc1059ed8 | 0;\n  Bh = 0x629a292a | 0;\n  Bl = 0x367cd507 | 0;\n  Ch = 0x9159015a | 0;\n  Cl = 0x3070dd17 | 0;\n  Dh = 0x152fecd8 | 0;\n  Dl = 0xf70e5939 | 0;\n  Eh = 0x67332667 | 0;\n  El = 0xffc00b31 | 0;\n  Fh = 0x8eb44a87 | 0;\n  Fl = 0x68581511 | 0;\n  Gh = 0xdb0c2e0d | 0;\n  Gl = 0x64f98fa7 | 0;\n  Hh = 0x47b5481d | 0;\n  Hl = 0xbefa4fa4 | 0;\n\n  constructor() {\n    super();\n    this.outputLen = 48;\n  }\n}\n\nexport const sha512 = /* @__PURE__ */ wrapConstructor(() => new SHA512());\nexport const sha512_224 = /* @__PURE__ */ wrapConstructor(() => new SHA512_224());\nexport const sha512_256 = /* @__PURE__ */ wrapConstructor(() => new SHA512_256());\nexport const sha384 = /* @__PURE__ */ wrapConstructor(() => new SHA384());\n", "/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Twisted Edwards curve. The formula is: ax² + y² = 1 + dx²y²\nimport { mod } from './modular.js';\nimport * as ut from './utils.js';\nimport { ensureBytes, FHash, Hex } from './utils.js';\nimport { Group, GroupConstructor, wNAF, BasicCurve, validateBasic, AffinePoint } from './curve.js';\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _8n = BigInt(8);\n\n// Edwards curves must declare params a & d.\nexport type CurveType = BasicCurve<bigint> & {\n  a: bigint; // curve param a\n  d: bigint; // curve param d\n  hash: FHash; // Hashing\n  randomBytes: (bytesLength?: number) => Uint8Array; // CSPRNG\n  adjustScalarBytes?: (bytes: Uint8Array) => Uint8Array; // clears bits to get valid field elemtn\n  domain?: (data: Uint8Array, ctx: Uint8Array, phflag: boolean) => Uint8Array; // Used for hashing\n  uvRatio?: (u: bigint, v: bigint) => { isValid: boolean; value: bigint }; // Ratio √(u/v)\n  prehash?: FHash; // RFC 8032 pre-hashing of messages to sign() / verify()\n  mapToCurve?: (scalar: bigint[]) => AffinePoint<bigint>; // for hash-to-curve standard\n};\n\n// verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:\nconst VERIFY_DEFAULT = { zip215: true };\n\nfunction validateOpts(curve: CurveType) {\n  const opts = validateBasic(curve);\n  ut.validateObject(\n    curve,\n    {\n      hash: 'function',\n      a: 'bigint',\n      d: 'bigint',\n      randomBytes: 'function',\n    },\n    {\n      adjustScalarBytes: 'function',\n      domain: 'function',\n      uvRatio: 'function',\n      mapToCurve: 'function',\n    }\n  );\n  // Set defaults\n  return Object.freeze({ ...opts } as const);\n}\n\n// Instance of Extended Point with coordinates in X, Y, Z, T\nexport interface ExtPointType extends Group<ExtPointType> {\n  readonly ex: bigint;\n  readonly ey: bigint;\n  readonly ez: bigint;\n  readonly et: bigint;\n  get x(): bigint;\n  get y(): bigint;\n  assertValidity(): void;\n  multiply(scalar: bigint): ExtPointType;\n  multiplyUnsafe(scalar: bigint): ExtPointType;\n  isSmallOrder(): boolean;\n  isTorsionFree(): boolean;\n  clearCofactor(): ExtPointType;\n  toAffine(iz?: bigint): AffinePoint<bigint>;\n  toRawBytes(isCompressed?: boolean): Uint8Array;\n  toHex(isCompressed?: boolean): string;\n}\n// Static methods of Extended Point with coordinates in X, Y, Z, T\nexport interface ExtPointConstructor extends GroupConstructor<ExtPointType> {\n  new (x: bigint, y: bigint, z: bigint, t: bigint): ExtPointType;\n  fromAffine(p: AffinePoint<bigint>): ExtPointType;\n  fromHex(hex: Hex): ExtPointType;\n  fromPrivateKey(privateKey: Hex): ExtPointType;\n}\n\nexport type CurveFn = {\n  CURVE: ReturnType<typeof validateOpts>;\n  getPublicKey: (privateKey: Hex) => Uint8Array;\n  sign: (message: Hex, privateKey: Hex, options?: { context?: Hex }) => Uint8Array;\n  verify: (\n    sig: Hex,\n    message: Hex,\n    publicKey: Hex,\n    options?: { context?: Hex; zip215: boolean }\n  ) => boolean;\n  ExtendedPoint: ExtPointConstructor;\n  utils: {\n    randomPrivateKey: () => Uint8Array;\n    getExtendedPublicKey: (key: Hex) => {\n      head: Uint8Array;\n      prefix: Uint8Array;\n      scalar: bigint;\n      point: ExtPointType;\n      pointBytes: Uint8Array;\n    };\n  };\n};\n\n// It is not generic twisted curve for now, but ed25519/ed448 generic implementation\nexport function twistedEdwards(curveDef: CurveType): CurveFn {\n  const CURVE = validateOpts(curveDef) as ReturnType<typeof validateOpts>;\n  const {\n    Fp,\n    n: CURVE_ORDER,\n    prehash: prehash,\n    hash: cHash,\n    randomBytes,\n    nByteLength,\n    h: cofactor,\n  } = CURVE;\n  const MASK = _2n << (BigInt(nByteLength * 8) - _1n);\n  const modP = Fp.create; // Function overrides\n\n  // sqrt(u/v)\n  const uvRatio =\n    CURVE.uvRatio ||\n    ((u: bigint, v: bigint) => {\n      try {\n        return { isValid: true, value: Fp.sqrt(u * Fp.inv(v)) };\n      } catch (e) {\n        return { isValid: false, value: _0n };\n      }\n    });\n  const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes: Uint8Array) => bytes); // NOOP\n  const domain =\n    CURVE.domain ||\n    ((data: Uint8Array, ctx: Uint8Array, phflag: boolean) => {\n      if (ctx.length || phflag) throw new Error('Contexts/pre-hash are not supported');\n      return data;\n    }); // NOOP\n  const inBig = (n: bigint) => typeof n === 'bigint' && _0n < n; // n in [1..]\n  const inRange = (n: bigint, max: bigint) => inBig(n) && inBig(max) && n < max; // n in [1..max-1]\n  const in0MaskRange = (n: bigint) => n === _0n || inRange(n, MASK); // n in [0..MASK-1]\n  function assertInRange(n: bigint, max: bigint) {\n    // n in [1..max-1]\n    if (inRange(n, max)) return n;\n    throw new Error(`Expected valid scalar < ${max}, got ${typeof n} ${n}`);\n  }\n  function assertGE0(n: bigint) {\n    // n in [0..CURVE_ORDER-1]\n    return n === _0n ? n : assertInRange(n, CURVE_ORDER); // GE = prime subgroup, not full group\n  }\n  const pointPrecomputes = new Map<Point, Point[]>();\n  function isPoint(other: unknown) {\n    if (!(other instanceof Point)) throw new Error('ExtendedPoint expected');\n  }\n  // Extended Point works in extended coordinates: (x, y, z, t) ∋ (x=x/z, y=y/z, t=xy).\n  // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates\n  class Point implements ExtPointType {\n    static readonly BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));\n    static readonly ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0\n\n    constructor(\n      readonly ex: bigint,\n      readonly ey: bigint,\n      readonly ez: bigint,\n      readonly et: bigint\n    ) {\n      if (!in0MaskRange(ex)) throw new Error('x required');\n      if (!in0MaskRange(ey)) throw new Error('y required');\n      if (!in0MaskRange(ez)) throw new Error('z required');\n      if (!in0MaskRange(et)) throw new Error('t required');\n    }\n\n    get x(): bigint {\n      return this.toAffine().x;\n    }\n    get y(): bigint {\n      return this.toAffine().y;\n    }\n\n    static fromAffine(p: AffinePoint<bigint>): Point {\n      if (p instanceof Point) throw new Error('extended point not allowed');\n      const { x, y } = p || {};\n      if (!in0MaskRange(x) || !in0MaskRange(y)) throw new Error('invalid affine point');\n      return new Point(x, y, _1n, modP(x * y));\n    }\n    static normalizeZ(points: Point[]): Point[] {\n      const toInv = Fp.invertBatch(points.map((p) => p.ez));\n      return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n    }\n\n    // We calculate precomputes for elliptic curve point multiplication\n    // using windowed method. This specifies window size and\n    // stores precomputed values. Usually only base point would be precomputed.\n    _WINDOW_SIZE?: number;\n\n    // \"Private method\", don't use it directly\n    _setWindowSize(windowSize: number) {\n      this._WINDOW_SIZE = windowSize;\n      pointPrecomputes.delete(this);\n    }\n    // Not required for fromHex(), which always creates valid points.\n    // Could be useful for fromAffine().\n    assertValidity(): void {\n      const { a, d } = CURVE;\n      if (this.is0()) throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?\n      // Equation in affine coordinates: ax² + y² = 1 + dx²y²\n      // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX² + Y²)Z² = Z⁴ + dX²Y²\n      const { ex: X, ey: Y, ez: Z, et: T } = this;\n      const X2 = modP(X * X); // X²\n      const Y2 = modP(Y * Y); // Y²\n      const Z2 = modP(Z * Z); // Z²\n      const Z4 = modP(Z2 * Z2); // Z⁴\n      const aX2 = modP(X2 * a); // aX²\n      const left = modP(Z2 * modP(aX2 + Y2)); // (aX² + Y²)Z²\n      const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z⁴ + dX²Y²\n      if (left !== right) throw new Error('bad point: equation left != right (1)');\n      // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n      const XY = modP(X * Y);\n      const ZT = modP(Z * T);\n      if (XY !== ZT) throw new Error('bad point: equation left != right (2)');\n    }\n\n    // Compare one point to another.\n    equals(other: Point): boolean {\n      isPoint(other);\n      const { ex: X1, ey: Y1, ez: Z1 } = this;\n      const { ex: X2, ey: Y2, ez: Z2 } = other;\n      const X1Z2 = modP(X1 * Z2);\n      const X2Z1 = modP(X2 * Z1);\n      const Y1Z2 = modP(Y1 * Z2);\n      const Y2Z1 = modP(Y2 * Z1);\n      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n\n    protected is0(): boolean {\n      return this.equals(Point.ZERO);\n    }\n\n    negate(): Point {\n      // Flips point sign to a negative one (-x, y in affine coords)\n      return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));\n    }\n\n    // Fast algo for doubling Extended Point.\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n    // Cost: 4M + 4S + 1*a + 6add + 1*2.\n    double(): Point {\n      const { a } = CURVE;\n      const { ex: X1, ey: Y1, ez: Z1 } = this;\n      const A = modP(X1 * X1); // A = X12\n      const B = modP(Y1 * Y1); // B = Y12\n      const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12\n      const D = modP(a * A); // D = a*A\n      const x1y1 = X1 + Y1;\n      const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B\n      const G = D + B; // G = D+B\n      const F = G - C; // F = G-C\n      const H = D - B; // H = D-B\n      const X3 = modP(E * F); // X3 = E*F\n      const Y3 = modP(G * H); // Y3 = G*H\n      const T3 = modP(E * H); // T3 = E*H\n      const Z3 = modP(F * G); // Z3 = F*G\n      return new Point(X3, Y3, Z3, T3);\n    }\n\n    // Fast algo for adding 2 Extended Points.\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n    // Cost: 9M + 1*a + 1*d + 7add.\n    add(other: Point) {\n      isPoint(other);\n      const { a, d } = CURVE;\n      const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;\n      const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;\n      // Faster algo for adding 2 Extended Points when curve's a=-1.\n      // http://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-add-2008-hwcd-4\n      // Cost: 8M + 8add + 2*2.\n      // Note: It does not check whether the `other` point is valid.\n      if (a === BigInt(-1)) {\n        const A = modP((Y1 - X1) * (Y2 + X2));\n        const B = modP((Y1 + X1) * (Y2 - X2));\n        const F = modP(B - A);\n        if (F === _0n) return this.double(); // Same point. Tests say it doesn't affect timing\n        const C = modP(Z1 * _2n * T2);\n        const D = modP(T1 * _2n * Z2);\n        const E = D + C;\n        const G = B + A;\n        const H = D - C;\n        const X3 = modP(E * F);\n        const Y3 = modP(G * H);\n        const T3 = modP(E * H);\n        const Z3 = modP(F * G);\n        return new Point(X3, Y3, Z3, T3);\n      }\n      const A = modP(X1 * X2); // A = X1*X2\n      const B = modP(Y1 * Y2); // B = Y1*Y2\n      const C = modP(T1 * d * T2); // C = T1*d*T2\n      const D = modP(Z1 * Z2); // D = Z1*Z2\n      const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B\n      const F = D - C; // F = D-C\n      const G = D + C; // G = D+C\n      const H = modP(B - a * A); // H = B-a*A\n      const X3 = modP(E * F); // X3 = E*F\n      const Y3 = modP(G * H); // Y3 = G*H\n      const T3 = modP(E * H); // T3 = E*H\n      const Z3 = modP(F * G); // Z3 = F*G\n\n      return new Point(X3, Y3, Z3, T3);\n    }\n\n    subtract(other: Point): Point {\n      return this.add(other.negate());\n    }\n\n    private wNAF(n: bigint): { p: Point; f: Point } {\n      return wnaf.wNAFCached(this, pointPrecomputes, n, Point.normalizeZ);\n    }\n\n    // Constant-time multiplication.\n    multiply(scalar: bigint): Point {\n      const { p, f } = this.wNAF(assertInRange(scalar, CURVE_ORDER));\n      return Point.normalizeZ([p, f])[0];\n    }\n\n    // Non-constant-time multiplication. Uses double-and-add algorithm.\n    // It's faster, but should only be used when you don't care about\n    // an exposed private key e.g. sig verification.\n    // Does NOT allow scalars higher than CURVE.n.\n    multiplyUnsafe(scalar: bigint): Point {\n      let n = assertGE0(scalar); // 0 <= scalar < CURVE.n\n      if (n === _0n) return I;\n      if (this.equals(I) || n === _1n) return this;\n      if (this.equals(G)) return this.wNAF(n).p;\n      return wnaf.unsafeLadder(this, n);\n    }\n\n    // Checks if point is of small order.\n    // If you add something to small order point, you will have \"dirty\"\n    // point with torsion component.\n    // Multiplies point by cofactor and checks if the result is 0.\n    isSmallOrder(): boolean {\n      return this.multiplyUnsafe(cofactor).is0();\n    }\n\n    // Multiplies point by curve order and checks if the result is 0.\n    // Returns `false` is the point is dirty.\n    isTorsionFree(): boolean {\n      return wnaf.unsafeLadder(this, CURVE_ORDER).is0();\n    }\n\n    // Converts Extended point to default (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    toAffine(iz?: bigint): AffinePoint<bigint> {\n      const { ex: x, ey: y, ez: z } = this;\n      const is0 = this.is0();\n      if (iz == null) iz = is0 ? _8n : (Fp.inv(z) as bigint); // 8 was chosen arbitrarily\n      const ax = modP(x * iz);\n      const ay = modP(y * iz);\n      const zz = modP(z * iz);\n      if (is0) return { x: _0n, y: _1n };\n      if (zz !== _1n) throw new Error('invZ was invalid');\n      return { x: ax, y: ay };\n    }\n\n    clearCofactor(): Point {\n      const { h: cofactor } = CURVE;\n      if (cofactor === _1n) return this;\n      return this.multiplyUnsafe(cofactor);\n    }\n\n    // Converts hash string or Uint8Array to Point.\n    // Uses algo from RFC8032 5.1.3.\n    static fromHex(hex: Hex, zip215 = false): Point {\n      const { d, a } = CURVE;\n      const len = Fp.BYTES;\n      hex = ensureBytes('pointHex', hex, len); // copy hex to a new array\n      const normed = hex.slice(); // copy again, we'll manipulate it\n      const lastByte = hex[len - 1]; // select last byte\n      normed[len - 1] = lastByte & ~0x80; // clear last bit\n      const y = ut.bytesToNumberLE(normed);\n      if (y === _0n) {\n        // y=0 is allowed\n      } else {\n        // RFC8032 prohibits >= p, but ZIP215 doesn't\n        if (zip215) assertInRange(y, MASK); // zip215=true [1..P-1] (2^255-19-1 for ed25519)\n        else assertInRange(y, Fp.ORDER); // zip215=false [1..MASK-1] (2^256-1 for ed25519)\n      }\n\n      // Ed25519: x² = (y²-1)/(dy²+1) mod p. Ed448: x² = (y²-1)/(dy²-1) mod p. Generic case:\n      // ax²+y²=1+dx²y² => y²-1=dx²y²-ax² => y²-1=x²(dy²-a) => x²=(y²-1)/(dy²-a)\n      const y2 = modP(y * y); // denominator is always non-0 mod p.\n      const u = modP(y2 - _1n); // u = y² - 1\n      const v = modP(d * y2 - a); // v = d y² + 1.\n      let { isValid, value: x } = uvRatio(u, v); // √(u/v)\n      if (!isValid) throw new Error('Point.fromHex: invalid y coordinate');\n      const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper\n      const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n      if (!zip215 && x === _0n && isLastByteOdd)\n        // if x=0 and x_0 = 1, fail\n        throw new Error('Point.fromHex: x=0 and x_0=1');\n      if (isLastByteOdd !== isXOdd) x = modP(-x); // if x_0 != x mod 2, set x = p-x\n      return Point.fromAffine({ x, y });\n    }\n    static fromPrivateKey(privKey: Hex) {\n      return getExtendedPublicKey(privKey).point;\n    }\n    toRawBytes(): Uint8Array {\n      const { x, y } = this.toAffine();\n      const bytes = ut.numberToBytesLE(y, Fp.BYTES); // each y has 2 x values (x, -y)\n      bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0; // when compressing, it's enough to store y\n      return bytes; // and use the last byte to encode sign of x\n    }\n    toHex(): string {\n      return ut.bytesToHex(this.toRawBytes()); // Same as toRawBytes, but returns string.\n    }\n  }\n  const { BASE: G, ZERO: I } = Point;\n  const wnaf = wNAF(Point, nByteLength * 8);\n\n  function modN(a: bigint) {\n    return mod(a, CURVE_ORDER);\n  }\n  // Little-endian SHA512 with modulo n\n  function modN_LE(hash: Uint8Array): bigint {\n    return modN(ut.bytesToNumberLE(hash));\n  }\n\n  /** Convenience method that creates public key and other stuff. RFC8032 5.1.5 */\n  function getExtendedPublicKey(key: Hex) {\n    const len = nByteLength;\n    key = ensureBytes('private key', key, len);\n    // Hash private key with curve's hash function to produce uniformingly random input\n    // Check byte lengths: ensure(64, h(ensure(32, key)))\n    const hashed = ensureBytes('hashed private key', cHash(key), 2 * len);\n    const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE\n    const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)\n    const scalar = modN_LE(head); // The actual private scalar\n    const point = G.multiply(scalar); // Point on Edwards curve aka public key\n    const pointBytes = point.toRawBytes(); // Uint8Array representation\n    return { head, prefix, scalar, point, pointBytes };\n  }\n\n  // Calculates EdDSA pub key. RFC8032 5.1.5. Privkey is hashed. Use first half with 3 bits cleared\n  function getPublicKey(privKey: Hex): Uint8Array {\n    return getExtendedPublicKey(privKey).pointBytes;\n  }\n\n  // int('LE', SHA512(dom2(F, C) || msgs)) mod N\n  function hashDomainToScalar(context: Hex = new Uint8Array(), ...msgs: Uint8Array[]) {\n    const msg = ut.concatBytes(...msgs);\n    return modN_LE(cHash(domain(msg, ensureBytes('context', context), !!prehash)));\n  }\n\n  /** Signs message with privateKey. RFC8032 5.1.6 */\n  function sign(msg: Hex, privKey: Hex, options: { context?: Hex } = {}): Uint8Array {\n    msg = ensureBytes('message', msg);\n    if (prehash) msg = prehash(msg); // for ed25519ph etc.\n    const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);\n    const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)\n    const R = G.multiply(r).toRawBytes(); // R = rG\n    const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)\n    const s = modN(r + k * scalar); // S = (r + k * s) mod L\n    assertGE0(s); // 0 <= s < l\n    const res = ut.concatBytes(R, ut.numberToBytesLE(s, Fp.BYTES));\n    return ensureBytes('result', res, nByteLength * 2); // 64-byte signature\n  }\n\n  const verifyOpts: { context?: Hex; zip215?: boolean } = VERIFY_DEFAULT;\n  function verify(sig: Hex, msg: Hex, publicKey: Hex, options = verifyOpts): boolean {\n    const { context, zip215 } = options;\n    const len = Fp.BYTES; // Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n    sig = ensureBytes('signature', sig, 2 * len); // An extended group equation is checked.\n    msg = ensureBytes('message', msg);\n    if (prehash) msg = prehash(msg); // for ed25519ph, etc\n\n    const s = ut.bytesToNumberLE(sig.slice(len, 2 * len));\n    // zip215: true is good for consensus-critical apps and allows points < 2^256\n    // zip215: false follows RFC8032 / NIST186-5 and restricts points to CURVE.p\n    let A, R, SB;\n    try {\n      A = Point.fromHex(publicKey, zip215);\n      R = Point.fromHex(sig.slice(0, len), zip215);\n      SB = G.multiplyUnsafe(s); // 0 <= s < l is done inside\n    } catch (error) {\n      return false;\n    }\n    if (!zip215 && A.isSmallOrder()) return false;\n\n    const k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);\n    const RkA = R.add(A.multiplyUnsafe(k));\n    // [8][S]B = [8]R + [8][k]A'\n    return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);\n  }\n\n  G._setWindowSize(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n\n  const utils = {\n    getExtendedPublicKey,\n    // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.\n    randomPrivateKey: (): Uint8Array => randomBytes(Fp.BYTES),\n\n    /**\n     * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT\n     * values. This slows down first getPublicKey() by milliseconds (see Speed section),\n     * but allows to speed-up subsequent getPublicKey() calls up to 20x.\n     * @param windowSize 2, 4, 8, 16\n     */\n    precompute(windowSize = 8, point = Point.BASE): typeof Point.BASE {\n      point._setWindowSize(windowSize);\n      point.multiply(BigInt(3));\n      return point;\n    },\n  };\n\n  return {\n    CURVE,\n    getPublicKey,\n    sign,\n    verify,\n    ExtendedPoint: Point,\n    utils,\n  };\n}\n", "/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { mod, pow } from './modular.js';\nimport { bytesToNumberLE, ensureBytes, numberToBytesLE, validateObject } from './utils.js';\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\ntype Hex = string | Uint8Array;\n\nexport type CurveType = {\n  P: bigint; // finite field prime\n  nByteLength: number;\n  adjustScalarBytes?: (bytes: Uint8Array) => Uint8Array;\n  domain?: (data: Uint8Array, ctx: Uint8Array, phflag: boolean) => Uint8Array;\n  a: bigint;\n  montgomeryBits: number;\n  powPminus2?: (x: bigint) => bigint;\n  xyToU?: (x: bigint, y: bigint) => bigint;\n  Gu: bigint;\n  randomBytes?: (bytesLength?: number) => Uint8Array;\n};\nexport type CurveFn = {\n  scalarMult: (scalar: Hex, u: Hex) => Uint8Array;\n  scalarMultBase: (scalar: Hex) => Uint8Array;\n  getSharedSecret: (privateKeyA: Hex, publicKeyB: Hex) => Uint8Array;\n  getPublicKey: (privateKey: Hex) => Uint8Array;\n  utils: { randomPrivateKey: () => Uint8Array };\n  GuBytes: Uint8Array;\n};\n\nfunction validateOpts(curve: CurveType) {\n  validateObject(\n    curve,\n    {\n      a: 'bigint',\n    },\n    {\n      montgomeryBits: 'isSafeInteger',\n      nByteLength: 'isSafeInteger',\n      adjustScalarBytes: 'function',\n      domain: 'function',\n      powPminus2: 'function',\n      Gu: 'bigint',\n    }\n  );\n  // Set defaults\n  return Object.freeze({ ...curve } as const);\n}\n\n// NOTE: not really montgomery curve, just bunch of very specific methods for X25519/X448 (RFC 7748, https://www.rfc-editor.org/rfc/rfc7748)\n// Uses only one coordinate instead of two\nexport function montgomery(curveDef: CurveType): CurveFn {\n  const CURVE = validateOpts(curveDef);\n  const { P } = CURVE;\n  const modP = (n: bigint) => mod(n, P);\n  const montgomeryBits = CURVE.montgomeryBits;\n  const montgomeryBytes = Math.ceil(montgomeryBits / 8);\n  const fieldLen = CURVE.nByteLength;\n  const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes: Uint8Array) => bytes);\n  const powPminus2 = CURVE.powPminus2 || ((x: bigint) => pow(x, P - BigInt(2), P));\n\n  // cswap from RFC7748. But it is not from RFC7748!\n  /*\n    cswap(swap, x_2, x_3):\n         dummy = mask(swap) AND (x_2 XOR x_3)\n         x_2 = x_2 XOR dummy\n         x_3 = x_3 XOR dummy\n         Return (x_2, x_3)\n  Where mask(swap) is the all-1 or all-0 word of the same length as x_2\n   and x_3, computed, e.g., as mask(swap) = 0 - swap.\n  */\n  function cswap(swap: bigint, x_2: bigint, x_3: bigint): [bigint, bigint] {\n    const dummy = modP(swap * (x_2 - x_3));\n    x_2 = modP(x_2 - dummy);\n    x_3 = modP(x_3 + dummy);\n    return [x_2, x_3];\n  }\n\n  // Accepts 0 as well\n  function assertFieldElement(n: bigint): bigint {\n    if (typeof n === 'bigint' && _0n <= n && n < P) return n;\n    throw new Error('Expected valid scalar 0 < scalar < CURVE.P');\n  }\n\n  // x25519 from 4\n  // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519\n  const a24 = (CURVE.a - BigInt(2)) / BigInt(4);\n  /**\n   *\n   * @param pointU u coordinate (x) on Montgomery Curve 25519\n   * @param scalar by which the point would be multiplied\n   * @returns new Point on Montgomery curve\n   */\n  function montgomeryLadder(pointU: bigint, scalar: bigint): bigint {\n    const u = assertFieldElement(pointU);\n    // Section 5: Implementations MUST accept non-canonical values and process them as\n    // if they had been reduced modulo the field prime.\n    const k = assertFieldElement(scalar);\n    const x_1 = u;\n    let x_2 = _1n;\n    let z_2 = _0n;\n    let x_3 = u;\n    let z_3 = _1n;\n    let swap = _0n;\n    let sw: [bigint, bigint];\n    for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {\n      const k_t = (k >> t) & _1n;\n      swap ^= k_t;\n      sw = cswap(swap, x_2, x_3);\n      x_2 = sw[0];\n      x_3 = sw[1];\n      sw = cswap(swap, z_2, z_3);\n      z_2 = sw[0];\n      z_3 = sw[1];\n      swap = k_t;\n\n      const A = x_2 + z_2;\n      const AA = modP(A * A);\n      const B = x_2 - z_2;\n      const BB = modP(B * B);\n      const E = AA - BB;\n      const C = x_3 + z_3;\n      const D = x_3 - z_3;\n      const DA = modP(D * A);\n      const CB = modP(C * B);\n      const dacb = DA + CB;\n      const da_cb = DA - CB;\n      x_3 = modP(dacb * dacb);\n      z_3 = modP(x_1 * modP(da_cb * da_cb));\n      x_2 = modP(AA * BB);\n      z_2 = modP(E * (AA + modP(a24 * E)));\n    }\n    // (x_2, x_3) = cswap(swap, x_2, x_3)\n    sw = cswap(swap, x_2, x_3);\n    x_2 = sw[0];\n    x_3 = sw[1];\n    // (z_2, z_3) = cswap(swap, z_2, z_3)\n    sw = cswap(swap, z_2, z_3);\n    z_2 = sw[0];\n    z_3 = sw[1];\n    // z_2^(p - 2)\n    const z2 = powPminus2(z_2);\n    // Return x_2 * (z_2^(p - 2))\n    return modP(x_2 * z2);\n  }\n\n  function encodeUCoordinate(u: bigint): Uint8Array {\n    return numberToBytesLE(modP(u), montgomeryBytes);\n  }\n\n  function decodeUCoordinate(uEnc: Hex): bigint {\n    // Section 5: When receiving such an array, implementations of X25519\n    // MUST mask the most significant bit in the final byte.\n    // This is very ugly way, but it works because fieldLen-1 is outside of bounds for X448, so this becomes NOOP\n    // fieldLen - scalaryBytes = 1 for X448 and = 0 for X25519\n    const u = ensureBytes('u coordinate', uEnc, montgomeryBytes);\n    // u[fieldLen-1] crashes QuickJS (TypeError: out-of-bound numeric index)\n    if (fieldLen === montgomeryBytes) u[fieldLen - 1] &= 127; // 0b0111_1111\n    return bytesToNumberLE(u);\n  }\n  function decodeScalar(n: Hex): bigint {\n    const bytes = ensureBytes('scalar', n);\n    if (bytes.length !== montgomeryBytes && bytes.length !== fieldLen)\n      throw new Error(`Expected ${montgomeryBytes} or ${fieldLen} bytes, got ${bytes.length}`);\n    return bytesToNumberLE(adjustScalarBytes(bytes));\n  }\n  function scalarMult(scalar: Hex, u: Hex): Uint8Array {\n    const pointU = decodeUCoordinate(u);\n    const _scalar = decodeScalar(scalar);\n    const pu = montgomeryLadder(pointU, _scalar);\n    // The result was not contributory\n    // https://cr.yp.to/ecdh.html#validate\n    if (pu === _0n) throw new Error('Invalid private or public key received');\n    return encodeUCoordinate(pu);\n  }\n  // Computes public key from private. By doing scalar multiplication of base point.\n  const GuBytes = encodeUCoordinate(CURVE.Gu);\n  function scalarMultBase(scalar: Hex): Uint8Array {\n    return scalarMult(scalar, GuBytes);\n  }\n\n  return {\n    scalarMult,\n    scalarMultBase,\n    getSharedSecret: (privateKey: Hex, publicKey: Hex) => scalarMult(privateKey, publicKey),\n    getPublicKey: (privateKey: Hex): Uint8Array => scalarMultBase(privateKey),\n    utils: { randomPrivateKey: () => CURVE.randomBytes!(CURVE.nByteLength) },\n    GuBytes: GuBytes,\n  };\n}\n", "/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha512 } from '@noble/hashes/sha512';\nimport { concatBytes, randomBytes, utf8ToBytes } from '@noble/hashes/utils';\nimport { ExtPointType, twistedEdwards } from './abstract/edwards.js';\nimport { montgomery } from './abstract/montgomery.js';\nimport { Field, FpSqrtEven, isNegativeLE, mod, pow2 } from './abstract/modular.js';\nimport {\n  bytesToHex,\n  bytesToNumberLE,\n  ensureBytes,\n  equalBytes,\n  Hex,\n  numberToBytesLE,\n} from './abstract/utils.js';\nimport { createHasher, htfBasicOpts, expand_message_xmd } from './abstract/hash-to-curve.js';\nimport { AffinePoint } from './abstract/curve.js';\n\n/**\n * ed25519 Twisted Edwards curve with following addons:\n * - X25519 ECDH\n * - Ristretto cofactor elimination\n * - Elligator hash-to-group / point indistinguishability\n */\n\nconst ED25519_P = BigInt(\n  '57896044618658097711785492504343953926634992332820282019728792003956564819949'\n);\n// √(-1) aka √(a) aka 2^((p-1)/4)\nconst ED25519_SQRT_M1 = BigInt(\n  '19681161376707505956807079304988542015446066515923890162744021073123829784752'\n);\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _5n = BigInt(5);\n// prettier-ignore\nconst _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);\n\nfunction ed25519_pow_2_252_3(x: bigint) {\n  const P = ED25519_P;\n  const x2 = (x * x) % P;\n  const b2 = (x2 * x) % P; // x^3, 11\n  const b4 = (pow2(b2, _2n, P) * b2) % P; // x^15, 1111\n  const b5 = (pow2(b4, _1n, P) * x) % P; // x^31\n  const b10 = (pow2(b5, _5n, P) * b5) % P;\n  const b20 = (pow2(b10, _10n, P) * b10) % P;\n  const b40 = (pow2(b20, _20n, P) * b20) % P;\n  const b80 = (pow2(b40, _40n, P) * b40) % P;\n  const b160 = (pow2(b80, _80n, P) * b80) % P;\n  const b240 = (pow2(b160, _80n, P) * b80) % P;\n  const b250 = (pow2(b240, _10n, P) * b10) % P;\n  const pow_p_5_8 = (pow2(b250, _2n, P) * x) % P;\n  // ^ To pow to (p+3)/8, multiply it by x.\n  return { pow_p_5_8, b2 };\n}\n\nfunction adjustScalarBytes(bytes: Uint8Array): Uint8Array {\n  // Section 5: For X25519, in order to decode 32 random bytes as an integer scalar,\n  // set the three least significant bits of the first byte\n  bytes[0] &= 248; // 0b1111_1000\n  // and the most significant bit of the last to zero,\n  bytes[31] &= 127; // 0b0111_1111\n  // set the second most significant bit of the last byte to 1\n  bytes[31] |= 64; // 0b0100_0000\n  return bytes;\n}\n\n// sqrt(u/v)\nfunction uvRatio(u: bigint, v: bigint): { isValid: boolean; value: bigint } {\n  const P = ED25519_P;\n  const v3 = mod(v * v * v, P); // v³\n  const v7 = mod(v3 * v3 * v, P); // v⁷\n  // (p+3)/8 and (p-5)/8\n  const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;\n  let x = mod(u * v3 * pow, P); // (uv³)(uv⁷)^(p-5)/8\n  const vx2 = mod(v * x * x, P); // vx²\n  const root1 = x; // First root candidate\n  const root2 = mod(x * ED25519_SQRT_M1, P); // Second root candidate\n  const useRoot1 = vx2 === u; // If vx² = u (mod p), x is a square root\n  const useRoot2 = vx2 === mod(-u, P); // If vx² = -u, set x <-- x * 2^((p-1)/4)\n  const noRoot = vx2 === mod(-u * ED25519_SQRT_M1, P); // There is no valid root, vx² = -u√(-1)\n  if (useRoot1) x = root1;\n  if (useRoot2 || noRoot) x = root2; // We return root2 anyway, for const-time\n  if (isNegativeLE(x, P)) x = mod(-x, P);\n  return { isValid: useRoot1 || useRoot2, value: x };\n}\n\n// Just in case\nexport const ED25519_TORSION_SUBGROUP = [\n  '0100000000000000000000000000000000000000000000000000000000000000',\n  'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',\n  '0000000000000000000000000000000000000000000000000000000000000080',\n  '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',\n  'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',\n  '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',\n  '0000000000000000000000000000000000000000000000000000000000000000',\n  'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa',\n];\n\nconst Fp = Field(ED25519_P, undefined, true);\n\nconst ed25519Defaults = {\n  // Param: a\n  a: BigInt(-1), // Fp.create(-1) is proper; our way still works and is faster\n  // d is equal to -121665/121666 over finite field.\n  // Negative number is P - number, and division is invert(number, P)\n  d: BigInt('37095705934669439343138083508754565189542113879843219016388785533085940283555'),\n  // Finite field 𝔽p over which we'll do calculations; 2n**255n - 19n\n  Fp,\n  // Subgroup order: how many points curve has\n  // 2n**252n + 27742317777372353535851937790883648493n;\n  n: BigInt('7237005577332262213973186563042994240857116359379907606001950938285454250989'),\n  // Cofactor\n  h: BigInt(8),\n  // Base point (x, y) aka generator point\n  Gx: BigInt('15112221349535400772501151409588531511454012693041857206046113283949847762202'),\n  Gy: BigInt('46316835694926478169428394003475163141307993866256225615783033603165251855960'),\n  hash: sha512,\n  randomBytes,\n  adjustScalarBytes,\n  // dom2\n  // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.\n  // Constant-time, u/√v\n  uvRatio,\n} as const;\n\nexport const ed25519 = /* @__PURE__ */ twistedEdwards(ed25519Defaults);\n\nfunction ed25519_domain(data: Uint8Array, ctx: Uint8Array, phflag: boolean) {\n  if (ctx.length > 255) throw new Error('Context is too big');\n  return concatBytes(\n    utf8ToBytes('SigEd25519 no Ed25519 collisions'),\n    new Uint8Array([phflag ? 1 : 0, ctx.length]),\n    ctx,\n    data\n  );\n}\n\nexport const ed25519ctx = /* @__PURE__ */ twistedEdwards({\n  ...ed25519Defaults,\n  domain: ed25519_domain,\n});\nexport const ed25519ph = /* @__PURE__ */ twistedEdwards({\n  ...ed25519Defaults,\n  domain: ed25519_domain,\n  prehash: sha512,\n});\n\nexport const x25519 = /* @__PURE__ */ (() =>\n  montgomery({\n    P: ED25519_P,\n    a: BigInt(486662),\n    montgomeryBits: 255, // n is 253 bits\n    nByteLength: 32,\n    Gu: BigInt(9),\n    powPminus2: (x: bigint): bigint => {\n      const P = ED25519_P;\n      // x^(p-2) aka x^(2^255-21)\n      const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);\n      return mod(pow2(pow_p_5_8, BigInt(3), P) * b2, P);\n    },\n    adjustScalarBytes,\n    randomBytes,\n  }))();\n\n/**\n * Converts ed25519 public key to x25519 public key. Uses formula:\n * * `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`\n * * `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`\n * @example\n *   const someonesPub = ed25519.getPublicKey(ed25519.utils.randomPrivateKey());\n *   const aPriv = x25519.utils.randomPrivateKey();\n *   x25519.getSharedSecret(aPriv, edwardsToMontgomeryPub(someonesPub))\n */\nexport function edwardsToMontgomeryPub(edwardsPub: Hex): Uint8Array {\n  const { y } = ed25519.ExtendedPoint.fromHex(edwardsPub);\n  const _1n = BigInt(1);\n  return Fp.toBytes(Fp.create((_1n + y) * Fp.inv(_1n - y)));\n}\nexport const edwardsToMontgomery = edwardsToMontgomeryPub; // deprecated\n\n/**\n * Converts ed25519 secret key to x25519 secret key.\n * @example\n *   const someonesPub = x25519.getPublicKey(x25519.utils.randomPrivateKey());\n *   const aPriv = ed25519.utils.randomPrivateKey();\n *   x25519.getSharedSecret(edwardsToMontgomeryPriv(aPriv), someonesPub)\n */\nexport function edwardsToMontgomeryPriv(edwardsPriv: Uint8Array): Uint8Array {\n  const hashed = ed25519Defaults.hash(edwardsPriv.subarray(0, 32));\n  return ed25519Defaults.adjustScalarBytes(hashed).subarray(0, 32);\n}\n\n// Hash To Curve Elligator2 Map (NOTE: different from ristretto255 elligator)\n// NOTE: very important part is usage of FpSqrtEven for ELL2_C1_EDWARDS, since\n// SageMath returns different root first and everything falls apart\n\nconst ELL2_C1 = (Fp.ORDER + BigInt(3)) / BigInt(8); // 1. c1 = (q + 3) / 8       # Integer arithmetic\n\nconst ELL2_C2 = Fp.pow(_2n, ELL2_C1); // 2. c2 = 2^c1\nconst ELL2_C3 = Fp.sqrt(Fp.neg(Fp.ONE)); // 3. c3 = sqrt(-1)\nconst ELL2_C4 = (Fp.ORDER - BigInt(5)) / BigInt(8); // 4. c4 = (q - 5) / 8       # Integer arithmetic\nconst ELL2_J = BigInt(486662);\n\n// prettier-ignore\nfunction map_to_curve_elligator2_curve25519(u: bigint) {\n  let tv1 = Fp.sqr(u);       //  1.  tv1 = u^2\n  tv1 = Fp.mul(tv1, _2n);       //  2.  tv1 = 2 * tv1\n  let xd = Fp.add(tv1, Fp.ONE); //  3.   xd = tv1 + 1         # Nonzero: -1 is square (mod p), tv1 is not\n  let x1n = Fp.neg(ELL2_J);  //  4.  x1n = -J              # x1 = x1n / xd = -J / (1 + 2 * u^2)\n  let tv2 = Fp.sqr(xd);      //  5.  tv2 = xd^2\n  let gxd = Fp.mul(tv2, xd);    //  6.  gxd = tv2 * xd        # gxd = xd^3\n  let gx1 = Fp.mul(tv1, ELL2_J); //  7.  gx1 = J * tv1         # x1n + J * xd\n  gx1 = Fp.mul(gx1, x1n);       //  8.  gx1 = gx1 * x1n       # x1n^2 + J * x1n * xd\n  gx1 = Fp.add(gx1, tv2);       //  9.  gx1 = gx1 + tv2       # x1n^2 + J * x1n * xd + xd^2\n  gx1 = Fp.mul(gx1, x1n);       //  10. gx1 = gx1 * x1n       # x1n^3 + J * x1n^2 * xd + x1n * xd^2\n  let tv3 = Fp.sqr(gxd);     //  11. tv3 = gxd^2\n  tv2 = Fp.sqr(tv3);         //  12. tv2 = tv3^2           # gxd^4\n  tv3 = Fp.mul(tv3, gxd);       //  13. tv3 = tv3 * gxd       # gxd^3\n  tv3 = Fp.mul(tv3, gx1);       //  14. tv3 = tv3 * gx1       # gx1 * gxd^3\n  tv2 = Fp.mul(tv2, tv3);       //  15. tv2 = tv2 * tv3       # gx1 * gxd^7\n  let y11 = Fp.pow(tv2, ELL2_C4); //  16. y11 = tv2^c4        # (gx1 * gxd^7)^((p - 5) / 8)\n  y11 = Fp.mul(y11, tv3);       //  17. y11 = y11 * tv3       # gx1*gxd^3*(gx1*gxd^7)^((p-5)/8)\n  let y12 = Fp.mul(y11, ELL2_C3); //  18. y12 = y11 * c3\n  tv2 = Fp.sqr(y11);         //  19. tv2 = y11^2\n  tv2 = Fp.mul(tv2, gxd);       //  20. tv2 = tv2 * gxd\n  let e1 = Fp.eql(tv2, gx1); //  21.  e1 = tv2 == gx1\n  let y1 = Fp.cmov(y12, y11, e1); //  22.  y1 = CMOV(y12, y11, e1)  # If g(x1) is square, this is its sqrt\n  let x2n = Fp.mul(x1n, tv1);   //  23. x2n = x1n * tv1       # x2 = x2n / xd = 2 * u^2 * x1n / xd\n  let y21 = Fp.mul(y11, u);     //  24. y21 = y11 * u\n  y21 = Fp.mul(y21, ELL2_C2);   //  25. y21 = y21 * c2\n  let y22 = Fp.mul(y21, ELL2_C3); //  26. y22 = y21 * c3\n  let gx2 = Fp.mul(gx1, tv1);   //  27. gx2 = gx1 * tv1       # g(x2) = gx2 / gxd = 2 * u^2 * g(x1)\n  tv2 = Fp.sqr(y21);         //  28. tv2 = y21^2\n  tv2 = Fp.mul(tv2, gxd);       //  29. tv2 = tv2 * gxd\n  let e2 = Fp.eql(tv2, gx2); //  30.  e2 = tv2 == gx2\n  let y2 = Fp.cmov(y22, y21, e2); //  31.  y2 = CMOV(y22, y21, e2)  # If g(x2) is square, this is its sqrt\n  tv2 = Fp.sqr(y1);          //  32. tv2 = y1^2\n  tv2 = Fp.mul(tv2, gxd);       //  33. tv2 = tv2 * gxd\n  let e3 = Fp.eql(tv2, gx1); //  34.  e3 = tv2 == gx1\n  let xn = Fp.cmov(x2n, x1n, e3); //  35.  xn = CMOV(x2n, x1n, e3)  # If e3, x = x1, else x = x2\n  let y = Fp.cmov(y2, y1, e3);  //  36.   y = CMOV(y2, y1, e3)    # If e3, y = y1, else y = y2\n  let e4 = Fp.isOdd(y);         //  37.  e4 = sgn0(y) == 1        # Fix sign of y\n  y = Fp.cmov(y, Fp.neg(y), e3 !== e4); //  38.   y = CMOV(y, -y, e3 XOR e4)\n  return { xMn: xn, xMd: xd, yMn: y, yMd: _1n }; //  39. return (xn, xd, y, 1)\n}\n\nconst ELL2_C1_EDWARDS = FpSqrtEven(Fp, Fp.neg(BigInt(486664))); // sgn0(c1) MUST equal 0\nfunction map_to_curve_elligator2_edwards25519(u: bigint) {\n  const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u); //  1.  (xMn, xMd, yMn, yMd) =\n  // map_to_curve_elligator2_curve25519(u)\n  let xn = Fp.mul(xMn, yMd); //  2.  xn = xMn * yMd\n  xn = Fp.mul(xn, ELL2_C1_EDWARDS); //  3.  xn = xn * c1\n  let xd = Fp.mul(xMd, yMn); //  4.  xd = xMd * yMn    # xn / xd = c1 * xM / yM\n  let yn = Fp.sub(xMn, xMd); //  5.  yn = xMn - xMd\n  let yd = Fp.add(xMn, xMd); //  6.  yd = xMn + xMd    # (n / d - 1) / (n / d + 1) = (n - d) / (n + d)\n  let tv1 = Fp.mul(xd, yd); //  7. tv1 = xd * yd\n  let e = Fp.eql(tv1, Fp.ZERO); //  8.   e = tv1 == 0\n  xn = Fp.cmov(xn, Fp.ZERO, e); //  9.  xn = CMOV(xn, 0, e)\n  xd = Fp.cmov(xd, Fp.ONE, e); //  10. xd = CMOV(xd, 1, e)\n  yn = Fp.cmov(yn, Fp.ONE, e); //  11. yn = CMOV(yn, 1, e)\n  yd = Fp.cmov(yd, Fp.ONE, e); //  12. yd = CMOV(yd, 1, e)\n\n  const inv = Fp.invertBatch([xd, yd]); // batch division\n  return { x: Fp.mul(xn, inv[0]), y: Fp.mul(yn, inv[1]) }; //  13. return (xn, xd, yn, yd)\n}\n\nconst htf = /* @__PURE__ */ (() =>\n  createHasher(\n    ed25519.ExtendedPoint,\n    (scalars: bigint[]) => map_to_curve_elligator2_edwards25519(scalars[0]),\n    {\n      DST: 'edwards25519_XMD:SHA-512_ELL2_RO_',\n      encodeDST: 'edwards25519_XMD:SHA-512_ELL2_NU_',\n      p: Fp.ORDER,\n      m: 1,\n      k: 128,\n      expand: 'xmd',\n      hash: sha512,\n    }\n  ))();\nexport const hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();\nexport const encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();\n\nfunction assertRstPoint(other: unknown) {\n  if (!(other instanceof RistPoint)) throw new Error('RistrettoPoint expected');\n}\n\n// √(-1) aka √(a) aka 2^((p-1)/4)\nconst SQRT_M1 = ED25519_SQRT_M1;\n// √(ad - 1)\nconst SQRT_AD_MINUS_ONE = BigInt(\n  '25063068953384623474111414158702152701244531502492656460079210482610430750235'\n);\n// 1 / √(a-d)\nconst INVSQRT_A_MINUS_D = BigInt(\n  '54469307008909316920995813868745141605393597292927456921205312896311721017578'\n);\n// 1-d²\nconst ONE_MINUS_D_SQ = BigInt(\n  '1159843021668779879193775521855586647937357759715417654439879720876111806838'\n);\n// (d-1)²\nconst D_MINUS_ONE_SQ = BigInt(\n  '40440834346308536858101042469323190826248399146238708352240133220865137265952'\n);\n// Calculates 1/√(number)\nconst invertSqrt = (number: bigint) => uvRatio(_1n, number);\n\nconst MAX_255B = BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');\nconst bytes255ToNumberLE = (bytes: Uint8Array) =>\n  ed25519.CURVE.Fp.create(bytesToNumberLE(bytes) & MAX_255B);\n\ntype ExtendedPoint = ExtPointType;\n\n// Computes Elligator map for Ristretto\n// https://ristretto.group/formulas/elligator.html\nfunction calcElligatorRistrettoMap(r0: bigint): ExtendedPoint {\n  const { d } = ed25519.CURVE;\n  const P = ed25519.CURVE.Fp.ORDER;\n  const mod = ed25519.CURVE.Fp.create;\n  const r = mod(SQRT_M1 * r0 * r0); // 1\n  const Ns = mod((r + _1n) * ONE_MINUS_D_SQ); // 2\n  let c = BigInt(-1); // 3\n  const D = mod((c - d * r) * mod(r + d)); // 4\n  let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D); // 5\n  let s_ = mod(s * r0); // 6\n  if (!isNegativeLE(s_, P)) s_ = mod(-s_);\n  if (!Ns_D_is_sq) s = s_; // 7\n  if (!Ns_D_is_sq) c = r; // 8\n  const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D); // 9\n  const s2 = s * s;\n  const W0 = mod((s + s) * D); // 10\n  const W1 = mod(Nt * SQRT_AD_MINUS_ONE); // 11\n  const W2 = mod(_1n - s2); // 12\n  const W3 = mod(_1n + s2); // 13\n  return new ed25519.ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n}\n\n/**\n * Each ed25519/ExtendedPoint has 8 different equivalent points. This can be\n * a source of bugs for protocols like ring signatures. Ristretto was created to solve this.\n * Ristretto point operates in X:Y:Z:T extended coordinates like ExtendedPoint,\n * but it should work in its own namespace: do not combine those two.\n * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-ristretto255-decaf448\n */\nclass RistPoint {\n  static BASE: RistPoint;\n  static ZERO: RistPoint;\n  // Private property to discourage combining ExtendedPoint + RistrettoPoint\n  // Always use Ristretto encoding/decoding instead.\n  constructor(private readonly ep: ExtendedPoint) {}\n\n  static fromAffine(ap: AffinePoint<bigint>) {\n    return new RistPoint(ed25519.ExtendedPoint.fromAffine(ap));\n  }\n\n  /**\n   * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.\n   * The hash-to-group operation applies Elligator twice and adds the results.\n   * **Note:** this is one-way map, there is no conversion from point to hash.\n   * https://ristretto.group/formulas/elligator.html\n   * @param hex 64-byte output of a hash function\n   */\n  static hashToCurve(hex: Hex): RistPoint {\n    hex = ensureBytes('ristrettoHash', hex, 64);\n    const r1 = bytes255ToNumberLE(hex.slice(0, 32));\n    const R1 = calcElligatorRistrettoMap(r1);\n    const r2 = bytes255ToNumberLE(hex.slice(32, 64));\n    const R2 = calcElligatorRistrettoMap(r2);\n    return new RistPoint(R1.add(R2));\n  }\n\n  /**\n   * Converts ristretto-encoded string to ristretto point.\n   * https://ristretto.group/formulas/decoding.html\n   * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding\n   */\n  static fromHex(hex: Hex): RistPoint {\n    hex = ensureBytes('ristrettoHex', hex, 32);\n    const { a, d } = ed25519.CURVE;\n    const P = ed25519.CURVE.Fp.ORDER;\n    const mod = ed25519.CURVE.Fp.create;\n    const emsg = 'RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint';\n    const s = bytes255ToNumberLE(hex);\n    // 1. Check that s_bytes is the canonical encoding of a field element, or else abort.\n    // 3. Check that s is non-negative, or else abort\n    if (!equalBytes(numberToBytesLE(s, 32), hex) || isNegativeLE(s, P)) throw new Error(emsg);\n    const s2 = mod(s * s);\n    const u1 = mod(_1n + a * s2); // 4 (a is -1)\n    const u2 = mod(_1n - a * s2); // 5\n    const u1_2 = mod(u1 * u1);\n    const u2_2 = mod(u2 * u2);\n    const v = mod(a * d * u1_2 - u2_2); // 6\n    const { isValid, value: I } = invertSqrt(mod(v * u2_2)); // 7\n    const Dx = mod(I * u2); // 8\n    const Dy = mod(I * Dx * v); // 9\n    let x = mod((s + s) * Dx); // 10\n    if (isNegativeLE(x, P)) x = mod(-x); // 10\n    const y = mod(u1 * Dy); // 11\n    const t = mod(x * y); // 12\n    if (!isValid || isNegativeLE(t, P) || y === _0n) throw new Error(emsg);\n    return new RistPoint(new ed25519.ExtendedPoint(x, y, _1n, t));\n  }\n\n  /**\n   * Encodes ristretto point to Uint8Array.\n   * https://ristretto.group/formulas/encoding.html\n   */\n  toRawBytes(): Uint8Array {\n    let { ex: x, ey: y, ez: z, et: t } = this.ep;\n    const P = ed25519.CURVE.Fp.ORDER;\n    const mod = ed25519.CURVE.Fp.create;\n    const u1 = mod(mod(z + y) * mod(z - y)); // 1\n    const u2 = mod(x * y); // 2\n    // Square root always exists\n    const u2sq = mod(u2 * u2);\n    const { value: invsqrt } = invertSqrt(mod(u1 * u2sq)); // 3\n    const D1 = mod(invsqrt * u1); // 4\n    const D2 = mod(invsqrt * u2); // 5\n    const zInv = mod(D1 * D2 * t); // 6\n    let D: bigint; // 7\n    if (isNegativeLE(t * zInv, P)) {\n      let _x = mod(y * SQRT_M1);\n      let _y = mod(x * SQRT_M1);\n      x = _x;\n      y = _y;\n      D = mod(D1 * INVSQRT_A_MINUS_D);\n    } else {\n      D = D2; // 8\n    }\n    if (isNegativeLE(x * zInv, P)) y = mod(-y); // 9\n    let s = mod((z - y) * D); // 10 (check footer's note, no sqrt(-a))\n    if (isNegativeLE(s, P)) s = mod(-s);\n    return numberToBytesLE(s, 32); // 11\n  }\n\n  toHex(): string {\n    return bytesToHex(this.toRawBytes());\n  }\n\n  toString(): string {\n    return this.toHex();\n  }\n\n  // Compare one point to another.\n  equals(other: RistPoint): boolean {\n    assertRstPoint(other);\n    const { ex: X1, ey: Y1 } = this.ep;\n    const { ex: X2, ey: Y2 } = other.ep;\n    const mod = ed25519.CURVE.Fp.create;\n    // (x1 * y2 == y1 * x2) | (y1 * y2 == x1 * x2)\n    const one = mod(X1 * Y2) === mod(Y1 * X2);\n    const two = mod(Y1 * Y2) === mod(X1 * X2);\n    return one || two;\n  }\n\n  add(other: RistPoint): RistPoint {\n    assertRstPoint(other);\n    return new RistPoint(this.ep.add(other.ep));\n  }\n\n  subtract(other: RistPoint): RistPoint {\n    assertRstPoint(other);\n    return new RistPoint(this.ep.subtract(other.ep));\n  }\n\n  multiply(scalar: bigint): RistPoint {\n    return new RistPoint(this.ep.multiply(scalar));\n  }\n\n  multiplyUnsafe(scalar: bigint): RistPoint {\n    return new RistPoint(this.ep.multiplyUnsafe(scalar));\n  }\n}\nexport const RistrettoPoint = /* @__PURE__ */ (() => {\n  if (!RistPoint.BASE) RistPoint.BASE = new RistPoint(ed25519.ExtendedPoint.BASE);\n  if (!RistPoint.ZERO) RistPoint.ZERO = new RistPoint(ed25519.ExtendedPoint.ZERO);\n  return RistPoint;\n})();\n\n// Hashing to ristretto255. https://www.rfc-editor.org/rfc/rfc9380#appendix-B\nexport const hashToRistretto255 = (msg: Uint8Array, options: htfBasicOpts) => {\n  const d = options.DST;\n  const DST = typeof d === 'string' ? utf8ToBytes(d) : d;\n  const uniform_bytes = expand_message_xmd(msg, DST, 64, sha512);\n  const P = RistPoint.hashToCurve(uniform_bytes);\n  return P;\n};\nexport const hash_to_ristretto255 = hashToRistretto255; // legacy\n", "import { hash as assertHash, number as assertNumber } from './_assert.js';\nimport { CHash, Input, toBytes } from './utils.js';\nimport { hmac } from './hmac.js';\n\n// HKDF (RFC 5869)\n// https://soatok.blog/2021/11/17/understanding-hkdf/\n\n/**\n * HKDF-Extract(IKM, salt) -> PRK\n * Arguments position differs from spec (IKM is first one, since it is not optional)\n * @param hash\n * @param ikm\n * @param salt\n * @returns\n */\nexport function extract(hash: CHash, ikm: Input, salt?: Input) {\n  assertHash(hash);\n  // NOTE: some libraries treat zero-length array as 'not provided';\n  // we don't, since we have undefined as 'not provided'\n  // https://github.com/RustCrypto/KDFs/issues/15\n  if (salt === undefined) salt = new Uint8Array(hash.outputLen); // if not provided, it is set to a string of HashLen zeros\n  return hmac(hash, toBytes(salt), toBytes(ikm));\n}\n\n// HKDF-Expand(PRK, info, L) -> OKM\nconst HKDF_COUNTER = /* @__PURE__ */ new Uint8Array([0]);\nconst EMPTY_BUFFER = /* @__PURE__ */ new Uint8Array();\n\n/**\n * HKDF-expand from the spec.\n * @param prk - a pseudorandom key of at least HashLen octets (usually, the output from the extract step)\n * @param info - optional context and application specific information (can be a zero-length string)\n * @param length - length of output keying material in octets\n */\nexport function expand(hash: CHash, prk: Input, info?: Input, length: number = 32) {\n  assertHash(hash);\n  assertNumber(length);\n  if (length > 255 * hash.outputLen) throw new Error('Length should be <= 255*HashLen');\n  const blocks = Math.ceil(length / hash.outputLen);\n  if (info === undefined) info = EMPTY_BUFFER;\n  // first L(ength) octets of T\n  const okm = new Uint8Array(blocks * hash.outputLen);\n  // Re-use HMAC instance between blocks\n  const HMAC = hmac.create(hash, prk);\n  const HMACTmp = HMAC._cloneInto();\n  const T = new Uint8Array(HMAC.outputLen);\n  for (let counter = 0; counter < blocks; counter++) {\n    HKDF_COUNTER[0] = counter + 1;\n    // T(0) = empty string (zero length)\n    // T(N) = HMAC-Hash(PRK, T(N-1) | info | N)\n    HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T)\n      .update(info)\n      .update(HKDF_COUNTER)\n      .digestInto(T);\n    okm.set(T, hash.outputLen * counter);\n    HMAC._cloneInto(HMACTmp);\n  }\n  HMAC.destroy();\n  HMACTmp.destroy();\n  T.fill(0);\n  HKDF_COUNTER.fill(0);\n  return okm.slice(0, length);\n}\n\n/**\n * HKDF (RFC 5869): extract + expand in one step.\n * @param hash - hash function that would be used (e.g. sha256)\n * @param ikm - input keying material, the initial key\n * @param salt - optional salt value (a non-secret random value)\n * @param info - optional context and application specific information\n * @param length - length of output keying material in octets\n */\nexport const hkdf = (\n  hash: CHash,\n  ikm: Input,\n  salt: Input | undefined,\n  info: Input | undefined,\n  length: number\n) => expand(hash, extract(hash, ikm, salt), info, length);\n", "import { chacha20poly1305 } from '@noble/ciphers/chacha'\nimport { x25519 } from '@noble/curves/ed25519'\nimport { extract, expand } from '@noble/hashes/hkdf'\nimport { sha256 } from '@noble/hashes/sha256'\nimport type { bytes, bytes32 } from '../@types/basic.js'\nimport type { Hkdf } from '../@types/handshake.js'\nimport type { KeyPair } from '../@types/libp2p.js'\nimport type { ICryptoInterface } from '../crypto.js'\n\nexport const pureJsCrypto: ICryptoInterface = {\n  hashSHA256 (data: Uint8Array): Uint8Array {\n    return sha256(data)\n  },\n\n  getHKDF (ck: bytes32, ikm: Uint8Array): Hkdf {\n    const prk = extract(sha256, ikm, ck)\n    const okmU8Array = expand(sha256, prk, undefined, 96)\n    const okm = okmU8Array\n\n    const k1 = okm.subarray(0, 32)\n    const k2 = okm.subarray(32, 64)\n    const k3 = okm.subarray(64, 96)\n\n    return [k1, k2, k3]\n  },\n\n  generateX25519KeyPair (): KeyPair {\n    const secretKey = x25519.utils.randomPrivateKey()\n    const publicKey = x25519.getPublicKey(secretKey)\n\n    return {\n      publicKey,\n      privateKey: secretKey\n    }\n  },\n\n  generateX25519KeyPairFromSeed (seed: Uint8Array): KeyPair {\n    const publicKey = x25519.getPublicKey(seed)\n\n    return {\n      publicKey,\n      privateKey: seed\n    }\n  },\n\n  generateX25519SharedKey (privateKey: Uint8Array, publicKey: Uint8Array): Uint8Array {\n    return x25519.getSharedSecret(privateKey, publicKey)\n  },\n\n  chaCha20Poly1305Encrypt (plaintext: Uint8Array, nonce: Uint8Array, ad: Uint8Array, k: bytes32): bytes {\n    return chacha20poly1305(k, nonce, ad).encrypt(plaintext)\n  },\n\n  chaCha20Poly1305Decrypt (ciphertext: Uint8Array, nonce: Uint8Array, ad: Uint8Array, k: bytes32, dst?: Uint8Array): bytes | null {\n    return chacha20poly1305(k, nonce, ad).decrypt(ciphertext, dst)\n  }\n}\n", "import { pureJsCrypto } from './js'\n\nexport const defaultCrypto = pureJsCrypto\n", "import { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport type { bytes } from './@types/basic.js'\nimport type { MessageBuffer } from './@types/handshake.js'\nimport type { LengthDecoderFunction } from 'it-length-prefixed'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nconst allocUnsafe = (len: number): Uint8Array => {\n  if (globalThis.Buffer) {\n    return globalThis.Buffer.allocUnsafe(len)\n  }\n\n  return new Uint8Array(len)\n}\n\nexport const uint16BEEncode = (value: number): Uint8Array => {\n  const target = allocUnsafe(2)\n  new DataView(target.buffer, target.byteOffset, target.byteLength).setUint16(0, value, false)\n  return target\n}\nuint16BEEncode.bytes = 2\n\nexport const uint16BEDecode: LengthDecoderFunction = (data: Uint8Array | Uint8ArrayList): number => {\n  if (data.length < 2) throw RangeError('Could not decode int16BE')\n\n  if (data instanceof Uint8Array) {\n    return new DataView(data.buffer, data.byteOffset, data.byteLength).getUint16(0, false)\n  }\n\n  return data.getUint16(0)\n}\nuint16BEDecode.bytes = 2\n\n// Note: IK and XX encoder usage is opposite (XX uses in stages encode0 where IK uses encode1)\n\nexport function encode0 (message: MessageBuffer): bytes {\n  return uint8ArrayConcat([message.ne, message.ciphertext], message.ne.length + message.ciphertext.length)\n}\n\nexport function encode1 (message: MessageBuffer): bytes {\n  return uint8ArrayConcat([message.ne, message.ns, message.ciphertext], message.ne.length + message.ns.length + message.ciphertext.length)\n}\n\nexport function encode2 (message: MessageBuffer): bytes {\n  return uint8ArrayConcat([message.ns, message.ciphertext], message.ns.length + message.ciphertext.length)\n}\n\nexport function decode0 (input: bytes): MessageBuffer {\n  if (input.length < 32) {\n    throw new Error('Cannot decode stage 0 MessageBuffer: length less than 32 bytes.')\n  }\n\n  return {\n    ne: input.subarray(0, 32),\n    ciphertext: input.subarray(32, input.length),\n    ns: new Uint8Array(0)\n  }\n}\n\nexport function decode1 (input: bytes): MessageBuffer {\n  if (input.length < 80) {\n    throw new Error('Cannot decode stage 1 MessageBuffer: length less than 80 bytes.')\n  }\n\n  return {\n    ne: input.subarray(0, 32),\n    ns: input.subarray(32, 80),\n    ciphertext: input.subarray(80, input.length)\n  }\n}\n\nexport function decode2 (input: bytes): MessageBuffer {\n  if (input.length < 48) {\n    throw new Error('Cannot decode stage 2 MessageBuffer: length less than 48 bytes.')\n  }\n\n  return {\n    ne: new Uint8Array(0),\n    ns: input.subarray(0, 48),\n    ciphertext: input.subarray(48, input.length)\n  }\n}\n", "import { concat as uint8ArrayConcat } from 'uint8arrays'\nimport { NOISE_MSG_MAX_LENGTH_BYTES, NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG } from '../constants.js'\nimport { uint16BEEncode } from '../encoder.js'\nimport type { IHandshake } from '../@types/handshake-interface.js'\nimport type { MetricsRegistry } from '../metrics.js'\nimport type { Transform } from 'it-stream-types'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nconst CHACHA_TAG_LENGTH = 16\n\n// Returns generator that encrypts payload from the user\nexport function encryptStream (handshake: IHandshake, metrics?: MetricsRegistry): Transform<AsyncIterable<Uint8Array>> {\n  return async function * (source) {\n    for await (const chunk of source) {\n      for (let i = 0; i < chunk.length; i += NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG) {\n        let end = i + NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG\n        if (end > chunk.length) {\n          end = chunk.length\n        }\n\n        const data = handshake.encrypt(chunk.subarray(i, end), handshake.session)\n        metrics?.encryptedPackets.increment()\n\n        yield uint8ArrayConcat([\n          uint16BEEncode(data.byteLength),\n          data\n        ], 2 + data.byteLength)\n      }\n    }\n  }\n}\n\n// Decrypt received payload to the user\nexport function decryptStream (handshake: IHandshake, metrics?: MetricsRegistry): Transform<AsyncIterable<Uint8ArrayList>, AsyncIterable<Uint8Array>> {\n  return async function * (source) {\n    for await (const chunk of source) {\n      for (let i = 0; i < chunk.length; i += NOISE_MSG_MAX_LENGTH_BYTES) {\n        let end = i + NOISE_MSG_MAX_LENGTH_BYTES\n        if (end > chunk.length) {\n          end = chunk.length\n        }\n\n        if (end - CHACHA_TAG_LENGTH < i) {\n          throw new Error('Invalid chunk')\n        }\n        const encrypted = chunk.subarray(i, end)\n        // memory allocation is not cheap so reuse the encrypted Uint8Array\n        // see https://github.com/ChainSafe/js-libp2p-noise/pull/242#issue-1422126164\n        // this is ok because chacha20 reads bytes one by one and don't reread after that\n        // it's also tested in https://github.com/ChainSafe/as-chacha20poly1305/pull/1/files#diff-25252846b58979dcaf4e41d47b3eadd7e4f335e7fb98da6c049b1f9cd011f381R48\n        const dst = chunk.subarray(i, end - CHACHA_TAG_LENGTH)\n        const { plaintext: decrypted, valid } = handshake.decrypt(encrypted, handshake.session, dst)\n        if (!valid) {\n          metrics?.decryptErrors.increment()\n          throw new Error('Failed to validate decrypted chunk')\n        }\n        metrics?.decryptedPackets.increment()\n        yield decrypted\n      }\n    }\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * **Supported Key Types**\n *\n * The {@link generateKeyPair}, {@link marshalPublicKey}, and {@link marshalPrivateKey} functions accept a string `type` argument.\n *\n * Currently the `'RSA'`, `'ed25519'`, and `secp256k1` types are supported, although ed25519 and secp256k1 keys support only signing and verification of messages.\n *\n * For encryption / decryption support, RSA keys should be used.\n */\n\nimport 'node-forge/lib/asn1.js'\nimport 'node-forge/lib/pbe.js'\nimport { CodeError } from '@libp2p/interface/errors'\n// @ts-expect-error types are missing\nimport forge from 'node-forge/lib/forge.js'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport * as Ed25519 from './ed25519-class.js'\nimport generateEphemeralKeyPair from './ephemeral-keys.js'\nimport { importer } from './importer.js'\nimport { keyStretcher } from './key-stretcher.js'\nimport * as keysPBM from './keys.js'\nimport * as RSA from './rsa-class.js'\nimport * as Secp256k1 from './secp256k1-class.js'\nimport type { PrivateKey, PublicKey } from '@libp2p/interface/keys'\n\nexport { keyStretcher }\nexport { generateEphemeralKeyPair }\nexport { keysPBM }\n\nexport type KeyTypes = 'RSA' | 'Ed25519' | 'secp256k1'\n\nexport const supportedKeys = {\n  rsa: RSA,\n  ed25519: Ed25519,\n  secp256k1: Secp256k1\n}\n\nfunction unsupportedKey (type: string): CodeError<Record<string, never>> {\n  const supported = Object.keys(supportedKeys).join(' / ')\n  return new CodeError(`invalid or unsupported key type ${type}. Must be ${supported}`, 'ERR_UNSUPPORTED_KEY_TYPE')\n}\n\nfunction typeToKey (type: string): typeof RSA | typeof Ed25519 | typeof Secp256k1 {\n  type = type.toLowerCase()\n\n  if (type === 'rsa' || type === 'ed25519' || type === 'secp256k1') {\n    return supportedKeys[type]\n  }\n\n  throw unsupportedKey(type)\n}\n\n/**\n * Generates a keypair of the given type and bitsize\n *\n * @param type\n * @param bits -  Minimum of 1024\n */\nexport async function generateKeyPair (type: KeyTypes, bits?: number): Promise<PrivateKey> {\n  return typeToKey(type).generateKeyPair(bits ?? 2048)\n}\n\n/**\n * Generates a keypair of the given type and bitsize.\n *\n * Seed is a 32 byte uint8array\n */\nexport async function generateKeyPairFromSeed (type: KeyTypes, seed: Uint8Array, bits?: number): Promise<PrivateKey> {\n  if (type.toLowerCase() !== 'ed25519') {\n    throw new CodeError('Seed key derivation is unimplemented for RSA or secp256k1', 'ERR_UNSUPPORTED_KEY_DERIVATION_TYPE')\n  }\n\n  return Ed25519.generateKeyPairFromSeed(seed)\n}\n\n/**\n * Converts a protobuf serialized public key into its representative object\n */\nexport function unmarshalPublicKey (buf: Uint8Array): PublicKey {\n  const decoded = keysPBM.PublicKey.decode(buf)\n  const data = decoded.Data ?? new Uint8Array()\n\n  switch (decoded.Type) {\n    case keysPBM.KeyType.RSA:\n      return supportedKeys.rsa.unmarshalRsaPublicKey(data)\n    case keysPBM.KeyType.Ed25519:\n      return supportedKeys.ed25519.unmarshalEd25519PublicKey(data)\n    case keysPBM.KeyType.Secp256k1:\n      return supportedKeys.secp256k1.unmarshalSecp256k1PublicKey(data)\n    default:\n      throw unsupportedKey(decoded.Type ?? 'unknown')\n  }\n}\n\n/**\n * Converts a public key object into a protobuf serialized public key\n */\nexport function marshalPublicKey (key: { bytes: Uint8Array }, type?: string): Uint8Array {\n  type = (type ?? 'rsa').toLowerCase()\n  typeToKey(type) // check type\n  return key.bytes\n}\n\n/**\n * Converts a protobuf serialized private key into its representative object\n */\nexport async function unmarshalPrivateKey (buf: Uint8Array): Promise<PrivateKey> {\n  const decoded = keysPBM.PrivateKey.decode(buf)\n  const data = decoded.Data ?? new Uint8Array()\n\n  switch (decoded.Type) {\n    case keysPBM.KeyType.RSA:\n      return supportedKeys.rsa.unmarshalRsaPrivateKey(data)\n    case keysPBM.KeyType.Ed25519:\n      return supportedKeys.ed25519.unmarshalEd25519PrivateKey(data)\n    case keysPBM.KeyType.Secp256k1:\n      return supportedKeys.secp256k1.unmarshalSecp256k1PrivateKey(data)\n    default:\n      throw unsupportedKey(decoded.Type ?? 'RSA')\n  }\n}\n\n/**\n * Converts a private key object into a protobuf serialized private key\n */\nexport function marshalPrivateKey (key: { bytes: Uint8Array }, type?: string): Uint8Array {\n  type = (type ?? 'rsa').toLowerCase()\n  typeToKey(type) // check type\n  return key.bytes\n}\n\n/**\n * Converts an exported private key into its representative object.\n *\n * Supported formats are 'pem' (RSA only) and 'libp2p-key'.\n */\nexport async function importKey (encryptedKey: string, password: string): Promise<PrivateKey> {\n  try {\n    const key = await importer(encryptedKey, password)\n    return await unmarshalPrivateKey(key)\n  } catch (_) {\n    // Ignore and try the old pem decrypt\n  }\n\n  // Only rsa supports pem right now\n  const key = forge.pki.decryptRsaPrivateKey(encryptedKey, password)\n  if (key === null) {\n    throw new CodeError('Cannot read the key, most likely the password is wrong or not a RSA key', 'ERR_CANNOT_DECRYPT_PEM')\n  }\n  let der = forge.asn1.toDer(forge.pki.privateKeyToAsn1(key))\n  der = uint8ArrayFromString(der.getBytes(), 'ascii')\n  return supportedKeys.rsa.unmarshalRsaPrivateKey(der)\n}\n", "import { CodeError } from '@libp2p/interface/errors'\nimport { base58btc } from 'multiformats/bases/base58'\nimport { identity } from 'multiformats/hashes/identity'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport * as crypto from './ed25519.js'\nimport { exporter } from './exporter.js'\nimport * as pbm from './keys.js'\nimport type { Multibase } from 'multiformats'\n\nexport class Ed25519PublicKey {\n  private readonly _key: Uint8Array\n\n  constructor (key: Uint8Array) {\n    this._key = ensureKey(key, crypto.publicKeyLength)\n  }\n\n  async verify (data: Uint8Array, sig: Uint8Array): Promise<boolean> {\n    return crypto.hashAndVerify(this._key, sig, data)\n  }\n\n  marshal (): Uint8Array {\n    return this._key\n  }\n\n  get bytes (): Uint8Array {\n    return pbm.PublicKey.encode({\n      Type: pbm.KeyType.Ed25519,\n      Data: this.marshal()\n    }).subarray()\n  }\n\n  equals (key: any): boolean {\n    return uint8ArrayEquals(this.bytes, key.bytes)\n  }\n\n  async hash (): Promise<Uint8Array> {\n    const { bytes } = await sha256.digest(this.bytes)\n\n    return bytes\n  }\n}\n\nexport class Ed25519PrivateKey {\n  private readonly _key: Uint8Array\n  private readonly _publicKey: Uint8Array\n\n  // key       - 64 byte Uint8Array containing private key\n  // publicKey - 32 byte Uint8Array containing public key\n  constructor (key: Uint8Array, publicKey: Uint8Array) {\n    this._key = ensureKey(key, crypto.privateKeyLength)\n    this._publicKey = ensureKey(publicKey, crypto.publicKeyLength)\n  }\n\n  async sign (message: Uint8Array): Promise<Uint8Array> {\n    return crypto.hashAndSign(this._key, message)\n  }\n\n  get public (): Ed25519PublicKey {\n    return new Ed25519PublicKey(this._publicKey)\n  }\n\n  marshal (): Uint8Array {\n    return this._key\n  }\n\n  get bytes (): Uint8Array {\n    return pbm.PrivateKey.encode({\n      Type: pbm.KeyType.Ed25519,\n      Data: this.marshal()\n    }).subarray()\n  }\n\n  equals (key: any): boolean {\n    return uint8ArrayEquals(this.bytes, key.bytes)\n  }\n\n  async hash (): Promise<Uint8Array> {\n    const { bytes } = await sha256.digest(this.bytes)\n\n    return bytes\n  }\n\n  /**\n   * Gets the ID of the key.\n   *\n   * The key id is the base58 encoding of the identity multihash containing its public key.\n   * The public key is a protobuf encoding containing a type and the DER encoding\n   * of the PKCS SubjectPublicKeyInfo.\n   *\n   * @returns {Promise<string>}\n   */\n  async id (): Promise<string> {\n    const encoding = identity.digest(this.public.bytes)\n    return base58btc.encode(encoding.bytes).substring(1)\n  }\n\n  /**\n   * Exports the key into a password protected `format`\n   */\n  async export (password: string, format = 'libp2p-key'): Promise<Multibase<'m'>> {\n    if (format === 'libp2p-key') {\n      return exporter(this.bytes, password)\n    } else {\n      throw new CodeError(`export format '${format}' is not supported`, 'ERR_INVALID_EXPORT_FORMAT')\n    }\n  }\n}\n\nexport function unmarshalEd25519PrivateKey (bytes: Uint8Array): Ed25519PrivateKey {\n  // Try the old, redundant public key version\n  if (bytes.length > crypto.privateKeyLength) {\n    bytes = ensureKey(bytes, crypto.privateKeyLength + crypto.publicKeyLength)\n    const privateKeyBytes = bytes.subarray(0, crypto.privateKeyLength)\n    const publicKeyBytes = bytes.subarray(crypto.privateKeyLength, bytes.length)\n    return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes)\n  }\n\n  bytes = ensureKey(bytes, crypto.privateKeyLength)\n  const privateKeyBytes = bytes.subarray(0, crypto.privateKeyLength)\n  const publicKeyBytes = bytes.subarray(crypto.publicKeyLength)\n  return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes)\n}\n\nexport function unmarshalEd25519PublicKey (bytes: Uint8Array): Ed25519PublicKey {\n  bytes = ensureKey(bytes, crypto.publicKeyLength)\n  return new Ed25519PublicKey(bytes)\n}\n\nexport async function generateKeyPair (): Promise<Ed25519PrivateKey> {\n  const { privateKey, publicKey } = await crypto.generateKey()\n  return new Ed25519PrivateKey(privateKey, publicKey)\n}\n\nexport async function generateKeyPairFromSeed (seed: Uint8Array): Promise<Ed25519PrivateKey> {\n  const { privateKey, publicKey } = await crypto.generateKeyFromSeed(seed)\n  return new Ed25519PrivateKey(privateKey, publicKey)\n}\n\nfunction ensureKey (key: Uint8Array, length: number): Uint8Array {\n  key = Uint8Array.from(key ?? [])\n  if (key.length !== length) {\n    throw new CodeError(`Key must be a Uint8Array of length ${length}, got ${key.length}`, 'ERR_INVALID_KEY_TYPE')\n  }\n  return key\n}\n", "// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET, name) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256);\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255;\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i);\n    var xc = x.charCodeAt(0);\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i;\n  }\n  var BASE = ALPHABET.length;\n  var LEADER = ALPHABET.charAt(0);\n  var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (source instanceof Uint8Array) ; else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source);\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0;\n    var length = 0;\n    var pbegin = 0;\n    var pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++;\n      zeroes++;\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n    var b58 = new Uint8Array(size);\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0;\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0;\n        b58[it1] = (carry % BASE) >>> 0;\n        carry = (carry / BASE) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      pbegin++;\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length;\n    while (it2 !== size && b58[it2] === 0) {\n      it2++;\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes);\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0;\n        // Skip leading spaces.\n    if (source[psz] === ' ') { return }\n        // Skip and count leading '1's.\n    var zeroes = 0;\n    var length = 0;\n    while (source[psz] === LEADER) {\n      zeroes++;\n      psz++;\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size);\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0;\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0;\n        b256[it3] = (carry % 256) >>> 0;\n        carry = (carry / 256) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      psz++;\n    }\n        // Skip trailing spaces.\n    if (source[psz] === ' ') { return }\n        // Skip leading zeroes in b256.\n    var it4 = size - length;\n    while (it4 !== size && b256[it4] === 0) {\n      it4++;\n    }\n    var vch = new Uint8Array(zeroes + (size - it4));\n    var j = zeroes;\n    while (it4 !== size) {\n      vch[j++] = b256[it4++];\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string);\n    if (buffer) { return buffer }\n    throw new Error(`Non-${name} character`)\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nvar src = base;\n\nvar _brrp__multiformats_scope_baseX = src;\n\nexport default _brrp__multiformats_scope_baseX;\n", "const empty = new Uint8Array(0)\n\n/**\n * @param {Uint8Array} d\n */\nconst toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')\n\n/**\n * @param {string} hex\n */\nconst fromHex = hex => {\n  const hexes = hex.match(/../g)\n  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty\n}\n\n/**\n * @param {Uint8Array} aa\n * @param {Uint8Array} bb\n */\nconst equals = (aa, bb) => {\n  if (aa === bb) return true\n  if (aa.byteLength !== bb.byteLength) {\n    return false\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @param {ArrayBufferView|ArrayBuffer|Uint8Array} o\n * @returns {Uint8Array}\n */\nconst coerce = o => {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o\n  if (o instanceof ArrayBuffer) return new Uint8Array(o)\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)\n  }\n  throw new Error('Unknown type, must be binary type')\n}\n\n/**\n * @param {any} o\n * @returns {o is ArrayBuffer|ArrayBufferView}\n */\nconst isBinary = o =>\n  o instanceof ArrayBuffer || ArrayBuffer.isView(o)\n\n/**\n * @param {string} str\n * @returns {Uint8Array}\n */\nconst fromString = str => (new TextEncoder()).encode(str)\n\n/**\n * @param {Uint8Array} b\n * @returns {string}\n */\nconst toString = b => (new TextDecoder()).decode(b)\n\nexport { equals, coerce, isBinary, fromHex, toHex, fromString, toString, empty }\n", "import basex from '../../vendor/base-x.js'\nimport { coerce } from '../bytes.js'\n// Linter can't see that API is used in types.\n// eslint-disable-next-line\nimport * as API from './interface.js'\n\n/**\n * Class represents both BaseEncoder and MultibaseEncoder meaning it\n * can be used to encode to multibase or base encode without multibase\n * prefix.\n *\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseEncoder<Prefix>}\n * @implements {API.BaseEncoder}\n */\nclass Encoder {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(bytes:Uint8Array) => string} baseEncode\n   */\n  constructor (name, prefix, baseEncode) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n  }\n\n  /**\n   * @param {Uint8Array} bytes\n   * @returns {API.Multibase<Prefix>}\n   */\n  encode (bytes) {\n    if (bytes instanceof Uint8Array) {\n      return `${this.prefix}${this.baseEncode(bytes)}`\n    } else {\n      throw Error('Unknown type, must be binary type')\n    }\n  }\n}\n\n/**\n * @template {string} Prefix\n */\n/**\n * Class represents both BaseDecoder and MultibaseDecoder so it could be used\n * to decode multibases (with matching prefix) or just base decode strings\n * with corresponding base encoding.\n *\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.UnibaseDecoder<Prefix>}\n * @implements {API.BaseDecoder}\n */\nclass Decoder {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(text:string) => Uint8Array} baseDecode\n   */\n  constructor (name, prefix, baseDecode) {\n    this.name = name\n    this.prefix = prefix\n    /* c8 ignore next 3 */\n    if (prefix.codePointAt(0) === undefined) {\n      throw new Error('Invalid prefix character')\n    }\n    /** @private */\n    this.prefixCodePoint = /** @type {number} */ (prefix.codePointAt(0))\n    this.baseDecode = baseDecode\n  }\n\n  /**\n   * @param {string} text\n   */\n  decode (text) {\n    if (typeof text === 'string') {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`)\n      }\n      return this.baseDecode(text.slice(this.prefix.length))\n    } else {\n      throw Error('Can only multibase decode strings')\n    }\n  }\n\n  /**\n   * @template {string} OtherPrefix\n   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder\n   * @returns {ComposedDecoder<Prefix|OtherPrefix>}\n   */\n  or (decoder) {\n    return or(this, decoder)\n  }\n}\n\n/**\n * @template {string} Prefix\n * @typedef {Record<Prefix, API.UnibaseDecoder<Prefix>>} Decoders\n */\n\n/**\n * @template {string} Prefix\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.CombobaseDecoder<Prefix>}\n */\nclass ComposedDecoder {\n  /**\n   * @param {Decoders<Prefix>} decoders\n   */\n  constructor (decoders) {\n    this.decoders = decoders\n  }\n\n  /**\n   * @template {string} OtherPrefix\n   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder\n   * @returns {ComposedDecoder<Prefix|OtherPrefix>}\n   */\n  or (decoder) {\n    return or(this, decoder)\n  }\n\n  /**\n   * @param {string} input\n   * @returns {Uint8Array}\n   */\n  decode (input) {\n    const prefix = /** @type {Prefix} */ (input[0])\n    const decoder = this.decoders[prefix]\n    if (decoder) {\n      return decoder.decode(input)\n    } else {\n      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)\n    }\n  }\n}\n\n/**\n * @template {string} L\n * @template {string} R\n * @param {API.UnibaseDecoder<L>|API.CombobaseDecoder<L>} left\n * @param {API.UnibaseDecoder<R>|API.CombobaseDecoder<R>} right\n * @returns {ComposedDecoder<L|R>}\n */\nexport const or = (left, right) => new ComposedDecoder(/** @type {Decoders<L|R>} */({\n  ...(left.decoders || { [/** @type API.UnibaseDecoder<L> */(left).prefix]: left }),\n  ...(right.decoders || { [/** @type API.UnibaseDecoder<R> */(right).prefix]: right })\n}))\n\n/**\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseCodec<Prefix>}\n * @implements {API.MultibaseEncoder<Prefix>}\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.BaseCodec}\n * @implements {API.BaseEncoder}\n * @implements {API.BaseDecoder}\n */\nexport class Codec {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(bytes:Uint8Array) => string} baseEncode\n   * @param {(text:string) => Uint8Array} baseDecode\n   */\n  constructor (name, prefix, baseEncode, baseDecode) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n    this.baseDecode = baseDecode\n    this.encoder = new Encoder(name, prefix, baseEncode)\n    this.decoder = new Decoder(name, prefix, baseDecode)\n  }\n\n  /**\n   * @param {Uint8Array} input\n   */\n  encode (input) {\n    return this.encoder.encode(input)\n  }\n\n  /**\n   * @param {string} input\n   */\n  decode (input) {\n    return this.decoder.decode(input)\n  }\n}\n\n/**\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {(bytes:Uint8Array) => string} options.encode\n * @param {(input:string) => Uint8Array} options.decode\n * @returns {Codec<Base, Prefix>}\n */\nexport const from = ({ name, prefix, encode, decode }) =>\n  new Codec(name, prefix, encode, decode)\n\n/**\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {string} options.alphabet\n * @returns {Codec<Base, Prefix>}\n */\nexport const baseX = ({ prefix, name, alphabet }) => {\n  const { encode, decode } = basex(alphabet, name)\n  return from({\n    prefix,\n    name,\n    encode,\n    /**\n     * @param {string} text\n     */\n    decode: text => coerce(decode(text))\n  })\n}\n\n/**\n * @param {string} string\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @param {string} name\n * @returns {Uint8Array}\n */\nconst decode = (string, alphabet, bitsPerChar, name) => {\n  // Build the character lookup table:\n  /** @type {Record<string, number>} */\n  const codes = {}\n  for (let i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i\n  }\n\n  // Count the padding bytes:\n  let end = string.length\n  while (string[end - 1] === '=') {\n    --end\n  }\n\n  // Allocate the output:\n  const out = new Uint8Array((end * bitsPerChar / 8) | 0)\n\n  // Parse the data:\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  let written = 0 // Next byte to write\n  for (let i = 0; i < end; ++i) {\n    // Read one character from the string:\n    const value = codes[string[i]]\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${name} character`)\n    }\n\n    // Append the bits to the buffer:\n    buffer = (buffer << bitsPerChar) | value\n    bits += bitsPerChar\n\n    // Write out some bits if the buffer has a byte's worth:\n    if (bits >= 8) {\n      bits -= 8\n      out[written++] = 0xff & (buffer >> bits)\n    }\n  }\n\n  // Verify that we have received just enough bits:\n  if (bits >= bitsPerChar || 0xff & (buffer << (8 - bits))) {\n    throw new SyntaxError('Unexpected end of data')\n  }\n\n  return out\n}\n\n/**\n * @param {Uint8Array} data\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @returns {string}\n */\nconst encode = (data, alphabet, bitsPerChar) => {\n  const pad = alphabet[alphabet.length - 1] === '='\n  const mask = (1 << bitsPerChar) - 1\n  let out = ''\n\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  for (let i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = (buffer << 8) | data[i]\n    bits += 8\n\n    // Write out as much as we can:\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar\n      out += alphabet[mask & (buffer >> bits)]\n    }\n  }\n\n  // Partial character:\n  if (bits) {\n    out += alphabet[mask & (buffer << (bitsPerChar - bits))]\n  }\n\n  // Add padding characters until we hit a byte boundary:\n  if (pad) {\n    while ((out.length * bitsPerChar) & 7) {\n      out += '='\n    }\n  }\n\n  return out\n}\n\n/**\n * RFC4648 Factory\n *\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {string} options.alphabet\n * @param {number} options.bitsPerChar\n */\nexport const rfc4648 = ({ name, prefix, bitsPerChar, alphabet }) => {\n  return from({\n    prefix,\n    name,\n    encode (input) {\n      return encode(input, alphabet, bitsPerChar)\n    },\n    decode (input) {\n      return decode(input, alphabet, bitsPerChar, name)\n    }\n  })\n}\n", "import { baseX } from './base.js'\n\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n})\n\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n})\n", "var encode_1 = encode;\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31);\n\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num /= 128;\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  \n  encode.bytes = offset - oldOffset + 1;\n  \n  return out\n}\n\nvar decode = read;\n\nvar MSB$1 = 0x80\n  , REST$1 = 0x7F;\n\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length;\n\n  do {\n    if (counter >= l) {\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++];\n    res += shift < 28\n      ? (b & REST$1) << shift\n      : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1)\n\n  read.bytes = counter - offset;\n\n  return res\n}\n\nvar N1 = Math.pow(2,  7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\n\nvar length = function (value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n};\n\nvar varint = {\n    encode: encode_1\n  , decode: decode\n  , encodingLength: length\n};\n\nvar _brrp_varint = varint;\n\nexport default _brrp_varint;\n", "import varint from '../vendor/varint.js'\n\n/**\n * @param {Uint8Array} data\n * @param {number} [offset=0]\n * @returns {[number, number]}\n */\nexport const decode = (data, offset = 0) => {\n  const code = varint.decode(data, offset)\n  return [code, varint.decode.bytes]\n}\n\n/**\n * @param {number} int\n * @param {Uint8Array} target\n * @param {number} [offset=0]\n */\nexport const encodeTo = (int, target, offset = 0) => {\n  varint.encode(int, target, offset)\n  return target\n}\n\n/**\n * @param {number} int\n * @returns {number}\n */\nexport const encodingLength = (int) => {\n  return varint.encodingLength(int)\n}\n", "import { coerce, equals as equalBytes } from '../bytes.js'\nimport * as varint from '../varint.js'\n\n/**\n * Creates a multihash digest.\n *\n * @template {number} Code\n * @param {Code} code\n * @param {Uint8Array} digest\n */\nexport const create = (code, digest) => {\n  const size = digest.byteLength\n  const sizeOffset = varint.encodingLength(code)\n  const digestOffset = sizeOffset + varint.encodingLength(size)\n\n  const bytes = new Uint8Array(digestOffset + size)\n  varint.encodeTo(code, bytes, 0)\n  varint.encodeTo(size, bytes, sizeOffset)\n  bytes.set(digest, digestOffset)\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * Turns bytes representation of multihash digest into an instance.\n *\n * @param {Uint8Array} multihash\n * @returns {MultihashDigest}\n */\nexport const decode = (multihash) => {\n  const bytes = coerce(multihash)\n  const [code, sizeOffset] = varint.decode(bytes)\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset))\n  const digest = bytes.subarray(sizeOffset + digestOffset)\n\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length')\n  }\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * @param {MultihashDigest} a\n * @param {unknown} b\n * @returns {b is MultihashDigest}\n */\nexport const equals = (a, b) => {\n  if (a === b) {\n    return true\n  } else {\n    const data = /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */(b)\n\n    return (\n      a.code === data.code &&\n      a.size === data.size &&\n      data.bytes instanceof Uint8Array &&\n      equalBytes(a.bytes, data.bytes)\n    )\n  }\n}\n\n/**\n * @typedef {import('./interface.js').MultihashDigest} MultihashDigest\n */\n\n/**\n * Represents a multihash digest which carries information about the\n * hashing algorithm and an actual hash digest.\n *\n * @template {number} Code\n * @template {number} Size\n * @class\n * @implements {MultihashDigest}\n */\nexport class Digest {\n  /**\n   * Creates a multihash digest.\n   *\n   * @param {Code} code\n   * @param {Size} size\n   * @param {Uint8Array} digest\n   * @param {Uint8Array} bytes\n   */\n  constructor (code, size, digest, bytes) {\n    this.code = code\n    this.size = size\n    this.digest = digest\n    this.bytes = bytes\n  }\n}\n", "import { coerce } from '../bytes.js'\nimport * as Digest from './digest.js'\n\nconst code = 0x0\nconst name = 'identity'\n\n/** @type {(input:Uint8Array) => Uint8Array} */\nconst encode = coerce\n\n/**\n * @param {Uint8Array} input\n * @returns {Digest.Digest<typeof code, number>}\n */\nconst digest = (input) => Digest.create(code, encode(input))\n\nexport const identity = { code, name, encode, digest }\n", "import * as Digest from './digest.js'\n\n/**\n * @template {string} Name\n * @template {number} Code\n * @param {object} options\n * @param {Name} options.name\n * @param {Code} options.code\n * @param {(input: Uint8Array) => Await<Uint8Array>} options.encode\n */\nexport const from = ({ name, code, encode }) => new Hasher(name, code, encode)\n\n/**\n * Hasher represents a hashing algorithm implementation that produces as\n * `MultihashDigest`.\n *\n * @template {string} Name\n * @template {number} Code\n * @class\n * @implements {MultihashHasher<Code>}\n */\nexport class Hasher {\n  /**\n   *\n   * @param {Name} name\n   * @param {Code} code\n   * @param {(input: Uint8Array) => Await<Uint8Array>} encode\n   */\n  constructor (name, code, encode) {\n    this.name = name\n    this.code = code\n    this.encode = encode\n  }\n\n  /**\n   * @param {Uint8Array} input\n   * @returns {Await<Digest.Digest<Code, number>>}\n   */\n  digest (input) {\n    if (input instanceof Uint8Array) {\n      const result = this.encode(input)\n      return result instanceof Uint8Array\n        ? Digest.create(this.code, result)\n        /* c8 ignore next 1 */\n        : result.then(digest => Digest.create(this.code, digest))\n    } else {\n      throw Error('Unknown type, must be binary type')\n      /* c8 ignore next 1 */\n    }\n  }\n}\n\n/**\n * @template {number} Alg\n * @typedef {import('./interface.js').MultihashHasher} MultihashHasher\n */\n\n/**\n * @template T\n * @typedef {Promise<T>|T} Await\n */\n", "/* global crypto */\n\nimport { from } from './hasher.js'\n\n/**\n * @param {AlgorithmIdentifier} name\n */\nconst sha = name =>\n  /**\n   * @param {Uint8Array} data\n   */\n  async data => new Uint8Array(await crypto.subtle.digest(name, data))\n\nexport const sha256 = from({\n  name: 'sha2-256',\n  code: 0x12,\n  encode: sha('SHA-256')\n})\n\nexport const sha512 = from({\n  name: 'sha2-512',\n  code: 0x13,\n  encode: sha('SHA-512')\n})\n", "import { ed25519 as ed } from '@noble/curves/ed25519'\nimport type { Uint8ArrayKeyPair } from './interface'\n\nconst PUBLIC_KEY_BYTE_LENGTH = 32\nconst PRIVATE_KEY_BYTE_LENGTH = 64 // private key is actually 32 bytes but for historical reasons we concat private and public keys\nconst KEYS_BYTE_LENGTH = 32\n\nexport { PUBLIC_KEY_BYTE_LENGTH as publicKeyLength }\nexport { PRIVATE_KEY_BYTE_LENGTH as privateKeyLength }\n\nexport async function generateKey (): Promise<Uint8ArrayKeyPair> {\n  // the actual private key (32 bytes)\n  const privateKeyRaw = ed.utils.randomPrivateKey()\n  const publicKey = ed.getPublicKey(privateKeyRaw)\n\n  // concatenated the public key to the private key\n  const privateKey = concatKeys(privateKeyRaw, publicKey)\n\n  return {\n    privateKey,\n    publicKey\n  }\n}\n\n/**\n * Generate keypair from a 32 byte uint8array\n */\nexport async function generateKeyFromSeed (seed: Uint8Array): Promise<Uint8ArrayKeyPair> {\n  if (seed.length !== KEYS_BYTE_LENGTH) {\n    throw new TypeError('\"seed\" must be 32 bytes in length.')\n  } else if (!(seed instanceof Uint8Array)) {\n    throw new TypeError('\"seed\" must be a node.js Buffer, or Uint8Array.')\n  }\n\n  // based on node forges algorithm, the seed is used directly as private key\n  const privateKeyRaw = seed\n  const publicKey = ed.getPublicKey(privateKeyRaw)\n\n  const privateKey = concatKeys(privateKeyRaw, publicKey)\n\n  return {\n    privateKey,\n    publicKey\n  }\n}\n\nexport async function hashAndSign (privateKey: Uint8Array, msg: Uint8Array): Promise<Uint8Array> {\n  const privateKeyRaw = privateKey.subarray(0, KEYS_BYTE_LENGTH)\n\n  return ed.sign(msg, privateKeyRaw)\n}\n\nexport async function hashAndVerify (publicKey: Uint8Array, sig: Uint8Array, msg: Uint8Array): Promise<boolean> {\n  return ed.verify(sig, msg, publicKey)\n}\n\nfunction concatKeys (privateKeyRaw: Uint8Array, publicKey: Uint8Array): Uint8Array {\n  const privateKey = new Uint8Array(PRIVATE_KEY_BYTE_LENGTH)\n  for (let i = 0; i < KEYS_BYTE_LENGTH; i++) {\n    privateKey[i] = privateKeyRaw[i]\n    privateKey[KEYS_BYTE_LENGTH + i] = publicKey[i]\n  }\n  return privateKey\n}\n", "// @ts-check\n\nimport { rfc4648 } from './base.js'\n\nexport const base64 = rfc4648({\n  prefix: 'm',\n  name: 'base64',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n  bitsPerChar: 6\n})\n\nexport const base64pad = rfc4648({\n  prefix: 'M',\n  name: 'base64pad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n  bitsPerChar: 6\n})\n\nexport const base64url = rfc4648({\n  prefix: 'u',\n  name: 'base64url',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n  bitsPerChar: 6\n})\n\nexport const base64urlpad = rfc4648({\n  prefix: 'U',\n  name: 'base64urlpad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',\n  bitsPerChar: 6\n})\n", "/* eslint-env browser */\n\n// Check native crypto exists and is enabled (In insecure context `self.crypto`\n// exists but `self.crypto.subtle` does not).\nexport default {\n  get (win = globalThis) {\n    const nativeCrypto = win.crypto\n\n    if (nativeCrypto == null || nativeCrypto.subtle == null) {\n      throw Object.assign(\n        new Error(\n          'Missing Web Crypto API. ' +\n          'The most likely cause of this error is that this page is being accessed ' +\n          'from an insecure context (i.e. not HTTPS). For more information and ' +\n          'possible resolutions see ' +\n          'https://github.com/libp2p/js-libp2p-crypto/blob/master/README.md#web-crypto-api'\n        ),\n        { code: 'ERR_MISSING_WEB_CRYPTO' }\n      )\n    }\n\n    return nativeCrypto\n  }\n}\n", "import { concat } from 'uint8arrays/concat'\nimport { fromString } from 'uint8arrays/from-string'\nimport webcrypto from '../webcrypto.js'\nimport type { CreateOptions, AESCipher } from './interface.js'\n\n// WebKit on Linux does not support deriving a key from an empty PBKDF2 key.\n// So, as a workaround, we provide the generated key as a constant. We test that\n// this generated key is accurate in test/workaround.spec.ts\n// Generated via:\n// await crypto.subtle.exportKey('jwk',\n//   await crypto.subtle.deriveKey(\n//     { name: 'PBKDF2', salt: new Uint8Array(16), iterations: 32767, hash: { name: 'SHA-256' } },\n//     await crypto.subtle.importKey('raw', new Uint8Array(0), { name: 'PBKDF2' }, false, ['deriveKey']),\n//     { name: 'AES-GCM', length: 128 }, true, ['encrypt', 'decrypt'])\n// )\nexport const derivedEmptyPasswordKey = { alg: 'A128GCM', ext: true, k: 'scm9jmO_4BJAgdwWGVulLg', key_ops: ['encrypt', 'decrypt'], kty: 'oct' }\n\n// Based off of code from https://github.com/luke-park/SecureCompatibleEncryptionExamples\n\nexport function create (opts?: CreateOptions): AESCipher {\n  const algorithm = opts?.algorithm ?? 'AES-GCM'\n  let keyLength = opts?.keyLength ?? 16\n  const nonceLength = opts?.nonceLength ?? 12\n  const digest = opts?.digest ?? 'SHA-256'\n  const saltLength = opts?.saltLength ?? 16\n  const iterations = opts?.iterations ?? 32767\n\n  const crypto = webcrypto.get()\n  keyLength *= 8 // Browser crypto uses bits instead of bytes\n\n  /**\n   * Uses the provided password to derive a pbkdf2 key. The key\n   * will then be used to encrypt the data.\n   */\n  async function encrypt (data: Uint8Array, password: string | Uint8Array): Promise<Uint8Array> {\n    const salt = crypto.getRandomValues(new Uint8Array(saltLength))\n    const nonce = crypto.getRandomValues(new Uint8Array(nonceLength))\n    const aesGcm = { name: algorithm, iv: nonce }\n\n    if (typeof password === 'string') {\n      password = fromString(password)\n    }\n\n    let cryptoKey: CryptoKey\n    if (password.length === 0) {\n      cryptoKey = await crypto.subtle.importKey('jwk', derivedEmptyPasswordKey, { name: 'AES-GCM' }, true, ['encrypt'])\n      try {\n        const deriveParams = { name: 'PBKDF2', salt, iterations, hash: { name: digest } }\n        const runtimeDerivedEmptyPassword = await crypto.subtle.importKey('raw', password, { name: 'PBKDF2' }, false, ['deriveKey'])\n        cryptoKey = await crypto.subtle.deriveKey(deriveParams, runtimeDerivedEmptyPassword, { name: algorithm, length: keyLength }, true, ['encrypt'])\n      } catch {\n        cryptoKey = await crypto.subtle.importKey('jwk', derivedEmptyPasswordKey, { name: 'AES-GCM' }, true, ['encrypt'])\n      }\n    } else {\n      // Derive a key using PBKDF2.\n      const deriveParams = { name: 'PBKDF2', salt, iterations, hash: { name: digest } }\n      const rawKey = await crypto.subtle.importKey('raw', password, { name: 'PBKDF2' }, false, ['deriveKey'])\n      cryptoKey = await crypto.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ['encrypt'])\n    }\n\n    // Encrypt the string.\n    const ciphertext = await crypto.subtle.encrypt(aesGcm, cryptoKey, data)\n    return concat([salt, aesGcm.iv, new Uint8Array(ciphertext)])\n  }\n\n  /**\n   * Uses the provided password to derive a pbkdf2 key. The key\n   * will then be used to decrypt the data. The options used to create\n   * this decryption cipher must be the same as those used to create\n   * the encryption cipher.\n   */\n  async function decrypt (data: Uint8Array, password: string | Uint8Array): Promise<Uint8Array> {\n    const salt = data.subarray(0, saltLength)\n    const nonce = data.subarray(saltLength, saltLength + nonceLength)\n    const ciphertext = data.subarray(saltLength + nonceLength)\n    const aesGcm = { name: algorithm, iv: nonce }\n\n    if (typeof password === 'string') {\n      password = fromString(password)\n    }\n\n    let cryptoKey: CryptoKey\n    if (password.length === 0) {\n      try {\n        const deriveParams = { name: 'PBKDF2', salt, iterations, hash: { name: digest } }\n        const runtimeDerivedEmptyPassword = await crypto.subtle.importKey('raw', password, { name: 'PBKDF2' }, false, ['deriveKey'])\n        cryptoKey = await crypto.subtle.deriveKey(deriveParams, runtimeDerivedEmptyPassword, { name: algorithm, length: keyLength }, true, ['decrypt'])\n      } catch {\n        cryptoKey = await crypto.subtle.importKey('jwk', derivedEmptyPasswordKey, { name: 'AES-GCM' }, true, ['decrypt'])\n      }\n    } else {\n      // Derive the key using PBKDF2.\n      const deriveParams = { name: 'PBKDF2', salt, iterations, hash: { name: digest } }\n      const rawKey = await crypto.subtle.importKey('raw', password, { name: 'PBKDF2' }, false, ['deriveKey'])\n      cryptoKey = await crypto.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ['decrypt'])\n    }\n\n    // Decrypt the string.\n    const plaintext = await crypto.subtle.decrypt(aesGcm, cryptoKey, ciphertext)\n    return new Uint8Array(plaintext)\n  }\n\n  const cipher: AESCipher = {\n    encrypt,\n    decrypt\n  }\n\n  return cipher\n}\n", "import { base64 } from 'multiformats/bases/base64'\nimport * as ciphers from '../ciphers/aes-gcm.js'\nimport type { Multibase } from 'multiformats'\n\n/**\n * Exports the given PrivateKey as a base64 encoded string.\n * The PrivateKey is encrypted via a password derived PBKDF2 key\n * leveraging the aes-gcm cipher algorithm.\n */\nexport async function exporter (privateKey: Uint8Array, password: string): Promise<Multibase<'m'>> {\n  const cipher = ciphers.create()\n  const encryptedKey = await cipher.encrypt(privateKey, password)\n  return base64.encode(encryptedKey)\n}\n", "/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nimport { enumeration, encodeMessage, decodeMessage, message } from 'protons-runtime'\nimport type { Codec } from 'protons-runtime'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport enum KeyType {\n  RSA = 'RSA',\n  Ed25519 = 'Ed25519',\n  Secp256k1 = 'Secp256k1'\n}\n\nenum __KeyTypeValues {\n  RSA = 0,\n  Ed25519 = 1,\n  Secp256k1 = 2\n}\n\nexport namespace KeyType {\n  export const codec = (): Codec<KeyType> => {\n    return enumeration<KeyType>(__KeyTypeValues)\n  }\n}\nexport interface PublicKey {\n  Type?: KeyType\n  Data?: Uint8Array\n}\n\nexport namespace PublicKey {\n  let _codec: Codec<PublicKey>\n\n  export const codec = (): Codec<PublicKey> => {\n    if (_codec == null) {\n      _codec = message<PublicKey>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.Type != null) {\n          w.uint32(8)\n          KeyType.codec().encode(obj.Type, w)\n        }\n\n        if (obj.Data != null) {\n          w.uint32(18)\n          w.bytes(obj.Data)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {}\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.Type = KeyType.codec().decode(reader)\n              break\n            case 2:\n              obj.Data = reader.bytes()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<PublicKey>): Uint8Array => {\n    return encodeMessage(obj, PublicKey.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): PublicKey => {\n    return decodeMessage(buf, PublicKey.codec())\n  }\n}\n\nexport interface PrivateKey {\n  Type?: KeyType\n  Data?: Uint8Array\n}\n\nexport namespace PrivateKey {\n  let _codec: Codec<PrivateKey>\n\n  export const codec = (): Codec<PrivateKey> => {\n    if (_codec == null) {\n      _codec = message<PrivateKey>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.Type != null) {\n          w.uint32(8)\n          KeyType.codec().encode(obj.Type, w)\n        }\n\n        if (obj.Data != null) {\n          w.uint32(18)\n          w.bytes(obj.Data)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {}\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.Type = KeyType.codec().decode(reader)\n              break\n            case 2:\n              obj.Data = reader.bytes()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<PrivateKey>): Uint8Array => {\n    return encodeMessage(obj, PrivateKey.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): PrivateKey => {\n    return decodeMessage(buf, PrivateKey.codec())\n  }\n}\n", "import 'node-forge/lib/util.js'\nimport 'node-forge/lib/jsbn.js'\n// @ts-expect-error types are missing\nimport forge from 'node-forge/lib/forge.js'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\n\nexport function bigIntegerToUintBase64url (num: { abs(): any }, len?: number): string {\n  // Call `.abs()` to convert to unsigned\n  let buf = Uint8Array.from(num.abs().toByteArray()) // toByteArray converts to big endian\n\n  // toByteArray() gives us back a signed array, which will include a leading 0\n  // byte if the most significant bit of the number is 1:\n  // https://docs.microsoft.com/en-us/windows/win32/seccertenroll/about-integer\n  // Our number will always be positive so we should remove the leading padding.\n  buf = buf[0] === 0 ? buf.subarray(1) : buf\n\n  if (len != null) {\n    if (buf.length > len) throw new Error('byte array longer than desired length')\n    buf = uint8ArrayConcat([new Uint8Array(len - buf.length), buf])\n  }\n\n  return uint8ArrayToString(buf, 'base64url')\n}\n\n// Convert a base64url encoded string to a BigInteger\nexport function base64urlToBigInteger (str: string): typeof forge.jsbn.BigInteger {\n  const buf = base64urlToBuffer(str)\n  return new forge.jsbn.BigInteger(uint8ArrayToString(buf, 'base16'), 16)\n}\n\nexport function base64urlToBuffer (str: string, len?: number): Uint8Array {\n  let buf = uint8ArrayFromString(str, 'base64urlpad')\n\n  if (len != null) {\n    if (buf.length > len) throw new Error('byte array longer than desired length')\n    buf = uint8ArrayConcat([new Uint8Array(len - buf.length), buf])\n  }\n\n  return buf\n}\n", "import { CodeError } from '@libp2p/interface/errors'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { base64urlToBuffer } from '../util.js'\nimport webcrypto from '../webcrypto.js'\nimport type { ECDHKey, ECDHKeyPair, JWKEncodedPrivateKey, JWKEncodedPublicKey } from './interface.js'\n\nconst bits = {\n  'P-256': 256,\n  'P-384': 384,\n  'P-521': 521\n}\n\nconst curveTypes = Object.keys(bits)\nconst names = curveTypes.join(' / ')\n\nexport async function generateEphmeralKeyPair (curve: string): Promise<ECDHKey> {\n  if (curve !== 'P-256' && curve !== 'P-384' && curve !== 'P-521') {\n    throw new CodeError(`Unknown curve: ${curve}. Must be ${names}`, 'ERR_INVALID_CURVE')\n  }\n\n  const pair = await webcrypto.get().subtle.generateKey(\n    {\n      name: 'ECDH',\n      namedCurve: curve\n    },\n    true,\n    ['deriveBits']\n  )\n\n  // forcePrivate is used for testing only\n  const genSharedKey = async (theirPub: Uint8Array, forcePrivate?: ECDHKeyPair): Promise<Uint8Array> => {\n    let privateKey\n\n    if (forcePrivate != null) {\n      privateKey = await webcrypto.get().subtle.importKey(\n        'jwk',\n        unmarshalPrivateKey(curve, forcePrivate),\n        {\n          name: 'ECDH',\n          namedCurve: curve\n        },\n        false,\n        ['deriveBits']\n      )\n    } else {\n      privateKey = pair.privateKey\n    }\n\n    const key = await webcrypto.get().subtle.importKey(\n      'jwk',\n      unmarshalPublicKey(curve, theirPub),\n      {\n        name: 'ECDH',\n        namedCurve: curve\n      },\n      false,\n      []\n    )\n\n    const buffer = await webcrypto.get().subtle.deriveBits(\n      {\n        name: 'ECDH',\n        // @ts-expect-error namedCurve is missing from the types\n        namedCurve: curve,\n        public: key\n      },\n      privateKey,\n      bits[curve]\n    )\n\n    return new Uint8Array(buffer, 0, buffer.byteLength)\n  }\n\n  const publicKey = await webcrypto.get().subtle.exportKey('jwk', pair.publicKey)\n\n  const ecdhKey: ECDHKey = {\n    key: marshalPublicKey(publicKey),\n    genSharedKey\n  }\n\n  return ecdhKey\n}\n\nconst curveLengths = {\n  'P-256': 32,\n  'P-384': 48,\n  'P-521': 66\n}\n\n// Marshal converts a jwk encoded ECDH public key into the\n// form specified in section 4.3.6 of ANSI X9.62. (This is the format\n// go-ipfs uses)\nfunction marshalPublicKey (jwk: JsonWebKey): Uint8Array {\n  if (jwk.crv == null || jwk.x == null || jwk.y == null) {\n    throw new CodeError('JWK was missing components', 'ERR_INVALID_PARAMETERS')\n  }\n\n  if (jwk.crv !== 'P-256' && jwk.crv !== 'P-384' && jwk.crv !== 'P-521') {\n    throw new CodeError(`Unknown curve: ${jwk.crv}. Must be ${names}`, 'ERR_INVALID_CURVE')\n  }\n\n  const byteLen = curveLengths[jwk.crv]\n\n  return uint8ArrayConcat([\n    Uint8Array.from([4]), // uncompressed point\n    base64urlToBuffer(jwk.x, byteLen),\n    base64urlToBuffer(jwk.y, byteLen)\n  ], 1 + byteLen * 2)\n}\n\n// Unmarshal converts a point, serialized by Marshal, into an jwk encoded key\nfunction unmarshalPublicKey (curve: string, key: Uint8Array): JWKEncodedPublicKey {\n  if (curve !== 'P-256' && curve !== 'P-384' && curve !== 'P-521') {\n    throw new CodeError(`Unknown curve: ${curve}. Must be ${names}`, 'ERR_INVALID_CURVE')\n  }\n\n  const byteLen = curveLengths[curve]\n\n  if (!uint8ArrayEquals(key.subarray(0, 1), Uint8Array.from([4]))) {\n    throw new CodeError('Cannot unmarshal public key - invalid key format', 'ERR_INVALID_KEY_FORMAT')\n  }\n\n  return {\n    kty: 'EC',\n    crv: curve,\n    x: uint8ArrayToString(key.subarray(1, byteLen + 1), 'base64url'),\n    y: uint8ArrayToString(key.subarray(1 + byteLen), 'base64url'),\n    ext: true\n  }\n}\n\nconst unmarshalPrivateKey = (curve: string, key: ECDHKeyPair): JWKEncodedPrivateKey => ({\n  ...unmarshalPublicKey(curve, key.public),\n  d: uint8ArrayToString(key.private, 'base64url')\n})\n", "import { base64 } from 'multiformats/bases/base64'\nimport * as ciphers from '../ciphers/aes-gcm.js'\n\n/**\n * Attempts to decrypt a base64 encoded PrivateKey string\n * with the given password. The privateKey must have been exported\n * using the same password and underlying cipher (aes-gcm)\n */\nexport async function importer (privateKey: string, password: string): Promise<Uint8Array> {\n  const encryptedKey = base64.decode(privateKey)\n  const cipher = ciphers.create()\n  return cipher.decrypt(encryptedKey, password)\n}\n", "import { CodeError } from '@libp2p/interface/errors'\nimport { sha256 } from 'multiformats/hashes/sha2'\n// @ts-expect-error types are missing\nimport forge from 'node-forge/lib/forge.js'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport 'node-forge/lib/sha512.js'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { exporter } from './exporter.js'\nimport * as pbm from './keys.js'\nimport * as crypto from './rsa.js'\nimport type { Multibase } from 'multiformats'\n\nexport const MAX_KEY_SIZE = 8192\n\nexport class RsaPublicKey {\n  private readonly _key: JsonWebKey\n\n  constructor (key: JsonWebKey) {\n    this._key = key\n  }\n\n  async verify (data: Uint8Array, sig: Uint8Array): Promise<boolean> {\n    return crypto.hashAndVerify(this._key, sig, data)\n  }\n\n  marshal (): Uint8Array {\n    return crypto.utils.jwkToPkix(this._key)\n  }\n\n  get bytes (): Uint8Array {\n    return pbm.PublicKey.encode({\n      Type: pbm.KeyType.RSA,\n      Data: this.marshal()\n    }).subarray()\n  }\n\n  encrypt (bytes: Uint8Array): Uint8Array {\n    return crypto.encrypt(this._key, bytes)\n  }\n\n  equals (key: any): boolean {\n    return uint8ArrayEquals(this.bytes, key.bytes)\n  }\n\n  async hash (): Promise<Uint8Array> {\n    const { bytes } = await sha256.digest(this.bytes)\n\n    return bytes\n  }\n}\n\nexport class RsaPrivateKey {\n  private readonly _key: JsonWebKey\n  private readonly _publicKey: JsonWebKey\n\n  constructor (key: JsonWebKey, publicKey: JsonWebKey) {\n    this._key = key\n    this._publicKey = publicKey\n  }\n\n  genSecret (): Uint8Array {\n    return crypto.getRandomValues(16)\n  }\n\n  async sign (message: Uint8Array): Promise<Uint8Array> {\n    return crypto.hashAndSign(this._key, message)\n  }\n\n  get public (): RsaPublicKey {\n    if (this._publicKey == null) {\n      throw new CodeError('public key not provided', 'ERR_PUBKEY_NOT_PROVIDED')\n    }\n\n    return new RsaPublicKey(this._publicKey)\n  }\n\n  decrypt (bytes: Uint8Array): Uint8Array {\n    return crypto.decrypt(this._key, bytes)\n  }\n\n  marshal (): Uint8Array {\n    return crypto.utils.jwkToPkcs1(this._key)\n  }\n\n  get bytes (): Uint8Array {\n    return pbm.PrivateKey.encode({\n      Type: pbm.KeyType.RSA,\n      Data: this.marshal()\n    }).subarray()\n  }\n\n  equals (key: any): boolean {\n    return uint8ArrayEquals(this.bytes, key.bytes)\n  }\n\n  async hash (): Promise<Uint8Array> {\n    const { bytes } = await sha256.digest(this.bytes)\n\n    return bytes\n  }\n\n  /**\n   * Gets the ID of the key.\n   *\n   * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n   * The public key is a protobuf encoding containing a type and the DER encoding\n   * of the PKCS SubjectPublicKeyInfo.\n   */\n  async id (): Promise<string> {\n    const hash = await this.public.hash()\n    return uint8ArrayToString(hash, 'base58btc')\n  }\n\n  /**\n   * Exports the key into a password protected PEM format\n   */\n  async export (password: string, format = 'pkcs-8'): Promise<Multibase<'m'>> {\n    if (format === 'pkcs-8') {\n      const buffer = new forge.util.ByteBuffer(this.marshal())\n      const asn1 = forge.asn1.fromDer(buffer)\n      const privateKey = forge.pki.privateKeyFromAsn1(asn1)\n\n      const options = {\n        algorithm: 'aes256',\n        count: 10000,\n        saltSize: 128 / 8,\n        prfAlgorithm: 'sha512'\n      }\n      return forge.pki.encryptRsaPrivateKey(privateKey, password, options)\n    } else if (format === 'libp2p-key') {\n      return exporter(this.bytes, password)\n    } else {\n      throw new CodeError(`export format '${format}' is not supported`, 'ERR_INVALID_EXPORT_FORMAT')\n    }\n  }\n}\n\nexport async function unmarshalRsaPrivateKey (bytes: Uint8Array): Promise<RsaPrivateKey> {\n  const jwk = crypto.utils.pkcs1ToJwk(bytes)\n\n  if (crypto.keySize(jwk) > MAX_KEY_SIZE) {\n    throw new CodeError('key size is too large', 'ERR_KEY_SIZE_TOO_LARGE')\n  }\n\n  const keys = await crypto.unmarshalPrivateKey(jwk)\n\n  return new RsaPrivateKey(keys.privateKey, keys.publicKey)\n}\n\nexport function unmarshalRsaPublicKey (bytes: Uint8Array): RsaPublicKey {\n  const jwk = crypto.utils.pkixToJwk(bytes)\n\n  if (crypto.keySize(jwk) > MAX_KEY_SIZE) {\n    throw new CodeError('key size is too large', 'ERR_KEY_SIZE_TOO_LARGE')\n  }\n\n  return new RsaPublicKey(jwk)\n}\n\nexport async function fromJwk (jwk: JsonWebKey): Promise<RsaPrivateKey> {\n  if (crypto.keySize(jwk) > MAX_KEY_SIZE) {\n    throw new CodeError('key size is too large', 'ERR_KEY_SIZE_TOO_LARGE')\n  }\n\n  const keys = await crypto.unmarshalPrivateKey(jwk)\n\n  return new RsaPrivateKey(keys.privateKey, keys.publicKey)\n}\n\nexport async function generateKeyPair (bits: number): Promise<RsaPrivateKey> {\n  if (bits > MAX_KEY_SIZE) {\n    throw new CodeError('key size is too large', 'ERR_KEY_SIZE_TOO_LARGE')\n  }\n\n  const keys = await crypto.generateKey(bits)\n\n  return new RsaPrivateKey(keys.privateKey, keys.publicKey)\n}\n", "import { CodeError } from '@libp2p/interface/errors'\nimport { randomBytes as randB } from '@noble/hashes/utils'\n\n/**\n * Generates a Uint8Array with length `number` populated by random bytes\n */\nexport default function randomBytes (length: number): Uint8Array {\n  if (isNaN(length) || length <= 0) {\n    throw new CodeError('random bytes length must be a Number bigger than 0', 'ERR_INVALID_LENGTH')\n  }\n  return randB(length)\n}\n", "import 'node-forge/lib/rsa.js'\n// @ts-expect-error types are missing\nimport forge from 'node-forge/lib/forge.js'\nimport { base64urlToBigInteger } from '../util.js'\n\nexport interface JWK {\n  encrypt(msg: string): string\n  decrypt(msg: string): string\n}\n\nfunction convert (key: any, types: string[]): Array<typeof forge.jsbn.BigInteger> {\n  return types.map(t => base64urlToBigInteger(key[t]))\n}\n\nexport function jwk2priv (key: JsonWebKey): JWK {\n  return forge.pki.setRsaPrivateKey(...convert(key, ['n', 'e', 'd', 'p', 'q', 'dp', 'dq', 'qi']))\n}\n\nexport function jwk2pub (key: JsonWebKey): JWK {\n  return forge.pki.setRsaPublicKey(...convert(key, ['n', 'e']))\n}\n", "import 'node-forge/lib/asn1.js'\nimport 'node-forge/lib/rsa.js'\nimport { CodeError } from '@libp2p/interface/errors'\n// @ts-expect-error types are missing\nimport forge from 'node-forge/lib/forge.js'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { bigIntegerToUintBase64url, base64urlToBigInteger } from './../util.js'\n\n// Convert a PKCS#1 in ASN1 DER format to a JWK key\nexport function pkcs1ToJwk (bytes: Uint8Array): JsonWebKey {\n  const asn1 = forge.asn1.fromDer(uint8ArrayToString(bytes, 'ascii'))\n  const privateKey = forge.pki.privateKeyFromAsn1(asn1)\n\n  // https://tools.ietf.org/html/rfc7518#section-6.3.1\n  return {\n    kty: 'RSA',\n    n: bigIntegerToUintBase64url(privateKey.n),\n    e: bigIntegerToUintBase64url(privateKey.e),\n    d: bigIntegerToUintBase64url(privateKey.d),\n    p: bigIntegerToUintBase64url(privateKey.p),\n    q: bigIntegerToUintBase64url(privateKey.q),\n    dp: bigIntegerToUintBase64url(privateKey.dP),\n    dq: bigIntegerToUintBase64url(privateKey.dQ),\n    qi: bigIntegerToUintBase64url(privateKey.qInv),\n    alg: 'RS256'\n  }\n}\n\n// Convert a JWK key into PKCS#1 in ASN1 DER format\nexport function jwkToPkcs1 (jwk: JsonWebKey): Uint8Array {\n  if (jwk.n == null || jwk.e == null || jwk.d == null || jwk.p == null || jwk.q == null || jwk.dp == null || jwk.dq == null || jwk.qi == null) {\n    throw new CodeError('JWK was missing components', 'ERR_INVALID_PARAMETERS')\n  }\n\n  const asn1 = forge.pki.privateKeyToAsn1({\n    n: base64urlToBigInteger(jwk.n),\n    e: base64urlToBigInteger(jwk.e),\n    d: base64urlToBigInteger(jwk.d),\n    p: base64urlToBigInteger(jwk.p),\n    q: base64urlToBigInteger(jwk.q),\n    dP: base64urlToBigInteger(jwk.dp),\n    dQ: base64urlToBigInteger(jwk.dq),\n    qInv: base64urlToBigInteger(jwk.qi)\n  })\n\n  return uint8ArrayFromString(forge.asn1.toDer(asn1).getBytes(), 'ascii')\n}\n\n// Convert a PKCIX in ASN1 DER format to a JWK key\nexport function pkixToJwk (bytes: Uint8Array): JsonWebKey {\n  const asn1 = forge.asn1.fromDer(uint8ArrayToString(bytes, 'ascii'))\n  const publicKey = forge.pki.publicKeyFromAsn1(asn1)\n\n  return {\n    kty: 'RSA',\n    n: bigIntegerToUintBase64url(publicKey.n),\n    e: bigIntegerToUintBase64url(publicKey.e)\n  }\n}\n\n// Convert a JWK key to PKCIX in ASN1 DER format\nexport function jwkToPkix (jwk: JsonWebKey): Uint8Array {\n  if (jwk.n == null || jwk.e == null) {\n    throw new CodeError('JWK was missing components', 'ERR_INVALID_PARAMETERS')\n  }\n\n  const asn1 = forge.pki.publicKeyToAsn1({\n    n: base64urlToBigInteger(jwk.n),\n    e: base64urlToBigInteger(jwk.e)\n  })\n\n  return uint8ArrayFromString(forge.asn1.toDer(asn1).getBytes(), 'ascii')\n}\n", "import { CodeError } from '@libp2p/interface/errors'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport randomBytes from '../random-bytes.js'\nimport webcrypto from '../webcrypto.js'\nimport { jwk2pub, jwk2priv } from './jwk2pem.js'\nimport * as utils from './rsa-utils.js'\nimport type { JWKKeyPair } from './interface.js'\n\nexport { utils }\n\nexport async function generateKey (bits: number): Promise<JWKKeyPair> {\n  const pair = await webcrypto.get().subtle.generateKey(\n    {\n      name: 'RSASSA-PKCS1-v1_5',\n      modulusLength: bits,\n      publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n      hash: { name: 'SHA-256' }\n    },\n    true,\n    ['sign', 'verify']\n  )\n\n  const keys = await exportKey(pair)\n\n  return {\n    privateKey: keys[0],\n    publicKey: keys[1]\n  }\n}\n\n// Takes a jwk key\nexport async function unmarshalPrivateKey (key: JsonWebKey): Promise<JWKKeyPair> {\n  const privateKey = await webcrypto.get().subtle.importKey(\n    'jwk',\n    key,\n    {\n      name: 'RSASSA-PKCS1-v1_5',\n      hash: { name: 'SHA-256' }\n    },\n    true,\n    ['sign']\n  )\n\n  const pair = [\n    privateKey,\n    await derivePublicFromPrivate(key)\n  ]\n\n  const keys = await exportKey({\n    privateKey: pair[0],\n    publicKey: pair[1]\n  })\n\n  return {\n    privateKey: keys[0],\n    publicKey: keys[1]\n  }\n}\n\nexport { randomBytes as getRandomValues }\n\nexport async function hashAndSign (key: JsonWebKey, msg: Uint8Array): Promise<Uint8Array> {\n  const privateKey = await webcrypto.get().subtle.importKey(\n    'jwk',\n    key,\n    {\n      name: 'RSASSA-PKCS1-v1_5',\n      hash: { name: 'SHA-256' }\n    },\n    false,\n    ['sign']\n  )\n\n  const sig = await webcrypto.get().subtle.sign(\n    { name: 'RSASSA-PKCS1-v1_5' },\n    privateKey,\n    Uint8Array.from(msg)\n  )\n\n  return new Uint8Array(sig, 0, sig.byteLength)\n}\n\nexport async function hashAndVerify (key: JsonWebKey, sig: Uint8Array, msg: Uint8Array): Promise<boolean> {\n  const publicKey = await webcrypto.get().subtle.importKey(\n    'jwk',\n    key,\n    {\n      name: 'RSASSA-PKCS1-v1_5',\n      hash: { name: 'SHA-256' }\n    },\n    false,\n    ['verify']\n  )\n\n  return webcrypto.get().subtle.verify(\n    { name: 'RSASSA-PKCS1-v1_5' },\n    publicKey,\n    sig,\n    msg\n  )\n}\n\nasync function exportKey (pair: CryptoKeyPair): Promise<[JsonWebKey, JsonWebKey]> {\n  if (pair.privateKey == null || pair.publicKey == null) {\n    throw new CodeError('Private and public key are required', 'ERR_INVALID_PARAMETERS')\n  }\n\n  return Promise.all([\n    webcrypto.get().subtle.exportKey('jwk', pair.privateKey),\n    webcrypto.get().subtle.exportKey('jwk', pair.publicKey)\n  ])\n}\n\nasync function derivePublicFromPrivate (jwKey: JsonWebKey): Promise<CryptoKey> {\n  return webcrypto.get().subtle.importKey(\n    'jwk',\n    {\n      kty: jwKey.kty,\n      n: jwKey.n,\n      e: jwKey.e\n    },\n    {\n      name: 'RSASSA-PKCS1-v1_5',\n      hash: { name: 'SHA-256' }\n    },\n    true,\n    ['verify']\n  )\n}\n\n/*\n\nRSA encryption/decryption for the browser with webcrypto workaround\n\"bloody dark magic. webcrypto's why.\"\n\nExplanation:\n  - Convert JWK to nodeForge\n  - Convert msg Uint8Array to nodeForge buffer: ByteBuffer is a \"binary-string backed buffer\", so let's make our Uint8Array a binary string\n  - Convert resulting nodeForge buffer to Uint8Array: it returns a binary string, turn that into a Uint8Array\n\n*/\n\nfunction convertKey (key: JsonWebKey, pub: boolean, msg: Uint8Array, handle: (msg: string, key: { encrypt(msg: string): string, decrypt(msg: string): string }) => string): Uint8Array {\n  const fkey = pub ? jwk2pub(key) : jwk2priv(key)\n  const fmsg = uint8ArrayToString(Uint8Array.from(msg), 'ascii')\n  const fomsg = handle(fmsg, fkey)\n  return uint8ArrayFromString(fomsg, 'ascii')\n}\n\nexport function encrypt (key: JsonWebKey, msg: Uint8Array): Uint8Array {\n  return convertKey(key, true, msg, (msg, key) => key.encrypt(msg))\n}\n\nexport function decrypt (key: JsonWebKey, msg: Uint8Array): Uint8Array {\n  return convertKey(key, false, msg, (msg, key) => key.decrypt(msg))\n}\n\nexport function keySize (jwk: JsonWebKey): number {\n  if (jwk.kty !== 'RSA') {\n    throw new CodeError('invalid key type', 'ERR_INVALID_KEY_TYPE')\n  } else if (jwk.n == null) {\n    throw new CodeError('invalid key modulus', 'ERR_INVALID_KEY_MODULUS')\n  }\n  const bytes = uint8ArrayFromString(jwk.n, 'base64url')\n  return bytes.length * 8\n}\n", "import { CodeError } from '@libp2p/interface/errors'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { exporter } from './exporter.js'\nimport * as keysProtobuf from './keys.js'\nimport * as crypto from './secp256k1.js'\nimport type { Multibase } from 'multiformats'\n\nexport class Secp256k1PublicKey {\n  private readonly _key: Uint8Array\n\n  constructor (key: Uint8Array) {\n    crypto.validatePublicKey(key)\n    this._key = key\n  }\n\n  async verify (data: Uint8Array, sig: Uint8Array): Promise<boolean> {\n    return crypto.hashAndVerify(this._key, sig, data)\n  }\n\n  marshal (): Uint8Array {\n    return crypto.compressPublicKey(this._key)\n  }\n\n  get bytes (): Uint8Array {\n    return keysProtobuf.PublicKey.encode({\n      Type: keysProtobuf.KeyType.Secp256k1,\n      Data: this.marshal()\n    }).subarray()\n  }\n\n  equals (key: any): boolean {\n    return uint8ArrayEquals(this.bytes, key.bytes)\n  }\n\n  async hash (): Promise<Uint8Array> {\n    const { bytes } = await sha256.digest(this.bytes)\n\n    return bytes\n  }\n}\n\nexport class Secp256k1PrivateKey {\n  private readonly _key: Uint8Array\n  private readonly _publicKey: Uint8Array\n\n  constructor (key: Uint8Array, publicKey?: Uint8Array) {\n    this._key = key\n    this._publicKey = publicKey ?? crypto.computePublicKey(key)\n    crypto.validatePrivateKey(this._key)\n    crypto.validatePublicKey(this._publicKey)\n  }\n\n  async sign (message: Uint8Array): Promise<Uint8Array> {\n    return crypto.hashAndSign(this._key, message)\n  }\n\n  get public (): Secp256k1PublicKey {\n    return new Secp256k1PublicKey(this._publicKey)\n  }\n\n  marshal (): Uint8Array {\n    return this._key\n  }\n\n  get bytes (): Uint8Array {\n    return keysProtobuf.PrivateKey.encode({\n      Type: keysProtobuf.KeyType.Secp256k1,\n      Data: this.marshal()\n    }).subarray()\n  }\n\n  equals (key: any): boolean {\n    return uint8ArrayEquals(this.bytes, key.bytes)\n  }\n\n  async hash (): Promise<Uint8Array> {\n    const { bytes } = await sha256.digest(this.bytes)\n\n    return bytes\n  }\n\n  /**\n   * Gets the ID of the key.\n   *\n   * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n   * The public key is a protobuf encoding containing a type and the DER encoding\n   * of the PKCS SubjectPublicKeyInfo.\n   */\n  async id (): Promise<string> {\n    const hash = await this.public.hash()\n    return uint8ArrayToString(hash, 'base58btc')\n  }\n\n  /**\n   * Exports the key into a password protected `format`\n   */\n  async export (password: string, format = 'libp2p-key'): Promise<Multibase<'m'>> {\n    if (format === 'libp2p-key') {\n      return exporter(this.bytes, password)\n    } else {\n      throw new CodeError(`export format '${format}' is not supported`, 'ERR_INVALID_EXPORT_FORMAT')\n    }\n  }\n}\n\nexport function unmarshalSecp256k1PrivateKey (bytes: Uint8Array): Secp256k1PrivateKey {\n  return new Secp256k1PrivateKey(bytes)\n}\n\nexport function unmarshalSecp256k1PublicKey (bytes: Uint8Array): Secp256k1PublicKey {\n  return new Secp256k1PublicKey(bytes)\n}\n\nexport async function generateKeyPair (): Promise<Secp256k1PrivateKey> {\n  const privateKeyBytes = crypto.generateKey()\n  return new Secp256k1PrivateKey(privateKeyBytes)\n}\n", "import { CodeError } from '@libp2p/interface/errors'\nimport { secp256k1 as secp } from '@noble/curves/secp256k1'\nimport { sha256 } from 'multiformats/hashes/sha2'\n\nconst PRIVATE_KEY_BYTE_LENGTH = 32\n\nexport { PRIVATE_KEY_BYTE_LENGTH as privateKeyLength }\n\nexport function generateKey (): Uint8Array {\n  return secp.utils.randomPrivateKey()\n}\n\n/**\n * Hash and sign message with private key\n */\nexport async function hashAndSign (key: Uint8Array, msg: Uint8Array): Promise<Uint8Array> {\n  const { digest } = await sha256.digest(msg)\n  try {\n    const signature = secp.sign(digest, key)\n    return signature.toDERRawBytes()\n  } catch (err) {\n    throw new CodeError(String(err), 'ERR_INVALID_INPUT')\n  }\n}\n\n/**\n * Hash message and verify signature with public key\n */\nexport async function hashAndVerify (key: Uint8Array, sig: Uint8Array, msg: Uint8Array): Promise<boolean> {\n  try {\n    const { digest } = await sha256.digest(msg)\n    return secp.verify(sig, digest, key)\n  } catch (err) {\n    throw new CodeError(String(err), 'ERR_INVALID_INPUT')\n  }\n}\n\nexport function compressPublicKey (key: Uint8Array): Uint8Array {\n  const point = secp.ProjectivePoint.fromHex(key).toRawBytes(true)\n  return point\n}\n\nexport function decompressPublicKey (key: Uint8Array): Uint8Array {\n  const point = secp.ProjectivePoint.fromHex(key).toRawBytes(false)\n  return point\n}\n\nexport function validatePrivateKey (key: Uint8Array): void {\n  try {\n    secp.getPublicKey(key, true)\n  } catch (err) {\n    throw new CodeError(String(err), 'ERR_INVALID_PRIVATE_KEY')\n  }\n}\n\nexport function validatePublicKey (key: Uint8Array): void {\n  try {\n    secp.ProjectivePoint.fromHex(key)\n  } catch (err) {\n    throw new CodeError(String(err), 'ERR_INVALID_PUBLIC_KEY')\n  }\n}\n\nexport function computePublicKey (privateKey: Uint8Array): Uint8Array {\n  try {\n    return secp.getPublicKey(privateKey, true)\n  } catch (err) {\n    throw new CodeError(String(err), 'ERR_INVALID_PRIVATE_KEY')\n  }\n}\n", "/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nimport { encodeMessage, decodeMessage, message } from 'protons-runtime'\nimport type { Codec } from 'protons-runtime'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface NoiseExtensions {\n  webtransportCerthashes: Uint8Array[]\n}\n\nexport namespace NoiseExtensions {\n  let _codec: Codec<NoiseExtensions>\n\n  export const codec = (): Codec<NoiseExtensions> => {\n    if (_codec == null) {\n      _codec = message<NoiseExtensions>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.webtransportCerthashes != null) {\n          for (const value of obj.webtransportCerthashes) {\n            w.uint32(10)\n            w.bytes(value)\n          }\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {\n          webtransportCerthashes: []\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.webtransportCerthashes.push(reader.bytes())\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<NoiseExtensions>): Uint8Array => {\n    return encodeMessage(obj, NoiseExtensions.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): NoiseExtensions => {\n    return decodeMessage(buf, NoiseExtensions.codec())\n  }\n}\n\nexport interface NoiseHandshakePayload {\n  identityKey: Uint8Array\n  identitySig: Uint8Array\n  extensions?: NoiseExtensions\n}\n\nexport namespace NoiseHandshakePayload {\n  let _codec: Codec<NoiseHandshakePayload>\n\n  export const codec = (): Codec<NoiseHandshakePayload> => {\n    if (_codec == null) {\n      _codec = message<NoiseHandshakePayload>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (opts.writeDefaults === true || (obj.identityKey != null && obj.identityKey.byteLength > 0)) {\n          w.uint32(10)\n          w.bytes(obj.identityKey ?? new Uint8Array(0))\n        }\n\n        if (opts.writeDefaults === true || (obj.identitySig != null && obj.identitySig.byteLength > 0)) {\n          w.uint32(18)\n          w.bytes(obj.identitySig ?? new Uint8Array(0))\n        }\n\n        if (obj.extensions != null) {\n          w.uint32(34)\n          NoiseExtensions.codec().encode(obj.extensions, w, {\n            writeDefaults: false\n          })\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {\n          identityKey: new Uint8Array(0),\n          identitySig: new Uint8Array(0)\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.identityKey = reader.bytes()\n              break\n            case 2:\n              obj.identitySig = reader.bytes()\n              break\n            case 4:\n              obj.extensions = NoiseExtensions.codec().decode(reader, reader.uint32())\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<NoiseHandshakePayload>): Uint8Array => {\n    return encodeMessage(obj, NoiseHandshakePayload.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): NoiseHandshakePayload => {\n    return decodeMessage(buf, NoiseHandshakePayload.codec())\n  }\n}\n", "import { unmarshalPublicKey, unmarshalPrivateKey } from '@libp2p/crypto/keys'\nimport { peerIdFromKeys } from '@libp2p/peer-id'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { type NoiseExtensions, NoiseHandshakePayload } from './proto/payload.js'\nimport type { bytes } from './@types/basic.js'\nimport type { PeerId } from '@libp2p/interface/peer-id'\n\nexport async function getPayload (\n  localPeer: PeerId,\n  staticPublicKey: bytes,\n  extensions?: NoiseExtensions\n): Promise<bytes> {\n  const signedPayload = await signPayload(localPeer, getHandshakePayload(staticPublicKey))\n\n  if (localPeer.publicKey == null) {\n    throw new Error('PublicKey was missing from local PeerId')\n  }\n\n  return createHandshakePayload(\n    localPeer.publicKey,\n    signedPayload,\n    extensions\n  )\n}\n\nexport function createHandshakePayload (\n  libp2pPublicKey: Uint8Array,\n  signedPayload: Uint8Array,\n  extensions?: NoiseExtensions\n): bytes {\n  return NoiseHandshakePayload.encode({\n    identityKey: libp2pPublicKey,\n    identitySig: signedPayload,\n    extensions: extensions ?? { webtransportCerthashes: [] }\n  }).subarray()\n}\n\nexport async function signPayload (peerId: PeerId, payload: bytes): Promise<bytes> {\n  if (peerId.privateKey == null) {\n    throw new Error('PrivateKey was missing from PeerId')\n  }\n\n  const privateKey = await unmarshalPrivateKey(peerId.privateKey)\n\n  return privateKey.sign(payload)\n}\n\nexport async function getPeerIdFromPayload (payload: NoiseHandshakePayload): Promise<PeerId> {\n  return peerIdFromKeys(payload.identityKey)\n}\n\nexport function decodePayload (payload: bytes | Uint8Array): NoiseHandshakePayload {\n  return NoiseHandshakePayload.decode(payload)\n}\n\nexport function getHandshakePayload (publicKey: bytes): bytes {\n  const prefix = uint8ArrayFromString('noise-libp2p-static-key:')\n  return uint8ArrayConcat([prefix, publicKey], prefix.length + publicKey.length)\n}\n\n/**\n * Verifies signed payload, throws on any irregularities.\n *\n * @param {bytes} noiseStaticKey - owner's noise static key\n * @param {bytes} payload - decoded payload\n * @param {PeerId} remotePeer - owner's libp2p peer ID\n * @returns {Promise<PeerId>} - peer ID of payload owner\n */\nexport async function verifySignedPayload (\n  noiseStaticKey: bytes,\n  payload: NoiseHandshakePayload,\n  remotePeer: PeerId\n): Promise<PeerId> {\n  // Unmarshaling from PublicKey protobuf\n  const payloadPeerId = await peerIdFromKeys(payload.identityKey)\n  if (!payloadPeerId.equals(remotePeer)) {\n    throw new Error(`Payload identity key ${payloadPeerId.toString()} does not match expected remote peer ${remotePeer.toString()}`)\n  }\n  const generatedPayload = getHandshakePayload(noiseStaticKey)\n\n  if (payloadPeerId.publicKey == null) {\n    throw new Error('PublicKey was missing from PeerId')\n  }\n\n  if (payload.identitySig == null) {\n    throw new Error('Signature was missing from message')\n  }\n\n  const publicKey = unmarshalPublicKey(payloadPeerId.publicKey)\n\n  const valid = await publicKey.verify(generatedPayload, payload.identitySig)\n\n  if (!valid) {\n    throw new Error(\"Static key doesn't match to peer that signed payload!\")\n  }\n\n  return payloadPeerId\n}\n\nexport function isValidPublicKey (pk: bytes): boolean {\n  if (!(pk instanceof Uint8Array)) {\n    return false\n  }\n\n  if (pk.length !== 32) {\n    return false\n  }\n\n  return true\n}\n", "import { type Logger, logger } from '@libp2p/logger'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { DUMP_SESSION_KEYS } from './constants.js'\nimport type { NoiseSession } from './@types/handshake.js'\nimport type { KeyPair } from './@types/libp2p.js'\n\nconst log = logger('libp2p:noise')\n\nexport { log as logger }\n\nlet keyLogger: Logger\nif (DUMP_SESSION_KEYS) {\n  keyLogger = log\n} else {\n  keyLogger = Object.assign(() => { /* do nothing */ }, {\n    enabled: false,\n    trace: () => {},\n    error: () => {}\n  })\n}\n\nexport function logLocalStaticKeys (s: KeyPair): void {\n  keyLogger(`LOCAL_STATIC_PUBLIC_KEY ${uint8ArrayToString(s.publicKey, 'hex')}`)\n  keyLogger(`LOCAL_STATIC_PRIVATE_KEY ${uint8ArrayToString(s.privateKey, 'hex')}`)\n}\n\nexport function logLocalEphemeralKeys (e: KeyPair | undefined): void {\n  if (e) {\n    keyLogger(`LOCAL_PUBLIC_EPHEMERAL_KEY ${uint8ArrayToString(e.publicKey, 'hex')}`)\n    keyLogger(`LOCAL_PRIVATE_EPHEMERAL_KEY ${uint8ArrayToString(e.privateKey, 'hex')}`)\n  } else {\n    keyLogger('Missing local ephemeral keys.')\n  }\n}\n\nexport function logRemoteStaticKey (rs: Uint8Array): void {\n  keyLogger(`REMOTE_STATIC_PUBLIC_KEY ${uint8ArrayToString(rs, 'hex')}`)\n}\n\nexport function logRemoteEphemeralKey (re: Uint8Array): void {\n  keyLogger(`REMOTE_EPHEMERAL_PUBLIC_KEY ${uint8ArrayToString(re, 'hex')}`)\n}\n\nexport function logCipherState (session: NoiseSession): void {\n  if (session.cs1 && session.cs2) {\n    keyLogger(`CIPHER_STATE_1 ${session.cs1.n.getUint64()} ${uint8ArrayToString(session.cs1.k, 'hex')}`)\n    keyLogger(`CIPHER_STATE_2 ${session.cs2.n.getUint64()} ${uint8ArrayToString(session.cs2.k, 'hex')}`)\n  } else {\n    keyLogger('Missing cipher state.')\n  }\n}\n", "import type { bytes, uint64 } from './@types/basic.js'\n\nexport const MIN_NONCE = 0\n// For performance reasons, the nonce is represented as a JS `number`\n// Although JS `number` can safely represent integers up to 2 ** 53 - 1, we choose to only use\n// 4 bytes to store the data for performance reason.\n// This is a slight deviation from the noise spec, which describes the max nonce as 2 ** 64 - 2\n// The effect is that this implementation will need a new handshake to be performed after fewer messages are exchanged than other implementations with full uint64 nonces.\n// this MAX_NONCE is still a large number of messages, so the practical effect of this is negligible.\nexport const MAX_NONCE = 0xffffffff\n\nconst ERR_MAX_NONCE = 'Cipherstate has reached maximum n, a new handshake must be performed'\n\n/**\n * The nonce is an uint that's increased over time.\n * Maintaining different representations help improve performance.\n */\nexport class Nonce {\n  private n: uint64\n  private readonly bytes: bytes\n  private readonly view: DataView\n\n  constructor (n = MIN_NONCE) {\n    this.n = n\n    this.bytes = new Uint8Array(12)\n    this.view = new DataView(this.bytes.buffer, this.bytes.byteOffset, this.bytes.byteLength)\n    this.view.setUint32(4, n, true)\n  }\n\n  increment (): void {\n    this.n++\n    // Even though we're treating the nonce as 8 bytes, RFC7539 specifies 12 bytes for a nonce.\n    this.view.setUint32(4, this.n, true)\n  }\n\n  getBytes (): bytes {\n    return this.bytes\n  }\n\n  getUint64 (): uint64 {\n    return this.n\n  }\n\n  assertValue (): void {\n    if (this.n > MAX_NONCE) {\n      throw new Error(ERR_MAX_NONCE)\n    }\n  }\n}\n", "import { fromString as uint8ArrayFromString } from 'uint8arrays'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { logger } from '../logger.js'\nimport { Nonce } from '../nonce.js'\nimport type { bytes, bytes32 } from '../@types/basic.js'\nimport type { CipherState, MessageBuffer, SymmetricState } from '../@types/handshake.js'\nimport type { ICryptoInterface } from '../crypto.js'\n\nexport interface DecryptedResult {\n  plaintext: bytes\n  valid: boolean\n}\n\nexport interface SplitState {\n  cs1: CipherState\n  cs2: CipherState\n}\n\nexport abstract class AbstractHandshake {\n  public crypto: ICryptoInterface\n\n  constructor (crypto: ICryptoInterface) {\n    this.crypto = crypto\n  }\n\n  public encryptWithAd (cs: CipherState, ad: Uint8Array, plaintext: Uint8Array): bytes {\n    const e = this.encrypt(cs.k, cs.n, ad, plaintext)\n    cs.n.increment()\n\n    return e\n  }\n\n  public decryptWithAd (cs: CipherState, ad: Uint8Array, ciphertext: Uint8Array, dst?: Uint8Array): DecryptedResult {\n    const { plaintext, valid } = this.decrypt(cs.k, cs.n, ad, ciphertext, dst)\n    if (valid) cs.n.increment()\n\n    return { plaintext, valid }\n  }\n\n  // Cipher state related\n  protected hasKey (cs: CipherState): boolean {\n    return !this.isEmptyKey(cs.k)\n  }\n\n  protected createEmptyKey (): bytes32 {\n    return new Uint8Array(32)\n  }\n\n  protected isEmptyKey (k: bytes32): boolean {\n    const emptyKey = this.createEmptyKey()\n    return uint8ArrayEquals(emptyKey, k)\n  }\n\n  protected encrypt (k: bytes32, n: Nonce, ad: Uint8Array, plaintext: Uint8Array): bytes {\n    n.assertValue()\n\n    return this.crypto.chaCha20Poly1305Encrypt(plaintext, n.getBytes(), ad, k)\n  }\n\n  protected encryptAndHash (ss: SymmetricState, plaintext: bytes): bytes {\n    let ciphertext\n    if (this.hasKey(ss.cs)) {\n      ciphertext = this.encryptWithAd(ss.cs, ss.h, plaintext)\n    } else {\n      ciphertext = plaintext\n    }\n\n    this.mixHash(ss, ciphertext)\n    return ciphertext\n  }\n\n  protected decrypt (k: bytes32, n: Nonce, ad: bytes, ciphertext: bytes, dst?: Uint8Array): DecryptedResult {\n    n.assertValue()\n\n    const encryptedMessage = this.crypto.chaCha20Poly1305Decrypt(ciphertext, n.getBytes(), ad, k, dst)\n\n    if (encryptedMessage) {\n      return {\n        plaintext: encryptedMessage,\n        valid: true\n      }\n    } else {\n      return {\n        plaintext: new Uint8Array(0),\n        valid: false\n      }\n    }\n  }\n\n  protected decryptAndHash (ss: SymmetricState, ciphertext: bytes): DecryptedResult {\n    let plaintext: bytes; let valid = true\n    if (this.hasKey(ss.cs)) {\n      ({ plaintext, valid } = this.decryptWithAd(ss.cs, ss.h, ciphertext))\n    } else {\n      plaintext = ciphertext\n    }\n\n    this.mixHash(ss, ciphertext)\n    return { plaintext, valid }\n  }\n\n  protected dh (privateKey: bytes32, publicKey: bytes32): bytes32 {\n    try {\n      const derivedU8 = this.crypto.generateX25519SharedKey(privateKey, publicKey)\n\n      if (derivedU8.length === 32) {\n        return derivedU8\n      }\n\n      return derivedU8.subarray(0, 32)\n    } catch (e) {\n      const err = e as Error\n      logger.error(err)\n      return new Uint8Array(32)\n    }\n  }\n\n  protected mixHash (ss: SymmetricState, data: bytes): void {\n    ss.h = this.getHash(ss.h, data)\n  }\n\n  protected getHash (a: Uint8Array, b: Uint8Array): bytes32 {\n    const u = this.crypto.hashSHA256(uint8ArrayConcat([a, b], a.length + b.length))\n    return u\n  }\n\n  protected mixKey (ss: SymmetricState, ikm: bytes32): void {\n    const [ck, tempK] = this.crypto.getHKDF(ss.ck, ikm)\n    ss.cs = this.initializeKey(tempK)\n    ss.ck = ck\n  }\n\n  protected initializeKey (k: bytes32): CipherState {\n    return { k, n: new Nonce() }\n  }\n\n  // Symmetric state related\n\n  protected initializeSymmetric (protocolName: string): SymmetricState {\n    const protocolNameBytes = uint8ArrayFromString(protocolName, 'utf-8')\n    const h = this.hashProtocolName(protocolNameBytes)\n\n    const ck = h\n    const key = this.createEmptyKey()\n    const cs: CipherState = this.initializeKey(key)\n\n    return { cs, ck, h }\n  }\n\n  protected hashProtocolName (protocolName: Uint8Array): bytes32 {\n    if (protocolName.length <= 32) {\n      const h = new Uint8Array(32)\n      h.set(protocolName)\n      return h\n    } else {\n      return this.getHash(protocolName, new Uint8Array(0))\n    }\n  }\n\n  protected split (ss: SymmetricState): SplitState {\n    const [tempk1, tempk2] = this.crypto.getHKDF(ss.ck, new Uint8Array(0))\n    const cs1 = this.initializeKey(tempk1)\n    const cs2 = this.initializeKey(tempk2)\n\n    return { cs1, cs2 }\n  }\n\n  protected writeMessageRegular (cs: CipherState, payload: bytes): MessageBuffer {\n    const ciphertext = this.encryptWithAd(cs, new Uint8Array(0), payload)\n    const ne = this.createEmptyKey()\n    const ns = new Uint8Array(0)\n\n    return { ne, ns, ciphertext }\n  }\n\n  protected readMessageRegular (cs: CipherState, message: MessageBuffer): DecryptedResult {\n    return this.decryptWithAd(cs, new Uint8Array(0), message.ciphertext)\n  }\n}\n", "import { isValidPublicKey } from '../utils.js'\nimport { AbstractHandshake, type DecryptedResult } from './abstract-handshake.js'\nimport type { bytes32, bytes } from '../@types/basic.js'\nimport type { CipherState, HandshakeState, MessageBuffer, NoiseSession } from '../@types/handshake.js'\nimport type { KeyPair } from '../@types/libp2p.js'\n\nexport class XX extends AbstractHandshake {\n  private initializeInitiator (prologue: bytes32, s: KeyPair, rs: bytes32, psk: bytes32): HandshakeState {\n    const name = 'Noise_XX_25519_ChaChaPoly_SHA256'\n    const ss = this.initializeSymmetric(name)\n    this.mixHash(ss, prologue)\n    const re = new Uint8Array(32)\n\n    return { ss, s, rs, psk, re }\n  }\n\n  private initializeResponder (prologue: bytes32, s: KeyPair, rs: bytes32, psk: bytes32): HandshakeState {\n    const name = 'Noise_XX_25519_ChaChaPoly_SHA256'\n    const ss = this.initializeSymmetric(name)\n    this.mixHash(ss, prologue)\n    const re = new Uint8Array(32)\n\n    return { ss, s, rs, psk, re }\n  }\n\n  private writeMessageA (hs: HandshakeState, payload: bytes, e?: KeyPair): MessageBuffer {\n    const ns = new Uint8Array(0)\n\n    if (e !== undefined) {\n      hs.e = e\n    } else {\n      hs.e = this.crypto.generateX25519KeyPair()\n    }\n\n    const ne = hs.e.publicKey\n\n    this.mixHash(hs.ss, ne)\n    const ciphertext = this.encryptAndHash(hs.ss, payload)\n\n    return { ne, ns, ciphertext }\n  }\n\n  private writeMessageB (hs: HandshakeState, payload: bytes): MessageBuffer {\n    hs.e = this.crypto.generateX25519KeyPair()\n    const ne = hs.e.publicKey\n    this.mixHash(hs.ss, ne)\n\n    this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re))\n    const spk = hs.s.publicKey\n    const ns = this.encryptAndHash(hs.ss, spk)\n\n    this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re))\n    const ciphertext = this.encryptAndHash(hs.ss, payload)\n\n    return { ne, ns, ciphertext }\n  }\n\n  private writeMessageC (hs: HandshakeState, payload: bytes): { messageBuffer: MessageBuffer, cs1: CipherState, cs2: CipherState, h: bytes } {\n    const spk = hs.s.publicKey\n    const ns = this.encryptAndHash(hs.ss, spk)\n    this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re))\n    const ciphertext = this.encryptAndHash(hs.ss, payload)\n    const ne = this.createEmptyKey()\n    const messageBuffer: MessageBuffer = { ne, ns, ciphertext }\n    const { cs1, cs2 } = this.split(hs.ss)\n\n    return { h: hs.ss.h, messageBuffer, cs1, cs2 }\n  }\n\n  private readMessageA (hs: HandshakeState, message: MessageBuffer): DecryptedResult {\n    if (isValidPublicKey(message.ne)) {\n      hs.re = message.ne\n    }\n\n    this.mixHash(hs.ss, hs.re)\n    return this.decryptAndHash(hs.ss, message.ciphertext)\n  }\n\n  private readMessageB (hs: HandshakeState, message: MessageBuffer): DecryptedResult {\n    if (isValidPublicKey(message.ne)) {\n      hs.re = message.ne\n    }\n\n    this.mixHash(hs.ss, hs.re)\n    if (!hs.e) {\n      throw new Error('Handshake state `e` param is missing.')\n    }\n    this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re))\n    const { plaintext: ns, valid: valid1 } = this.decryptAndHash(hs.ss, message.ns)\n    if (valid1 && isValidPublicKey(ns)) {\n      hs.rs = ns\n    }\n    this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs))\n    const { plaintext, valid: valid2 } = this.decryptAndHash(hs.ss, message.ciphertext)\n    return { plaintext, valid: (valid1 && valid2) }\n  }\n\n  private readMessageC (hs: HandshakeState, message: MessageBuffer): { h: bytes, plaintext: bytes, valid: boolean, cs1: CipherState, cs2: CipherState } {\n    const { plaintext: ns, valid: valid1 } = this.decryptAndHash(hs.ss, message.ns)\n    if (valid1 && isValidPublicKey(ns)) {\n      hs.rs = ns\n    }\n    if (!hs.e) {\n      throw new Error('Handshake state `e` param is missing.')\n    }\n    this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs))\n\n    const { plaintext, valid: valid2 } = this.decryptAndHash(hs.ss, message.ciphertext)\n    const { cs1, cs2 } = this.split(hs.ss)\n\n    return { h: hs.ss.h, plaintext, valid: (valid1 && valid2), cs1, cs2 }\n  }\n\n  public initSession (initiator: boolean, prologue: bytes32, s: KeyPair): NoiseSession {\n    const psk = this.createEmptyKey()\n    const rs = new Uint8Array(32) // no static key yet\n    let hs\n\n    if (initiator) {\n      hs = this.initializeInitiator(prologue, s, rs, psk)\n    } else {\n      hs = this.initializeResponder(prologue, s, rs, psk)\n    }\n\n    return {\n      hs,\n      i: initiator,\n      mc: 0\n    }\n  }\n\n  public sendMessage (session: NoiseSession, message: bytes, ephemeral?: KeyPair): MessageBuffer {\n    let messageBuffer: MessageBuffer\n    if (session.mc === 0) {\n      messageBuffer = this.writeMessageA(session.hs, message, ephemeral)\n    } else if (session.mc === 1) {\n      messageBuffer = this.writeMessageB(session.hs, message)\n    } else if (session.mc === 2) {\n      const { h, messageBuffer: resultingBuffer, cs1, cs2 } = this.writeMessageC(session.hs, message)\n      messageBuffer = resultingBuffer\n      session.h = h\n      session.cs1 = cs1\n      session.cs2 = cs2\n    } else if (session.mc > 2) {\n      if (session.i) {\n        if (!session.cs1) {\n          throw new Error('CS1 (cipher state) is not defined')\n        }\n\n        messageBuffer = this.writeMessageRegular(session.cs1, message)\n      } else {\n        if (!session.cs2) {\n          throw new Error('CS2 (cipher state) is not defined')\n        }\n\n        messageBuffer = this.writeMessageRegular(session.cs2, message)\n      }\n    } else {\n      throw new Error('Session invalid.')\n    }\n\n    session.mc++\n    return messageBuffer\n  }\n\n  public recvMessage (session: NoiseSession, message: MessageBuffer): DecryptedResult {\n    let plaintext: bytes = new Uint8Array(0)\n    let valid = false\n    if (session.mc === 0) {\n      ({ plaintext, valid } = this.readMessageA(session.hs, message))\n    } else if (session.mc === 1) {\n      ({ plaintext, valid } = this.readMessageB(session.hs, message))\n    } else if (session.mc === 2) {\n      const { h, plaintext: resultingPlaintext, valid: resultingValid, cs1, cs2 } = this.readMessageC(session.hs, message)\n      plaintext = resultingPlaintext\n      valid = resultingValid\n      session.h = h\n      session.cs1 = cs1\n      session.cs2 = cs2\n    }\n    session.mc++\n    return { plaintext, valid }\n  }\n}\n", "import { InvalidCryptoExchangeError, UnexpectedPeerError } from '@libp2p/interface/errors'\nimport { decode0, decode1, decode2, encode0, encode1, encode2 } from './encoder.js'\nimport { XX } from './handshakes/xx.js'\nimport {\n  logger,\n  logLocalStaticKeys,\n  logLocalEphemeralKeys,\n  logRemoteEphemeralKey,\n  logRemoteStaticKey,\n  logCipherState\n} from './logger.js'\nimport {\n  decodePayload,\n  getPeerIdFromPayload,\n  verifySignedPayload\n} from './utils.js'\nimport type { bytes, bytes32 } from './@types/basic.js'\nimport type { IHandshake } from './@types/handshake-interface.js'\nimport type { CipherState, NoiseSession } from './@types/handshake.js'\nimport type { KeyPair } from './@types/libp2p.js'\nimport type { ICryptoInterface } from './crypto.js'\nimport type { NoiseExtensions } from './proto/payload.js'\nimport type { PeerId } from '@libp2p/interface/peer-id'\nimport type { LengthPrefixedStream } from 'it-length-prefixed-stream'\n\nexport class XXHandshake implements IHandshake {\n  public isInitiator: boolean\n  public session: NoiseSession\n  public remotePeer!: PeerId\n  public remoteExtensions: NoiseExtensions = { webtransportCerthashes: [] }\n\n  protected payload: bytes\n  protected connection: LengthPrefixedStream\n  protected xx: XX\n  protected staticKeypair: KeyPair\n\n  private readonly prologue: bytes32\n\n  constructor (\n    isInitiator: boolean,\n    payload: bytes,\n    prologue: bytes32,\n    crypto: ICryptoInterface,\n    staticKeypair: KeyPair,\n    connection: LengthPrefixedStream,\n    remotePeer?: PeerId,\n    handshake?: XX\n  ) {\n    this.isInitiator = isInitiator\n    this.payload = payload\n    this.prologue = prologue\n    this.staticKeypair = staticKeypair\n    this.connection = connection\n    if (remotePeer) {\n      this.remotePeer = remotePeer\n    }\n    this.xx = handshake ?? new XX(crypto)\n    this.session = this.xx.initSession(this.isInitiator, this.prologue, this.staticKeypair)\n  }\n\n  // stage 0\n  public async propose (): Promise<void> {\n    logLocalStaticKeys(this.session.hs.s)\n    if (this.isInitiator) {\n      logger.trace('Stage 0 - Initiator starting to send first message.')\n      const messageBuffer = this.xx.sendMessage(this.session, new Uint8Array(0))\n      await this.connection.write(encode0(messageBuffer))\n      logger.trace('Stage 0 - Initiator finished sending first message.')\n      logLocalEphemeralKeys(this.session.hs.e)\n    } else {\n      logger.trace('Stage 0 - Responder waiting to receive first message...')\n      const receivedMessageBuffer = decode0((await this.connection.read()).subarray())\n      const { valid } = this.xx.recvMessage(this.session, receivedMessageBuffer)\n      if (!valid) {\n        throw new InvalidCryptoExchangeError('xx handshake stage 0 validation fail')\n      }\n      logger.trace('Stage 0 - Responder received first message.')\n      logRemoteEphemeralKey(this.session.hs.re)\n    }\n  }\n\n  // stage 1\n  public async exchange (): Promise<void> {\n    if (this.isInitiator) {\n      logger.trace('Stage 1 - Initiator waiting to receive first message from responder...')\n      const receivedMessageBuffer = decode1((await this.connection.read()).subarray())\n      const { plaintext, valid } = this.xx.recvMessage(this.session, receivedMessageBuffer)\n      if (!valid) {\n        throw new InvalidCryptoExchangeError('xx handshake stage 1 validation fail')\n      }\n      logger.trace('Stage 1 - Initiator received the message.')\n      logRemoteEphemeralKey(this.session.hs.re)\n      logRemoteStaticKey(this.session.hs.rs)\n\n      logger.trace(\"Initiator going to check remote's signature...\")\n      try {\n        const decodedPayload = decodePayload(plaintext)\n        this.remotePeer = this.remotePeer || await getPeerIdFromPayload(decodedPayload)\n        await verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer)\n        this.setRemoteNoiseExtension(decodedPayload.extensions)\n      } catch (e) {\n        const err = e as Error\n        throw new UnexpectedPeerError(`Error occurred while verifying signed payload: ${err.message}`)\n      }\n      logger.trace('All good with the signature!')\n    } else {\n      logger.trace('Stage 1 - Responder sending out first message with signed payload and static key.')\n      const messageBuffer = this.xx.sendMessage(this.session, this.payload)\n      await this.connection.write(encode1(messageBuffer))\n      logger.trace('Stage 1 - Responder sent the second handshake message with signed payload.')\n      logLocalEphemeralKeys(this.session.hs.e)\n    }\n  }\n\n  // stage 2\n  public async finish (): Promise<void> {\n    if (this.isInitiator) {\n      logger.trace('Stage 2 - Initiator sending third handshake message.')\n      const messageBuffer = this.xx.sendMessage(this.session, this.payload)\n      await this.connection.write(encode2(messageBuffer))\n      logger.trace('Stage 2 - Initiator sent message with signed payload.')\n    } else {\n      logger.trace('Stage 2 - Responder waiting for third handshake message...')\n      const receivedMessageBuffer = decode2((await this.connection.read()).subarray())\n      const { plaintext, valid } = this.xx.recvMessage(this.session, receivedMessageBuffer)\n      if (!valid) {\n        throw new InvalidCryptoExchangeError('xx handshake stage 2 validation fail')\n      }\n      logger.trace('Stage 2 - Responder received the message, finished handshake.')\n\n      try {\n        const decodedPayload = decodePayload(plaintext)\n        this.remotePeer = this.remotePeer || await getPeerIdFromPayload(decodedPayload)\n        await verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer)\n        this.setRemoteNoiseExtension(decodedPayload.extensions)\n      } catch (e) {\n        const err = e as Error\n        throw new UnexpectedPeerError(`Error occurred while verifying signed payload: ${err.message}`)\n      }\n    }\n    logCipherState(this.session)\n  }\n\n  public encrypt (plaintext: Uint8Array, session: NoiseSession): bytes {\n    const cs = this.getCS(session)\n\n    return this.xx.encryptWithAd(cs, new Uint8Array(0), plaintext)\n  }\n\n  public decrypt (ciphertext: Uint8Array, session: NoiseSession, dst?: Uint8Array): { plaintext: bytes, valid: boolean } {\n    const cs = this.getCS(session, false)\n\n    return this.xx.decryptWithAd(cs, new Uint8Array(0), ciphertext, dst)\n  }\n\n  public getRemoteStaticKey (): bytes {\n    return this.session.hs.rs\n  }\n\n  private getCS (session: NoiseSession, encryption = true): CipherState {\n    if (!session.cs1 || !session.cs2) {\n      throw new InvalidCryptoExchangeError('Handshake not completed properly, cipher state does not exist.')\n    }\n\n    if (this.isInitiator) {\n      return encryption ? session.cs1 : session.cs2\n    } else {\n      return encryption ? session.cs2 : session.cs1\n    }\n  }\n\n  protected setRemoteNoiseExtension (e: NoiseExtensions | null | undefined): void {\n    if (e) {\n      this.remoteExtensions = e\n    }\n  }\n}\n", "import type { Counter, Metrics } from '@libp2p/interface/metrics'\n\nexport type MetricsRegistry = Record<string, Counter>\n\nexport function registerMetrics (metrics: Metrics): MetricsRegistry {\n  return {\n    xxHandshakeSuccesses: metrics.registerCounter(\n      'libp2p_noise_xxhandshake_successes_total', {\n        help: 'Total count of noise xxHandshakes successes_'\n      }),\n\n    xxHandshakeErrors: metrics.registerCounter(\n      'libp2p_noise_xxhandshake_error_total', {\n        help: 'Total count of noise xxHandshakes errors'\n      }),\n\n    encryptedPackets: metrics.registerCounter(\n      'libp2p_noise_encrypted_packets_total', {\n        help: 'Total count of noise encrypted packets successfully'\n      }),\n\n    decryptedPackets: metrics.registerCounter(\n      'libp2p_noise_decrypted_packets_total', {\n        help: 'Total count of noise decrypted packets'\n      }),\n\n    decryptErrors: metrics.registerCounter(\n      'libp2p_noise_decrypt_errors_total', {\n        help: 'Total count of noise decrypt errors'\n      })\n  }\n}\n", "import { decode } from 'it-length-prefixed'\nimport { lpStream, type LengthPrefixedStream } from 'it-length-prefixed-stream'\nimport { duplexPair } from 'it-pair/duplex'\nimport { pipe } from 'it-pipe'\nimport { NOISE_MSG_MAX_LENGTH_BYTES } from './constants.js'\nimport { defaultCrypto } from './crypto/index.js'\nimport { decryptStream, encryptStream } from './crypto/streaming.js'\nimport { uint16BEDecode, uint16BEEncode } from './encoder.js'\nimport { XXHandshake } from './handshake-xx.js'\nimport { type MetricsRegistry, registerMetrics } from './metrics.js'\nimport { getPayload } from './utils.js'\nimport type { bytes } from './@types/basic.js'\nimport type { IHandshake } from './@types/handshake-interface.js'\nimport type { INoiseConnection, KeyPair } from './@types/libp2p.js'\nimport type { ICryptoInterface } from './crypto.js'\nimport type { NoiseExtensions } from './proto/payload.js'\nimport type { SecuredConnection } from '@libp2p/interface/connection-encrypter'\nimport type { Metrics } from '@libp2p/interface/metrics'\nimport type { PeerId } from '@libp2p/interface/peer-id'\nimport type { Duplex, Source } from 'it-stream-types'\n\ninterface HandshakeParams {\n  connection: LengthPrefixedStream\n  isInitiator: boolean\n  localPeer: PeerId\n  remotePeer?: PeerId\n}\n\nexport interface NoiseInit {\n  /**\n   * x25519 private key, reuse for faster handshakes\n   */\n  staticNoiseKey?: bytes\n  extensions?: NoiseExtensions\n  crypto?: ICryptoInterface\n  prologueBytes?: Uint8Array\n  metrics?: Metrics\n}\n\nexport class Noise implements INoiseConnection {\n  public protocol = '/noise'\n  public crypto: ICryptoInterface\n\n  private readonly prologue: Uint8Array\n  private readonly staticKeys: KeyPair\n  private readonly extensions?: NoiseExtensions\n  private readonly metrics?: MetricsRegistry\n\n  constructor (init: NoiseInit = {}) {\n    const { staticNoiseKey, extensions, crypto, prologueBytes, metrics } = init\n\n    this.crypto = crypto ?? defaultCrypto\n    this.extensions = extensions\n    this.metrics = metrics ? registerMetrics(metrics) : undefined\n\n    if (staticNoiseKey) {\n      // accepts x25519 private key of length 32\n      this.staticKeys = this.crypto.generateX25519KeyPairFromSeed(staticNoiseKey)\n    } else {\n      this.staticKeys = this.crypto.generateX25519KeyPair()\n    }\n    this.prologue = prologueBytes ?? new Uint8Array(0)\n  }\n\n  /**\n   * Encrypt outgoing data to the remote party (handshake as initiator)\n   *\n   * @param {PeerId} localPeer - PeerId of the receiving peer\n   * @param {Duplex<AsyncGenerator<Uint8Array>, AsyncIterable<Uint8Array>, Promise<void>>} connection - streaming iterable duplex that will be encrypted\n   * @param {PeerId} remotePeer - PeerId of the remote peer. Used to validate the integrity of the remote peer.\n   * @returns {Promise<SecuredConnection>}\n   */\n  public async secureOutbound (localPeer: PeerId, connection: Duplex<AsyncGenerator<Uint8Array>, AsyncIterable<Uint8Array>, Promise<void>>, remotePeer?: PeerId): Promise<SecuredConnection<NoiseExtensions>> {\n    const wrappedConnection = lpStream(\n      connection,\n      {\n        lengthEncoder: uint16BEEncode,\n        lengthDecoder: uint16BEDecode,\n        maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES\n      }\n    )\n    const handshake = await this.performHandshake({\n      connection: wrappedConnection,\n      isInitiator: true,\n      localPeer,\n      remotePeer\n    })\n    const conn = await this.createSecureConnection(wrappedConnection, handshake)\n\n    return {\n      conn,\n      remoteExtensions: handshake.remoteExtensions,\n      remotePeer: handshake.remotePeer\n    }\n  }\n\n  /**\n   * Decrypt incoming data (handshake as responder).\n   *\n   * @param {PeerId} localPeer - PeerId of the receiving peer.\n   * @param {Duplex<AsyncGenerator<Uint8Array>, AsyncIterable<Uint8Array>, Promise<void>>} connection - streaming iterable duplex that will be encryption.\n   * @param {PeerId} remotePeer - optional PeerId of the initiating peer, if known. This may only exist during transport upgrades.\n   * @returns {Promise<SecuredConnection>}\n   */\n  public async secureInbound (localPeer: PeerId, connection: Duplex<AsyncGenerator<Uint8Array>, AsyncIterable<Uint8Array>, Promise<void>>, remotePeer?: PeerId): Promise<SecuredConnection<NoiseExtensions>> {\n    const wrappedConnection = lpStream(\n      connection,\n      {\n        lengthEncoder: uint16BEEncode,\n        lengthDecoder: uint16BEDecode,\n        maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES\n      }\n    )\n    const handshake = await this.performHandshake({\n      connection: wrappedConnection,\n      isInitiator: false,\n      localPeer,\n      remotePeer\n    })\n    const conn = await this.createSecureConnection(wrappedConnection, handshake)\n\n    return {\n      conn,\n      remotePeer: handshake.remotePeer,\n      remoteExtensions: handshake.remoteExtensions\n    }\n  }\n\n  /**\n   * If Noise pipes supported, tries IK handshake first with XX as fallback if it fails.\n   * If noise pipes disabled or remote peer static key is unknown, use XX.\n   *\n   * @param {HandshakeParams} params\n   */\n  private async performHandshake (params: HandshakeParams): Promise<IHandshake> {\n    const payload = await getPayload(params.localPeer, this.staticKeys.publicKey, this.extensions)\n\n    // run XX handshake\n    return this.performXXHandshake(params, payload)\n  }\n\n  private async performXXHandshake (\n    params: HandshakeParams,\n    payload: bytes\n  ): Promise<XXHandshake> {\n    const { isInitiator, remotePeer, connection } = params\n    const handshake = new XXHandshake(\n      isInitiator,\n      payload,\n      this.prologue,\n      this.crypto,\n      this.staticKeys,\n      connection,\n      remotePeer\n    )\n\n    try {\n      await handshake.propose()\n      await handshake.exchange()\n      await handshake.finish()\n      this.metrics?.xxHandshakeSuccesses.increment()\n    } catch (e: unknown) {\n      this.metrics?.xxHandshakeErrors.increment()\n      if (e instanceof Error) {\n        e.message = `Error occurred during XX handshake: ${e.message}`\n        throw e\n      }\n    }\n\n    return handshake\n  }\n\n  private async createSecureConnection (\n    connection: LengthPrefixedStream<Duplex<AsyncGenerator<Uint8Array>, AsyncIterable<Uint8Array>, Promise<void>>>,\n    handshake: IHandshake\n  ): Promise<Duplex<AsyncGenerator<Uint8Array>, Source<Uint8Array>, Promise<void>>> {\n    // Create encryption box/unbox wrapper\n    const [secure, user] = duplexPair<Uint8Array>()\n    const network = connection.unwrap()\n\n    await pipe(\n      secure, // write to wrapper\n      encryptStream(handshake, this.metrics), // encrypt data + prefix with message length\n      network, // send to the remote peer\n      (source) => decode(source, { lengthDecoder: uint16BEDecode }), // read message length prefix\n      decryptStream(handshake, this.metrics), // decrypt the incoming data\n      secure // pipe to the wrapper\n    )\n\n    return user\n  }\n}\n", "import { Noise } from './noise.js'\nimport type { NoiseInit } from './noise.js'\nimport type { NoiseExtensions } from './proto/payload.js'\nimport type { ConnectionEncrypter } from '@libp2p/interface/connection-encrypter'\nexport type { ICryptoInterface } from './crypto.js'\nexport { pureJsCrypto } from './crypto/js.js'\n\nexport function noise (init: NoiseInit = {}): () => ConnectionEncrypter<NoiseExtensions> {\n  return () => new Noise(init)\n}\n", "\nexport class AbortError extends Error {\n  type: string\n  code: string\n\n  constructor (message?: string, code?: string) {\n    super(message ?? 'The operation was aborted')\n    this.type = 'aborted'\n    this.code = code ?? 'ABORT_ERR'\n  }\n}\n", "\n// If the passed object is an (async) iterable, then get the iterator\n// If it's probably an iterator already (i.e. has next function) return it\n// else throw\nexport function getIterator <T> (obj: AsyncIterable<T>): AsyncIterator<T>\nexport function getIterator <T> (obj: AsyncIterator<T>): AsyncIterator<T>\nexport function getIterator <T> (obj: Iterable<T>): Iterator<T>\nexport function getIterator <T> (obj: Iterator<T>): Iterator<T>\nexport function getIterator <T> (obj: any): AsyncIterator<T> | Iterator <T>\nexport function getIterator <T> (obj: any): AsyncIterator<T> | Iterator <T> {\n  if (obj != null) {\n    if (typeof obj[Symbol.iterator] === 'function') {\n      return obj[Symbol.iterator]()\n    }\n    if (typeof obj[Symbol.asyncIterator] === 'function') {\n      return obj[Symbol.asyncIterator]()\n    }\n    if (typeof obj.next === 'function') {\n      return obj // probably an iterator\n    }\n  }\n  throw new Error('argument is not an iterator or iterable')\n}\n", "/**\n * @packageDocumentation\n *\n * @example\n *\n * ```js\n * import { abortableSource } from 'abortable-iterator'\n *\n * async function main () {\n *   // An example function that creates an async iterator that yields an increasing\n *   // number every x milliseconds and NEVER ENDS!\n *   const asyncCounter = async function * (start, delay) {\n *     let i = start\n *     while (true) {\n *       yield new Promise(resolve => setTimeout(() => resolve(i++), delay))\n *     }\n *   }\n *\n *   // Create a counter that'll yield numbers from 0 upwards every second\n *   const everySecond = asyncCounter(0, 1000)\n *\n *   // Make everySecond abortable!\n *   const controller = new AbortController()\n *   const abortableEverySecond = abortableSource(everySecond, controller.signal)\n *\n *   // Abort after 5 seconds\n *   setTimeout(() => controller.abort(), 5000)\n *\n *   try {\n *     // Start the iteration, which will throw after 5 seconds when it is aborted\n *     for await (const n of abortableEverySecond) {\n *       console.log(n)\n *     }\n *   } catch (err) {\n *     if (err.code === 'ERR_ABORTED') {\n *       // Expected - all ok :D\n *     } else {\n *       throw err\n *     }\n *   }\n * }\n *\n * main()\n * ```\n */\n\nimport { AbortError } from './abort-error.js'\nimport { getIterator } from 'get-iterator'\nimport type { Duplex, Source, Sink } from 'it-stream-types'\n\nexport interface Options<T> {\n  onReturnError?: (err: Error) => void\n  onAbort?: (source: Source<T>) => void\n  abortMessage?: string\n  abortCode?: string\n  returnOnAbort?: boolean\n}\n\n/**\n * Wrap an iterator to make it abortable, allow cleanup when aborted via onAbort\n */\nexport function abortableSource <T> (source: Source<T>, signal: AbortSignal, options?: Options<T>): AsyncGenerator<T> {\n  const opts: Options<T> = options ?? {}\n  const iterator = getIterator<T>(source)\n\n  async function * abortable (): AsyncGenerator<Awaited<T>, void, unknown> {\n    let nextAbortHandler: (() => void) | null\n    const abortHandler = (): void => {\n      if (nextAbortHandler != null) nextAbortHandler()\n    }\n\n    signal.addEventListener('abort', abortHandler)\n\n    while (true) {\n      let result: IteratorResult<T, any>\n      try {\n        if (signal.aborted) {\n          const { abortMessage, abortCode } = opts\n          throw new AbortError(abortMessage, abortCode)\n        }\n\n        const abort = new Promise<any>((resolve, reject) => { // eslint-disable-line no-loop-func\n          nextAbortHandler = () => {\n            const { abortMessage, abortCode } = opts\n            reject(new AbortError(abortMessage, abortCode))\n          }\n        })\n\n        // Race the iterator and the abort signals\n        result = await Promise.race([abort, iterator.next()])\n        nextAbortHandler = null\n      } catch (err: any) {\n        signal.removeEventListener('abort', abortHandler)\n\n        // Might not have been aborted by a known signal\n        const isKnownAborter = err.type === 'aborted' && signal.aborted\n\n        if (isKnownAborter && (opts.onAbort != null)) {\n          // Do any custom abort handling for the iterator\n          opts.onAbort(source)\n        }\n\n        // End the iterator if it is a generator\n        if (typeof iterator.return === 'function') {\n          try {\n            const p = iterator.return()\n\n            if (p instanceof Promise) { // eslint-disable-line max-depth\n              p.catch(err => {\n                if (opts.onReturnError != null) {\n                  opts.onReturnError(err)\n                }\n              })\n            }\n          } catch (err: any) {\n            if (opts.onReturnError != null) { // eslint-disable-line max-depth\n              opts.onReturnError(err)\n            }\n          }\n        }\n\n        if (isKnownAborter && opts.returnOnAbort === true) {\n          return\n        }\n\n        throw err\n      }\n\n      if (result.done === true) {\n        break\n      }\n\n      yield result.value\n    }\n\n    signal.removeEventListener('abort', abortHandler)\n  }\n\n  return abortable()\n}\n\nexport function abortableSink <T, R = Promise<void>> (sink: Sink<AsyncIterable<T>, R>, signal: AbortSignal, options?: Options<T>): Sink<Source<T>, R> {\n  return (source: Source<T>) => sink(abortableSource(source, signal, options))\n}\n\nexport function abortableDuplex <TSource, TSink = TSource, RSink = Promise<void>> (duplex: Duplex<AsyncIterable<TSource>, Source<TSink>, RSink>, signal: AbortSignal, options?: Options<TSource>): Duplex<AsyncGenerator<TSource>, Source<TSink>, RSink> {\n  return {\n    sink: abortableSink(duplex.sink, signal, {\n      ...options,\n      onAbort: undefined\n    }),\n    source: abortableSource(duplex.source, signal, options)\n  }\n}\n\nexport { AbortError }\nexport { abortableSink as abortableTransform }\n", "import { CodeError } from '@libp2p/interface/errors'\nimport { logger } from '@libp2p/logger'\nimport { abortableSource } from 'abortable-iterator'\nimport { pipe } from 'it-pipe'\nimport { type PushableV, pushableV } from 'it-pushable'\nimport { RateLimiterMemory } from 'rate-limiter-flexible'\nimport { toString as uint8ArrayToString } from 'uint8arrays'\nimport { Decoder } from './decode.js'\nimport { encode } from './encode.js'\nimport { MessageTypes, MessageTypeNames, type Message } from './message-types.js'\nimport { createStream, type MplexStream } from './stream.js'\nimport type { MplexInit } from './index.js'\nimport type { AbortOptions } from '@libp2p/interface'\nimport type { Stream } from '@libp2p/interface/connection'\nimport type { StreamMuxer, StreamMuxerInit } from '@libp2p/interface/stream-muxer'\nimport type { Sink, Source } from 'it-stream-types'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nconst log = logger('libp2p:mplex')\n\nconst MAX_STREAMS_INBOUND_STREAMS_PER_CONNECTION = 1024\nconst MAX_STREAMS_OUTBOUND_STREAMS_PER_CONNECTION = 1024\nconst MAX_STREAM_BUFFER_SIZE = 1024 * 1024 * 4 // 4MB\nconst DISCONNECT_THRESHOLD = 5\nconst CLOSE_TIMEOUT = 500\n\nfunction printMessage (msg: Message): any {\n  const output: any = {\n    ...msg,\n    type: `${MessageTypeNames[msg.type]} (${msg.type})`\n  }\n\n  if (msg.type === MessageTypes.NEW_STREAM) {\n    output.data = uint8ArrayToString(msg.data instanceof Uint8Array ? msg.data : msg.data.subarray())\n  }\n\n  if (msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) {\n    output.data = uint8ArrayToString(msg.data instanceof Uint8Array ? msg.data : msg.data.subarray(), 'base16')\n  }\n\n  return output\n}\n\ninterface MplexStreamMuxerInit extends MplexInit, StreamMuxerInit {\n  /**\n   * The default timeout to use in ms when shutting down the muxer.\n   */\n  closeTimeout?: number\n}\n\nexport class MplexStreamMuxer implements StreamMuxer {\n  public protocol = '/mplex/6.7.0'\n\n  public sink: Sink<Source<Uint8ArrayList | Uint8Array>, Promise<void>>\n  public source: AsyncGenerator<Uint8Array>\n\n  private _streamId: number\n  private readonly _streams: { initiators: Map<number, MplexStream>, receivers: Map<number, MplexStream> }\n  private readonly _init: MplexStreamMuxerInit\n  private readonly _source: PushableV<Message>\n  private readonly closeController: AbortController\n  private readonly rateLimiter: RateLimiterMemory\n  private readonly closeTimeout: number\n\n  constructor (init?: MplexStreamMuxerInit) {\n    init = init ?? {}\n\n    this._streamId = 0\n    this._streams = {\n      /**\n       * Stream to ids map\n       */\n      initiators: new Map<number, MplexStream>(),\n      /**\n       * Stream to ids map\n       */\n      receivers: new Map<number, MplexStream>()\n    }\n    this._init = init\n    this.closeTimeout = init.closeTimeout ?? CLOSE_TIMEOUT\n\n    /**\n     * An iterable sink\n     */\n    this.sink = this._createSink()\n\n    /**\n     * An iterable source\n     */\n    this._source = pushableV<Message>({\n      objectMode: true,\n      onEnd: (): void => {\n        // the source has ended, we can't write any more messages to gracefully\n        // close streams so all we can do is destroy them\n        for (const stream of this._streams.initiators.values()) {\n          stream.destroy()\n        }\n\n        for (const stream of this._streams.receivers.values()) {\n          stream.destroy()\n        }\n      }\n    })\n    this.source = pipe(\n      this._source,\n      source => encode(source, this._init.minSendBytes)\n    )\n\n    /**\n     * Close controller\n     */\n    this.closeController = new AbortController()\n\n    this.rateLimiter = new RateLimiterMemory({\n      points: init.disconnectThreshold ?? DISCONNECT_THRESHOLD,\n      duration: 1\n    })\n  }\n\n  /**\n   * Returns a Map of streams and their ids\n   */\n  get streams (): Stream[] {\n    // Inbound and Outbound streams may have the same ids, so we need to make those unique\n    const streams: Stream[] = []\n    for (const stream of this._streams.initiators.values()) {\n      streams.push(stream)\n    }\n\n    for (const stream of this._streams.receivers.values()) {\n      streams.push(stream)\n    }\n    return streams\n  }\n\n  /**\n   * Initiate a new stream with the given name. If no name is\n   * provided, the id of the stream will be used.\n   */\n  newStream (name?: string): Stream {\n    if (this.closeController.signal.aborted) {\n      throw new Error('Muxer already closed')\n    }\n    const id = this._streamId++\n    name = name == null ? id.toString() : name.toString()\n    const registry = this._streams.initiators\n    return this._newStream({ id, name, type: 'initiator', registry })\n  }\n\n  /**\n   * Close or abort all tracked streams and stop the muxer\n   */\n  async close (options?: AbortOptions): Promise<void> {\n    if (this.closeController.signal.aborted) {\n      return\n    }\n\n    const signal = options?.signal ?? AbortSignal.timeout(this.closeTimeout)\n\n    try {\n      // try to gracefully close all streams\n      await Promise.all(\n        this.streams.map(async s => s.close({\n          signal\n        }))\n      )\n\n      this._source.end()\n\n      // try to gracefully close the muxer\n      await this._source.onEmpty({\n        signal\n      })\n\n      this.closeController.abort()\n    } catch (err: any) {\n      this.abort(err)\n    }\n  }\n\n  abort (err: Error): void {\n    if (this.closeController.signal.aborted) {\n      return\n    }\n\n    this.streams.forEach(s => { s.abort(err) })\n    this.closeController.abort(err)\n  }\n\n  /**\n   * Called whenever an inbound stream is created\n   */\n  _newReceiverStream (options: { id: number, name: string }): MplexStream {\n    const { id, name } = options\n    const registry = this._streams.receivers\n    return this._newStream({ id, name, type: 'receiver', registry })\n  }\n\n  _newStream (options: { id: number, name: string, type: 'initiator' | 'receiver', registry: Map<number, MplexStream> }): MplexStream {\n    const { id, name, type, registry } = options\n\n    log('new %s stream %s', type, id)\n\n    if (type === 'initiator' && this._streams.initiators.size === (this._init.maxOutboundStreams ?? MAX_STREAMS_OUTBOUND_STREAMS_PER_CONNECTION)) {\n      throw new CodeError('Too many outbound streams open', 'ERR_TOO_MANY_OUTBOUND_STREAMS')\n    }\n\n    if (registry.has(id)) {\n      throw new Error(`${type} stream ${id} already exists!`)\n    }\n\n    const send = async (msg: Message): Promise<void> => {\n      if (log.enabled) {\n        log.trace('%s stream %s send', type, id, printMessage(msg))\n      }\n\n      this._source.push(msg)\n    }\n\n    const onEnd = (): void => {\n      log('%s stream with id %s and protocol %s ended', type, id, stream.protocol)\n      registry.delete(id)\n\n      if (this._init.onStreamEnd != null) {\n        this._init.onStreamEnd(stream)\n      }\n    }\n\n    const stream = createStream({ id, name, send, type, onEnd, maxMsgSize: this._init.maxMsgSize })\n    registry.set(id, stream)\n    return stream\n  }\n\n  /**\n   * Creates a sink with an abortable source. Incoming messages will\n   * also have their size restricted. All messages will be varint decoded.\n   */\n  _createSink (): Sink<Source<Uint8ArrayList | Uint8Array>, Promise<void>> {\n    const sink: Sink<Source<Uint8ArrayList | Uint8Array>, Promise<void>> = async source => {\n      try {\n        source = abortableSource(source, this.closeController.signal, {\n          returnOnAbort: true\n        })\n\n        const decoder = new Decoder(this._init.maxMsgSize, this._init.maxUnprocessedMessageQueueSize)\n\n        for await (const chunk of source) {\n          for (const msg of decoder.write(chunk)) {\n            await this._handleIncoming(msg)\n          }\n        }\n\n        this._source.end()\n      } catch (err: any) {\n        log('error in sink', err)\n        this._source.end(err) // End the source with an error\n      }\n    }\n\n    return sink\n  }\n\n  async _handleIncoming (message: Message): Promise<void> {\n    const { id, type } = message\n\n    if (log.enabled) {\n      log.trace('incoming message', printMessage(message))\n    }\n\n    // Create a new stream?\n    if (message.type === MessageTypes.NEW_STREAM) {\n      if (this._streams.receivers.size === (this._init.maxInboundStreams ?? MAX_STREAMS_INBOUND_STREAMS_PER_CONNECTION)) {\n        log('too many inbound streams open')\n\n        // not going to allow this stream, send the reset message manually\n        // instead of setting it up just to tear it down\n        this._source.push({\n          id,\n          type: MessageTypes.RESET_RECEIVER\n        })\n\n        // if we've hit our stream limit, and the remote keeps trying to open\n        // more new streams, if they are doing this very quickly maybe they\n        // are attacking us and we should close the connection\n        try {\n          await this.rateLimiter.consume('new-stream', 1)\n        } catch {\n          log('rate limit hit when opening too many new streams over the inbound stream limit - closing remote connection')\n          // since there's no backpressure in mplex, the only thing we can really do to protect ourselves is close the connection\n          this.abort(new Error('Too many open streams'))\n          return\n        }\n\n        return\n      }\n\n      const stream = this._newReceiverStream({ id, name: uint8ArrayToString(message.data instanceof Uint8Array ? message.data : message.data.subarray()) })\n\n      if (this._init.onIncomingStream != null) {\n        this._init.onIncomingStream(stream)\n      }\n\n      return\n    }\n\n    const list = (type & 1) === 1 ? this._streams.initiators : this._streams.receivers\n    const stream = list.get(id)\n\n    if (stream == null) {\n      log('missing stream %s for message type %s', id, MessageTypeNames[type])\n\n      // if the remote keeps sending us messages for streams that have been\n      // closed or were never opened they may be attacking us so if they do\n      // this very quickly all we can do is close the connection\n      try {\n        await this.rateLimiter.consume('missing-stream', 1)\n      } catch {\n        log('rate limit hit when receiving messages for streams that do not exist - closing remote connection')\n        // since there's no backpressure in mplex, the only thing we can really do to protect ourselves is close the connection\n        this.abort(new Error('Too many messages for missing streams'))\n        return\n      }\n\n      return\n    }\n\n    const maxBufferSize = this._init.maxStreamBufferSize ?? MAX_STREAM_BUFFER_SIZE\n\n    try {\n      switch (type) {\n        case MessageTypes.MESSAGE_INITIATOR:\n        case MessageTypes.MESSAGE_RECEIVER:\n          if (stream.sourceReadableLength() > maxBufferSize) {\n            // Stream buffer has got too large, reset the stream\n            this._source.push({\n              id: message.id,\n              type: type === MessageTypes.MESSAGE_INITIATOR ? MessageTypes.RESET_RECEIVER : MessageTypes.RESET_INITIATOR\n            })\n\n            // Inform the stream consumer they are not fast enough\n            throw new CodeError('Input buffer full - increase Mplex maxBufferSize to accommodate slow consumers', 'ERR_STREAM_INPUT_BUFFER_FULL')\n          }\n\n          // We got data from the remote, push it into our local stream\n          stream.sourcePush(message.data)\n          break\n        case MessageTypes.CLOSE_INITIATOR:\n        case MessageTypes.CLOSE_RECEIVER:\n          // The remote has stopped writing, so we can stop reading\n          stream.remoteCloseWrite()\n          break\n        case MessageTypes.RESET_INITIATOR:\n        case MessageTypes.RESET_RECEIVER:\n          // The remote has errored, stop reading and writing to the stream immediately\n          stream.reset()\n          break\n        default:\n          log('unknown message type %s', type)\n      }\n    } catch (err: any) {\n      log.error('error while processing message', err)\n      stream.abort(err)\n    }\n  }\n}\n", "import type { Uint8ArrayList } from 'uint8arraylist'\n\ntype INITIATOR_NAME = 'NEW_STREAM' | 'MESSAGE' | 'CLOSE' | 'RESET'\ntype RECEIVER_NAME = 'MESSAGE' | 'CLOSE' | 'RESET'\ntype NAME = 'NEW_STREAM' | 'MESSAGE_INITIATOR' | 'CLOSE_INITIATOR' | 'RESET_INITIATOR' | 'MESSAGE_RECEIVER' | 'CLOSE_RECEIVER' | 'RESET_RECEIVER'\ntype CODE = 0 | 1 | 2 | 3 | 4 | 5 | 6\n\nexport enum MessageTypes {\n  NEW_STREAM = 0,\n  MESSAGE_RECEIVER = 1,\n  MESSAGE_INITIATOR = 2,\n  CLOSE_RECEIVER = 3,\n  CLOSE_INITIATOR = 4,\n  RESET_RECEIVER = 5,\n  RESET_INITIATOR = 6\n}\n\nexport const MessageTypeNames: Record<CODE, NAME> = Object.freeze({\n  0: 'NEW_STREAM',\n  1: 'MESSAGE_RECEIVER',\n  2: 'MESSAGE_INITIATOR',\n  3: 'CLOSE_RECEIVER',\n  4: 'CLOSE_INITIATOR',\n  5: 'RESET_RECEIVER',\n  6: 'RESET_INITIATOR'\n})\n\nexport const InitiatorMessageTypes: Record<INITIATOR_NAME, CODE> = Object.freeze({\n  NEW_STREAM: MessageTypes.NEW_STREAM,\n  MESSAGE: MessageTypes.MESSAGE_INITIATOR,\n  CLOSE: MessageTypes.CLOSE_INITIATOR,\n  RESET: MessageTypes.RESET_INITIATOR\n})\n\nexport const ReceiverMessageTypes: Record<RECEIVER_NAME, CODE> = Object.freeze({\n  MESSAGE: MessageTypes.MESSAGE_RECEIVER,\n  CLOSE: MessageTypes.CLOSE_RECEIVER,\n  RESET: MessageTypes.RESET_RECEIVER\n})\n\nexport interface NewStreamMessage {\n  id: number\n  type: MessageTypes.NEW_STREAM\n  data: Uint8ArrayList\n}\n\nexport interface MessageReceiverMessage {\n  id: number\n  type: MessageTypes.MESSAGE_RECEIVER\n  data: Uint8ArrayList\n}\n\nexport interface MessageInitiatorMessage {\n  id: number\n  type: MessageTypes.MESSAGE_INITIATOR\n  data: Uint8ArrayList\n}\n\nexport interface CloseReceiverMessage {\n  id: number\n  type: MessageTypes.CLOSE_RECEIVER\n}\n\nexport interface CloseInitiatorMessage {\n  id: number\n  type: MessageTypes.CLOSE_INITIATOR\n}\n\nexport interface ResetReceiverMessage {\n  id: number\n  type: MessageTypes.RESET_RECEIVER\n}\n\nexport interface ResetInitiatorMessage {\n  id: number\n  type: MessageTypes.RESET_INITIATOR\n}\n\nexport type Message = NewStreamMessage | MessageReceiverMessage | MessageInitiatorMessage | CloseReceiverMessage | CloseInitiatorMessage | ResetReceiverMessage | ResetInitiatorMessage\n", "import { Uint8ArrayList } from 'uint8arraylist'\nimport { MessageTypeNames, MessageTypes } from './message-types.js'\nimport type { Message } from './message-types.js'\n\nexport const MAX_MSG_SIZE = 1 << 20 // 1MB\nexport const MAX_MSG_QUEUE_SIZE = 4 << 20 // 4MB\n\ninterface MessageHeader {\n  id: number\n  type: keyof typeof MessageTypeNames\n  offset: number\n  length: number\n}\n\nexport class Decoder {\n  private readonly _buffer: Uint8ArrayList\n  private _headerInfo: MessageHeader | null\n  private readonly _maxMessageSize: number\n  private readonly _maxUnprocessedMessageQueueSize: number\n\n  constructor (maxMessageSize: number = MAX_MSG_SIZE, maxUnprocessedMessageQueueSize: number = MAX_MSG_QUEUE_SIZE) {\n    this._buffer = new Uint8ArrayList()\n    this._headerInfo = null\n    this._maxMessageSize = maxMessageSize\n    this._maxUnprocessedMessageQueueSize = maxUnprocessedMessageQueueSize\n  }\n\n  write (chunk: Uint8Array | Uint8ArrayList): Message[] {\n    if (chunk == null || chunk.length === 0) {\n      return []\n    }\n\n    this._buffer.append(chunk)\n\n    if (this._buffer.byteLength > this._maxUnprocessedMessageQueueSize) {\n      throw Object.assign(new Error('unprocessed message queue size too large!'), { code: 'ERR_MSG_QUEUE_TOO_BIG' })\n    }\n\n    const msgs: Message[] = []\n\n    while (this._buffer.length !== 0) {\n      if (this._headerInfo == null) {\n        try {\n          this._headerInfo = this._decodeHeader(this._buffer)\n        } catch (err: any) {\n          if (err.code === 'ERR_MSG_TOO_BIG') {\n            throw err\n          }\n\n          break // We haven't received enough data yet\n        }\n      }\n\n      const { id, type, length, offset } = this._headerInfo\n      const bufferedDataLength = this._buffer.length - offset\n\n      if (bufferedDataLength < length) {\n        break // not enough data yet\n      }\n\n      const msg: any = {\n        id,\n        type\n      }\n\n      if (type === MessageTypes.NEW_STREAM || type === MessageTypes.MESSAGE_INITIATOR || type === MessageTypes.MESSAGE_RECEIVER) {\n        msg.data = this._buffer.sublist(offset, offset + length)\n      }\n\n      msgs.push(msg)\n\n      this._buffer.consume(offset + length)\n      this._headerInfo = null\n    }\n\n    return msgs\n  }\n\n  /**\n   * Attempts to decode the message header from the buffer\n   */\n  _decodeHeader (data: Uint8ArrayList): MessageHeader {\n    const {\n      value: h,\n      offset\n    } = readVarInt(data)\n    const {\n      value: length,\n      offset: end\n    } = readVarInt(data, offset)\n\n    const type = h & 7\n\n    // @ts-expect-error h is a number not a CODE\n    if (MessageTypeNames[type] == null) {\n      throw new Error(`Invalid type received: ${type}`)\n    }\n\n    // test message type varint + data length\n    if (length > this._maxMessageSize) {\n      throw Object.assign(new Error('message size too large!'), { code: 'ERR_MSG_TOO_BIG' })\n    }\n\n    // @ts-expect-error h is a number not a CODE\n    return { id: h >> 3, type, offset: offset + end, length }\n  }\n}\n\nconst MSB = 0x80\nconst REST = 0x7F\n\nexport interface ReadVarIntResult {\n  value: number\n  offset: number\n}\n\nfunction readVarInt (buf: Uint8ArrayList, offset: number = 0): ReadVarIntResult {\n  let res = 0\n  let shift = 0\n  let counter = offset\n  let b: number\n  const l = buf.length\n\n  do {\n    if (counter >= l || shift > 49) {\n      offset = 0\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf.get(counter++)\n    res += shift < 28\n      ? (b & REST) << shift\n      : (b & REST) * Math.pow(2, shift)\n    shift += 7\n  } while (b >= MSB)\n\n  offset = counter - offset\n\n  return {\n    value: res,\n    offset\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * The final batch may be smaller than the max.\n *\n * @example\n *\n * ```javascript\n * import batch from 'it-batched-bytes'\n * import all from 'it-all'\n *\n * // This can also be an iterator, generator, etc\n * const values = [\n *   Uint8Array.from([0]),\n *   Uint8Array.from([1]),\n *   Uint8Array.from([2]),\n *   Uint8Array.from([3]),\n *   Uint8Array.from([4])\n * ]\n * const batchSize = 2\n *\n * const result = all(batch(values, { size: batchSize }))\n *\n * console.info(result) // [0, 1], [2, 3], [4]\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import batch from 'it-batched-bytes'\n * import all from 'it-all'\n *\n * const values = async function * () {\n *   yield Uint8Array.from([0])\n *   yield Uint8Array.from([1])\n *   yield Uint8Array.from([2])\n *   yield Uint8Array.from([3])\n *   yield Uint8Array.from([4])\n * }\n * const batchSize = 2\n *\n * const result = await all(batch(values, { size: batchSize }))\n *\n * console.info(result) // [0, 1], [2, 3], [4]\n * ```\n */\n\nimport defer from 'p-defer'\nimport { Uint8ArrayList } from 'uint8arraylist'\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\nconst DEFAULT_BATCH_SIZE = 1024 * 1024\nconst DEFAULT_SERIALIZE = (buf: Uint8Array | Uint8ArrayList, list: Uint8ArrayList): void => { list.append(buf) }\n\nexport interface BatchedBytesOptions {\n  /**\n   * The minimum number of bytes that should be in a batch (default: 1MB)\n   */\n  size?: number\n}\n\nexport interface AsyncBatchedBytesOptions extends BatchedBytesOptions {\n  /**\n   * If this amount of time passes, yield all the bytes in the batch even\n   * if they are below `size` (default: 0 - e.g. on every tick)\n   */\n  yieldAfter?: number\n}\n\nexport interface BatchedObjectsOptions<T> extends BatchedBytesOptions {\n  /**\n   * This function should serialize the object and append the\n   * result to the passed list\n   */\n  serialize(object: T, list: Uint8ArrayList): void\n}\n\nexport interface AsyncBatchedObjectsOptions<T> extends AsyncBatchedBytesOptions, BatchedObjectsOptions<T> {\n\n}\n\n/**\n * Takes a stream of Uint8Arrays and/or Uint8ArrayLists and store them in\n * an internal buffer. Either once the buffer reaches the requested size\n * or the next event loop tick occurs, yield any bytes from the buffer.\n */\nfunction batchedBytes (source: Iterable<Uint8Array | Uint8ArrayList>, options?: BatchedBytesOptions): Iterable<Uint8Array>\nfunction batchedBytes (source: Iterable<Uint8Array | Uint8ArrayList> | AsyncIterable<Uint8Array | Uint8ArrayList>, options?: AsyncBatchedBytesOptions): AsyncIterable<Uint8Array>\nfunction batchedBytes <T> (source: Iterable<T>, options?: BatchedObjectsOptions<T>): Iterable<Uint8Array>\nfunction batchedBytes <T> (source: Iterable<T> | AsyncIterable<T>, options?: AsyncBatchedObjectsOptions<T>): AsyncIterable<Uint8Array>\nfunction batchedBytes <T = Uint8Array | Uint8ArrayList> (source: Iterable<T> | AsyncIterable<T>, options?: Partial<AsyncBatchedObjectsOptions<T>>): AsyncIterable<Uint8Array> | Iterable<Uint8Array> {\n  if (isAsyncIterable(source)) {\n    return (async function * () {\n      let buffer = new Uint8ArrayList()\n      let ended = false\n      let deferred = defer()\n\n      let size = Number(options?.size ?? DEFAULT_BATCH_SIZE)\n\n      if (isNaN(size) || size === 0 || size < 0) {\n        size = DEFAULT_BATCH_SIZE\n      }\n\n      if (size !== Math.round(size)) {\n        throw new Error('Batch size must be an integer')\n      }\n\n      const yieldAfter = options?.yieldAfter ?? 0\n      const serialize = options?.serialize ?? DEFAULT_SERIALIZE\n\n      void Promise.resolve().then(async () => {\n        try {\n          let timeout\n\n          for await (const buf of source) {\n            // @ts-expect-error - if buf is not `Uint8Array | Uint8ArrayList` we cannot use the default serializer\n            serialize(buf, buffer)\n\n            if (buffer.byteLength >= size) {\n              clearTimeout(timeout)\n              deferred.resolve()\n              continue\n            }\n\n            timeout = setTimeout(() => { // eslint-disable-line no-loop-func\n              deferred.resolve()\n            }, yieldAfter)\n          }\n\n          clearTimeout(timeout)\n          deferred.resolve()\n        } catch (err) {\n          deferred.reject(err)\n        } finally {\n          ended = true\n        }\n      })\n\n      while (!ended) { // eslint-disable-line no-unmodified-loop-condition\n        await deferred.promise\n        deferred = defer()\n        if (buffer.byteLength > 0) {\n          const b = buffer\n          buffer = new Uint8ArrayList()\n          yield b.subarray()\n        }\n      }\n    })()\n  }\n\n  return (function * () {\n    const buffer = new Uint8ArrayList()\n    let size = Number(options?.size ?? DEFAULT_BATCH_SIZE)\n\n    if (isNaN(size) || size === 0 || size < 0) {\n      size = DEFAULT_BATCH_SIZE\n    }\n\n    if (size !== Math.round(size)) {\n      throw new Error('Batch size must be an integer')\n    }\n\n    const serialize = options?.serialize ?? DEFAULT_SERIALIZE\n\n    for (const buf of source) {\n      // @ts-expect-error - if buf is not `Uint8Array | Uint8ArrayList` we cannot use the default serializer\n      serialize(buf, buffer)\n\n      if (buffer.byteLength >= size) {\n        yield buffer.subarray(0, size)\n        buffer.consume(size)\n      }\n    }\n\n    if (buffer.byteLength > 0) {\n      yield buffer.subarray()\n    }\n  })()\n}\n\nexport default batchedBytes\n", "export function allocUnsafe (size: number): Uint8Array {\n  return new Uint8Array(size)\n}\n", "import batchedBytes from 'it-batched-bytes'\nimport * as varint from 'uint8-varint'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { allocUnsafe } from './alloc-unsafe.js'\nimport { type Message, MessageTypes } from './message-types.js'\nimport type { Source } from 'it-stream-types'\n\nconst POOL_SIZE = 10 * 1024\n\nclass Encoder {\n  private _pool: Uint8Array\n  private _poolOffset: number\n\n  constructor () {\n    this._pool = allocUnsafe(POOL_SIZE)\n    this._poolOffset = 0\n  }\n\n  /**\n   * Encodes the given message and adds it to the passed list\n   */\n  write (msg: Message, list: Uint8ArrayList): void {\n    const pool = this._pool\n    let offset = this._poolOffset\n\n    varint.encode(msg.id << 3 | msg.type, pool, offset)\n    offset += varint.encodingLength(msg.id << 3 | msg.type)\n\n    if ((msg.type === MessageTypes.NEW_STREAM || msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) && msg.data != null) {\n      varint.encode(msg.data.length, pool, offset)\n      offset += varint.encodingLength(msg.data.length)\n    } else {\n      varint.encode(0, pool, offset)\n      offset += varint.encodingLength(0)\n    }\n\n    const header = pool.subarray(this._poolOffset, offset)\n\n    if (POOL_SIZE - offset < 100) {\n      this._pool = allocUnsafe(POOL_SIZE)\n      this._poolOffset = 0\n    } else {\n      this._poolOffset = offset\n    }\n\n    list.append(header)\n\n    if ((msg.type === MessageTypes.NEW_STREAM || msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) && msg.data != null) {\n      list.append(msg.data)\n    }\n  }\n}\n\nconst encoder = new Encoder()\n\n/**\n * Encode and yield one or more messages\n */\nexport async function * encode (source: Source<Message[]>, minSendBytes: number = 0): AsyncGenerator<Uint8Array, void, undefined> {\n  if (minSendBytes == null || minSendBytes === 0) {\n    // just send the messages\n    for await (const messages of source) {\n      const list = new Uint8ArrayList()\n\n      for (const msg of messages) {\n        encoder.write(msg, list)\n      }\n\n      yield list.subarray()\n    }\n\n    return\n  }\n\n  // batch messages up for sending\n  yield * batchedBytes(source, {\n    size: minSendBytes,\n    serialize: (obj, list) => {\n      for (const m of obj) {\n        encoder.write(m, list)\n      }\n    }\n  })\n}\n", "import { abortableSource } from 'abortable-iterator'\nimport { type Pushable, pushable } from 'it-pushable'\nimport defer, { type DeferredPromise } from 'p-defer'\nimport { raceSignal } from 'race-signal'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { CodeError } from '../errors.js'\nimport type { Direction, ReadStatus, Stream, StreamStatus, StreamTimeline, WriteStatus } from '../connection/index.js'\nimport type { AbortOptions } from '../index.js'\nimport type { Source } from 'it-stream-types'\n\n// copied from @libp2p/logger to break a circular dependency\ninterface Logger {\n  (formatter: any, ...args: any[]): void\n  error(formatter: any, ...args: any[]): void\n  trace(formatter: any, ...args: any[]): void\n  enabled: boolean\n}\n\nconst ERR_STREAM_RESET = 'ERR_STREAM_RESET'\nconst ERR_SINK_INVALID_STATE = 'ERR_SINK_INVALID_STATE'\nconst DEFAULT_SEND_CLOSE_WRITE_TIMEOUT = 5000\n\nexport interface AbstractStreamInit {\n  /**\n   * A unique identifier for this stream\n   */\n  id: string\n\n  /**\n   * The stream direction\n   */\n  direction: Direction\n\n  /**\n   * A Logger implementation used to log stream-specific information\n   */\n  log: Logger\n\n  /**\n   * User specific stream metadata\n   */\n  metadata?: Record<string, unknown>\n\n  /**\n   * Invoked when the stream ends\n   */\n  onEnd?(err?: Error | undefined): void\n\n  /**\n   * Invoked when the readable end of the stream is closed\n   */\n  onCloseRead?(): void\n\n  /**\n   * Invoked when the writable end of the stream is closed\n   */\n  onCloseWrite?(): void\n\n  /**\n   * Invoked when the the stream has been reset by the remote\n   */\n  onReset?(): void\n\n  /**\n   * Invoked when the the stream has errored\n   */\n  onAbort?(err: Error): void\n\n  /**\n   * How long to wait in ms for stream data to be written to the underlying\n   * connection when closing the writable end of the stream. (default: 500)\n   */\n  closeTimeout?: number\n\n  /**\n   * After the stream sink has closed, a limit on how long it takes to send\n   * a close-write message to the remote peer.\n   */\n  sendCloseWriteTimeout?: number\n}\n\nfunction isPromise (res?: any): res is Promise<void> {\n  return res != null && typeof res.then === 'function'\n}\n\nexport abstract class AbstractStream implements Stream {\n  public id: string\n  public direction: Direction\n  public timeline: StreamTimeline\n  public protocol?: string\n  public metadata: Record<string, unknown>\n  public source: AsyncGenerator<Uint8ArrayList, void, unknown>\n  public status: StreamStatus\n  public readStatus: ReadStatus\n  public writeStatus: WriteStatus\n\n  private readonly sinkController: AbortController\n  private readonly sinkEnd: DeferredPromise<void>\n  private endErr: Error | undefined\n  private readonly streamSource: Pushable<Uint8ArrayList>\n  private readonly onEnd?: (err?: Error | undefined) => void\n  private readonly onCloseRead?: () => void\n  private readonly onCloseWrite?: () => void\n  private readonly onReset?: () => void\n  private readonly onAbort?: (err: Error) => void\n  private readonly sendCloseWriteTimeout: number\n\n  protected readonly log: Logger\n\n  constructor (init: AbstractStreamInit) {\n    this.sinkController = new AbortController()\n    this.sinkEnd = defer()\n    this.log = init.log\n\n    // stream status\n    this.status = 'open'\n    this.readStatus = 'ready'\n    this.writeStatus = 'ready'\n\n    this.id = init.id\n    this.metadata = init.metadata ?? {}\n    this.direction = init.direction\n    this.timeline = {\n      open: Date.now()\n    }\n    this.sendCloseWriteTimeout = init.sendCloseWriteTimeout ?? DEFAULT_SEND_CLOSE_WRITE_TIMEOUT\n\n    this.onEnd = init.onEnd\n    this.onCloseRead = init?.onCloseRead\n    this.onCloseWrite = init?.onCloseWrite\n    this.onReset = init?.onReset\n    this.onAbort = init?.onAbort\n\n    this.source = this.streamSource = pushable<Uint8ArrayList>({\n      onEnd: (err) => {\n        if (err != null) {\n          this.log.trace('source ended with error', err)\n        } else {\n          this.log.trace('source ended')\n        }\n\n        this.onSourceEnd(err)\n      }\n    })\n\n    // necessary because the libp2p upgrader wraps the sink function\n    this.sink = this.sink.bind(this)\n  }\n\n  async sink (source: Source<Uint8ArrayList | Uint8Array>): Promise<void> {\n    if (this.writeStatus !== 'ready') {\n      throw new CodeError(`writable end state is \"${this.writeStatus}\" not \"ready\"`, ERR_SINK_INVALID_STATE)\n    }\n\n    try {\n      this.writeStatus = 'writing'\n\n      const options: AbortOptions = {\n        signal: this.sinkController.signal\n      }\n\n      if (this.direction === 'outbound') { // If initiator, open a new stream\n        const res = this.sendNewStream(options)\n\n        if (isPromise(res)) {\n          await res\n        }\n      }\n\n      source = abortableSource(source, this.sinkController.signal, {\n        returnOnAbort: true\n      })\n\n      this.log.trace('sink reading from source')\n\n      for await (let data of source) {\n        data = data instanceof Uint8Array ? new Uint8ArrayList(data) : data\n\n        const res = this.sendData(data, options)\n\n        if (isPromise(res)) { // eslint-disable-line max-depth\n          await res\n        }\n      }\n\n      this.log.trace('sink finished reading from source, write status is \"%s\"', this.writeStatus)\n\n      if (this.writeStatus === 'writing') {\n        this.writeStatus = 'closing'\n\n        this.log.trace('send close write to remote')\n        await this.sendCloseWrite({\n          signal: AbortSignal.timeout(this.sendCloseWriteTimeout)\n        })\n\n        this.writeStatus = 'closed'\n      }\n\n      this.onSinkEnd()\n    } catch (err: any) {\n      this.log.trace('sink ended with error, calling abort with error', err)\n      this.abort(err)\n\n      throw err\n    } finally {\n      this.log.trace('resolve sink end')\n      this.sinkEnd.resolve()\n    }\n  }\n\n  protected onSourceEnd (err?: Error): void {\n    if (this.timeline.closeRead != null) {\n      return\n    }\n\n    this.timeline.closeRead = Date.now()\n    this.readStatus = 'closed'\n\n    if (err != null && this.endErr == null) {\n      this.endErr = err\n    }\n\n    this.onCloseRead?.()\n\n    if (this.timeline.closeWrite != null) {\n      this.log.trace('source and sink ended')\n      this.timeline.close = Date.now()\n\n      if (this.status !== 'aborted' && this.status !== 'reset') {\n        this.status = 'closed'\n      }\n\n      if (this.onEnd != null) {\n        this.onEnd(this.endErr)\n      }\n    } else {\n      this.log.trace('source ended, waiting for sink to end')\n    }\n  }\n\n  protected onSinkEnd (err?: Error): void {\n    if (this.timeline.closeWrite != null) {\n      return\n    }\n\n    this.timeline.closeWrite = Date.now()\n    this.writeStatus = 'closed'\n\n    if (err != null && this.endErr == null) {\n      this.endErr = err\n    }\n\n    this.onCloseWrite?.()\n\n    if (this.timeline.closeRead != null) {\n      this.log.trace('sink and source ended')\n      this.timeline.close = Date.now()\n\n      if (this.status !== 'aborted' && this.status !== 'reset') {\n        this.status = 'closed'\n      }\n\n      if (this.onEnd != null) {\n        this.onEnd(this.endErr)\n      }\n    } else {\n      this.log.trace('sink ended, waiting for source to end')\n    }\n  }\n\n  // Close for both Reading and Writing\n  async close (options?: AbortOptions): Promise<void> {\n    this.log.trace('closing gracefully')\n\n    this.status = 'closing'\n\n    await Promise.all([\n      this.closeRead(options),\n      this.closeWrite(options)\n    ])\n\n    this.status = 'closed'\n\n    this.log.trace('closed gracefully')\n  }\n\n  async closeRead (options: AbortOptions = {}): Promise<void> {\n    if (this.readStatus === 'closing' || this.readStatus === 'closed') {\n      return\n    }\n\n    this.log.trace('closing readable end of stream with starting read status \"%s\"', this.readStatus)\n\n    const readStatus = this.readStatus\n    this.readStatus = 'closing'\n\n    if (this.status !== 'reset' && this.status !== 'aborted' && this.timeline.closeRead == null) {\n      this.log.trace('send close read to remote')\n      await this.sendCloseRead(options)\n    }\n\n    if (readStatus === 'ready') {\n      this.log.trace('ending internal source queue')\n      this.streamSource.end()\n    }\n\n    this.log.trace('closed readable end of stream')\n  }\n\n  async closeWrite (options: AbortOptions = {}): Promise<void> {\n    if (this.writeStatus === 'closing' || this.writeStatus === 'closed') {\n      return\n    }\n\n    this.log.trace('closing writable end of stream with starting write status \"%s\"', this.writeStatus)\n\n    if (this.writeStatus === 'ready') {\n      this.log.trace('sink was never sunk, sink an empty array')\n\n      await raceSignal(this.sink([]), options.signal)\n    }\n\n    if (this.writeStatus === 'writing') {\n      // stop reading from the source passed to `.sink` in the microtask queue\n      // - this lets any data queued by the user in the current tick get read\n      // before we exit\n      await new Promise((resolve, reject) => {\n        queueMicrotask(() => {\n          this.log.trace('aborting source passed to .sink')\n          this.sinkController.abort()\n          raceSignal(this.sinkEnd.promise, options.signal)\n            .then(resolve, reject)\n        })\n      })\n    }\n\n    this.writeStatus = 'closed'\n\n    this.log.trace('closed writable end of stream')\n  }\n\n  /**\n   * Close immediately for reading and writing and send a reset message (local\n   * error)\n   */\n  abort (err: Error): void {\n    if (this.status === 'closed' || this.status === 'aborted' || this.status === 'reset') {\n      return\n    }\n\n    this.log('abort with error', err)\n\n    // try to send a reset message\n    this.log('try to send reset to remote')\n    const res = this.sendReset()\n\n    if (isPromise(res)) {\n      res.catch((err) => {\n        this.log.error('error sending reset message', err)\n      })\n    }\n\n    this.status = 'aborted'\n    this.timeline.abort = Date.now()\n    this._closeSinkAndSource(err)\n    this.onAbort?.(err)\n  }\n\n  /**\n   * Receive a reset message - close immediately for reading and writing (remote\n   * error)\n   */\n  reset (): void {\n    if (this.status === 'closed' || this.status === 'aborted' || this.status === 'reset') {\n      return\n    }\n\n    const err = new CodeError('stream reset', ERR_STREAM_RESET)\n\n    this.status = 'reset'\n    this.timeline.reset = Date.now()\n    this._closeSinkAndSource(err)\n    this.onReset?.()\n  }\n\n  _closeSinkAndSource (err?: Error): void {\n    this._closeSink(err)\n    this._closeSource(err)\n  }\n\n  _closeSink (err?: Error): void {\n    // if the sink function is running, cause it to end\n    if (this.writeStatus === 'writing') {\n      this.log.trace('end sink source')\n      this.sinkController.abort()\n    }\n\n    this.onSinkEnd(err)\n  }\n\n  _closeSource (err?: Error): void {\n    // if the source is not ending, end it\n    if (this.readStatus !== 'closing' && this.readStatus !== 'closed') {\n      this.log.trace('ending source with %d bytes to be read by consumer', this.streamSource.readableLength)\n      this.readStatus = 'closing'\n      this.streamSource.end(err)\n    }\n  }\n\n  /**\n   * The remote closed for writing so we should expect to receive no more\n   * messages\n   */\n  remoteCloseWrite (): void {\n    if (this.readStatus === 'closing' || this.readStatus === 'closed') {\n      this.log('received remote close write but local source is already closed')\n      return\n    }\n\n    this.log.trace('remote close write')\n    this._closeSource()\n  }\n\n  /**\n   * The remote closed for reading so we should not send any more\n   * messages\n   */\n  remoteCloseRead (): void {\n    if (this.writeStatus === 'closing' || this.writeStatus === 'closed') {\n      this.log('received remote close read but local sink is already closed')\n      return\n    }\n\n    this.log.trace('remote close read')\n    this._closeSink()\n  }\n\n  /**\n   * The underlying muxer has closed, no more messages can be sent or will\n   * be received, close immediately to free up resources\n   */\n  destroy (): void {\n    if (this.status === 'closed' || this.status === 'aborted' || this.status === 'reset') {\n      this.log('received destroy but we are already closed')\n      return\n    }\n\n    this.log.trace('stream destroyed')\n\n    this._closeSinkAndSource()\n  }\n\n  /**\n   * When an extending class reads data from it's implementation-specific source,\n   * call this method to allow the stream consumer to read the data.\n   */\n  sourcePush (data: Uint8ArrayList): void {\n    this.streamSource.push(data)\n  }\n\n  /**\n   * Returns the amount of unread data - can be used to prevent large amounts of\n   * data building up when the stream consumer is too slow.\n   */\n  sourceReadableLength (): number {\n    return this.streamSource.readableLength\n  }\n\n  /**\n   * Send a message to the remote muxer informing them a new stream is being\n   * opened\n   */\n  abstract sendNewStream (options?: AbortOptions): void | Promise<void>\n\n  /**\n   * Send a data message to the remote muxer\n   */\n  abstract sendData (buf: Uint8ArrayList, options?: AbortOptions): void | Promise<void>\n\n  /**\n   * Send a reset message to the remote muxer\n   */\n  abstract sendReset (options?: AbortOptions): void | Promise<void>\n\n  /**\n   * Send a message to the remote muxer, informing them no more data messages\n   * will be sent by this end of the stream\n   */\n  abstract sendCloseWrite (options?: AbortOptions): void | Promise<void>\n\n  /**\n   * Send a message to the remote muxer, informing them no more data messages\n   * will be read by this end of the stream\n   */\n  abstract sendCloseRead (options?: AbortOptions): void | Promise<void>\n}\n", "import { AbstractStream, type AbstractStreamInit } from '@libp2p/interface/stream-muxer/stream'\nimport { logger } from '@libp2p/logger'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { MAX_MSG_SIZE } from './decode.js'\nimport { InitiatorMessageTypes, ReceiverMessageTypes } from './message-types.js'\nimport type { Message } from './message-types.js'\n\nexport interface Options {\n  id: number\n  send(msg: Message): Promise<void>\n  name?: string\n  onEnd?(err?: Error): void\n  type?: 'initiator' | 'receiver'\n  maxMsgSize?: number\n}\n\ninterface MplexStreamInit extends AbstractStreamInit {\n  streamId: number\n  name: string\n  send(msg: Message): Promise<void>\n\n  /**\n   * The maximum allowable data size, any data larger than this will be\n   * chunked and sent in multiple data messages\n   */\n  maxDataSize: number\n}\n\nexport class MplexStream extends AbstractStream {\n  private readonly name: string\n  private readonly streamId: number\n  private readonly send: (msg: Message) => Promise<void>\n  private readonly types: Record<string, number>\n  private readonly maxDataSize: number\n\n  constructor (init: MplexStreamInit) {\n    super(init)\n\n    this.types = init.direction === 'outbound' ? InitiatorMessageTypes : ReceiverMessageTypes\n    this.send = init.send\n    this.name = init.name\n    this.streamId = init.streamId\n    this.maxDataSize = init.maxDataSize\n  }\n\n  async sendNewStream (): Promise<void> {\n    await this.send({ id: this.streamId, type: InitiatorMessageTypes.NEW_STREAM, data: new Uint8ArrayList(uint8ArrayFromString(this.name)) })\n  }\n\n  async sendData (data: Uint8ArrayList): Promise<void> {\n    data = data.sublist()\n\n    while (data.byteLength > 0) {\n      const toSend = Math.min(data.byteLength, this.maxDataSize)\n      await this.send({\n        id: this.streamId,\n        type: this.types.MESSAGE,\n        data: data.sublist(0, toSend)\n      })\n\n      data.consume(toSend)\n    }\n  }\n\n  async sendReset (): Promise<void> {\n    await this.send({ id: this.streamId, type: this.types.RESET })\n  }\n\n  async sendCloseWrite (): Promise<void> {\n    await this.send({ id: this.streamId, type: this.types.CLOSE })\n  }\n\n  async sendCloseRead (): Promise<void> {\n    // mplex does not support close read, only close write\n  }\n}\n\nexport function createStream (options: Options): MplexStream {\n  const { id, name, send, onEnd, type = 'initiator', maxMsgSize = MAX_MSG_SIZE } = options\n\n  return new MplexStream({\n    id: type === 'initiator' ? (`i${id}`) : `r${id}`,\n    streamId: id,\n    name: `${name == null ? id : name}`,\n    direction: type === 'initiator' ? 'outbound' : 'inbound',\n    maxDataSize: maxMsgSize,\n    onEnd,\n    send,\n    log: logger(`libp2p:mplex:stream:${type}:${id}`)\n  })\n}\n", "/**\n * @packageDocumentation\n *\n * This is a [simple stream multiplexer(https://docs.libp2p.io/concepts/multiplex/mplex/) that has been deprecated.\n *\n * Please use [@chainsafe/libp2p-yamux](https://www.npmjs.com/package/@chainsafe/libp2p-yamux) instead.\n *\n * @example\n *\n * ```js\n * import { mplex } from '@libp2p/mplex'\n * import { pipe } from 'it-pipe'\n *\n * const factory = mplex()\n *\n * const muxer = factory.createStreamMuxer(components, {\n *   onStream: stream => { // Receive a duplex stream from the remote\n *     // ...receive data from the remote and optionally send data back\n *   },\n *   onStreamEnd: stream => {\n *     // ...handle any tracking you may need of stream closures\n *   }\n * })\n *\n * pipe(conn, muxer, conn) // conn is duplex connection to another peer\n *\n * const stream = muxer.newStream() // Create a new duplex stream to the remote\n *\n * // Use the duplex stream to send some data to the remote...\n * pipe([1, 2, 3], stream)\n * ```\n */\n\nimport { MplexStreamMuxer } from './mplex.js'\nimport type { StreamMuxer, StreamMuxerFactory, StreamMuxerInit } from '@libp2p/interface/stream-muxer'\n\nexport interface MplexInit {\n  /**\n   * The maximum size of message that can be sent in one go in bytes.\n   * Messages larger than this will be split into multiple smaller\n   * messages. If we receive a message larger than this an error will\n   * be thrown and the connection closed. (default: 1MB)\n   */\n  maxMsgSize?: number\n\n  /**\n   * Constrains the size of the unprocessed message queue buffer.\n   * Before messages are deserialized, the raw bytes are buffered to ensure\n   * we have the complete message to deserialized. If the queue gets longer\n   * than this value an error will be thrown and the connection closed.\n   * (default: 4MB)\n   */\n  maxUnprocessedMessageQueueSize?: number\n\n  /**\n   * Each byte array written into a multiplexed stream is converted to one or\n   * more messages which are sent as byte arrays to the remote node. Sending\n   * lots of small messages can be expensive - use this setting to batch up\n   * the serialized bytes of all messages sent during the current tick up to\n   * this limit to send in one go similar to Nagle's algorithm. N.b. you\n   * should benchmark your application carefully when using this setting as it\n   * may cause the opposite of the desired effect. Omit this setting to send\n   * all messages as they become available. (default: undefined)\n   */\n  minSendBytes?: number\n\n  /**\n   * The maximum number of multiplexed streams that can be open at any\n   * one time. A request to open more than this will have a stream\n   * reset message sent immediately as a response for the newly opened\n   * stream id (default: 1024)\n   */\n  maxInboundStreams?: number\n\n  /**\n   * The maximum number of multiplexed streams that can be open at any\n   * one time. An attempt to open more than this will throw (default: 1024)\n   */\n  maxOutboundStreams?: number\n\n  /**\n   * Incoming stream messages are buffered until processed by the stream\n   * handler. If the buffer reaches this size in bytes the stream will\n   * be reset (default: 4MB)\n   */\n  maxStreamBufferSize?: number\n\n  /**\n   * When `maxInboundStreams` is hit, if the remote continues try to open\n   * more than this many new multiplexed streams per second the connection\n   * will be closed (default: 5)\n   */\n  disconnectThreshold?: number\n}\n\nclass Mplex implements StreamMuxerFactory {\n  public protocol = '/mplex/6.7.0'\n  private readonly _init: MplexInit\n\n  constructor (init: MplexInit = {}) {\n    this._init = init\n  }\n\n  createStreamMuxer (init: StreamMuxerInit = {}): StreamMuxer {\n    return new MplexStreamMuxer({\n      ...init,\n      ...this._init\n    })\n  }\n}\n\nexport function mplex (init: MplexInit = {}): () => StreamMuxerFactory {\n  return () => new Mplex(init)\n}\n", "import type { Connection, MultiaddrConnection } from '../connection/index.js'\nimport type { TypedEventTarget } from '../events.js'\nimport type { AbortOptions } from '../index.js'\nimport type { StreamMuxerFactory } from '../stream-muxer/index.js'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nexport interface ListenerEvents {\n  'connection': CustomEvent<Connection>\n  'listening': CustomEvent\n  'error': CustomEvent<Error>\n  'close': CustomEvent\n}\n\nexport interface Listener extends TypedEventTarget<ListenerEvents> {\n  /**\n   * Start a listener\n   */\n  listen(multiaddr: Multiaddr): Promise<void>\n  /**\n   * Get listen addresses\n   */\n  getAddrs(): Multiaddr[]\n  /**\n   * Close listener\n   *\n   * @returns {Promise<void>}\n   */\n  close(): Promise<void>\n}\n\nexport const symbol = Symbol.for('@libp2p/transport')\n\nexport interface ConnectionHandler { (connection: Connection): void }\n\nexport interface MultiaddrFilter { (multiaddrs: Multiaddr[]): Multiaddr[] }\n\nexport interface CreateListenerOptions {\n  handler?: ConnectionHandler\n  upgrader: Upgrader\n}\n\nexport interface DialOptions extends AbortOptions {\n  upgrader: Upgrader\n}\n\n/**\n * A libp2p transport is understood as something that offers a dial and listen interface to establish connections.\n */\nexport interface Transport {\n  /**\n   * Used to identify the transport\n   */\n  [Symbol.toStringTag]: string\n\n  /**\n   * Used by the isTransport function\n   */\n  [symbol]: true\n\n  /**\n   * Dial a given multiaddr.\n   */\n  dial(ma: Multiaddr, options: DialOptions): Promise<Connection>\n\n  /**\n   * Create transport listeners.\n   */\n  createListener(options: CreateListenerOptions): Listener\n\n  /**\n   * Takes a list of `Multiaddr`s and returns only valid addresses for the transport\n   */\n  filter: MultiaddrFilter\n}\n\nexport function isTransport (other: any): other is Transport {\n  return other != null && Boolean(other[symbol])\n}\n\n/**\n * Enum Transport Manager Fault Tolerance values\n */\nexport enum FaultTolerance {\n  /**\n   * should be used for failing in any listen circumstance\n   */\n  FATAL_ALL = 0,\n\n  /**\n   * should be used for not failing when not listening\n   */\n  NO_FATAL\n}\n\nexport interface UpgraderOptions {\n  skipEncryption?: boolean\n  skipProtection?: boolean\n  muxerFactory?: StreamMuxerFactory\n\n  /**\n   * The passed MultiaddrConnection has limits place on duration and/or data\n   * transfer amounts so is not expected to be open for very long.\n   */\n  transient?: boolean\n}\n\nexport interface Upgrader {\n  /**\n   * Upgrades an outbound connection on `transport.dial`.\n   */\n  upgradeOutbound(maConn: MultiaddrConnection, opts?: UpgraderOptions): Promise<Connection>\n\n  /**\n   * Upgrades an inbound connection on transport listener.\n   */\n  upgradeInbound(maConn: MultiaddrConnection, opts?: UpgraderOptions): Promise<Connection>\n}\n", "import { multiaddr, protocols } from '@multiformats/multiaddr'\nimport type { Multiaddr, StringTuple } from '@multiformats/multiaddr'\n\nexport interface MultiaddrToUriOpts {\n  assumeHttp?: boolean\n}\n\ninterface Interpreter { (value: string, ma: StringTuple[]): string }\n\nfunction extractSNI (ma: StringTuple[]): string | null {\n  let sniProtoCode: number\n  try {\n    sniProtoCode = protocols('sni').code\n  } catch (e) {\n    // No SNI protocol in multiaddr\n    return null\n  }\n  for (const [proto, value] of ma) {\n    if (proto === sniProtoCode && value !== undefined) {\n      return value\n    }\n  }\n  return null\n}\n\nfunction hasTLS (ma: StringTuple[]): boolean {\n  return ma.some(([proto, _]) => proto === protocols('tls').code)\n}\n\nfunction interpretNext (headProtoCode: number, headProtoVal: string, restMa: StringTuple[]): string {\n  const interpreter = interpreters[protocols(headProtoCode).name]\n  if (interpreter === undefined) {\n    throw new Error(`Can't interpret protocol ${protocols(headProtoCode).name}`)\n  }\n  const restVal = interpreter(headProtoVal, restMa)\n  if (headProtoCode === protocols('ip6').code) {\n    return `[${restVal}]`\n  }\n  return restVal\n}\n\nconst interpreters: Record<string, Interpreter> = {\n  ip4: (value: string, restMa: StringTuple[]) => value,\n  ip6: (value: string, restMa: StringTuple[]) => {\n    if (restMa.length === 0) {\n      return value\n    }\n    return `[${value}]`\n  },\n  tcp: (value: string, restMa: StringTuple[]) => {\n    const tailProto = restMa.pop()\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    return `tcp://${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}:${value}`\n  },\n  udp: (value: string, restMa: StringTuple[]) => {\n    const tailProto = restMa.pop()\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    return `udp://${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}:${value}`\n  },\n  dnsaddr: (value: string, restMa: StringTuple[]) => value,\n  dns4: (value: string, restMa: StringTuple[]) => value,\n  dns6: (value: string, restMa: StringTuple[]) => value,\n  dns: (value: string, restMa: StringTuple[]) => value,\n  ipfs: (value: string, restMa: StringTuple[]) => {\n    const tailProto = restMa.pop()\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    return `${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}/ipfs/${value}`\n  },\n  p2p: (value: string, restMa: StringTuple[]) => {\n    const tailProto = restMa.pop()\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    return `${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}/p2p/${value}`\n  },\n  http: (value: string, restMa: StringTuple[]) => {\n    const maHasTLS = hasTLS(restMa)\n    const sni = extractSNI(restMa)\n    if (maHasTLS && sni !== null) {\n      return `https://${sni}`\n    }\n    const protocol = maHasTLS ? 'https://' : 'http://'\n    const tailProto = restMa.pop()\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    let baseVal = interpretNext(tailProto[0], tailProto[1] ?? '', restMa)\n    // We are reinterpreting the base as http, so we need to remove the tcp:// if it's there\n    baseVal = baseVal.replace('tcp://', '')\n    return `${protocol}${baseVal}`\n  },\n  tls: (value: string, restMa: StringTuple[]) => {\n    // Noop, the parent context knows that it's tls. We don't need to do\n    // anything here\n    const tailProto = restMa.pop()\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    return interpretNext(tailProto[0], tailProto[1] ?? '', restMa)\n  },\n  sni: (value: string, restMa: StringTuple[]) => {\n    // Noop, the parent context uses the sni information, we don't need to do\n    // anything here\n    const tailProto = restMa.pop()\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    return interpretNext(tailProto[0], tailProto[1] ?? '', restMa)\n  },\n  https: (value: string, restMa: StringTuple[]) => {\n    const tailProto = restMa.pop()\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    let baseVal = interpretNext(tailProto[0], tailProto[1] ?? '', restMa)\n    // We are reinterpreting the base as http, so we need to remove the tcp:// if it's there\n    baseVal = baseVal.replace('tcp://', '')\n    return `https://${baseVal}`\n  },\n  ws: (value: string, restMa: StringTuple[]) => {\n    const maHasTLS = hasTLS(restMa)\n    const sni = extractSNI(restMa)\n    if (maHasTLS && sni !== null) {\n      return `wss://${sni}`\n    }\n    const protocol = maHasTLS ? 'wss://' : 'ws://'\n    const tailProto = restMa.pop()\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    let baseVal = interpretNext(tailProto[0], tailProto[1] ?? '', restMa)\n    // We are reinterpreting the base, so we need to remove the tcp:// if it's there\n    baseVal = baseVal.replace('tcp://', '')\n    return `${protocol}${baseVal}`\n  },\n  wss: (value: string, restMa: StringTuple[]) => {\n    const tailProto = restMa.pop()\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    let baseVal = interpretNext(tailProto[0], tailProto[1] ?? '', restMa)\n    // We are reinterpreting the base as http, so we need to remove the tcp:// if it's there\n    baseVal = baseVal.replace('tcp://', '')\n    return `wss://${baseVal}`\n  },\n  'p2p-websocket-star': (value: string, restMa: StringTuple[]) => {\n    const tailProto = restMa.pop()\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    return `${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}/p2p-websocket-star`\n  },\n  'p2p-webrtc-star': (value: string, restMa: StringTuple[]) => {\n    const tailProto = restMa.pop()\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    return `${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}/p2p-webrtc-star`\n  },\n  'p2p-webrtc-direct': (value: string, restMa: StringTuple[]) => {\n    const tailProto = restMa.pop()\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    return `${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}/p2p-webrtc-direct`\n  }\n}\n\nexport function multiaddrToUri (input: Multiaddr | string | Uint8Array, opts?: MultiaddrToUriOpts): string {\n  const ma = multiaddr(input)\n  const parts = ma.stringTuples()\n  const head = parts.pop()\n  if (head === undefined) {\n    throw new Error('Unexpected end of multiaddr')\n  }\n\n  const protocol = protocols(head[0])\n  const interpreter = interpreters[protocol.name]\n\n  if (interpreter == null) {\n    throw new Error(`No interpreter found for ${protocol.name}`)\n  }\n\n  let uri = interpreter(head[1] ?? '', parts)\n  if (opts?.assumeHttp !== false && head[0] === protocols('tcp').code) {\n    // If rightmost proto is tcp, we assume http here\n    uri = uri.replace('tcp://', 'http://')\n    if (head[1] === '443' || head[1] === '80') {\n      if (head[1] === '443') {\n        uri = uri.replace('http://', 'https://')\n      }\n      // Drop the port\n      uri = uri.substring(0, uri.lastIndexOf(':'))\n    }\n  }\n\n  return uri\n}\n", "import type { ErrorEvent, WebSocket } from 'ws'\n\nexport default async (socket: WebSocket): Promise<void> => {\n  // if the socket is closing or closed, return end\n  if (socket.readyState >= 2) {\n    throw new Error('socket closed')\n  }\n\n  // if open, return\n  if (socket.readyState === 1) {\n    return\n  }\n\n  await new Promise<void>((resolve, reject) => {\n    function cleanup (): void {\n      socket.removeEventListener('open', handleOpen)\n      socket.removeEventListener('error', handleErr)\n    }\n\n    function handleOpen (): void {\n      cleanup()\n      resolve()\n    }\n\n    function handleErr (event: ErrorEvent): void {\n      cleanup()\n      reject(event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`))\n    }\n\n    socket.addEventListener('open', handleOpen)\n    socket.addEventListener('error', handleErr)\n  })\n}\n", "import ready from './ready.js'\nimport type { Sink, Source } from 'it-stream-types'\nimport type { WebSocket } from 'ws'\n\nexport interface SinkOptions {\n  closeOnEnd?: boolean\n}\n\nexport default (socket: WebSocket, options: SinkOptions): Sink<Source<Uint8Array>, Promise<void>> => {\n  options = options ?? {}\n  options.closeOnEnd = options.closeOnEnd !== false\n\n  const sink: Sink<Source<Uint8Array>, Promise<void>> = async source => {\n    for await (const data of source) {\n      try {\n        await ready(socket)\n      } catch (err: any) {\n        if (err.message === 'socket closed') break\n        throw err\n      }\n\n      // the ready promise resolved without error but the socket was closing so\n      // exit the loop and don't send data\n      if (socket.readyState === socket.CLOSING || socket.readyState === socket.CLOSED) {\n        break\n      }\n\n      socket.send(data)\n    }\n\n    if (options.closeOnEnd != null && socket.readyState <= 1) {\n      await new Promise<void>((resolve, reject) => {\n        socket.addEventListener('close', event => {\n          if (event.wasClean || event.code === 1006) {\n            resolve()\n          } else {\n            const err = Object.assign(new Error('ws error'), { event })\n            reject(err)\n          }\n        })\n\n        setTimeout(() => { socket.close() })\n      })\n    }\n  }\n\n  return sink\n}\n", "import { EventIterator } from 'event-iterator'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport type { WebSocket, ErrorEvent, MessageEvent } from 'ws'\n\n// copied from github.com/feross/buffer\n// Some ArrayBuffers are not passing the instanceof check, so we need to do a bit more work :(\nfunction isArrayBuffer (obj: any): obj is ArrayBuffer {\n  return (obj instanceof ArrayBuffer) ||\n    (obj?.constructor?.name === 'ArrayBuffer' && typeof obj?.byteLength === 'number')\n}\n\nexport interface ConnectedSource extends AsyncGenerator<Uint8Array> {\n  connected: () => Promise<void>\n}\n\nexport default (socket: WebSocket): ConnectedSource => {\n  socket.binaryType = 'arraybuffer'\n\n  const connected = async (): Promise<void> => {\n    await new Promise<void>((resolve, reject) => {\n      if (isConnected) {\n        resolve(); return\n      }\n      if (connError != null) {\n        reject(connError); return\n      }\n\n      const cleanUp = (cont: () => void): void => {\n        socket.removeEventListener('open', onOpen)\n        socket.removeEventListener('error', onError)\n        cont()\n      }\n\n      const onOpen = (): void => { cleanUp(resolve) }\n      const onError = (event: ErrorEvent): void => {\n        cleanUp(() => { reject(event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`)) })\n      }\n\n      socket.addEventListener('open', onOpen)\n      socket.addEventListener('error', onError)\n    })\n  }\n\n  const source = (async function * () {\n    const messages = new EventIterator<Uint8Array>(\n      ({ push, stop, fail }) => {\n        const onMessage = (event: MessageEvent): void => {\n          let data: Uint8Array | null = null\n\n          if (typeof event.data === 'string') {\n            data = uint8ArrayFromString(event.data)\n          }\n\n          if (isArrayBuffer(event.data)) {\n            data = new Uint8Array(event.data)\n          }\n\n          if (event.data instanceof Uint8Array) {\n            data = event.data\n          }\n\n          if (data == null) {\n            return\n          }\n\n          push(data)\n        }\n        const onError = (event: ErrorEvent): void => { fail(event.error ?? new Error('Socket error')) }\n\n        socket.addEventListener('message', onMessage)\n        socket.addEventListener('error', onError)\n        socket.addEventListener('close', stop)\n\n        return () => {\n          socket.removeEventListener('message', onMessage)\n          socket.removeEventListener('error', onError)\n          socket.removeEventListener('close', stop)\n        }\n      },\n      { highWaterMark: Infinity }\n    )\n\n    await connected()\n\n    for await (const chunk of messages) {\n      yield isArrayBuffer(chunk) ? new Uint8Array(chunk) : chunk\n    }\n  }())\n\n  let isConnected = socket.readyState === 1\n  let connError: Error | null\n\n  socket.addEventListener('open', () => {\n    isConnected = true\n    connError = null\n  })\n\n  socket.addEventListener('close', () => {\n    isConnected = false\n    connError = null\n  })\n\n  socket.addEventListener('error', event => {\n    if (!isConnected) {\n      connError = event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`)\n    }\n  })\n\n  return Object.assign(source, {\n    connected\n  })\n}\n", "import sink from './sink.js'\nimport source from './source.js'\nimport type { SinkOptions } from './sink.js'\nimport type WebSocket from './web-socket.js'\nimport type { Duplex, Source } from 'it-stream-types'\n\nexport interface DuplexWebSocket extends Duplex<AsyncGenerator<Uint8Array>, Source<Uint8Array>, Promise<void>> {\n  connected: () => Promise<void>\n  localAddress?: string\n  localPort?: number\n  remoteAddress: string\n  remotePort: number\n  close: () => Promise<void>\n  destroy: () => void\n  socket: WebSocket\n}\n\nexport interface DuplexWebSocketOptions extends SinkOptions {\n  remoteAddress?: string\n  remotePort?: number\n}\n\nexport default (socket: WebSocket, options?: DuplexWebSocketOptions): DuplexWebSocket => {\n  options = options ?? {}\n\n  const connectedSource = source(socket)\n  let remoteAddress: string | undefined = options.remoteAddress\n  let remotePort: number | undefined = options.remotePort\n\n  if (socket.url != null) {\n    // only client->server sockets have urls, server->client connections do not\n    try {\n      const url = new URL(socket.url)\n      remoteAddress = url.hostname\n      remotePort = parseInt(url.port, 10)\n    } catch {}\n  }\n\n  if (remoteAddress == null || remotePort == null) {\n    throw new Error('Remote connection did not have address and/or port')\n  }\n\n  const duplex: DuplexWebSocket = {\n    sink: sink(socket, options),\n    source: connectedSource,\n    connected: async () => { await connectedSource.connected() },\n    close: async () => {\n      if (socket.readyState === socket.CONNECTING || socket.readyState === socket.OPEN) {\n        await new Promise<void>((resolve) => {\n          socket.addEventListener('close', () => {\n            resolve()\n          })\n          socket.close()\n        })\n      }\n    },\n    destroy: () => {\n      if (socket.terminate != null) {\n        socket.terminate()\n      } else {\n        socket.close()\n      }\n    },\n    remoteAddress,\n    remotePort,\n    socket\n  }\n\n  return duplex\n}\n", "/* eslint-env browser */\n\nexport default WebSocket\n", "import { relative } from 'iso-url'\n\nconst map = { http: 'ws', https: 'wss' }\nconst def = 'ws'\n\nexport default (url: string, location: string | Partial<Location>): string => relative(url, location, map, def)\n", "// load websocket library if we are not in the browser\nimport duplex from './duplex.js'\nimport WebSocket from './web-socket.js'\nimport wsurl from './ws-url.js'\nimport type { DuplexWebSocket } from './duplex.js'\nimport type { SinkOptions } from './sink.js'\nimport type { ClientOptions } from 'ws'\n\nexport interface WebSocketOptions extends SinkOptions {\n  websocket?: ClientOptions\n}\n\nexport function connect (addr: string, opts?: WebSocketOptions): DuplexWebSocket {\n  const location = typeof window === 'undefined' ? '' : window.location\n  opts = opts ?? {}\n\n  const url = wsurl(addr, location.toString())\n  const socket = new WebSocket(url, opts.websocket)\n\n  return duplex(socket, opts)\n}\n", "import detectElectron from 'is-electron'\n\nexport const isEnvWithDom = typeof window === 'object' && typeof document === 'object' && document.nodeType === 9\nexport const isElectron = detectElectron()\n\n/**\n * Detects browser main thread  **NOT** web worker or service worker\n */\nexport const isBrowser = isEnvWithDom && !isElectron\nexport const isElectronMain = isElectron && !isEnvWithDom\nexport const isElectronRenderer = isElectron && isEnvWithDom\nexport const isNode = typeof globalThis.process !== 'undefined' && typeof globalThis.process.release !== 'undefined' && globalThis.process.release.name === 'node' && !isElectron\n// @ts-ignore\n// eslint-disable-next-line no-undef\nexport const isWebWorker = typeof importScripts === 'function' && typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope\n\n// defeat bundlers replacing process.env.NODE_ENV with \"development\" or whatever\nexport const isTest = typeof globalThis.process !== 'undefined' && typeof globalThis.process.env !== 'undefined' && globalThis.process.env['NODE' + (() => '_')() + 'ENV'] === 'test'\nexport const isReactNative = typeof navigator !== 'undefined' && navigator.product === 'ReactNative'\n", "// p2p multi-address code\nexport const CODE_P2P = 421\nexport const CODE_CIRCUIT = 290\n\nexport const CODE_TCP = 6\nexport const CODE_WS = 477\nexport const CODE_WSS = 478\n\n// Time to wait for a connection to close gracefully before destroying it manually\nexport const CLOSE_TIMEOUT = 500\n", "import * as mafmt from '@multiformats/mafmt'\nimport {\n  CODE_CIRCUIT,\n  CODE_P2P,\n  CODE_TCP,\n  CODE_WS,\n  CODE_WSS\n} from './constants.js'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nexport function all (multiaddrs: Multiaddr[]): Multiaddr[] {\n  return multiaddrs.filter((ma) => {\n    if (ma.protoCodes().includes(CODE_CIRCUIT)) {\n      return false\n    }\n\n    const testMa = ma.decapsulateCode(CODE_P2P)\n\n    return mafmt.WebSockets.matches(testMa) ||\n      mafmt.WebSocketsSecure.matches(testMa)\n  })\n}\n\nexport function wss (multiaddrs: Multiaddr[]): Multiaddr[] {\n  return multiaddrs.filter((ma) => {\n    if (ma.protoCodes().includes(CODE_CIRCUIT)) {\n      return false\n    }\n\n    const testMa = ma.decapsulateCode(CODE_P2P)\n\n    return mafmt.WebSocketsSecure.matches(testMa)\n  })\n}\n\nexport function dnsWss (multiaddrs: Multiaddr[]): Multiaddr[] {\n  return multiaddrs.filter((ma) => {\n    if (ma.protoCodes().includes(CODE_CIRCUIT)) {\n      return false\n    }\n\n    const testMa = ma.decapsulateCode(CODE_P2P)\n\n    return mafmt.WebSocketsSecure.matches(testMa) &&\n      mafmt.DNS.matches(testMa.decapsulateCode(CODE_TCP).decapsulateCode(CODE_WSS))\n  })\n}\n\nexport function dnsWsOrWss (multiaddrs: Multiaddr[]): Multiaddr[] {\n  return multiaddrs.filter((ma) => {\n    if (ma.protoCodes().includes(CODE_CIRCUIT)) {\n      return false\n    }\n\n    const testMa = ma.decapsulateCode(CODE_P2P)\n\n    // WS\n    if (mafmt.WebSockets.matches(testMa)) {\n      return mafmt.DNS.matches(testMa.decapsulateCode(CODE_TCP).decapsulateCode(CODE_WS))\n    }\n\n    // WSS\n    return mafmt.WebSocketsSecure.matches(testMa) &&\n      mafmt.DNS.matches(testMa.decapsulateCode(CODE_TCP).decapsulateCode(CODE_WSS))\n  })\n}\n", "import type { Listener } from '@libp2p/interface/transport'\n\nexport function createListener (): Listener {\n  throw new Error('WebSocket Servers can not be created in the browser!')\n}\n", "import { CodeError } from '@libp2p/interface/errors'\nimport { logger } from '@libp2p/logger'\nimport { abortableSource } from 'abortable-iterator'\nimport { CLOSE_TIMEOUT } from './constants.js'\nimport type { AbortOptions } from '@libp2p/interface'\nimport type { MultiaddrConnection } from '@libp2p/interface/connection'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { DuplexWebSocket } from 'it-ws/duplex'\n\nconst log = logger('libp2p:websockets:socket')\n\nexport interface SocketToConnOptions extends AbortOptions {\n  localAddr?: Multiaddr\n}\n\n// Convert a stream into a MultiaddrConnection\n// https://github.com/libp2p/interface-transport#multiaddrconnection\nexport function socketToMaConn (stream: DuplexWebSocket, remoteAddr: Multiaddr, options?: SocketToConnOptions): MultiaddrConnection {\n  options = options ?? {}\n\n  const maConn: MultiaddrConnection = {\n    async sink (source) {\n      if ((options?.signal) != null) {\n        source = abortableSource(source, options.signal)\n      }\n\n      try {\n        await stream.sink(source)\n      } catch (err: any) {\n        if (err.type !== 'aborted') {\n          log.error(err)\n        }\n      }\n    },\n\n    source: (options.signal != null) ? abortableSource(stream.source, options.signal) : stream.source,\n\n    remoteAddr,\n\n    timeline: { open: Date.now() },\n\n    async close (options: AbortOptions = {}) {\n      const start = Date.now()\n\n      if (options.signal == null) {\n        const signal = AbortSignal.timeout(CLOSE_TIMEOUT)\n\n        options = {\n          ...options,\n          signal\n        }\n      }\n\n      const listener = (): void => {\n        const { host, port } = maConn.remoteAddr.toOptions()\n        log('timeout closing stream to %s:%s after %dms, destroying it manually',\n          host, port, Date.now() - start)\n\n        this.abort(new CodeError('Socket close timeout', 'ERR_SOCKET_CLOSE_TIMEOUT'))\n      }\n\n      options.signal?.addEventListener('abort', listener)\n\n      try {\n        await stream.close()\n      } catch (err: any) {\n        log.error('error closing WebSocket gracefully', err)\n        this.abort(err)\n      } finally {\n        options.signal?.removeEventListener('abort', listener)\n        maConn.timeline.close = Date.now()\n      }\n    },\n\n    abort (err: Error): void {\n      const { host, port } = maConn.remoteAddr.toOptions()\n      log('timeout closing stream to %s:%s due to error',\n        host, port, err)\n\n      stream.destroy()\n      maConn.timeline.close = Date.now()\n    }\n  }\n\n  stream.socket.addEventListener('close', () => {\n    // In instances where `close` was not explicitly called,\n    // such as an iterable stream ending, ensure we have set the close\n    // timeline\n    if (maConn.timeline.close == null) {\n      maConn.timeline.close = Date.now()\n    }\n  }, { once: true })\n\n  return maConn\n}\n", "/**\n * @packageDocumentation\n *\n * A [libp2p transport](https://docs.libp2p.io/concepts/transports/overview/) based on [WebSockets](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API).\n *\n * @example\n *\n * ```js\n * import { createLibp2pNode } from 'libp2p'\n * import { webSockets } from '@libp2p/webrtc-direct'\n *\n * const node = await createLibp2p({\n *   transports: [\n *     webSockets()\n *   ]\n * //... other config\n * })\n * await node.start()\n * await node.dial('/ip4/127.0.0.1/tcp/9090/ws')\n * ```\n *\n * ## Filters\n *\n * When run in a browser by default this module will only connect to secure web socket addresses.\n *\n * To change this you should pass a filter to the factory function.\n *\n * You can create your own address filters for this transports, or rely in the filters [provided](./src/filters.js).\n *\n * The available filters are:\n *\n * - `filters.all`\n *   - Returns all TCP and DNS based addresses, both with `ws` or `wss`.\n * - `filters.dnsWss`\n *   - Returns all DNS based addresses with `wss`.\n * - `filters.dnsWsOrWss`\n *   - Returns all DNS based addresses, both with `ws` or `wss`.\n *\n * @example\n *\n * ```js\n * import { createLibp2pNode } from 'libp2p'\n * import { websockets } from '@libp2p/websockets'\n * import filters from '@libp2p/websockets/filters'\n * import { mplex } from '@libp2p/mplex'\n * import { noise } from '@libp2p/noise'\n *\n * const transportKey = Websockets.prototype[Symbol.toStringTag]\n * const node = await Libp2p.create({\n *   transport: [\n *     websockets({\n *       // connect to all sockets, even insecure ones\n *       filter: filters.all\n *     })\n *   ],\n *   streamMuxers: [\n *     mplex()\n *   ],\n *   connectionEncryption: [\n *     noise()\n *   ]\n * })\n * ```\n */\n\nimport { AbortError, CodeError } from '@libp2p/interface/errors'\nimport { type Transport, type MultiaddrFilter, symbol, type CreateListenerOptions, type DialOptions, type Listener } from '@libp2p/interface/transport'\nimport { logger } from '@libp2p/logger'\nimport { multiaddrToUri as toUri } from '@multiformats/multiaddr-to-uri'\nimport { connect, type WebSocketOptions } from 'it-ws/client'\nimport pDefer from 'p-defer'\nimport { isBrowser, isWebWorker } from 'wherearewe'\nimport * as filters from './filters.js'\nimport { createListener } from './listener.js'\nimport { socketToMaConn } from './socket-to-conn.js'\nimport type { AbortOptions } from '@libp2p/interface'\nimport type { Connection } from '@libp2p/interface/connection'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { Server } from 'http'\nimport type { DuplexWebSocket } from 'it-ws/duplex'\nimport type { ClientOptions } from 'ws'\n\nconst log = logger('libp2p:websockets')\n\nexport interface WebSocketsInit extends AbortOptions, WebSocketOptions {\n  filter?: MultiaddrFilter\n  websocket?: ClientOptions\n  server?: Server\n}\n\nclass WebSockets implements Transport {\n  private readonly init?: WebSocketsInit\n\n  constructor (init?: WebSocketsInit) {\n    this.init = init\n  }\n\n  readonly [Symbol.toStringTag] = '@libp2p/websockets'\n\n  readonly [symbol] = true\n\n  async dial (ma: Multiaddr, options: DialOptions): Promise<Connection> {\n    log('dialing %s', ma)\n    options = options ?? {}\n\n    const socket = await this._connect(ma, options)\n    const maConn = socketToMaConn(socket, ma)\n    log('new outbound connection %s', maConn.remoteAddr)\n\n    const conn = await options.upgrader.upgradeOutbound(maConn)\n    log('outbound connection %s upgraded', maConn.remoteAddr)\n    return conn\n  }\n\n  async _connect (ma: Multiaddr, options: AbortOptions): Promise<DuplexWebSocket> {\n    if (options?.signal?.aborted === true) {\n      throw new AbortError()\n    }\n    const cOpts = ma.toOptions()\n    log('dialing %s:%s', cOpts.host, cOpts.port)\n\n    const errorPromise = pDefer()\n    const rawSocket = connect(toUri(ma), this.init)\n    rawSocket.socket.addEventListener('error', () => {\n      // the WebSocket.ErrorEvent type doesn't actually give us any useful\n      // information about what happened\n      // https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/error_event\n      const err = new CodeError(`Could not connect to ${ma.toString()}`, 'ERR_CONNECTION_FAILED')\n      log.error('connection error:', err)\n      errorPromise.reject(err)\n    })\n\n    if (options.signal == null) {\n      await Promise.race([rawSocket.connected(), errorPromise.promise])\n\n      log('connected %s', ma)\n      return rawSocket\n    }\n\n    // Allow abort via signal during connect\n    let onAbort\n    const abort = new Promise((resolve, reject) => {\n      onAbort = () => {\n        reject(new AbortError())\n        rawSocket.close().catch(err => {\n          log.error('error closing raw socket', err)\n        })\n      }\n\n      // Already aborted?\n      if (options?.signal?.aborted === true) {\n        onAbort(); return\n      }\n\n      options?.signal?.addEventListener('abort', onAbort)\n    })\n\n    try {\n      await Promise.race([abort, errorPromise.promise, rawSocket.connected()])\n    } finally {\n      if (onAbort != null) {\n        options?.signal?.removeEventListener('abort', onAbort)\n      }\n    }\n\n    log('connected %s', ma)\n    return rawSocket\n  }\n\n  /**\n   * Creates a Websockets listener. The provided `handler` function will be called\n   * anytime a new incoming Connection has been successfully upgraded via\n   * `upgrader.upgradeInbound`\n   */\n  createListener (options: CreateListenerOptions): Listener {\n    return createListener({ ...this.init, ...options })\n  }\n\n  /**\n   * Takes a list of `Multiaddr`s and returns only valid Websockets addresses.\n   * By default, in a browser environment only DNS+WSS multiaddr is accepted,\n   * while in a Node.js environment DNS+{WS, WSS} multiaddrs are accepted.\n   */\n  filter (multiaddrs: Multiaddr[]): Multiaddr[] {\n    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs]\n\n    if (this.init?.filter != null) {\n      return this.init?.filter(multiaddrs)\n    }\n\n    // Browser\n    if (isBrowser || isWebWorker) {\n      return filters.wss(multiaddrs)\n    }\n\n    return filters.all(multiaddrs)\n  }\n}\n\nexport function webSockets (init: WebSocketsInit = {}): (components?: any) => Transport {\n  return () => {\n    return new WebSockets(init)\n  }\n}\n", "import { proto_peer_exchange as proto } from \"@waku/proto\";\nimport type { Uint8ArrayList } from \"uint8arraylist\";\n\n/**\n * PeerExchangeRPC represents a message conforming to the Waku Peer Exchange protocol\n */\nexport class PeerExchangeRPC {\n  public constructor(public proto: proto.PeerExchangeRPC) {}\n\n  static createRequest(params: proto.PeerExchangeQuery): PeerExchangeRPC {\n    const { numPeers } = params;\n    return new PeerExchangeRPC({\n      query: {\n        numPeers: numPeers\n      },\n      response: undefined\n    });\n  }\n\n  /**\n   * Encode the current PeerExchangeRPC request to bytes\n   * @returns Uint8Array\n   */\n  encode(): Uint8Array {\n    return proto.PeerExchangeRPC.encode(this.proto);\n  }\n\n  /**\n   * Decode the current PeerExchangeRPC request to bytes\n   * @returns Uint8Array\n   */\n  static decode(bytes: Uint8ArrayList): PeerExchangeRPC {\n    const res = proto.PeerExchangeRPC.decode(bytes);\n    return new PeerExchangeRPC(res);\n  }\n\n  get query(): proto.PeerExchangeQuery | undefined {\n    return this.proto.query;\n  }\n\n  get response(): proto.PeerExchangeResponse | undefined {\n    return this.proto.response;\n  }\n}\n", "import { BaseProtocol } from \"@waku/core/lib/base_protocol\";\nimport { EnrDecoder } from \"@waku/enr\";\nimport type {\n  IPeerExchange,\n  Libp2pComponents,\n  PeerExchangeQueryParams,\n  PeerInfo\n} from \"@waku/interfaces\";\nimport { isDefined } from \"@waku/utils\";\nimport { Logger } from \"@waku/utils\";\nimport all from \"it-all\";\nimport * as lp from \"it-length-prefixed\";\nimport { pipe } from \"it-pipe\";\nimport { Uint8ArrayList } from \"uint8arraylist\";\n\nimport { PeerExchangeRPC } from \"./rpc.js\";\n\nexport const PeerExchangeCodec = \"/vac/waku/peer-exchange/2.0.0-alpha1\";\n\nconst log = new Logger(\"peer-exchange\");\n\n/**\n * Implementation of the Peer Exchange protocol (https://rfc.vac.dev/spec/34/)\n */\nexport class WakuPeerExchange extends BaseProtocol implements IPeerExchange {\n  /**\n   * @param components - libp2p components\n   */\n  constructor(components: Libp2pComponents) {\n    super(PeerExchangeCodec, components);\n  }\n\n  /**\n   * Make a peer exchange query to a peer\n   */\n  async query(\n    params: PeerExchangeQueryParams\n  ): Promise<PeerInfo[] | undefined> {\n    const { numPeers } = params;\n\n    const rpcQuery = PeerExchangeRPC.createRequest({\n      numPeers: BigInt(numPeers)\n    });\n\n    const peer = await this.getPeer(params.peerId);\n\n    const stream = await this.getStream(peer);\n\n    const res = await pipe(\n      [rpcQuery.encode()],\n      lp.encode,\n      stream,\n      lp.decode,\n      async (source) => await all(source)\n    );\n\n    try {\n      const bytes = new Uint8ArrayList();\n      res.forEach((chunk) => {\n        bytes.append(chunk);\n      });\n\n      const { response } = PeerExchangeRPC.decode(bytes);\n\n      if (!response) {\n        log.error(\n          \"PeerExchangeRPC message did not contains a `response` field\"\n        );\n        return;\n      }\n\n      return Promise.all(\n        response.peerInfos\n          .map((peerInfo) => peerInfo.enr)\n          .filter(isDefined)\n          .map(async (enr) => {\n            return { ENR: await EnrDecoder.fromRLP(enr) };\n          })\n      );\n    } catch (err) {\n      log.error(\"Failed to decode push reply\", err);\n      return;\n    }\n  }\n}\n\n/**\n *\n * @returns A function that creates a new peer exchange protocol\n */\nexport function wakuPeerExchange(): (\n  components: Libp2pComponents\n) => WakuPeerExchange {\n  return (components: Libp2pComponents) => new WakuPeerExchange(components);\n}\n", "import type { IdentifyResult } from \"@libp2p/interface\";\nimport { CustomEvent, EventEmitter } from \"@libp2p/interface/events\";\nimport type {\n  PeerDiscovery,\n  PeerDiscoveryEvents\n} from \"@libp2p/interface/peer-discovery\";\nimport { peerDiscovery as symbol } from \"@libp2p/interface/peer-discovery\";\nimport type { PeerId } from \"@libp2p/interface/peer-id\";\nimport type { PeerInfo } from \"@libp2p/interface/peer-info\";\nimport { encodeRelayShard } from \"@waku/enr\";\nimport { Libp2pComponents, Tags } from \"@waku/interfaces\";\nimport { Logger } from \"@waku/utils\";\n\nimport { PeerExchangeCodec, WakuPeerExchange } from \"./waku_peer_exchange.js\";\n\nconst log = new Logger(\"peer-exchange-discovery\");\n\nconst DEFAULT_PEER_EXCHANGE_REQUEST_NODES = 10;\nconst DEFAULT_PEER_EXCHANGE_QUERY_INTERVAL_MS = 10 * 1000;\nconst DEFAULT_MAX_RETRIES = 3;\n\nexport interface Options {\n  /**\n   * Tag a bootstrap peer with this name before \"discovering\" it (default: 'bootstrap')\n   */\n  tagName?: string;\n\n  /**\n   * The bootstrap peer tag will have this value (default: 50)\n   */\n  tagValue?: number;\n\n  /**\n   * Cause the bootstrap peer tag to be removed after this number of ms (default: 2 minutes)\n   */\n  tagTTL?: number;\n  /**\n   * The interval between queries to a peer (default: 10 seconds)\n   * The interval will increase by a factor of an incrementing number (starting at 1)\n   * until it reaches the maximum attempts before backoff\n   */\n  queryInterval?: number;\n  /**\n   * The number of attempts before the queries to a peer are aborted (default: 3)\n   */\n  maxRetries?: number;\n}\n\nexport const DEFAULT_PEER_EXCHANGE_TAG_NAME = Tags.PEER_EXCHANGE;\nconst DEFAULT_PEER_EXCHANGE_TAG_VALUE = 50;\nconst DEFAULT_PEER_EXCHANGE_TAG_TTL = 100_000_000;\n\nexport class PeerExchangeDiscovery\n  extends EventEmitter<PeerDiscoveryEvents>\n  implements PeerDiscovery\n{\n  private readonly components: Libp2pComponents;\n  private readonly peerExchange: WakuPeerExchange;\n  private readonly options: Options;\n  private isStarted: boolean;\n  private queryingPeers: Set<string> = new Set();\n  private queryAttempts: Map<string, number> = new Map();\n\n  private readonly handleDiscoveredPeer = (\n    event: CustomEvent<IdentifyResult>\n  ): void => {\n    const { protocols, peerId } = event.detail;\n\n    if (\n      !protocols.includes(PeerExchangeCodec) ||\n      this.queryingPeers.has(peerId.toString())\n    )\n      return;\n\n    this.queryingPeers.add(peerId.toString());\n    this.startRecurringQueries(peerId).catch((error) =>\n      log.error(`Error querying peer ${error}`)\n    );\n  };\n\n  constructor(components: Libp2pComponents, options: Options = {}) {\n    super();\n    this.components = components;\n    this.peerExchange = new WakuPeerExchange(components);\n    this.options = options;\n    this.isStarted = false;\n  }\n\n  /**\n   * Start emitting events\n   */\n  start(): void {\n    if (this.isStarted) {\n      return;\n    }\n\n    log.info(\"Starting peer exchange node discovery, discovering peers\");\n\n    // might be better to use \"peer:identify\" or \"peer:update\"\n    this.components.events.addEventListener(\n      \"peer:identify\",\n      this.handleDiscoveredPeer\n    );\n  }\n\n  /**\n   * Remove event listener\n   */\n  stop(): void {\n    if (!this.isStarted) return;\n    log.info(\"Stopping peer exchange node discovery\");\n    this.isStarted = false;\n    this.queryingPeers.clear();\n    this.components.events.removeEventListener(\n      \"peer:identify\",\n      this.handleDiscoveredPeer\n    );\n  }\n\n  get [symbol](): true {\n    return true;\n  }\n\n  get [Symbol.toStringTag](): string {\n    return \"@waku/peer-exchange\";\n  }\n\n  private readonly startRecurringQueries = async (\n    peerId: PeerId\n  ): Promise<void> => {\n    const peerIdStr = peerId.toString();\n    const {\n      queryInterval = DEFAULT_PEER_EXCHANGE_QUERY_INTERVAL_MS,\n      maxRetries = DEFAULT_MAX_RETRIES\n    } = this.options;\n\n    log.info(\n      `Querying peer: ${peerIdStr} (attempt ${\n        this.queryAttempts.get(peerIdStr) ?? 1\n      })`\n    );\n\n    await this.query(peerId);\n\n    const currentAttempt = this.queryAttempts.get(peerIdStr) ?? 1;\n\n    if (currentAttempt > maxRetries) {\n      this.abortQueriesForPeer(peerIdStr);\n      return;\n    }\n\n    setTimeout(() => {\n      this.queryAttempts.set(peerIdStr, currentAttempt + 1);\n      this.startRecurringQueries(peerId).catch((error) => {\n        log.error(`Error in startRecurringQueries: ${error}`);\n      });\n    }, queryInterval * currentAttempt);\n  };\n\n  private async query(peerId: PeerId): Promise<void> {\n    const peerInfos = await this.peerExchange.query({\n      numPeers: DEFAULT_PEER_EXCHANGE_REQUEST_NODES,\n      peerId\n    });\n\n    if (!peerInfos) {\n      log.error(\"Peer exchange query failed, no peer info returned\");\n      return;\n    }\n\n    for (const _peerInfo of peerInfos) {\n      const { ENR } = _peerInfo;\n      if (!ENR) {\n        log.warn(\"No ENR in peerInfo object, skipping\");\n        continue;\n      }\n\n      const { peerId, peerInfo, shardInfo } = ENR;\n      if (!peerId || !peerInfo) {\n        continue;\n      }\n\n      const hasPeer = await this.components.peerStore.has(peerId);\n      if (hasPeer) {\n        continue;\n      }\n\n      // update the tags for the peer\n      await this.components.peerStore.save(peerId, {\n        tags: {\n          [DEFAULT_PEER_EXCHANGE_TAG_NAME]: {\n            value: this.options.tagValue ?? DEFAULT_PEER_EXCHANGE_TAG_VALUE,\n            ttl: this.options.tagTTL ?? DEFAULT_PEER_EXCHANGE_TAG_TTL\n          }\n        },\n        ...(shardInfo && {\n          metadata: {\n            shardInfo: encodeRelayShard(shardInfo)\n          }\n        })\n      });\n\n      log.info(`Discovered peer: ${peerId.toString()}`);\n\n      this.dispatchEvent(\n        new CustomEvent<PeerInfo>(\"peer\", {\n          detail: {\n            id: peerId,\n            protocols: [],\n            multiaddrs: peerInfo.multiaddrs\n          }\n        })\n      );\n    }\n  }\n\n  private abortQueriesForPeer(peerIdStr: string): void {\n    log.info(`Aborting queries for peer: ${peerIdStr}`);\n    this.queryingPeers.delete(peerIdStr);\n    this.queryAttempts.delete(peerIdStr);\n  }\n}\n\nexport function wakuPeerExchangeDiscovery(): (\n  components: Libp2pComponents\n) => PeerExchangeDiscovery {\n  return (components: Libp2pComponents) =>\n    new PeerExchangeDiscovery(components);\n}\n", "import {\n  GossipSub,\n  GossipSubComponents,\n  GossipsubMessage,\n  GossipsubOpts\n} from \"@chainsafe/libp2p-gossipsub\";\nimport type { PeerIdStr, TopicStr } from \"@chainsafe/libp2p-gossipsub/types\";\nimport { SignaturePolicy } from \"@chainsafe/libp2p-gossipsub/types\";\nimport type { PeerId } from \"@libp2p/interface/peer-id\";\nimport type { PubSub } from \"@libp2p/interface/pubsub\";\nimport { sha256 } from \"@noble/hashes/sha256\";\nimport { DefaultPubSubTopic } from \"@waku/core\";\nimport {\n  ActiveSubscriptions,\n  Callback,\n  IAsyncIterator,\n  IDecodedMessage,\n  IDecoder,\n  IEncoder,\n  IMessage,\n  IRelay,\n  Libp2p,\n  ProtocolCreateOptions,\n  PubSubTopic,\n  SendError,\n  SendResult\n} from \"@waku/interfaces\";\nimport { isWireSizeUnderCap, toAsyncIterator } from \"@waku/utils\";\nimport { pushOrInitMapSet } from \"@waku/utils\";\nimport { Logger } from \"@waku/utils\";\n\nimport { RelayCodecs } from \"./constants.js\";\nimport { messageValidator } from \"./message_validator.js\";\nimport { TopicOnlyDecoder } from \"./topic_only_message.js\";\n\nconst log = new Logger(\"relay\");\n\nexport type Observer<T extends IDecodedMessage> = {\n  decoder: IDecoder<T>;\n  callback: Callback<T>;\n};\n\nexport type RelayCreateOptions = ProtocolCreateOptions & GossipsubOpts;\nexport type ContentTopic = string;\n\n/**\n * Implements the [Waku v2 Relay protocol](https://rfc.vac.dev/spec/11/).\n * Throws if libp2p.pubsub does not support Waku Relay\n */\nclass Relay implements IRelay {\n  public readonly pubsubTopics: Set<PubSubTopic>;\n  private defaultDecoder: IDecoder<IDecodedMessage>;\n\n  public static multicodec: string = RelayCodecs[0];\n  public readonly gossipSub: GossipSub;\n\n  /**\n   * observers called when receiving new message.\n   * Observers under key `\"\"` are always called.\n   */\n  private observers: Map<PubSubTopic, Map<ContentTopic, Set<unknown>>>;\n\n  constructor(libp2p: Libp2p, options?: Partial<RelayCreateOptions>) {\n    if (!this.isRelayPubSub(libp2p.services.pubsub)) {\n      throw Error(\n        `Failed to initialize Relay. libp2p.pubsub does not support ${Relay.multicodec}`\n      );\n    }\n\n    this.gossipSub = libp2p.services.pubsub as GossipSub;\n    this.pubsubTopics = new Set(options?.pubsubTopics ?? [DefaultPubSubTopic]);\n\n    if (this.gossipSub.isStarted()) {\n      this.subscribeToAllTopics();\n    }\n\n    this.observers = new Map();\n\n    // Default PubSubTopic decoder\n    // TODO: User might want to decide what decoder should be used (e.g. for RLN)\n    this.defaultDecoder = new TopicOnlyDecoder();\n  }\n\n  /**\n   * Mounts the gossipsub protocol onto the libp2p node\n   * and subscribes to all the topics.\n   *\n   * @override\n   * @returns {void}\n   */\n  public async start(): Promise<void> {\n    if (this.gossipSub.isStarted()) {\n      throw Error(\"GossipSub already started.\");\n    }\n\n    await this.gossipSub.start();\n    this.subscribeToAllTopics();\n  }\n\n  /**\n   * Send Waku message.\n   */\n  public async send(encoder: IEncoder, message: IMessage): Promise<SendResult> {\n    const recipients: PeerId[] = [];\n\n    const { pubsubTopic } = encoder;\n    if (!this.pubsubTopics.has(pubsubTopic)) {\n      log.error(\"Failed to send waku relay: topic not configured\");\n      return {\n        recipients,\n        errors: [SendError.TOPIC_NOT_CONFIGURED]\n      };\n    }\n\n    const msg = await encoder.toWire(message);\n    if (!msg) {\n      log.error(\"Failed to encode message, aborting publish\");\n      return {\n        recipients,\n        errors: [SendError.ENCODE_FAILED]\n      };\n    }\n\n    if (!isWireSizeUnderCap(msg)) {\n      log.error(\"Failed to send waku relay: message is bigger that 1MB\");\n      return {\n        recipients,\n        errors: [SendError.SIZE_TOO_BIG]\n      };\n    }\n\n    return this.gossipSub.publish(pubsubTopic, msg);\n  }\n\n  public subscribe<T extends IDecodedMessage>(\n    decoders: IDecoder<T> | IDecoder<T>[],\n    callback: Callback<T>\n  ): () => void {\n    const observers: Array<[PubSubTopic, Observer<T>]> = [];\n\n    for (const decoder of Array.isArray(decoders) ? decoders : [decoders]) {\n      const { pubsubTopic } = decoder;\n      const ctObs: Map<ContentTopic, Set<Observer<T>>> = this.observers.get(\n        pubsubTopic\n      ) ?? new Map();\n      const observer = { pubsubTopic, decoder, callback };\n      pushOrInitMapSet(ctObs, decoder.contentTopic, observer);\n\n      this.observers.set(pubsubTopic, ctObs);\n      observers.push([pubsubTopic, observer]);\n    }\n\n    return () => {\n      this.removeObservers(observers);\n    };\n  }\n\n  private removeObservers<T extends IDecodedMessage>(\n    observers: Array<[PubSubTopic, Observer<T>]>\n  ): void {\n    for (const [pubsubTopic, observer] of observers) {\n      const ctObs = this.observers.get(pubsubTopic);\n      if (!ctObs) continue;\n\n      const contentTopic = observer.decoder.contentTopic;\n      const _obs = ctObs.get(contentTopic);\n      if (!_obs) continue;\n\n      _obs.delete(observer);\n      ctObs.set(contentTopic, _obs);\n      this.observers.set(pubsubTopic, ctObs);\n    }\n  }\n\n  public toSubscriptionIterator<T extends IDecodedMessage>(\n    decoders: IDecoder<T> | IDecoder<T>[]\n  ): Promise<IAsyncIterator<T>> {\n    return toAsyncIterator(this, decoders);\n  }\n\n  public getActiveSubscriptions(): ActiveSubscriptions {\n    const map = new Map();\n    for (const pubsubTopic of this.pubsubTopics) {\n      map.set(pubsubTopic, Array.from(this.observers.keys()));\n    }\n    return map;\n  }\n\n  public getMeshPeers(topic: TopicStr = DefaultPubSubTopic): PeerIdStr[] {\n    return this.gossipSub.getMeshPeers(topic);\n  }\n\n  private subscribeToAllTopics(): void {\n    for (const pubsubTopic of this.pubsubTopics) {\n      this.gossipSubSubscribe(pubsubTopic);\n    }\n  }\n\n  private async processIncomingMessage<T extends IDecodedMessage>(\n    pubsubTopic: string,\n    bytes: Uint8Array\n  ): Promise<void> {\n    const topicOnlyMsg = await this.defaultDecoder.fromWireToProtoObj(bytes);\n    if (!topicOnlyMsg || !topicOnlyMsg.contentTopic) {\n      log.warn(\"Message does not have a content topic, skipping\");\n      return;\n    }\n\n    // Retrieve the map of content topics for the given pubsubTopic\n    const contentTopicMap = this.observers.get(pubsubTopic);\n    if (!contentTopicMap) {\n      return;\n    }\n\n    // Retrieve the set of observers for the given contentTopic\n    const observers = contentTopicMap.get(topicOnlyMsg.contentTopic) as Set<\n      Observer<T>\n    >;\n    if (!observers) {\n      return;\n    }\n\n    await Promise.all(\n      Array.from(observers).map(({ decoder, callback }) => {\n        return (async () => {\n          try {\n            const protoMsg = await decoder.fromWireToProtoObj(bytes);\n            if (!protoMsg) {\n              log.error(\n                \"Internal error: message previously decoded failed on 2nd pass.\"\n              );\n              return;\n            }\n            const msg = await decoder.fromProtoObj(pubsubTopic, protoMsg);\n            if (msg) {\n              await callback(msg);\n            } else {\n              log.error(\n                \"Failed to decode messages on\",\n                topicOnlyMsg.contentTopic\n              );\n            }\n          } catch (error) {\n            log.error(\"Error while decoding message:\", error);\n          }\n        })();\n      })\n    );\n  }\n\n  /**\n   * Subscribe to a pubsub topic and start emitting Waku messages to observers.\n   *\n   * @override\n   */\n  private gossipSubSubscribe(pubsubTopic: string): void {\n    this.gossipSub.addEventListener(\n      \"gossipsub:message\",\n      (event: CustomEvent<GossipsubMessage>) => {\n        if (event.detail.msg.topic !== pubsubTopic) return;\n\n        this.processIncomingMessage(\n          event.detail.msg.topic,\n          event.detail.msg.data\n        ).catch((e) => log.error(\"Failed to process incoming message\", e));\n      }\n    );\n\n    this.gossipSub.topicValidators.set(pubsubTopic, messageValidator);\n    this.gossipSub.subscribe(pubsubTopic);\n  }\n\n  private isRelayPubSub(pubsub: PubSub | undefined): boolean {\n    return pubsub?.multicodecs?.includes(Relay.multicodec) ?? false;\n  }\n}\n\nexport function wakuRelay(\n  init: Partial<ProtocolCreateOptions> = {}\n): (libp2p: Libp2p) => IRelay {\n  return (libp2p: Libp2p) => new Relay(libp2p, init);\n}\n\nexport function wakuGossipSub(\n  init: Partial<RelayCreateOptions> = {}\n): (components: GossipSubComponents) => GossipSub {\n  return (components: GossipSubComponents) => {\n    init = {\n      ...init,\n      msgIdFn: ({ data }) => sha256(data),\n      // Ensure that no signature is included nor expected in the messages.\n      globalSignaturePolicy: SignaturePolicy.StrictNoSign,\n      fallbackToFloodsub: false\n    };\n    const pubsub = new GossipSub(components, init);\n    pubsub.multicodecs = RelayCodecs;\n    return pubsub;\n  };\n}\n", "import type { RPC } from './message/rpc.js'\nimport type { MessageId, MsgIdStr, PeerIdStr, TopicStr, MsgIdToStrFn } from './types.js'\n\nexport type CacheEntry = MessageId & {\n  topic: TopicStr\n}\n\nexport type MessageCacheRecord = Pick<MessageCacheEntry, 'message' | 'originatingPeers'>\n\ninterface MessageCacheEntry {\n  message: RPC.IMessage\n  /**\n   * Tracks if the message has been validated by the app layer and thus forwarded\n   */\n  validated: boolean\n  /**\n   * Tracks peers that sent this message before it has been validated by the app layer\n   */\n  originatingPeers: Set<PeerIdStr>\n  /**\n   * For every message and peer the number of times this peer asked for the message\n   */\n  iwantCounts: Map<PeerIdStr, number>\n}\n\nexport class MessageCache {\n  msgs = new Map<MsgIdStr, MessageCacheEntry>()\n\n  msgIdToStrFn: MsgIdToStrFn\n\n  history: CacheEntry[][] = []\n\n  /** Track with accounting of messages in the mcache that are not yet validated */\n  notValidatedCount = 0\n\n  /**\n   * Holds history of messages in timebounded history arrays\n   */\n  constructor(\n    /**\n     * The number of indices in the cache history used for gossiping. That means that a message\n     * won't get gossiped anymore when shift got called `gossip` many times after inserting the\n     * message in the cache.\n     */\n    private readonly gossip: number,\n    historyCapacity: number,\n    msgIdToStrFn: MsgIdToStrFn\n  ) {\n    this.msgIdToStrFn = msgIdToStrFn\n    for (let i = 0; i < historyCapacity; i++) {\n      this.history[i] = []\n    }\n  }\n\n  get size(): number {\n    return this.msgs.size\n  }\n\n  /**\n   * Adds a message to the current window and the cache\n   * Returns true if the message is not known and is inserted in the cache\n   */\n  put(messageId: MessageId, msg: RPC.IMessage, validated = false): boolean {\n    const { msgIdStr } = messageId\n    // Don't add duplicate entries to the cache.\n    if (this.msgs.has(msgIdStr)) {\n      return false\n    }\n\n    this.msgs.set(msgIdStr, {\n      message: msg,\n      validated,\n      originatingPeers: new Set(),\n      iwantCounts: new Map()\n    })\n\n    this.history[0].push({ ...messageId, topic: msg.topic })\n\n    if (!validated) {\n      this.notValidatedCount++\n    }\n\n    return true\n  }\n\n  observeDuplicate(msgId: MsgIdStr, fromPeerIdStr: PeerIdStr): void {\n    const entry = this.msgs.get(msgId)\n\n    if (\n      entry &&\n      // if the message is already validated, we don't need to store extra peers sending us\n      // duplicates as the message has already been forwarded\n      !entry.validated\n    ) {\n      entry.originatingPeers.add(fromPeerIdStr)\n    }\n  }\n\n  /**\n   * Retrieves a message from the cache by its ID, if it is still present\n   */\n  get(msgId: Uint8Array): RPC.IMessage | undefined {\n    return this.msgs.get(this.msgIdToStrFn(msgId))?.message\n  }\n\n  /**\n   * Increases the iwant count for the given message by one and returns the message together\n   * with the iwant if the message exists.\n   */\n  getWithIWantCount(msgIdStr: string, p: string): { msg: RPC.IMessage; count: number } | null {\n    const msg = this.msgs.get(msgIdStr)\n    if (!msg) {\n      return null\n    }\n\n    const count = (msg.iwantCounts.get(p) ?? 0) + 1\n    msg.iwantCounts.set(p, count)\n\n    return { msg: msg.message, count }\n  }\n\n  /**\n   * Retrieves a list of message IDs for a set of topics\n   */\n  getGossipIDs(topics: Set<string>): Map<string, Uint8Array[]> {\n    const msgIdsByTopic = new Map<string, Uint8Array[]>()\n    for (let i = 0; i < this.gossip; i++) {\n      this.history[i].forEach((entry) => {\n        const msg = this.msgs.get(entry.msgIdStr)\n        if (msg && msg.validated && topics.has(entry.topic)) {\n          let msgIds = msgIdsByTopic.get(entry.topic)\n          if (!msgIds) {\n            msgIds = []\n            msgIdsByTopic.set(entry.topic, msgIds)\n          }\n          msgIds.push(entry.msgId)\n        }\n      })\n    }\n\n    return msgIdsByTopic\n  }\n\n  /**\n   * Gets a message with msgId and tags it as validated.\n   * This function also returns the known peers that have sent us this message. This is used to\n   * prevent us sending redundant messages to peers who have already propagated it.\n   */\n  validate(msgId: MsgIdStr): MessageCacheRecord | null {\n    const entry = this.msgs.get(msgId)\n    if (!entry) {\n      return null\n    }\n\n    if (!entry.validated) {\n      this.notValidatedCount--\n    }\n\n    const { message, originatingPeers } = entry\n    entry.validated = true\n    // Clear the known peers list (after a message is validated, it is forwarded and we no\n    // longer need to store the originating peers).\n    entry.originatingPeers = new Set()\n    return { message, originatingPeers }\n  }\n\n  /**\n   * Shifts the current window, discarding messages older than this.history.length of the cache\n   */\n  shift(): void {\n    const lastCacheEntries = this.history[this.history.length - 1]\n    lastCacheEntries.forEach((cacheEntry) => {\n      const entry = this.msgs.get(cacheEntry.msgIdStr)\n      if (entry) {\n        this.msgs.delete(cacheEntry.msgIdStr)\n        if (!entry.validated) {\n          this.notValidatedCount--\n        }\n      }\n    })\n\n    this.history.pop()\n    this.history.unshift([])\n  }\n\n  remove(msgId: MsgIdStr): MessageCacheRecord | null {\n    const entry = this.msgs.get(msgId)\n    if (!entry) {\n      return null\n    }\n\n    // Keep the message on the history vector, it will be dropped on a shift()\n    this.msgs.delete(msgId)\n    return entry\n  }\n}\n", "import cjs from \"./rpc.cjs\"\n\nexport const {RPC} = cjs\n", "export const second = 1000\nexport const minute = 60 * second\n\n// Protocol identifiers\n\nexport const FloodsubID = '/floodsub/1.0.0'\n\n/**\n * The protocol ID for version 1.0.0 of the Gossipsub protocol\n * It is advertised along with GossipsubIDv11 for backwards compatability\n */\nexport const GossipsubIDv10 = '/meshsub/1.0.0'\n\n/**\n * The protocol ID for version 1.1.0 of the Gossipsub protocol\n * See the spec for details about how v1.1.0 compares to v1.0.0:\n * https://github.com/libp2p/specs/blob/master/pubsub/gossipsub/gossipsub-v1.1.md\n */\nexport const GossipsubIDv11 = '/meshsub/1.1.0'\n\n// Overlay parameters\n\n/**\n * GossipsubD sets the optimal degree for a Gossipsub topic mesh. For example, if GossipsubD == 6,\n * each peer will want to have about six peers in their mesh for each topic they're subscribed to.\n * GossipsubD should be set somewhere between GossipsubDlo and GossipsubDhi.\n */\nexport const GossipsubD = 6\n\n/**\n * GossipsubDlo sets the lower bound on the number of peers we keep in a Gossipsub topic mesh.\n * If we have fewer than GossipsubDlo peers, we will attempt to graft some more into the mesh at\n * the next heartbeat.\n */\nexport const GossipsubDlo = 4\n\n/**\n * GossipsubDhi sets the upper bound on the number of peers we keep in a Gossipsub topic mesh.\n * If we have more than GossipsubDhi peers, we will select some to prune from the mesh at the next heartbeat.\n */\nexport const GossipsubDhi = 12\n\n/**\n * GossipsubDscore affects how peers are selected when pruning a mesh due to over subscription.\n * At least GossipsubDscore of the retained peers will be high-scoring, while the remainder are\n * chosen randomly.\n */\nexport const GossipsubDscore = 4\n\n/**\n * GossipsubDout sets the quota for the number of outbound connections to maintain in a topic mesh.\n * When the mesh is pruned due to over subscription, we make sure that we have outbound connections\n * to at least GossipsubDout of the survivor peers. This prevents sybil attackers from overwhelming\n * our mesh with incoming connections.\n *\n * GossipsubDout must be set below GossipsubDlo, and must not exceed GossipsubD / 2.\n */\nexport const GossipsubDout = 2\n\n// Gossip parameters\n\n/**\n * GossipsubHistoryLength controls the size of the message cache used for gossip.\n * The message cache will remember messages for GossipsubHistoryLength heartbeats.\n */\nexport const GossipsubHistoryLength = 5\n\n/**\n * GossipsubHistoryGossip controls how many cached message ids we will advertise in\n * IHAVE gossip messages. When asked for our seen message IDs, we will return\n * only those from the most recent GossipsubHistoryGossip heartbeats. The slack between\n * GossipsubHistoryGossip and GossipsubHistoryLength allows us to avoid advertising messages\n * that will be expired by the time they're requested.\n *\n * GossipsubHistoryGossip must be less than or equal to GossipsubHistoryLength to\n * avoid a runtime panic.\n */\nexport const GossipsubHistoryGossip = 3\n\n/**\n * GossipsubDlazy affects how many peers we will emit gossip to at each heartbeat.\n * We will send gossip to at least GossipsubDlazy peers outside our mesh. The actual\n * number may be more, depending on GossipsubGossipFactor and how many peers we're\n * connected to.\n */\nexport const GossipsubDlazy = 6\n\n/**\n * GossipsubGossipFactor affects how many peers we will emit gossip to at each heartbeat.\n * We will send gossip to GossipsubGossipFactor * (total number of non-mesh peers), or\n * GossipsubDlazy, whichever is greater.\n */\nexport const GossipsubGossipFactor = 0.25\n\n/**\n * GossipsubGossipRetransmission controls how many times we will allow a peer to request\n * the same message id through IWANT gossip before we start ignoring them. This is designed\n * to prevent peers from spamming us with requests and wasting our resources.\n */\nexport const GossipsubGossipRetransmission = 3\n\n// Heartbeat interval\n\n/**\n * GossipsubHeartbeatInitialDelay is the short delay before the heartbeat timer begins\n * after the router is initialized.\n */\nexport const GossipsubHeartbeatInitialDelay = 100\n\n/**\n * GossipsubHeartbeatInterval controls the time between heartbeats.\n */\nexport const GossipsubHeartbeatInterval = second\n\n/**\n * GossipsubFanoutTTL controls how long we keep track of the fanout state. If it's been\n * GossipsubFanoutTTL since we've published to a topic that we're not subscribed to,\n * we'll delete the fanout map for that topic.\n */\nexport const GossipsubFanoutTTL = minute\n\n/**\n * GossipsubPrunePeers controls the number of peers to include in prune Peer eXchange.\n * When we prune a peer that's eligible for PX (has a good score, etc), we will try to\n * send them signed peer records for up to GossipsubPrunePeers other peers that we\n * know of.\n */\nexport const GossipsubPrunePeers = 16\n\n/**\n * GossipsubPruneBackoff controls the backoff time for pruned peers. This is how long\n * a peer must wait before attempting to graft into our mesh again after being pruned.\n * When pruning a peer, we send them our value of GossipsubPruneBackoff so they know\n * the minimum time to wait. Peers running older versions may not send a backoff time,\n * so if we receive a prune message without one, we will wait at least GossipsubPruneBackoff\n * before attempting to re-graft.\n */\nexport const GossipsubPruneBackoff = minute\n\n/**\n * Backoff to use when unsuscribing from a topic. Should not resubscribe to this topic before it expired.\n */\nexport const GossipsubUnsubscribeBackoff = 10 * second\n\n/**\n * GossipsubPruneBackoffTicks is the number of heartbeat ticks for attempting to prune expired\n * backoff timers.\n */\nexport const GossipsubPruneBackoffTicks = 15\n\n/**\n * GossipsubConnectors controls the number of active connection attempts for peers obtained through PX.\n */\nexport const GossipsubConnectors = 8\n\n/**\n * GossipsubMaxPendingConnections sets the maximum number of pending connections for peers attempted through px.\n */\nexport const GossipsubMaxPendingConnections = 128\n\n/**\n * GossipsubConnectionTimeout controls the timeout for connection attempts.\n */\nexport const GossipsubConnectionTimeout = 30 * second\n\n/**\n * GossipsubDirectConnectTicks is the number of heartbeat ticks for attempting to reconnect direct peers\n * that are not currently connected.\n */\nexport const GossipsubDirectConnectTicks = 300\n\n/**\n * GossipsubDirectConnectInitialDelay is the initial delay before opening connections to direct peers\n */\nexport const GossipsubDirectConnectInitialDelay = second\n\n/**\n * GossipsubOpportunisticGraftTicks is the number of heartbeat ticks for attempting to improve the mesh\n * with opportunistic grafting. Every GossipsubOpportunisticGraftTicks we will attempt to select some\n * high-scoring mesh peers to replace lower-scoring ones, if the median score of our mesh peers falls\n * below a threshold\n */\nexport const GossipsubOpportunisticGraftTicks = 60\n\n/**\n * GossipsubOpportunisticGraftPeers is the number of peers to opportunistically graft.\n */\nexport const GossipsubOpportunisticGraftPeers = 2\n\n/**\n * If a GRAFT comes before GossipsubGraftFloodThreshold has elapsed since the last PRUNE,\n * then there is an extra score penalty applied to the peer through P7.\n */\nexport const GossipsubGraftFloodThreshold = 10 * second\n\n/**\n * GossipsubMaxIHaveLength is the maximum number of messages to include in an IHAVE message.\n * Also controls the maximum number of IHAVE ids we will accept and request with IWANT from a\n * peer within a heartbeat, to protect from IHAVE floods. You should adjust this value from the\n * default if your system is pushing more than 5000 messages in GossipsubHistoryGossip heartbeats;\n * with the defaults this is 1666 messages/s.\n */\nexport const GossipsubMaxIHaveLength = 5000\n\n/**\n * GossipsubMaxIHaveMessages is the maximum number of IHAVE messages to accept from a peer within a heartbeat.\n */\nexport const GossipsubMaxIHaveMessages = 10\n\n/**\n * Time to wait for a message requested through IWANT following an IHAVE advertisement.\n * If the message is not received within this window, a broken promise is declared and\n * the router may apply bahavioural penalties.\n */\nexport const GossipsubIWantFollowupTime = 3 * second\n\n/**\n * Time in milliseconds to keep message ids in the seen cache\n */\nexport const GossipsubSeenTTL = 2 * minute\n\nexport const TimeCacheDuration = 120 * 1000\n\nexport const ERR_TOPIC_VALIDATOR_REJECT = 'ERR_TOPIC_VALIDATOR_REJECT'\nexport const ERR_TOPIC_VALIDATOR_IGNORE = 'ERR_TOPIC_VALIDATOR_IGNORE'\n\n/**\n * If peer score is better than this, we accept messages from this peer\n * within ACCEPT_FROM_WHITELIST_DURATION_MS from the last time computing score.\n **/\nexport const ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE = 0\n\n/**\n * If peer score >= ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE, accept up to this\n * number of messages from that peer.\n */\nexport const ACCEPT_FROM_WHITELIST_MAX_MESSAGES = 128\n\n/**\n * If peer score >= ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE, accept messages from\n * this peer up to this time duration.\n */\nexport const ACCEPT_FROM_WHITELIST_DURATION_MS = 1000\n\n/**\n * The default MeshMessageDeliveriesWindow to be used in metrics.\n */\nexport const DEFAULT_METRIC_MESH_MESSAGE_DELIVERIES_WINDOWS = 1000\n\n/** Wait for 1 more heartbeats before clearing a backoff */\nexport const BACKOFF_SLACK = 1\n", "/**\n * Pseudo-randomly shuffles an array\n *\n * Mutates the input array\n */\nexport function shuffle<T>(arr: T[]): T[] {\n  if (arr.length <= 1) {\n    return arr\n  }\n  const randInt = () => {\n    return Math.floor(Math.random() * Math.floor(arr.length))\n  }\n\n  for (let i = 0; i < arr.length; i++) {\n    const j = randInt()\n    const tmp = arr[i]\n    arr[i] = arr[j]\n    arr[j] = tmp\n  }\n  return arr\n}\n", "import { toString } from 'uint8arrays/to-string'\n\n/**\n * Browser friendly function to convert Uint8Array message id to base64 string.\n */\nexport function messageIdToString(msgId: Uint8Array): string {\n  return toString(msgId, 'base64')\n}\n", "import type { Stream } from '../connection/index.js'\nimport type { TypedEventTarget } from '../events.js'\nimport type { PeerId } from '../peer-id/index.js'\nimport type { Pushable } from 'it-pushable'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\n/**\n * On the producing side:\n * * Build messages with the signature, key (from may be enough for certain inlineable public key types), from and seqno fields.\n *\n * On the consuming side:\n * * Enforce the fields to be present, reject otherwise.\n * * Propagate only if the fields are valid and signature can be verified, reject otherwise.\n */\nexport const StrictSign = 'StrictSign'\n\n/**\n * On the producing side:\n * * Build messages without the signature, key, from and seqno fields.\n * * The corresponding protobuf key-value pairs are absent from the marshalled message, not just empty.\n *\n * On the consuming side:\n * * Enforce the fields to be absent, reject otherwise.\n * * Propagate only if the fields are absent, reject otherwise.\n * * A message_id function will not be able to use the above fields, and should instead rely on the data field. A commonplace strategy is to calculate a hash.\n */\nexport const StrictNoSign = 'StrictNoSign'\n\nexport type SignaturePolicy = typeof StrictSign | typeof StrictNoSign\n\nexport interface SignedMessage {\n  type: 'signed'\n  from: PeerId\n  topic: string\n  data: Uint8Array\n  sequenceNumber: bigint\n  signature: Uint8Array\n  key: Uint8Array\n}\n\nexport interface UnsignedMessage {\n  type: 'unsigned'\n  topic: string\n  data: Uint8Array\n}\n\nexport type Message = SignedMessage | UnsignedMessage\n\nexport interface PubSubRPCMessage {\n  from?: Uint8Array\n  topic?: string\n  data?: Uint8Array\n  sequenceNumber?: Uint8Array\n  signature?: Uint8Array\n  key?: Uint8Array\n}\n\nexport interface PubSubRPCSubscription {\n  subscribe?: boolean\n  topic?: string\n}\n\nexport interface PubSubRPC {\n  subscriptions: PubSubRPCSubscription[]\n  messages: PubSubRPCMessage[]\n}\n\nexport interface PeerStreams extends TypedEventTarget<PeerStreamEvents> {\n  id: PeerId\n  protocol: string\n  outboundStream?: Pushable<Uint8ArrayList>\n  inboundStream?: AsyncIterable<Uint8ArrayList>\n  isWritable: boolean\n\n  close(): void\n  write(buf: Uint8Array | Uint8ArrayList): void\n  attachInboundStream(stream: Stream): AsyncIterable<Uint8ArrayList>\n  attachOutboundStream(stream: Stream): Promise<Pushable<Uint8ArrayList>>\n}\n\nexport interface PubSubInit {\n  enabled?: boolean\n\n  multicodecs?: string[]\n\n  /**\n   * defines how signatures should be handled\n   */\n  globalSignaturePolicy?: SignaturePolicy\n\n  /**\n   * if can relay messages not subscribed\n   */\n  canRelayMessage?: boolean\n\n  /**\n   * if publish should emit to self, if subscribed\n   */\n  emitSelf?: boolean\n\n  /**\n   * handle this many incoming pubsub messages concurrently\n   */\n  messageProcessingConcurrency?: number\n\n  /**\n   * How many parallel incoming streams to allow on the pubsub protocol per-connection\n   */\n  maxInboundStreams?: number\n\n  /**\n   * How many parallel outgoing streams to allow on the pubsub protocol per-connection\n   */\n  maxOutboundStreams?: number\n}\n\ninterface Subscription {\n  topic: string\n  subscribe: boolean\n}\n\nexport interface SubscriptionChangeData {\n  peerId: PeerId\n  subscriptions: Subscription[]\n}\n\nexport interface PubSubEvents {\n  'subscription-change': CustomEvent<SubscriptionChangeData>\n  'message': CustomEvent<Message>\n}\n\nexport interface PublishResult {\n  recipients: PeerId[]\n}\n\nexport enum TopicValidatorResult {\n  /**\n   * The message is considered valid, and it should be delivered and forwarded to the network\n   */\n  Accept = 'accept',\n  /**\n   * The message is neither delivered nor forwarded to the network\n   */\n  Ignore = 'ignore',\n  /**\n   * The message is considered invalid, and it should be rejected\n   */\n  Reject = 'reject'\n}\n\nexport interface TopicValidatorFn {\n  (peer: PeerId, message: Message): TopicValidatorResult | Promise<TopicValidatorResult>\n}\n\nexport interface PubSub<Events extends Record<string, any> = PubSubEvents> extends TypedEventTarget<Events> {\n  /**\n   * The global signature policy controls whether or not we sill send and receive\n   * signed or unsigned messages.\n   *\n   * Signed messages prevent spoofing message senders and should be preferred to\n   * using unsigned messages.\n   */\n  globalSignaturePolicy: typeof StrictSign | typeof StrictNoSign\n\n  /**\n   * A list of multicodecs that contain the pubsub protocol name.\n   */\n  multicodecs: string[]\n\n  /**\n   * Pubsub routers support message validators per topic, which will validate the message\n   * before its propagations. They are stored in a map where keys are the topic name and\n   * values are the validators.\n   *\n   * @example\n   *\n   * ```js\n   * const topic = 'topic'\n   * const validateMessage = (msgTopic, msg) => {\n   *   const input = uint8ArrayToString(msg.data)\n   *   const validInputs = ['a', 'b', 'c']\n   *\n   *   if (!validInputs.includes(input)) {\n   *     throw new Error('no valid input received')\n   *   }\n   * }\n   * libp2p.pubsub.topicValidators.set(topic, validateMessage)\n   * ```\n   */\n  topicValidators: Map<string, TopicValidatorFn>\n\n  getPeers(): PeerId[]\n\n  /**\n   * Gets a list of topics the node is subscribed to.\n   *\n   * ```js\n   * const topics = libp2p.pubsub.getTopics()\n   * ```\n   */\n  getTopics(): string[]\n\n  /**\n   * Subscribes to a pubsub topic.\n   *\n   * @example\n   *\n   * ```js\n   * const topic = 'topic'\n   * const handler = (msg) => {\n   *   if (msg.topic === topic) {\n   *     // msg.data - pubsub data received\n   *   }\n   * }\n   *\n   * libp2p.pubsub.addEventListener('message', handler)\n   * libp2p.pubsub.subscribe(topic)\n   * ```\n   */\n  subscribe(topic: string): void\n\n  /**\n   * Unsubscribes from a pubsub topic.\n   *\n   * @example\n   *\n   * ```js\n   * const topic = 'topic'\n   * const handler = (msg) => {\n   *   // msg.data - pubsub data received\n   * }\n   *\n   * libp2p.pubsub.removeEventListener(topic handler)\n   * libp2p.pubsub.unsubscribe(topic)\n   * ```\n   */\n  unsubscribe(topic: string): void\n\n  /**\n   * Gets a list of the PeerIds that are subscribed to one topic.\n   *\n   * @example\n   *\n   * ```js\n   * const peerIds = libp2p.pubsub.getSubscribers(topic)\n   * ```\n   */\n  getSubscribers(topic: string): PeerId[]\n\n  /**\n   * Publishes messages to the given topic.\n   *\n   * @example\n   *\n   * ```js\n   * const topic = 'topic'\n   * const data = uint8ArrayFromString('data')\n   *\n   * await libp2p.pubsub.publish(topic, data)\n   * ```\n   */\n  publish(topic: string, data: Uint8Array): Promise<PublishResult>\n}\n\nexport interface PeerStreamEvents {\n  'stream:inbound': CustomEvent<never>\n  'stream:outbound': CustomEvent<never>\n  'close': CustomEvent<never>\n}\n", "import type { PeerId } from '@libp2p/interface/peer-id'\nimport type { PrivateKey } from '@libp2p/interface/keys'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { RPC } from './message/rpc.js'\nimport { type Message, TopicValidatorResult } from '@libp2p/interface/pubsub'\n\nexport type MsgIdStr = string\nexport type PeerIdStr = string\nexport type TopicStr = string\nexport type IPStr = string\n\nexport interface AddrInfo {\n  id: PeerId\n  addrs: Multiaddr[]\n}\n\n/**\n * Compute a local non-spec'ed msg-id for faster de-duplication of seen messages.\n * Used exclusively for a local seen_cache\n */\nexport type FastMsgIdFn = (msg: RPC.IMessage) => string | number\n\n/**\n * By default, gossipsub only provide a browser friendly function to convert Uint8Array message id to string.\n * Application could use this option to provide a more efficient function.\n */\nexport type MsgIdToStrFn = (msgId: Uint8Array) => string\n\n/**\n * Compute spec'ed msg-id. Used for IHAVE / IWANT messages\n */\nexport interface MsgIdFn {\n  (msg: Message): Promise<Uint8Array> | Uint8Array\n}\n\nexport interface DataTransform {\n  /**\n   * Takes the data published by peers on a topic and transforms the data.\n   * Should be the reverse of outboundTransform(). Example:\n   * - `inboundTransform()`: decompress snappy payload\n   * - `outboundTransform()`: compress snappy payload\n   */\n  inboundTransform(topic: TopicStr, data: Uint8Array): Uint8Array\n\n  /**\n   * Takes the data to be published (a topic and associated data) transforms the data. The\n   * transformed data will then be used to create a `RawGossipsubMessage` to be sent to peers.\n   */\n  outboundTransform(topic: TopicStr, data: Uint8Array): Uint8Array\n}\n\nexport enum SignaturePolicy {\n  /**\n   * On the producing side:\n   * - Build messages with the signature, key (from may be enough for certain inlineable public key types), from and seqno fields.\n   *\n   * On the consuming side:\n   * - Enforce the fields to be present, reject otherwise.\n   * - Propagate only if the fields are valid and signature can be verified, reject otherwise.\n   */\n  StrictSign = 'StrictSign',\n  /**\n   * On the producing side:\n   * - Build messages without the signature, key, from and seqno fields.\n   * - The corresponding protobuf key-value pairs are absent from the marshalled message, not just empty.\n   *\n   * On the consuming side:\n   * - Enforce the fields to be absent, reject otherwise.\n   * - Propagate only if the fields are absent, reject otherwise.\n   * - A message_id function will not be able to use the above fields, and should instead rely on the data field. A commonplace strategy is to calculate a hash.\n   */\n  StrictNoSign = 'StrictNoSign'\n}\n\nexport type PublishOpts = {\n  allowPublishToZeroPeers?: boolean\n  ignoreDuplicatePublishError?: boolean\n}\n\nexport enum PublishConfigType {\n  Signing,\n  Anonymous\n}\n\nexport type PublishConfig =\n  | {\n      type: PublishConfigType.Signing\n      author: PeerId\n      key: Uint8Array\n      privateKey: PrivateKey\n    }\n  | { type: PublishConfigType.Anonymous }\n\nexport type RejectReasonObj =\n  | { reason: RejectReason.Error; error: ValidateError }\n  | { reason: Exclude<RejectReason, RejectReason.Error> }\n\nexport enum RejectReason {\n  /**\n   * The message failed the configured validation during decoding.\n   * SelfOrigin is considered a ValidationError\n   */\n  Error = 'error',\n  /**\n   * Custom validator fn reported status IGNORE.\n   */\n  Ignore = 'ignore',\n  /**\n   * Custom validator fn reported status REJECT.\n   */\n  Reject = 'reject',\n  /**\n   * The peer that sent the message OR the source from field is blacklisted.\n   * Causes messages to be ignored, not penalized, neither do score record creation.\n   */\n  Blacklisted = 'blacklisted'\n}\n\nexport enum ValidateError {\n  /// The message has an invalid signature,\n  InvalidSignature = 'invalid_signature',\n  /// The sequence number was the incorrect size\n  InvalidSeqno = 'invalid_seqno',\n  /// The PeerId was invalid\n  InvalidPeerId = 'invalid_peerid',\n  /// Signature existed when validation has been sent to\n  /// [`crate::behaviour::MessageAuthenticity::Anonymous`].\n  SignaturePresent = 'signature_present',\n  /// Sequence number existed when validation has been sent to\n  /// [`crate::behaviour::MessageAuthenticity::Anonymous`].\n  SeqnoPresent = 'seqno_present',\n  /// Message source existed when validation has been sent to\n  /// [`crate::behaviour::MessageAuthenticity::Anonymous`].\n  FromPresent = 'from_present',\n  /// The data transformation failed.\n  TransformFailed = 'transform_failed'\n}\n\nexport enum MessageStatus {\n  duplicate = 'duplicate',\n  invalid = 'invalid',\n  valid = 'valid'\n}\n\n/**\n * Store both Uint8Array and string message id so that we don't have to convert data between the two.\n * See https://github.com/ChainSafe/js-libp2p-gossipsub/pull/274\n */\nexport type MessageId = {\n  msgId: Uint8Array\n  msgIdStr: MsgIdStr\n}\n\n/**\n * Typesafe conversion of MessageAcceptance -> RejectReason. TS ensures all values covered\n */\nexport function rejectReasonFromAcceptance(\n  acceptance: Exclude<TopicValidatorResult, TopicValidatorResult.Accept>\n): RejectReason.Ignore | RejectReason.Reject {\n  switch (acceptance) {\n    case TopicValidatorResult.Ignore:\n      return RejectReason.Ignore\n    case TopicValidatorResult.Reject:\n      return RejectReason.Reject\n  }\n}\n", "import { unmarshalPrivateKey } from '@libp2p/crypto/keys'\nimport { StrictSign, StrictNoSign } from '@libp2p/interface/pubsub'\nimport type { PeerId } from '@libp2p/interface/peer-id'\nimport { type PublishConfig, PublishConfigType } from '../types.js'\n\n/**\n * Prepare a PublishConfig object from a PeerId.\n */\nexport async function getPublishConfigFromPeerId(\n  signaturePolicy: typeof StrictSign | typeof StrictNoSign,\n  peerId?: PeerId\n): Promise<PublishConfig> {\n  switch (signaturePolicy) {\n    case StrictSign: {\n      if (!peerId) {\n        throw Error('Must provide PeerId')\n      }\n\n      if (peerId.privateKey == null) {\n        throw Error('Cannot sign message, no private key present')\n      }\n\n      if (peerId.publicKey == null) {\n        throw Error('Cannot sign message, no public key present')\n      }\n\n      // Transform privateKey once at initialization time instead of once per message\n      const privateKey = await unmarshalPrivateKey(peerId.privateKey)\n\n      return {\n        type: PublishConfigType.Signing,\n        author: peerId,\n        key: peerId.publicKey,\n        privateKey\n      }\n    }\n\n    case StrictNoSign:\n      return {\n        type: PublishConfigType.Anonymous\n      }\n\n    default:\n      throw new Error(`Unknown signature policy \"${signaturePolicy}\"`)\n  }\n}\n", "export const ERR_INVALID_PEER_SCORE_PARAMS = 'ERR_INVALID_PEER_SCORE_PARAMS'\nexport const ERR_INVALID_PEER_SCORE_THRESHOLDS = 'ERR_INVALID_PEER_SCORE_THRESHOLDS'\n", "import { ERR_INVALID_PEER_SCORE_PARAMS } from './constants.js'\nimport { CodeError } from '@libp2p/interface/errors'\n\n// This file defines PeerScoreParams and TopicScoreParams interfaces\n// as well as constructors, default constructors, and validation functions\n// for these interfaces\n\nexport interface PeerScoreParams {\n  /**\n   * Score parameters per topic.\n   */\n  topics: Record<string, TopicScoreParams>\n\n  /**\n   * Aggregate topic score cap; this limits the total contribution of topics towards a positive\n   * score. It must be positive (or 0 for no cap).\n   */\n  topicScoreCap: number\n\n  /**\n   * P5: Application-specific peer scoring\n   */\n  appSpecificScore: (p: string) => number\n  appSpecificWeight: number\n\n  /**\n   * P6: IP-colocation factor.\n   * The parameter has an associated counter which counts the number of peers with the same IP.\n   * If the number of peers in the same IP exceeds IPColocationFactorThreshold, then the value\n   * is the square of the difference, ie (PeersInSameIP - IPColocationThreshold)^2.\n   * If the number of peers in the same IP is less than the threshold, then the value is 0.\n   * The weight of the parameter MUST be negative, unless you want to disable for testing.\n   * Note: In order to simulate many IPs in a managable manner when testing, you can set the weight to 0\n   *       thus disabling the IP colocation penalty.\n   */\n  IPColocationFactorWeight: number\n  IPColocationFactorThreshold: number\n  IPColocationFactorWhitelist: Set<string>\n\n  /**\n   * P7: behavioural pattern penalties.\n   * This parameter has an associated counter which tracks misbehaviour as detected by the\n   * router. The router currently applies penalties for the following behaviors:\n   * - attempting to re-graft before the prune backoff time has elapsed.\n   * - not following up in IWANT requests for messages advertised with IHAVE.\n   *\n   * The value of the parameter is the square of the counter, which decays with  BehaviourPenaltyDecay.\n   * The weight of the parameter MUST be negative (or zero to disable).\n   */\n  behaviourPenaltyWeight: number\n  behaviourPenaltyThreshold: number\n  behaviourPenaltyDecay: number\n\n  /**\n   * the decay interval for parameter counters.\n   */\n  decayInterval: number\n\n  /**\n   * counter value below which it is considered 0.\n   */\n  decayToZero: number\n\n  /**\n   * time to remember counters for a disconnected peer.\n   */\n  retainScore: number\n}\n\nexport interface TopicScoreParams {\n  /**\n   * The weight of the topic.\n   */\n  topicWeight: number\n\n  /**\n   * P1: time in the mesh\n   * This is the time the peer has ben grafted in the mesh.\n   * The value of the parameter is the time/TimeInMeshQuantum, capped by TimeInMeshCap\n   * The weight of the parameter MUST be positive (or zero to disable).\n   */\n  timeInMeshWeight: number\n  timeInMeshQuantum: number\n  timeInMeshCap: number\n\n  /**\n   * P2: first message deliveries\n   * This is the number of message deliveries in the topic.\n   * The value of the parameter is a counter, decaying with FirstMessageDeliveriesDecay, and capped\n   * by FirstMessageDeliveriesCap.\n   * The weight of the parameter MUST be positive (or zero to disable).\n   */\n  firstMessageDeliveriesWeight: number\n  firstMessageDeliveriesDecay: number\n  firstMessageDeliveriesCap: number\n\n  /**\n   * P3: mesh message deliveries\n   * This is the number of message deliveries in the mesh, within the MeshMessageDeliveriesWindow of\n   * message validation; deliveries during validation also count and are retroactively applied\n   * when validation succeeds.\n   * This window accounts for the minimum time before a hostile mesh peer trying to game the score\n   * could replay back a valid message we just sent them.\n   * It effectively tracks first and near-first deliveries, ie a message seen from a mesh peer\n   * before we have forwarded it to them.\n   * The parameter has an associated counter, decaying with MeshMessageDeliveriesDecay.\n   * If the counter exceeds the threshold, its value is 0.\n   * If the counter is below the MeshMessageDeliveriesThreshold, the value is the square of\n   * the deficit, ie (MessageDeliveriesThreshold - counter)^2\n   * The penalty is only activated after MeshMessageDeliveriesActivation time in the mesh.\n   * The weight of the parameter MUST be negative (or zero to disable).\n   */\n  meshMessageDeliveriesWeight: number\n  meshMessageDeliveriesDecay: number\n  meshMessageDeliveriesCap: number\n  meshMessageDeliveriesThreshold: number\n  meshMessageDeliveriesWindow: number\n  meshMessageDeliveriesActivation: number\n\n  /**\n   * P3b: sticky mesh propagation failures\n   * This is a sticky penalty that applies when a peer gets pruned from the mesh with an active\n   * mesh message delivery penalty.\n   * The weight of the parameter MUST be negative (or zero to disable)\n   */\n  meshFailurePenaltyWeight: number\n  meshFailurePenaltyDecay: number\n\n  /**\n   * P4: invalid messages\n   * This is the number of invalid messages in the topic.\n   * The value of the parameter is the square of the counter, decaying with\n   * InvalidMessageDeliveriesDecay.\n   * The weight of the parameter MUST be negative (or zero to disable).\n   */\n  invalidMessageDeliveriesWeight: number\n  invalidMessageDeliveriesDecay: number\n}\n\nexport const defaultPeerScoreParams: PeerScoreParams = {\n  topics: {},\n  topicScoreCap: 10.0,\n  appSpecificScore: () => 0.0,\n  appSpecificWeight: 10.0,\n  IPColocationFactorWeight: -5.0,\n  IPColocationFactorThreshold: 10.0,\n  IPColocationFactorWhitelist: new Set(),\n  behaviourPenaltyWeight: -10.0,\n  behaviourPenaltyThreshold: 0.0,\n  behaviourPenaltyDecay: 0.2,\n  decayInterval: 1000.0,\n  decayToZero: 0.1,\n  retainScore: 3600 * 1000\n}\n\nexport const defaultTopicScoreParams: TopicScoreParams = {\n  topicWeight: 0.5,\n  timeInMeshWeight: 1,\n  timeInMeshQuantum: 1,\n  timeInMeshCap: 3600,\n\n  firstMessageDeliveriesWeight: 1,\n  firstMessageDeliveriesDecay: 0.5,\n  firstMessageDeliveriesCap: 2000,\n\n  meshMessageDeliveriesWeight: -1,\n  meshMessageDeliveriesDecay: 0.5,\n  meshMessageDeliveriesCap: 100,\n  meshMessageDeliveriesThreshold: 20,\n  meshMessageDeliveriesWindow: 10,\n  meshMessageDeliveriesActivation: 5000,\n\n  meshFailurePenaltyWeight: -1,\n  meshFailurePenaltyDecay: 0.5,\n\n  invalidMessageDeliveriesWeight: -1,\n  invalidMessageDeliveriesDecay: 0.3\n}\n\nexport function createPeerScoreParams(p: Partial<PeerScoreParams> = {}): PeerScoreParams {\n  return {\n    ...defaultPeerScoreParams,\n    ...p,\n    topics: p.topics\n      ? Object.entries(p.topics).reduce((topics, [topic, topicScoreParams]) => {\n          topics[topic] = createTopicScoreParams(topicScoreParams)\n          return topics\n        }, {} as Record<string, TopicScoreParams>)\n      : {}\n  }\n}\n\nexport function createTopicScoreParams(p: Partial<TopicScoreParams> = {}): TopicScoreParams {\n  return {\n    ...defaultTopicScoreParams,\n    ...p\n  }\n}\n\n// peer score parameter validation\nexport function validatePeerScoreParams(p: PeerScoreParams): void {\n  for (const [topic, params] of Object.entries(p.topics)) {\n    try {\n      validateTopicScoreParams(params)\n    } catch (e) {\n      throw new CodeError(\n        `invalid score parameters for topic ${topic}: ${(e as Error).message}`,\n        ERR_INVALID_PEER_SCORE_PARAMS\n      )\n    }\n  }\n\n  // check that the topic score is 0 or something positive\n  if (p.topicScoreCap < 0) {\n    throw new CodeError('invalid topic score cap; must be positive (or 0 for no cap)', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n\n  // check that we have an app specific score; the weight can be anything (but expected positive)\n  if (p.appSpecificScore === null || p.appSpecificScore === undefined) {\n    throw new CodeError('missing application specific score function', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n\n  // check the IP colocation factor\n  if (p.IPColocationFactorWeight > 0) {\n    throw new CodeError(\n      'invalid IPColocationFactorWeight; must be negative (or 0 to disable)',\n      ERR_INVALID_PEER_SCORE_PARAMS\n    )\n  }\n  if (p.IPColocationFactorWeight !== 0 && p.IPColocationFactorThreshold < 1) {\n    throw new CodeError('invalid IPColocationFactorThreshold; must be at least 1', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n\n  // check the behaviour penalty\n  if (p.behaviourPenaltyWeight > 0) {\n    throw new CodeError(\n      'invalid BehaviourPenaltyWeight; must be negative (or 0 to disable)',\n      ERR_INVALID_PEER_SCORE_PARAMS\n    )\n  }\n  if (p.behaviourPenaltyWeight !== 0 && (p.behaviourPenaltyDecay <= 0 || p.behaviourPenaltyDecay >= 1)) {\n    throw new CodeError('invalid BehaviourPenaltyDecay; must be between 0 and 1', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n\n  // check the decay parameters\n  if (p.decayInterval < 1000) {\n    throw new CodeError('invalid DecayInterval; must be at least 1s', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n  if (p.decayToZero <= 0 || p.decayToZero >= 1) {\n    throw new CodeError('invalid DecayToZero; must be between 0 and 1', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n\n  // no need to check the score retention; a value of 0 means that we don't retain scores\n}\n\nexport function validateTopicScoreParams(p: TopicScoreParams): void {\n  // make sure we have a sane topic weight\n  if (p.topicWeight < 0) {\n    throw new CodeError('invalid topic weight; must be >= 0', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n\n  // check P1\n  if (p.timeInMeshQuantum === 0) {\n    throw new CodeError('invalid TimeInMeshQuantum; must be non zero', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n  if (p.timeInMeshWeight < 0) {\n    throw new CodeError('invalid TimeInMeshWeight; must be positive (or 0 to disable)', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n  if (p.timeInMeshWeight !== 0 && p.timeInMeshQuantum <= 0) {\n    throw new CodeError('invalid TimeInMeshQuantum; must be positive', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n  if (p.timeInMeshWeight !== 0 && p.timeInMeshCap <= 0) {\n    throw new CodeError('invalid TimeInMeshCap; must be positive', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n\n  // check P2\n  if (p.firstMessageDeliveriesWeight < 0) {\n    throw new CodeError(\n      'invallid FirstMessageDeliveriesWeight; must be positive (or 0 to disable)',\n      ERR_INVALID_PEER_SCORE_PARAMS\n    )\n  }\n  if (\n    p.firstMessageDeliveriesWeight !== 0 &&\n    (p.firstMessageDeliveriesDecay <= 0 || p.firstMessageDeliveriesDecay >= 1)\n  ) {\n    throw new CodeError('invalid FirstMessageDeliveriesDecay; must be between 0 and 1', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n  if (p.firstMessageDeliveriesWeight !== 0 && p.firstMessageDeliveriesCap <= 0) {\n    throw new CodeError('invalid FirstMessageDeliveriesCap; must be positive', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n\n  // check P3\n  if (p.meshMessageDeliveriesWeight > 0) {\n    throw new CodeError(\n      'invalid MeshMessageDeliveriesWeight; must be negative (or 0 to disable)',\n      ERR_INVALID_PEER_SCORE_PARAMS\n    )\n  }\n  if (p.meshMessageDeliveriesWeight !== 0 && (p.meshMessageDeliveriesDecay <= 0 || p.meshMessageDeliveriesDecay >= 1)) {\n    throw new CodeError('invalid MeshMessageDeliveriesDecay; must be between 0 and 1', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n  if (p.meshMessageDeliveriesWeight !== 0 && p.meshMessageDeliveriesCap <= 0) {\n    throw new CodeError('invalid MeshMessageDeliveriesCap; must be positive', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n  if (p.meshMessageDeliveriesWeight !== 0 && p.meshMessageDeliveriesThreshold <= 0) {\n    throw new CodeError('invalid MeshMessageDeliveriesThreshold; must be positive', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n  if (p.meshMessageDeliveriesWindow < 0) {\n    throw new CodeError('invalid MeshMessageDeliveriesWindow; must be non-negative', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n  if (p.meshMessageDeliveriesWeight !== 0 && p.meshMessageDeliveriesActivation < 1000) {\n    throw new CodeError('invalid MeshMessageDeliveriesActivation; must be at least 1s', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n\n  // check P3b\n  if (p.meshFailurePenaltyWeight > 0) {\n    throw new CodeError(\n      'invalid MeshFailurePenaltyWeight; must be negative (or 0 to disable)',\n      ERR_INVALID_PEER_SCORE_PARAMS\n    )\n  }\n  if (p.meshFailurePenaltyWeight !== 0 && (p.meshFailurePenaltyDecay <= 0 || p.meshFailurePenaltyDecay >= 1)) {\n    throw new CodeError('invalid MeshFailurePenaltyDecay; must be between 0 and 1', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n\n  // check P4\n  if (p.invalidMessageDeliveriesWeight > 0) {\n    throw new CodeError(\n      'invalid InvalidMessageDeliveriesWeight; must be negative (or 0 to disable)',\n      ERR_INVALID_PEER_SCORE_PARAMS\n    )\n  }\n  if (p.invalidMessageDeliveriesDecay <= 0 || p.invalidMessageDeliveriesDecay >= 1) {\n    throw new CodeError('invalid InvalidMessageDeliveriesDecay; must be between 0 and 1', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n}\n", "import { ERR_INVALID_PEER_SCORE_THRESHOLDS } from './constants.js'\nimport { CodeError } from '@libp2p/interface/errors'\n\n// This file defines PeerScoreThresholds interface\n// as well as a constructor, default constructor, and validation function\n// for this interface\n\nexport interface PeerScoreThresholds {\n  /**\n   * gossipThreshold is the score threshold below which gossip propagation is supressed;\n   * should be negative.\n   */\n  gossipThreshold: number\n\n  /**\n   * publishThreshold is the score threshold below which we shouldn't publish when using flood\n   * publishing (also applies to fanout and floodsub peers); should be negative and <= GossipThreshold.\n   */\n  publishThreshold: number\n\n  /**\n   * graylistThreshold is the score threshold below which message processing is supressed altogether,\n   * implementing an effective graylist according to peer score; should be negative and <= PublisThreshold.\n   */\n  graylistThreshold: number\n\n  /**\n   * acceptPXThreshold is the score threshold below which PX will be ignored; this should be positive\n   * and limited to scores attainable by bootstrappers and other trusted nodes.\n   */\n  acceptPXThreshold: number\n\n  /**\n   * opportunisticGraftThreshold is the median mesh score threshold before triggering opportunistic\n   * grafting; this should have a small positive value.\n   */\n  opportunisticGraftThreshold: number\n}\n\nexport const defaultPeerScoreThresholds: PeerScoreThresholds = {\n  gossipThreshold: -10,\n  publishThreshold: -50,\n  graylistThreshold: -80,\n  acceptPXThreshold: 10,\n  opportunisticGraftThreshold: 20\n}\n\nexport function createPeerScoreThresholds(p: Partial<PeerScoreThresholds> = {}): PeerScoreThresholds {\n  return {\n    ...defaultPeerScoreThresholds,\n    ...p\n  }\n}\n\nexport function validatePeerScoreThresholds(p: PeerScoreThresholds): void {\n  if (p.gossipThreshold > 0) {\n    throw new CodeError('invalid gossip threshold; it must be <= 0', ERR_INVALID_PEER_SCORE_THRESHOLDS)\n  }\n  if (p.publishThreshold > 0 || p.publishThreshold > p.gossipThreshold) {\n    throw new CodeError(\n      'invalid publish threshold; it must be <= 0 and <= gossip threshold',\n      ERR_INVALID_PEER_SCORE_THRESHOLDS\n    )\n  }\n  if (p.graylistThreshold > 0 || p.graylistThreshold > p.publishThreshold) {\n    throw new CodeError(\n      'invalid graylist threshold; it must be <= 0 and <= publish threshold',\n      ERR_INVALID_PEER_SCORE_THRESHOLDS\n    )\n  }\n  if (p.acceptPXThreshold < 0) {\n    throw new CodeError('invalid accept PX threshold; it must be >= 0', ERR_INVALID_PEER_SCORE_THRESHOLDS)\n  }\n  if (p.opportunisticGraftThreshold < 0) {\n    throw new CodeError('invalid opportunistic grafting threshold; it must be >= 0', ERR_INVALID_PEER_SCORE_THRESHOLDS)\n  }\n}\n", "import type { PeerStats } from './peer-stats.js'\nimport type { PeerScoreParams } from './peer-score-params.js'\n\nexport function computeScore(\n  peer: string,\n  pstats: PeerStats,\n  params: PeerScoreParams,\n  peerIPs: Map<string, Set<string>>\n): number {\n  let score = 0\n\n  // topic stores\n  Object.entries(pstats.topics).forEach(([topic, tstats]) => {\n    // the topic parameters\n    const topicParams = params.topics[topic]\n    if (topicParams === undefined) {\n      // we are not scoring this topic\n      return\n    }\n\n    let topicScore = 0\n\n    // P1: time in Mesh\n    if (tstats.inMesh) {\n      let p1 = tstats.meshTime / topicParams.timeInMeshQuantum\n      if (p1 > topicParams.timeInMeshCap) {\n        p1 = topicParams.timeInMeshCap\n      }\n      topicScore += p1 * topicParams.timeInMeshWeight\n    }\n\n    // P2: first message deliveries\n    let p2 = tstats.firstMessageDeliveries\n    if (p2 > topicParams.firstMessageDeliveriesCap) {\n      p2 = topicParams.firstMessageDeliveriesCap\n    }\n    topicScore += p2 * topicParams.firstMessageDeliveriesWeight\n\n    // P3: mesh message deliveries\n    if (\n      tstats.meshMessageDeliveriesActive &&\n      tstats.meshMessageDeliveries < topicParams.meshMessageDeliveriesThreshold\n    ) {\n      const deficit = topicParams.meshMessageDeliveriesThreshold - tstats.meshMessageDeliveries\n      const p3 = deficit * deficit\n      topicScore += p3 * topicParams.meshMessageDeliveriesWeight\n    }\n\n    // P3b:\n    // NOTE: the weight of P3b is negative (validated in validateTopicScoreParams) so this detracts\n    const p3b = tstats.meshFailurePenalty\n    topicScore += p3b * topicParams.meshFailurePenaltyWeight\n\n    // P4: invalid messages\n    // NOTE: the weight of P4 is negative (validated in validateTopicScoreParams) so this detracts\n    const p4 = tstats.invalidMessageDeliveries * tstats.invalidMessageDeliveries\n    topicScore += p4 * topicParams.invalidMessageDeliveriesWeight\n\n    // update score, mixing with topic weight\n    score += topicScore * topicParams.topicWeight\n  })\n\n  // apply the topic score cap, if any\n  if (params.topicScoreCap > 0 && score > params.topicScoreCap) {\n    score = params.topicScoreCap\n  }\n\n  // P5: application-specific score\n  const p5 = params.appSpecificScore(peer)\n  score += p5 * params.appSpecificWeight\n\n  // P6: IP colocation factor\n  pstats.knownIPs.forEach((ip) => {\n    if (params.IPColocationFactorWhitelist.has(ip)) {\n      return\n    }\n\n    // P6 has a cliff (IPColocationFactorThreshold)\n    // It's only applied if at least that many peers are connected to us from that source IP addr.\n    // It is quadratic, and the weight is negative (validated in validatePeerScoreParams)\n    const peersInIP = peerIPs.get(ip)\n    const numPeersInIP = peersInIP ? peersInIP.size : 0\n    if (numPeersInIP > params.IPColocationFactorThreshold) {\n      const surplus = numPeersInIP - params.IPColocationFactorThreshold\n      const p6 = surplus * surplus\n      score += p6 * params.IPColocationFactorWeight\n    }\n  })\n\n  // P7: behavioural pattern penalty\n  if (pstats.behaviourPenalty > params.behaviourPenaltyThreshold) {\n    const excess = pstats.behaviourPenalty - params.behaviourPenaltyThreshold\n    const p7 = excess * excess\n    score += p7 * params.behaviourPenaltyWeight\n  }\n\n  return score\n}\n", "import { TimeCacheDuration } from '../constants.js'\nimport Denque from 'denque'\n\nexport enum DeliveryRecordStatus {\n  /**\n   * we don't know (yet) if the message is valid\n   */\n  unknown,\n  /**\n   * we know the message is valid\n   */\n  valid,\n  /**\n   * we know the message is invalid\n   */\n  invalid,\n  /**\n   * we were instructed by the validator to ignore the message\n   */\n  ignored\n}\n\nexport interface DeliveryRecord {\n  status: DeliveryRecordStatus\n  firstSeenTsMs: number\n  validated: number\n  peers: Set<string>\n}\n\ninterface DeliveryQueueEntry {\n  msgId: string\n  expire: number\n}\n\n/**\n * Map of canonical message ID to DeliveryRecord\n *\n * Maintains an internal queue for efficient gc of old messages\n */\nexport class MessageDeliveries {\n  private records: Map<string, DeliveryRecord>\n  public queue: Denque<DeliveryQueueEntry>\n\n  constructor() {\n    this.records = new Map()\n    this.queue = new Denque()\n  }\n\n  getRecord(msgIdStr: string): DeliveryRecord | undefined {\n    return this.records.get(msgIdStr)\n  }\n\n  ensureRecord(msgIdStr: string): DeliveryRecord {\n    let drec = this.records.get(msgIdStr)\n    if (drec) {\n      return drec\n    }\n\n    // record doesn't exist yet\n    // create record\n    drec = {\n      status: DeliveryRecordStatus.unknown,\n      firstSeenTsMs: Date.now(),\n      validated: 0,\n      peers: new Set()\n    }\n    this.records.set(msgIdStr, drec)\n\n    // and add msgId to the queue\n    const entry: DeliveryQueueEntry = {\n      msgId: msgIdStr,\n      expire: Date.now() + TimeCacheDuration\n    }\n    this.queue.push(entry)\n\n    return drec\n  }\n\n  gc(): void {\n    const now = Date.now()\n    // queue is sorted by expiry time\n    // remove expired messages, remove from queue until first un-expired message found\n    let head = this.queue.peekFront()\n    while (head && head.expire < now) {\n      this.records.delete(head.msgId)\n      this.queue.shift()\n      head = this.queue.peekFront()\n    }\n  }\n\n  clear(): void {\n    this.records.clear()\n    this.queue.clear()\n  }\n}\n", "/**\n * Exclude up to `ineed` items from a set if item meets condition `cond`\n */\nexport function removeItemsFromSet<T>(\n  superSet: Set<T>,\n  ineed: number,\n  cond: (peer: T) => boolean = () => true\n): Set<T> {\n  const subset = new Set<T>()\n  if (ineed <= 0) return subset\n\n  for (const id of superSet) {\n    if (subset.size >= ineed) break\n    if (cond(id)) {\n      subset.add(id)\n      superSet.delete(id)\n    }\n  }\n\n  return subset\n}\n\n/**\n * Exclude up to `ineed` items from a set\n */\nexport function removeFirstNItemsFromSet<T>(superSet: Set<T>, ineed: number): Set<T> {\n  return removeItemsFromSet(superSet, ineed, () => true)\n}\n\nexport class MapDef<K, V> extends Map<K, V> {\n  constructor(private readonly getDefault: () => V) {\n    super()\n  }\n\n  getOrDefault(key: K): V {\n    let value = super.get(key)\n    if (value === undefined) {\n      value = this.getDefault()\n      this.set(key, value)\n    }\n    return value\n  }\n}\n", "import { type PeerScoreParams, validatePeerScoreParams } from './peer-score-params.js'\nimport type { PeerStats, TopicStats } from './peer-stats.js'\nimport { computeScore } from './compute-score.js'\nimport { MessageDeliveries, DeliveryRecordStatus } from './message-deliveries.js'\nimport { logger } from '@libp2p/logger'\nimport { type MsgIdStr, type PeerIdStr, RejectReason, type TopicStr, type IPStr } from '../types.js'\nimport type { Metrics, ScorePenalty } from '../metrics.js'\nimport { MapDef } from '../utils/set.js'\n\nconst log = logger('libp2p:gossipsub:score')\n\ninterface PeerScoreOpts {\n  /**\n   * Miliseconds to cache computed score per peer\n   */\n  scoreCacheValidityMs: number\n\n  computeScore?: typeof computeScore\n}\n\ninterface ScoreCacheEntry {\n  /** The cached score */\n  score: number\n  /** Unix timestamp in miliseconds, the time after which the cached score for a peer is no longer valid */\n  cacheUntil: number\n}\n\nexport type PeerScoreStatsDump = Record<PeerIdStr, PeerStats>\n\nexport class PeerScore {\n  /**\n   * Per-peer stats for score calculation\n   */\n  readonly peerStats = new Map<PeerIdStr, PeerStats>()\n  /**\n   * IP colocation tracking; maps IP => set of peers.\n   */\n  readonly peerIPs = new MapDef<PeerIdStr, Set<IPStr>>(() => new Set())\n  /**\n   * Cache score up to decayInterval if topic stats are unchanged.\n   */\n  readonly scoreCache = new Map<PeerIdStr, ScoreCacheEntry>()\n  /**\n   * Recent message delivery timing/participants\n   */\n  readonly deliveryRecords = new MessageDeliveries()\n\n  _backgroundInterval?: ReturnType<typeof setInterval>\n\n  private readonly scoreCacheValidityMs: number\n  private readonly computeScore: typeof computeScore\n\n  constructor(readonly params: PeerScoreParams, private readonly metrics: Metrics | null, opts: PeerScoreOpts) {\n    validatePeerScoreParams(params)\n    this.scoreCacheValidityMs = opts.scoreCacheValidityMs\n    this.computeScore = opts.computeScore ?? computeScore\n  }\n\n  get size(): number {\n    return this.peerStats.size\n  }\n\n  /**\n   * Start PeerScore instance\n   */\n  start(): void {\n    if (this._backgroundInterval) {\n      log('Peer score already running')\n      return\n    }\n    this._backgroundInterval = setInterval(() => this.background(), this.params.decayInterval)\n    log('started')\n  }\n\n  /**\n   * Stop PeerScore instance\n   */\n  stop(): void {\n    if (!this._backgroundInterval) {\n      log('Peer score already stopped')\n      return\n    }\n    clearInterval(this._backgroundInterval)\n    delete this._backgroundInterval\n    this.peerIPs.clear()\n    this.peerStats.clear()\n    this.deliveryRecords.clear()\n    log('stopped')\n  }\n\n  /**\n   * Periodic maintenance\n   */\n  background(): void {\n    this.refreshScores()\n    this.deliveryRecords.gc()\n  }\n\n  dumpPeerScoreStats(): PeerScoreStatsDump {\n    return Object.fromEntries(Array.from(this.peerStats.entries()).map(([peer, stats]) => [peer, stats]))\n  }\n\n  messageFirstSeenTimestampMs(msgIdStr: MsgIdStr): number | null {\n    const drec = this.deliveryRecords.getRecord(msgIdStr)\n    return drec ? drec.firstSeenTsMs : null\n  }\n\n  /**\n   * Decays scores, and purges score records for disconnected peers once their expiry has elapsed.\n   */\n  public refreshScores(): void {\n    const now = Date.now()\n    const decayToZero = this.params.decayToZero\n\n    this.peerStats.forEach((pstats, id) => {\n      if (!pstats.connected) {\n        // has the retention period expired?\n        if (now > pstats.expire) {\n          // yes, throw it away (but clean up the IP tracking first)\n          this.removeIPsForPeer(id, pstats.knownIPs)\n          this.peerStats.delete(id)\n          this.scoreCache.delete(id)\n        }\n\n        // we don't decay retained scores, as the peer is not active.\n        // this way the peer cannot reset a negative score by simply disconnecting and reconnecting,\n        // unless the retention period has elapsed.\n        // similarly, a well behaved peer does not lose its score by getting disconnected.\n        return\n      }\n\n      Object.entries(pstats.topics).forEach(([topic, tstats]) => {\n        const tparams = this.params.topics[topic]\n        if (tparams === undefined) {\n          // we are not scoring this topic\n          // should be unreachable, we only add scored topics to pstats\n          return\n        }\n\n        // decay counters\n        tstats.firstMessageDeliveries *= tparams.firstMessageDeliveriesDecay\n        if (tstats.firstMessageDeliveries < decayToZero) {\n          tstats.firstMessageDeliveries = 0\n        }\n\n        tstats.meshMessageDeliveries *= tparams.meshMessageDeliveriesDecay\n        if (tstats.meshMessageDeliveries < decayToZero) {\n          tstats.meshMessageDeliveries = 0\n        }\n\n        tstats.meshFailurePenalty *= tparams.meshFailurePenaltyDecay\n        if (tstats.meshFailurePenalty < decayToZero) {\n          tstats.meshFailurePenalty = 0\n        }\n\n        tstats.invalidMessageDeliveries *= tparams.invalidMessageDeliveriesDecay\n        if (tstats.invalidMessageDeliveries < decayToZero) {\n          tstats.invalidMessageDeliveries = 0\n        }\n\n        // update mesh time and activate mesh message delivery parameter if need be\n        if (tstats.inMesh) {\n          tstats.meshTime = now - tstats.graftTime\n          if (tstats.meshTime > tparams.meshMessageDeliveriesActivation) {\n            tstats.meshMessageDeliveriesActive = true\n          }\n        }\n      })\n\n      // decay P7 counter\n      pstats.behaviourPenalty *= this.params.behaviourPenaltyDecay\n      if (pstats.behaviourPenalty < decayToZero) {\n        pstats.behaviourPenalty = 0\n      }\n    })\n  }\n\n  /**\n   * Return the score for a peer\n   */\n  score(id: PeerIdStr): number {\n    this.metrics?.scoreFnCalls.inc()\n\n    const pstats = this.peerStats.get(id)\n    if (!pstats) {\n      return 0\n    }\n\n    const now = Date.now()\n    const cacheEntry = this.scoreCache.get(id)\n\n    // Found cached score within validity period\n    if (cacheEntry && cacheEntry.cacheUntil > now) {\n      return cacheEntry.score\n    }\n\n    this.metrics?.scoreFnRuns.inc()\n\n    const score = this.computeScore(id, pstats, this.params, this.peerIPs)\n    const cacheUntil = now + this.scoreCacheValidityMs\n\n    if (cacheEntry) {\n      this.metrics?.scoreCachedDelta.observe(Math.abs(score - cacheEntry.score))\n      cacheEntry.score = score\n      cacheEntry.cacheUntil = cacheUntil\n    } else {\n      this.scoreCache.set(id, { score, cacheUntil })\n    }\n\n    return score\n  }\n\n  /**\n   * Apply a behavioural penalty to a peer\n   */\n  addPenalty(id: PeerIdStr, penalty: number, penaltyLabel: ScorePenalty): void {\n    const pstats = this.peerStats.get(id)\n    if (pstats) {\n      pstats.behaviourPenalty += penalty\n      this.metrics?.onScorePenalty(penaltyLabel)\n    }\n  }\n\n  addPeer(id: PeerIdStr): void {\n    // create peer stats (not including topic stats for each topic to be scored)\n    // topic stats will be added as needed\n    const pstats: PeerStats = {\n      connected: true,\n      expire: 0,\n      topics: {},\n      knownIPs: new Set(),\n      behaviourPenalty: 0\n    }\n    this.peerStats.set(id, pstats)\n  }\n\n  /** Adds a new IP to a peer, if the peer is not known the update is ignored */\n  addIP(id: PeerIdStr, ip: string): void {\n    const pstats = this.peerStats.get(id)\n    if (pstats) {\n      pstats.knownIPs.add(ip)\n    }\n\n    this.peerIPs.getOrDefault(ip).add(id)\n  }\n\n  /** Remove peer association with IP */\n  removeIP(id: PeerIdStr, ip: string): void {\n    const pstats = this.peerStats.get(id)\n    if (pstats) {\n      pstats.knownIPs.delete(ip)\n    }\n\n    const peersWithIP = this.peerIPs.get(ip)\n    if (peersWithIP) {\n      peersWithIP.delete(id)\n      if (peersWithIP.size === 0) {\n        this.peerIPs.delete(ip)\n      }\n    }\n  }\n\n  removePeer(id: PeerIdStr): void {\n    const pstats = this.peerStats.get(id)\n    if (!pstats) {\n      return\n    }\n\n    // decide whether to retain the score; this currently only retains non-positive scores\n    // to dissuade attacks on the score function.\n    if (this.score(id) > 0) {\n      this.removeIPsForPeer(id, pstats.knownIPs)\n      this.peerStats.delete(id)\n      return\n    }\n\n    // furthermore, when we decide to retain the score, the firstMessageDelivery counters are\n    // reset to 0 and mesh delivery penalties applied.\n    Object.entries(pstats.topics).forEach(([topic, tstats]) => {\n      tstats.firstMessageDeliveries = 0\n\n      const threshold = this.params.topics[topic].meshMessageDeliveriesThreshold\n      if (tstats.inMesh && tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {\n        const deficit = threshold - tstats.meshMessageDeliveries\n        tstats.meshFailurePenalty += deficit * deficit\n      }\n\n      tstats.inMesh = false\n      tstats.meshMessageDeliveriesActive = false\n    })\n\n    pstats.connected = false\n    pstats.expire = Date.now() + this.params.retainScore\n  }\n\n  /** Handles scoring functionality as a peer GRAFTs to a topic. */\n  graft(id: PeerIdStr, topic: TopicStr): void {\n    const pstats = this.peerStats.get(id)\n    if (pstats) {\n      const tstats = this.getPtopicStats(pstats, topic)\n      if (tstats) {\n        // if we are scoring the topic, update the mesh status.\n        tstats.inMesh = true\n        tstats.graftTime = Date.now()\n        tstats.meshTime = 0\n        tstats.meshMessageDeliveriesActive = false\n      }\n    }\n  }\n\n  /** Handles scoring functionality as a peer PRUNEs from a topic. */\n  prune(id: PeerIdStr, topic: TopicStr): void {\n    const pstats = this.peerStats.get(id)\n    if (pstats) {\n      const tstats = this.getPtopicStats(pstats, topic)\n      if (tstats) {\n        // sticky mesh delivery rate failure penalty\n        const threshold = this.params.topics[topic].meshMessageDeliveriesThreshold\n        if (tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {\n          const deficit = threshold - tstats.meshMessageDeliveries\n          tstats.meshFailurePenalty += deficit * deficit\n        }\n        tstats.meshMessageDeliveriesActive = false\n        tstats.inMesh = false\n\n        // TODO: Consider clearing score cache on important penalties\n        // this.scoreCache.delete(id)\n      }\n    }\n  }\n\n  validateMessage(msgIdStr: MsgIdStr): void {\n    this.deliveryRecords.ensureRecord(msgIdStr)\n  }\n\n  deliverMessage(from: PeerIdStr, msgIdStr: MsgIdStr, topic: TopicStr): void {\n    this.markFirstMessageDelivery(from, topic)\n\n    const drec = this.deliveryRecords.ensureRecord(msgIdStr)\n    const now = Date.now()\n\n    // defensive check that this is the first delivery trace -- delivery status should be unknown\n    if (drec.status !== DeliveryRecordStatus.unknown) {\n      log(\n        'unexpected delivery: message from %s was first seen %s ago and has delivery status %s',\n        from,\n        now - drec.firstSeenTsMs,\n        DeliveryRecordStatus[drec.status]\n      )\n      return\n    }\n\n    // mark the message as valid and reward mesh peers that have already forwarded it to us\n    drec.status = DeliveryRecordStatus.valid\n    drec.validated = now\n    drec.peers.forEach((p) => {\n      // this check is to make sure a peer can't send us a message twice and get a double count\n      // if it is a first delivery.\n      if (p !== from.toString()) {\n        this.markDuplicateMessageDelivery(p, topic)\n      }\n    })\n  }\n\n  /**\n   * Similar to `rejectMessage` except does not require the message id or reason for an invalid message.\n   */\n  rejectInvalidMessage(from: PeerIdStr, topic: TopicStr): void {\n    this.markInvalidMessageDelivery(from, topic)\n  }\n\n  rejectMessage(from: PeerIdStr, msgIdStr: MsgIdStr, topic: TopicStr, reason: RejectReason): void {\n    switch (reason) {\n      // these messages are not tracked, but the peer is penalized as they are invalid\n      case RejectReason.Error:\n        this.markInvalidMessageDelivery(from, topic)\n        return\n\n      // we ignore those messages, so do nothing.\n      case RejectReason.Blacklisted:\n        return\n\n      // the rest are handled after record creation\n    }\n\n    const drec = this.deliveryRecords.ensureRecord(msgIdStr)\n\n    // defensive check that this is the first rejection -- delivery status should be unknown\n    if (drec.status !== DeliveryRecordStatus.unknown) {\n      log(\n        'unexpected rejection: message from %s was first seen %s ago and has delivery status %d',\n        from,\n        Date.now() - drec.firstSeenTsMs,\n        DeliveryRecordStatus[drec.status]\n      )\n      return\n    }\n\n    if (reason === RejectReason.Ignore) {\n      // we were explicitly instructed by the validator to ignore the message but not penalize the peer\n      drec.status = DeliveryRecordStatus.ignored\n      drec.peers.clear()\n      return\n    }\n\n    // mark the message as invalid and penalize peers that have already forwarded it.\n    drec.status = DeliveryRecordStatus.invalid\n\n    this.markInvalidMessageDelivery(from, topic)\n    drec.peers.forEach((p) => {\n      this.markInvalidMessageDelivery(p, topic)\n    })\n\n    // release the delivery time tracking map to free some memory early\n    drec.peers.clear()\n  }\n\n  duplicateMessage(from: PeerIdStr, msgIdStr: MsgIdStr, topic: TopicStr): void {\n    const drec = this.deliveryRecords.ensureRecord(msgIdStr)\n\n    if (drec.peers.has(from)) {\n      // we have already seen this duplicate\n      return\n    }\n\n    switch (drec.status) {\n      case DeliveryRecordStatus.unknown:\n        // the message is being validated; track the peer delivery and wait for\n        // the Deliver/Reject/Ignore notification.\n        drec.peers.add(from)\n        break\n\n      case DeliveryRecordStatus.valid:\n        // mark the peer delivery time to only count a duplicate delivery once.\n        drec.peers.add(from)\n        this.markDuplicateMessageDelivery(from, topic, drec.validated)\n        break\n\n      case DeliveryRecordStatus.invalid:\n        // we no longer track delivery time\n        this.markInvalidMessageDelivery(from, topic)\n        break\n\n      case DeliveryRecordStatus.ignored:\n        // the message was ignored; do nothing (we don't know if it was valid)\n        break\n    }\n  }\n\n  /**\n   * Increments the \"invalid message deliveries\" counter for all scored topics the message is published in.\n   */\n  public markInvalidMessageDelivery(from: PeerIdStr, topic: TopicStr): void {\n    const pstats = this.peerStats.get(from)\n    if (pstats) {\n      const tstats = this.getPtopicStats(pstats, topic)\n      if (tstats) {\n        tstats.invalidMessageDeliveries += 1\n      }\n    }\n  }\n\n  /**\n   * Increments the \"first message deliveries\" counter for all scored topics the message is published in,\n   * as well as the \"mesh message deliveries\" counter, if the peer is in the mesh for the topic.\n   * Messages already known (with the seenCache) are counted with markDuplicateMessageDelivery()\n   */\n  public markFirstMessageDelivery(from: PeerIdStr, topic: TopicStr): void {\n    const pstats = this.peerStats.get(from)\n    if (pstats) {\n      const tstats = this.getPtopicStats(pstats, topic)\n      if (tstats) {\n        let cap = this.params.topics[topic].firstMessageDeliveriesCap\n        tstats.firstMessageDeliveries = Math.min(cap, tstats.firstMessageDeliveries + 1)\n\n        if (tstats.inMesh) {\n          cap = this.params.topics[topic].meshMessageDeliveriesCap\n          tstats.meshMessageDeliveries = Math.min(cap, tstats.meshMessageDeliveries + 1)\n        }\n      }\n    }\n  }\n\n  /**\n   * Increments the \"mesh message deliveries\" counter for messages we've seen before,\n   * as long the message was received within the P3 window.\n   */\n  public markDuplicateMessageDelivery(from: PeerIdStr, topic: TopicStr, validatedTime?: number): void {\n    const pstats = this.peerStats.get(from)\n    if (pstats) {\n      const now = validatedTime !== undefined ? Date.now() : 0\n\n      const tstats = this.getPtopicStats(pstats, topic)\n      if (tstats && tstats.inMesh) {\n        const tparams = this.params.topics[topic]\n\n        // check against the mesh delivery window -- if the validated time is passed as 0, then\n        // the message was received before we finished validation and thus falls within the mesh\n        // delivery window.\n        if (validatedTime !== undefined) {\n          const deliveryDelayMs = now - validatedTime\n          const isLateDelivery = deliveryDelayMs > tparams.meshMessageDeliveriesWindow\n          this.metrics?.onDuplicateMsgDelivery(topic, deliveryDelayMs, isLateDelivery)\n\n          if (isLateDelivery) {\n            return\n          }\n        }\n\n        const cap = tparams.meshMessageDeliveriesCap\n        tstats.meshMessageDeliveries = Math.min(cap, tstats.meshMessageDeliveries + 1)\n      }\n    }\n  }\n\n  /**\n   * Removes an IP list from the tracking list for a peer.\n   */\n  private removeIPsForPeer(id: PeerIdStr, ipsToRemove: Set<IPStr>): void {\n    for (const ipToRemove of ipsToRemove) {\n      const peerSet = this.peerIPs.get(ipToRemove)\n      if (peerSet) {\n        peerSet.delete(id)\n        if (peerSet.size === 0) {\n          this.peerIPs.delete(ipToRemove)\n        }\n      }\n    }\n  }\n\n  /**\n   * Returns topic stats if they exist, otherwise if the supplied parameters score the\n   * topic, inserts the default stats and returns a reference to those. If neither apply, returns None.\n   */\n  private getPtopicStats(pstats: PeerStats, topic: TopicStr): TopicStats | null {\n    let topicStats: TopicStats | undefined = pstats.topics[topic]\n\n    if (topicStats !== undefined) {\n      return topicStats\n    }\n\n    if (this.params.topics[topic] !== undefined) {\n      topicStats = {\n        inMesh: false,\n        graftTime: 0,\n        meshTime: 0,\n        firstMessageDeliveries: 0,\n        meshMessageDeliveries: 0,\n        meshMessageDeliveriesActive: false,\n        meshFailurePenalty: 0,\n        invalidMessageDeliveries: 0\n      }\n      pstats.topics[topic] = topicStats\n\n      return topicStats\n    }\n\n    return null\n  }\n}\n", "import { type MsgIdStr, type MsgIdToStrFn, type PeerIdStr, RejectReason } from './types.js'\nimport type { Metrics } from './metrics.js'\n\n/**\n * IWantTracer is an internal tracer that tracks IWANT requests in order to penalize\n * peers who don't follow up on IWANT requests after an IHAVE advertisement.\n * The tracking of promises is probabilistic to avoid using too much memory.\n *\n * Note: Do not confuse these 'promises' with JS Promise objects.\n * These 'promises' are merely expectations of a peer's behavior.\n */\nexport class IWantTracer {\n  /**\n   * Promises to deliver a message\n   * Map per message id, per peer, promise expiration time\n   */\n  private readonly promises = new Map<MsgIdStr, Map<PeerIdStr, number>>()\n  /**\n   * First request time by msgId. Used for metrics to track expire times.\n   * Necessary to know if peers are actually breaking promises or simply sending them a bit later\n   */\n  private readonly requestMsByMsg = new Map<MsgIdStr, number>()\n  private readonly requestMsByMsgExpire: number\n\n  constructor(\n    private readonly gossipsubIWantFollowupMs: number,\n    private readonly msgIdToStrFn: MsgIdToStrFn,\n    private readonly metrics: Metrics | null\n  ) {\n    this.requestMsByMsgExpire = 10 * gossipsubIWantFollowupMs\n  }\n\n  get size(): number {\n    return this.promises.size\n  }\n\n  get requestMsByMsgSize(): number {\n    return this.requestMsByMsg.size\n  }\n\n  /**\n   * Track a promise to deliver a message from a list of msgIds we are requesting\n   */\n  addPromise(from: PeerIdStr, msgIds: Uint8Array[]): void {\n    // pick msgId randomly from the list\n    const ix = Math.floor(Math.random() * msgIds.length)\n    const msgId = msgIds[ix]\n    const msgIdStr = this.msgIdToStrFn(msgId)\n\n    let expireByPeer = this.promises.get(msgIdStr)\n    if (!expireByPeer) {\n      expireByPeer = new Map()\n      this.promises.set(msgIdStr, expireByPeer)\n    }\n\n    const now = Date.now()\n\n    // If a promise for this message id and peer already exists we don't update the expiry\n    if (!expireByPeer.has(from)) {\n      expireByPeer.set(from, now + this.gossipsubIWantFollowupMs)\n\n      if (this.metrics) {\n        this.metrics.iwantPromiseStarted.inc(1)\n        if (!this.requestMsByMsg.has(msgIdStr)) {\n          this.requestMsByMsg.set(msgIdStr, now)\n        }\n      }\n    }\n  }\n\n  /**\n   * Returns the number of broken promises for each peer who didn't follow up on an IWANT request.\n   *\n   * This should be called not too often relative to the expire times, since it iterates over the whole data.\n   */\n  getBrokenPromises(): Map<PeerIdStr, number> {\n    const now = Date.now()\n    const result = new Map<PeerIdStr, number>()\n\n    let brokenPromises = 0\n\n    this.promises.forEach((expireByPeer, msgId) => {\n      expireByPeer.forEach((expire, p) => {\n        // the promise has been broken\n        if (expire < now) {\n          // add 1 to result\n          result.set(p, (result.get(p) ?? 0) + 1)\n          // delete from tracked promises\n          expireByPeer.delete(p)\n          // for metrics\n          brokenPromises++\n        }\n      })\n      // clean up empty promises for a msgId\n      if (!expireByPeer.size) {\n        this.promises.delete(msgId)\n      }\n    })\n\n    this.metrics?.iwantPromiseBroken.inc(brokenPromises)\n\n    return result\n  }\n\n  /**\n   * Someone delivered a message, stop tracking promises for it\n   */\n  deliverMessage(msgIdStr: MsgIdStr, isDuplicate = false): void {\n    this.trackMessage(msgIdStr)\n\n    const expireByPeer = this.promises.get(msgIdStr)\n\n    // Expired promise, check requestMsByMsg\n    if (expireByPeer) {\n      this.promises.delete(msgIdStr)\n\n      if (this.metrics) {\n        this.metrics.iwantPromiseResolved.inc(1)\n        if (isDuplicate) this.metrics.iwantPromiseResolvedFromDuplicate.inc(1)\n        this.metrics.iwantPromiseResolvedPeers.inc(expireByPeer.size)\n      }\n    }\n  }\n\n  /**\n   * A message got rejected, so we can stop tracking promises and let the score penalty apply from invalid message delivery,\n   * unless its an obviously invalid message.\n   */\n  rejectMessage(msgIdStr: MsgIdStr, reason: RejectReason): void {\n    this.trackMessage(msgIdStr)\n\n    // A message got rejected, so we can stop tracking promises and let the score penalty apply.\n    // With the expection of obvious invalid messages\n    switch (reason) {\n      case RejectReason.Error:\n        return\n    }\n\n    this.promises.delete(msgIdStr)\n  }\n\n  clear(): void {\n    this.promises.clear()\n  }\n\n  prune(): void {\n    const maxMs = Date.now() - this.requestMsByMsgExpire\n    let count = 0\n\n    for (const [k, v] of this.requestMsByMsg.entries()) {\n      if (v < maxMs) {\n        // messages that stay too long in the requestMsByMsg map, delete\n        this.requestMsByMsg.delete(k)\n        count++\n      } else {\n        // recent messages, keep them\n        // sort by insertion order\n        break\n      }\n    }\n\n    this.metrics?.iwantMessagePruned.inc(count)\n  }\n\n  private trackMessage(msgIdStr: MsgIdStr): void {\n    if (this.metrics) {\n      const requestMs = this.requestMsByMsg.get(msgIdStr)\n      if (requestMs !== undefined) {\n        this.metrics.iwantPromiseDeliveryTime.observe((Date.now() - requestMs) / 1000)\n        this.requestMsByMsg.delete(msgIdStr)\n      }\n    }\n  }\n}\n", "type SimpleTimeCacheOpts = {\n  validityMs: number\n}\n\ntype CacheValue<T> = {\n  value: T\n  validUntilMs: number\n}\n\n/**\n * This is similar to https://github.com/daviddias/time-cache/blob/master/src/index.js\n * for our own need, we don't use lodash throttle to improve performance.\n * This gives 4x - 5x performance gain compared to npm TimeCache\n */\nexport class SimpleTimeCache<T> {\n  private readonly entries = new Map<string | number, CacheValue<T>>()\n  private readonly validityMs: number\n\n  constructor(opts: SimpleTimeCacheOpts) {\n    this.validityMs = opts.validityMs\n\n    // allow negative validityMs so that this does not cache anything, spec test compliance.spec.js\n    // sends duplicate messages and expect peer to receive all. Application likely uses positive validityMs\n  }\n\n  get size(): number {\n    return this.entries.size\n  }\n\n  /** Returns true if there was a key collision and the entry is dropped */\n  put(key: string | number, value: T): boolean {\n    if (this.entries.has(key)) {\n      // Key collisions break insertion order in the entries cache, which break prune logic.\n      // prune relies on each iterated entry to have strictly ascending validUntilMs, else it\n      // won't prune expired entries and SimpleTimeCache will grow unexpectedly.\n      // As of Oct 2022 NodeJS v16, inserting the same key twice with different value does not\n      // change the key position in the iterator stream. A unit test asserts this behaviour.\n      return true\n    }\n\n    this.entries.set(key, { value, validUntilMs: Date.now() + this.validityMs })\n    return false\n  }\n\n  prune(): void {\n    const now = Date.now()\n\n    for (const [k, v] of this.entries.entries()) {\n      if (v.validUntilMs < now) {\n        this.entries.delete(k)\n      } else {\n        // Entries are inserted with strictly ascending validUntilMs.\n        // Stop early to save iterations\n        break\n      }\n    }\n  }\n\n  has(key: string): boolean {\n    return this.entries.has(key)\n  }\n\n  get(key: string | number): T | undefined {\n    const value = this.entries.get(key)\n    return value && value.validUntilMs >= Date.now() ? value.value : undefined\n  }\n\n  clear(): void {\n    this.entries.clear()\n  }\n}\n", "import { TopicValidatorResult } from '@libp2p/interface/pubsub'\nimport type { IRPC } from './message/rpc.js'\nimport type { PeerScoreThresholds } from './score/peer-score-thresholds.js'\nimport {\n  MessageStatus,\n  type PeerIdStr,\n  RejectReason,\n  type RejectReasonObj,\n  type TopicStr,\n  ValidateError\n} from './types.js'\n\n/** Topic label as provided in `topicStrToLabel` */\nexport type TopicLabel = string\nexport type TopicStrToLabel = Map<TopicStr, TopicLabel>\n\nexport enum MessageSource {\n  forward = 'forward',\n  publish = 'publish'\n}\n\ntype LabelsGeneric = Record<string, string | undefined>\ntype CollectFn<Labels extends LabelsGeneric> = (metric: Gauge<Labels>) => void\n\nexport interface Gauge<Labels extends LabelsGeneric = never> {\n  // Sorry for this mess, `prom-client` API choices are not great\n  // If the function signature was `inc(value: number, labels?: Labels)`, this would be simpler\n  inc(value?: number): void\n  inc(labels: Labels, value?: number): void\n  inc(arg1?: Labels | number, arg2?: number): void\n\n  set(value: number): void\n  set(labels: Labels, value: number): void\n  set(arg1?: Labels | number, arg2?: number): void\n\n  addCollect(collectFn: CollectFn<Labels>): void\n}\n\nexport interface Histogram<Labels extends LabelsGeneric = never> {\n  startTimer(): () => void\n\n  observe(value: number): void\n  observe(labels: Labels, values: number): void\n  observe(arg1: Labels | number, arg2?: number): void\n\n  reset(): void\n}\n\nexport interface AvgMinMax<Labels extends LabelsGeneric = never> {\n  set(values: number[]): void\n  set(labels: Labels, values: number[]): void\n  set(arg1?: Labels | number[], arg2?: number[]): void\n}\n\nexport type GaugeConfig<Labels extends LabelsGeneric> = {\n  name: string\n  help: string\n  labelNames?: keyof Labels extends string ? (keyof Labels)[] : undefined\n}\n\nexport type HistogramConfig<Labels extends LabelsGeneric> = {\n  name: string\n  help: string\n  labelNames?: (keyof Labels)[]\n  buckets?: number[]\n}\n\nexport type AvgMinMaxConfig<Labels extends LabelsGeneric> = GaugeConfig<Labels>\n\nexport interface MetricsRegister {\n  gauge<T extends LabelsGeneric>(config: GaugeConfig<T>): Gauge<T>\n  histogram<T extends LabelsGeneric>(config: HistogramConfig<T>): Histogram<T>\n  avgMinMax<T extends LabelsGeneric>(config: AvgMinMaxConfig<T>): AvgMinMax<T>\n}\n\nexport enum InclusionReason {\n  /** Peer was a fanaout peer. */\n  Fanout = 'fanout',\n  /** Included from random selection. */\n  Random = 'random',\n  /** Peer subscribed. */\n  Subscribed = 'subscribed',\n  /** On heartbeat, peer was included to fill the outbound quota. */\n  Outbound = 'outbound',\n  /** On heartbeat, not enough peers in mesh */\n  NotEnough = 'not_enough',\n  /** On heartbeat opportunistic grafting due to low mesh score */\n  Opportunistic = 'opportunistic'\n}\n\n/// Reasons why a peer was removed from the mesh.\nexport enum ChurnReason {\n  /// Peer disconnected.\n  Dc = 'disconnected',\n  /// Peer had a bad score.\n  BadScore = 'bad_score',\n  /// Peer sent a PRUNE.\n  Prune = 'prune',\n  /// Too many peers.\n  Excess = 'excess'\n}\n\n/// Kinds of reasons a peer's score has been penalized\nexport enum ScorePenalty {\n  /// A peer grafted before waiting the back-off time.\n  GraftBackoff = 'graft_backoff',\n  /// A Peer did not respond to an IWANT request in time.\n  BrokenPromise = 'broken_promise',\n  /// A Peer did not send enough messages as expected.\n  MessageDeficit = 'message_deficit',\n  /// Too many peers under one IP address.\n  IPColocation = 'IP_colocation'\n}\n\nexport enum IHaveIgnoreReason {\n  LowScore = 'low_score',\n  MaxIhave = 'max_ihave',\n  MaxIasked = 'max_iasked'\n}\n\nexport enum ScoreThreshold {\n  graylist = 'graylist',\n  publish = 'publish',\n  gossip = 'gossip',\n  mesh = 'mesh'\n}\n\nexport type PeersByScoreThreshold = Record<ScoreThreshold, number>\n\nexport type ToSendGroupCount = {\n  direct: number\n  floodsub: number\n  mesh: number\n  fanout: number\n}\n\nexport type ToAddGroupCount = {\n  fanout: number\n  random: number\n}\n\nexport type PromiseDeliveredStats =\n  | { expired: false; requestedCount: number; maxDeliverMs: number }\n  | { expired: true; maxDeliverMs: number }\n\nexport type TopicScoreWeights<T> = { p1w: T; p2w: T; p3w: T; p3bw: T; p4w: T }\nexport type ScoreWeights<T> = {\n  byTopic: Map<TopicLabel, TopicScoreWeights<T>>\n  p5w: T\n  p6w: T\n  p7w: T\n  score: T\n}\n\nexport type Metrics = ReturnType<typeof getMetrics>\n\n/**\n * A collection of metrics used throughout the Gossipsub behaviour.\n * NOTE: except for special reasons, do not add more than 1 label for frequent metrics,\n * there's a performance penalty as of June 2023.\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function getMetrics(\n  register: MetricsRegister,\n  topicStrToLabel: TopicStrToLabel,\n  opts: { gossipPromiseExpireSec: number; behaviourPenaltyThreshold: number; maxMeshMessageDeliveriesWindowSec: number }\n) {\n  // Using function style instead of class to prevent having to re-declare all MetricsPrometheus types.\n\n  return {\n    /* Metrics for static config */\n    protocolsEnabled: register.gauge<{ protocol: string }>({\n      name: 'gossipsub_protocol',\n      help: 'Status of enabled protocols',\n      labelNames: ['protocol']\n    }),\n\n    /* Metrics per known topic */\n    /** Status of our subscription to this topic. This metric allows analyzing other topic metrics\n     *  filtered by our current subscription status.\n     *  = rust-libp2p `topic_subscription_status` */\n    topicSubscriptionStatus: register.gauge<{ topicStr: TopicStr }>({\n      name: 'gossipsub_topic_subscription_status',\n      help: 'Status of our subscription to this topic',\n      labelNames: ['topicStr']\n    }),\n    /** Number of peers subscribed to each topic. This allows us to analyze a topic's behaviour\n     * regardless of our subscription status. */\n    topicPeersCount: register.gauge<{ topicStr: TopicStr }>({\n      name: 'gossipsub_topic_peer_count',\n      help: 'Number of peers subscribed to each topic',\n      labelNames: ['topicStr']\n    }),\n\n    /* Metrics regarding mesh state */\n    /** Number of peers in our mesh. This metric should be updated with the count of peers for a\n     *  topic in the mesh regardless of inclusion and churn events.\n     *  = rust-libp2p `mesh_peer_counts` */\n    meshPeerCounts: register.gauge<{ topicStr: TopicStr }>({\n      name: 'gossipsub_mesh_peer_count',\n      help: 'Number of peers in our mesh',\n      labelNames: ['topicStr']\n    }),\n    /** Number of times we include peers in a topic mesh for different reasons.\n     *  = rust-libp2p `mesh_peer_inclusion_events` */\n    meshPeerInclusionEventsFanout: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_mesh_peer_inclusion_events_fanout_total',\n      help: 'Number of times we include peers in a topic mesh for fanout reasons',\n      labelNames: ['topic']\n    }),\n    meshPeerInclusionEventsRandom: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_mesh_peer_inclusion_events_random_total',\n      help: 'Number of times we include peers in a topic mesh for random reasons',\n      labelNames: ['topic']\n    }),\n    meshPeerInclusionEventsSubscribed: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_mesh_peer_inclusion_events_subscribed_total',\n      help: 'Number of times we include peers in a topic mesh for subscribed reasons',\n      labelNames: ['topic']\n    }),\n    meshPeerInclusionEventsOutbound: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_mesh_peer_inclusion_events_outbound_total',\n      help: 'Number of times we include peers in a topic mesh for outbound reasons',\n      labelNames: ['topic']\n    }),\n    meshPeerInclusionEventsNotEnough: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_mesh_peer_inclusion_events_not_enough_total',\n      help: 'Number of times we include peers in a topic mesh for not_enough reasons',\n      labelNames: ['topic']\n    }),\n    meshPeerInclusionEventsOpportunistic: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_mesh_peer_inclusion_events_opportunistic_total',\n      help: 'Number of times we include peers in a topic mesh for opportunistic reasons',\n      labelNames: ['topic']\n    }),\n    meshPeerInclusionEventsUnknown: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_mesh_peer_inclusion_events_unknown_total',\n      help: 'Number of times we include peers in a topic mesh for unknown reasons',\n      labelNames: ['topic']\n    }),\n    /** Number of times we remove peers in a topic mesh for different reasons.\n     *  = rust-libp2p `mesh_peer_churn_events` */\n    meshPeerChurnEventsDisconnected: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_peer_churn_events_disconnected_total',\n      help: 'Number of times we remove peers in a topic mesh for disconnected reasons',\n      labelNames: ['topic']\n    }),\n    meshPeerChurnEventsBadScore: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_peer_churn_events_bad_score_total',\n      help: 'Number of times we remove peers in a topic mesh for bad_score reasons',\n      labelNames: ['topic']\n    }),\n    meshPeerChurnEventsPrune: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_peer_churn_events_prune_total',\n      help: 'Number of times we remove peers in a topic mesh for prune reasons',\n      labelNames: ['topic']\n    }),\n    meshPeerChurnEventsExcess: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_peer_churn_events_excess_total',\n      help: 'Number of times we remove peers in a topic mesh for excess reasons',\n      labelNames: ['topic']\n    }),\n    meshPeerChurnEventsUnknown: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_peer_churn_events_unknown_total',\n      help: 'Number of times we remove peers in a topic mesh for unknown reasons',\n      labelNames: ['topic']\n    }),\n\n    /* General Metrics */\n    /** Gossipsub supports floodsub, gossipsub v1.0 and gossipsub v1.1. Peers are classified based\n     *  on which protocol they support. This metric keeps track of the number of peers that are\n     *  connected of each type. */\n    peersPerProtocol: register.gauge<{ protocol: string }>({\n      name: 'gossipsub_peers_per_protocol_count',\n      help: 'Peers connected for each topic',\n      labelNames: ['protocol']\n    }),\n    /** The time it takes to complete one iteration of the heartbeat. */\n    heartbeatDuration: register.histogram({\n      name: 'gossipsub_heartbeat_duration_seconds',\n      help: 'The time it takes to complete one iteration of the heartbeat',\n      // Should take <10ms, over 1s it's a huge issue that needs debugging, since a heartbeat will be cancelled\n      buckets: [0.01, 0.1, 1]\n    }),\n    /** Heartbeat run took longer than heartbeat interval so next is skipped */\n    heartbeatSkipped: register.gauge({\n      name: 'gossipsub_heartbeat_skipped',\n      help: 'Heartbeat run took longer than heartbeat interval so next is skipped'\n    }),\n\n    /** Message validation results for each topic.\n     *  Invalid == Reject?\n     *  = rust-libp2p `invalid_messages`, `accepted_messages`, `ignored_messages`, `rejected_messages` */\n    acceptedMessagesTotal: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_accepted_messages_total',\n      help: 'Total accepted messages for each topic',\n      labelNames: ['topic']\n    }),\n    ignoredMessagesTotal: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_ignored_messages_total',\n      help: 'Total ignored messages for each topic',\n      labelNames: ['topic']\n    }),\n    rejectedMessagesTotal: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_rejected_messages_total',\n      help: 'Total rejected messages for each topic',\n      labelNames: ['topic']\n    }),\n    unknownValidationResultsTotal: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_unknown_validation_results_total',\n      help: 'Total unknown validation results for each topic',\n      labelNames: ['topic']\n    }),\n    /** When the user validates a message, it tries to re propagate it to its mesh peers. If the\n     *  message expires from the memcache before it can be validated, we count this a cache miss\n     *  and it is an indicator that the memcache size should be increased.\n     *  = rust-libp2p `mcache_misses` */\n    asyncValidationMcacheHit: register.gauge<{ hit: 'hit' | 'miss' }>({\n      name: 'gossipsub_async_validation_mcache_hit_total',\n      help: 'Async validation result reported by the user layer',\n      labelNames: ['hit']\n    }),\n\n    asyncValidationDelayFromFirstSeenSec: register.histogram<{ topic: TopicLabel }>({\n      name: 'gossipsub_async_validation_delay_from_first_seen',\n      help: 'Async validation report delay from first seen in second',\n      labelNames: ['topic'],\n      buckets: [0.01, 0.03, 0.1, 0.3, 1, 3, 10]\n    }),\n\n    asyncValidationUnknownFirstSeen: register.gauge({\n      name: 'gossipsub_async_validation_unknown_first_seen_count_total',\n      help: 'Async validation report unknown first seen value for message'\n    }),\n\n    // peer stream\n    peerReadStreamError: register.gauge({\n      name: 'gossipsub_peer_read_stream_err_count_total',\n      help: 'Peer read stream error'\n    }),\n\n    // RPC outgoing. Track byte length + data structure sizes\n    rpcRecvBytes: register.gauge({ name: 'gossipsub_rpc_recv_bytes_total', help: 'RPC recv' }),\n    rpcRecvCount: register.gauge({ name: 'gossipsub_rpc_recv_count_total', help: 'RPC recv' }),\n    rpcRecvSubscription: register.gauge({ name: 'gossipsub_rpc_recv_subscription_total', help: 'RPC recv' }),\n    rpcRecvMessage: register.gauge({ name: 'gossipsub_rpc_recv_message_total', help: 'RPC recv' }),\n    rpcRecvControl: register.gauge({ name: 'gossipsub_rpc_recv_control_total', help: 'RPC recv' }),\n    rpcRecvIHave: register.gauge({ name: 'gossipsub_rpc_recv_ihave_total', help: 'RPC recv' }),\n    rpcRecvIWant: register.gauge({ name: 'gossipsub_rpc_recv_iwant_total', help: 'RPC recv' }),\n    rpcRecvGraft: register.gauge({ name: 'gossipsub_rpc_recv_graft_total', help: 'RPC recv' }),\n    rpcRecvPrune: register.gauge({ name: 'gossipsub_rpc_recv_prune_total', help: 'RPC recv' }),\n    rpcDataError: register.gauge({ name: 'gossipsub_rpc_data_err_count_total', help: 'RPC data error' }),\n    rpcRecvError: register.gauge({ name: 'gossipsub_rpc_recv_err_count_total', help: 'RPC recv error' }),\n\n    /** Total count of RPC dropped because acceptFrom() == false */\n    rpcRecvNotAccepted: register.gauge({\n      name: 'gossipsub_rpc_rcv_not_accepted_total',\n      help: 'Total count of RPC dropped because acceptFrom() == false'\n    }),\n\n    // RPC incoming. Track byte length + data structure sizes\n    rpcSentBytes: register.gauge({ name: 'gossipsub_rpc_sent_bytes_total', help: 'RPC sent' }),\n    rpcSentCount: register.gauge({ name: 'gossipsub_rpc_sent_count_total', help: 'RPC sent' }),\n    rpcSentSubscription: register.gauge({ name: 'gossipsub_rpc_sent_subscription_total', help: 'RPC sent' }),\n    rpcSentMessage: register.gauge({ name: 'gossipsub_rpc_sent_message_total', help: 'RPC sent' }),\n    rpcSentControl: register.gauge({ name: 'gossipsub_rpc_sent_control_total', help: 'RPC sent' }),\n    rpcSentIHave: register.gauge({ name: 'gossipsub_rpc_sent_ihave_total', help: 'RPC sent' }),\n    rpcSentIWant: register.gauge({ name: 'gossipsub_rpc_sent_iwant_total', help: 'RPC sent' }),\n    rpcSentGraft: register.gauge({ name: 'gossipsub_rpc_sent_graft_total', help: 'RPC sent' }),\n    rpcSentPrune: register.gauge({ name: 'gossipsub_rpc_sent_prune_total', help: 'RPC sent' }),\n\n    // publish message. Track peers sent to and bytes\n    /** Total count of msg published by topic */\n    msgPublishCount: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_msg_publish_count_total',\n      help: 'Total count of msg published by topic',\n      labelNames: ['topic']\n    }),\n    /** Total count of peers that we publish a msg to */\n    msgPublishPeersByTopic: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_msg_publish_peers_total',\n      help: 'Total count of peers that we publish a msg to',\n      labelNames: ['topic']\n    }),\n    /** Total count of peers (by group) that we publish a msg to */\n    directPeersPublishedTotal: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_direct_peers_published_total',\n      help: 'Total direct peers that we publish a msg to',\n      labelNames: ['topic']\n    }),\n    floodsubPeersPublishedTotal: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_floodsub_peers_published_total',\n      help: 'Total floodsub peers that we publish a msg to',\n      labelNames: ['topic']\n    }),\n    meshPeersPublishedTotal: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_mesh_peers_published_total',\n      help: 'Total mesh peers that we publish a msg to',\n      labelNames: ['topic']\n    }),\n    fanoutPeersPublishedTotal: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_fanout_peers_published_total',\n      help: 'Total fanout peers that we publish a msg to',\n      labelNames: ['topic']\n    }),\n    /** Total count of msg publish data.length bytes */\n    msgPublishBytes: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_msg_publish_bytes_total',\n      help: 'Total count of msg publish data.length bytes',\n      labelNames: ['topic']\n    }),\n    /** Total time in seconds to publish a message */\n    msgPublishTime: register.histogram<{ topic: TopicLabel }>({\n      name: 'gossipsub_msg_publish_seconds',\n      help: 'Total time in seconds to publish a message',\n      buckets: [0.001, 0.002, 0.005, 0.01, 0.1, 0.5, 1],\n      labelNames: ['topic']\n    }),\n\n    /** Total count of msg forwarded by topic */\n    msgForwardCount: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_msg_forward_count_total',\n      help: 'Total count of msg forwarded by topic',\n      labelNames: ['topic']\n    }),\n    /** Total count of peers that we forward a msg to */\n    msgForwardPeers: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_msg_forward_peers_total',\n      help: 'Total count of peers that we forward a msg to',\n      labelNames: ['topic']\n    }),\n\n    /** Total count of recv msgs before any validation */\n    msgReceivedPreValidation: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_msg_received_prevalidation_total',\n      help: 'Total count of recv msgs before any validation',\n      labelNames: ['topic']\n    }),\n    /** Total count of recv msgs error */\n    msgReceivedError: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_msg_received_error_total',\n      help: 'Total count of recv msgs error',\n      labelNames: ['topic']\n    }),\n    /** Tracks distribution of recv msgs by duplicate, invalid, valid */\n    prevalidationInvalidTotal: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_pre_validation_invalid_total',\n      help: 'Total count of invalid messages received',\n      labelNames: ['topic']\n    }),\n    prevalidationValidTotal: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_pre_validation_valid_total',\n      help: 'Total count of valid messages received',\n      labelNames: ['topic']\n    }),\n    prevalidationDuplicateTotal: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_pre_validation_duplicate_total',\n      help: 'Total count of duplicate messages received',\n      labelNames: ['topic']\n    }),\n    prevalidationUnknownTotal: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_pre_validation_unknown_status_total',\n      help: 'Total count of unknown_status messages received',\n      labelNames: ['topic']\n    }),\n    /** Tracks specific reason of invalid */\n    msgReceivedInvalid: register.gauge<{ error: RejectReason | ValidateError }>({\n      name: 'gossipsub_msg_received_invalid_total',\n      help: 'Tracks specific reason of invalid',\n      labelNames: ['error']\n    }),\n    msgReceivedInvalidByTopic: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_msg_received_invalid_by_topic_total',\n      help: 'Tracks specific invalid message by topic',\n      labelNames: ['topic']\n    }),\n    /** Track duplicate message delivery time */\n    duplicateMsgDeliveryDelay: register.histogram({\n      name: 'gossisub_duplicate_msg_delivery_delay_seconds',\n      help: 'Time since the 1st duplicated message validated',\n      labelNames: ['topic'],\n      buckets: [\n        0.25 * opts.maxMeshMessageDeliveriesWindowSec,\n        0.5 * opts.maxMeshMessageDeliveriesWindowSec,\n        1 * opts.maxMeshMessageDeliveriesWindowSec,\n        2 * opts.maxMeshMessageDeliveriesWindowSec,\n        4 * opts.maxMeshMessageDeliveriesWindowSec\n      ]\n    }),\n    /** Total count of late msg delivery total by topic */\n    duplicateMsgLateDelivery: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossisub_duplicate_msg_late_delivery_total',\n      help: 'Total count of late duplicate message delivery by topic, which triggers P3 penalty',\n      labelNames: ['topic']\n    }),\n\n    duplicateMsgIgnored: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossisub_ignored_published_duplicate_msgs_total',\n      help: 'Total count of published duplicate message ignored by topic',\n      labelNames: ['topic']\n    }),\n\n    /* Metrics related to scoring */\n    /** Total times score() is called */\n    scoreFnCalls: register.gauge({\n      name: 'gossipsub_score_fn_calls_total',\n      help: 'Total times score() is called'\n    }),\n    /** Total times score() call actually computed computeScore(), no cache */\n    scoreFnRuns: register.gauge({\n      name: 'gossipsub_score_fn_runs_total',\n      help: 'Total times score() call actually computed computeScore(), no cache'\n    }),\n    scoreCachedDelta: register.histogram({\n      name: 'gossipsub_score_cache_delta',\n      help: 'Delta of score between cached values that expired',\n      buckets: [10, 100, 1000]\n    }),\n    /** Current count of peers by score threshold */\n    peersByScoreThreshold: register.gauge<{ threshold: ScoreThreshold }>({\n      name: 'gossipsub_peers_by_score_threshold_count',\n      help: 'Current count of peers by score threshold',\n      labelNames: ['threshold']\n    }),\n    score: register.avgMinMax({\n      name: 'gossipsub_score',\n      help: 'Avg min max of gossip scores'\n    }),\n    /**\n     * Separate score weights\n     * Need to use 2-label metrics in this case to debug the score weights\n     **/\n    scoreWeights: register.avgMinMax<{ topic?: TopicLabel; p: string }>({\n      name: 'gossipsub_score_weights',\n      help: 'Separate score weights',\n      labelNames: ['topic', 'p']\n    }),\n    /** Histogram of the scores for each mesh topic. */\n    // TODO: Not implemented\n    scorePerMesh: register.avgMinMax<{ topic: TopicLabel }>({\n      name: 'gossipsub_score_per_mesh',\n      help: 'Histogram of the scores for each mesh topic',\n      labelNames: ['topic']\n    }),\n    /** A counter of the kind of penalties being applied to peers. */\n    // TODO: Not fully implemented\n    scoringPenalties: register.gauge<{ penalty: ScorePenalty }>({\n      name: 'gossipsub_scoring_penalties_total',\n      help: 'A counter of the kind of penalties being applied to peers',\n      labelNames: ['penalty']\n    }),\n    behaviourPenalty: register.histogram({\n      name: 'gossipsub_peer_stat_behaviour_penalty',\n      help: 'Current peer stat behaviour_penalty at each scrape',\n      buckets: [\n        0.25 * opts.behaviourPenaltyThreshold,\n        0.5 * opts.behaviourPenaltyThreshold,\n        1 * opts.behaviourPenaltyThreshold,\n        2 * opts.behaviourPenaltyThreshold,\n        4 * opts.behaviourPenaltyThreshold\n      ]\n    }),\n\n    // TODO:\n    // - iasked per peer (on heartbeat)\n    // - when promise is resolved, track messages from promises\n\n    /** Total received IHAVE messages that we ignore for some reason */\n    ihaveRcvIgnored: register.gauge<{ reason: IHaveIgnoreReason }>({\n      name: 'gossipsub_ihave_rcv_ignored_total',\n      help: 'Total received IHAVE messages that we ignore for some reason',\n      labelNames: ['reason']\n    }),\n    /** Total received IHAVE messages by topic */\n    ihaveRcvMsgids: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_ihave_rcv_msgids_total',\n      help: 'Total received IHAVE messages by topic',\n      labelNames: ['topic']\n    }),\n    /** Total messages per topic we don't have. Not actual requests.\n     *  The number of times we have decided that an IWANT control message is required for this\n     *  topic. A very high metric might indicate an underperforming network.\n     *  = rust-libp2p `topic_iwant_msgs` */\n    ihaveRcvNotSeenMsgids: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_ihave_rcv_not_seen_msgids_total',\n      help: 'Total messages per topic we do not have, not actual requests',\n      labelNames: ['topic']\n    }),\n\n    /** Total received IWANT messages by topic */\n    iwantRcvMsgids: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_iwant_rcv_msgids_total',\n      help: 'Total received IWANT messages by topic',\n      labelNames: ['topic']\n    }),\n    /** Total requested messageIDs that we don't have */\n    iwantRcvDonthaveMsgids: register.gauge({\n      name: 'gossipsub_iwant_rcv_dont_have_msgids_total',\n      help: 'Total requested messageIDs that we do not have'\n    }),\n    iwantPromiseStarted: register.gauge({\n      name: 'gossipsub_iwant_promise_sent_total',\n      help: 'Total count of started IWANT promises'\n    }),\n    /** Total count of resolved IWANT promises */\n    iwantPromiseResolved: register.gauge({\n      name: 'gossipsub_iwant_promise_resolved_total',\n      help: 'Total count of resolved IWANT promises'\n    }),\n    /** Total count of resolved IWANT promises from duplicate messages */\n    iwantPromiseResolvedFromDuplicate: register.gauge({\n      name: 'gossipsub_iwant_promise_resolved_from_duplicate_total',\n      help: 'Total count of resolved IWANT promises from duplicate messages'\n    }),\n    /** Total count of peers we have asked IWANT promises that are resolved */\n    iwantPromiseResolvedPeers: register.gauge({\n      name: 'gossipsub_iwant_promise_resolved_peers',\n      help: 'Total count of peers we have asked IWANT promises that are resolved'\n    }),\n    iwantPromiseBroken: register.gauge({\n      name: 'gossipsub_iwant_promise_broken',\n      help: 'Total count of broken IWANT promises'\n    }),\n    iwantMessagePruned: register.gauge({\n      name: 'gossipsub_iwant_message_pruned',\n      help: 'Total count of pruned IWANT messages'\n    }),\n    /** Histogram of delivery time of resolved IWANT promises */\n    iwantPromiseDeliveryTime: register.histogram({\n      name: 'gossipsub_iwant_promise_delivery_seconds',\n      help: 'Histogram of delivery time of resolved IWANT promises',\n      buckets: [\n        0.5 * opts.gossipPromiseExpireSec,\n        1 * opts.gossipPromiseExpireSec,\n        2 * opts.gossipPromiseExpireSec,\n        4 * opts.gossipPromiseExpireSec\n      ]\n    }),\n    iwantPromiseUntracked: register.gauge({\n      name: 'gossip_iwant_promise_untracked',\n      help: 'Total count of untracked IWANT promise'\n    }),\n    /** Backoff time */\n    connectedPeersBackoffSec: register.histogram({\n      name: 'gossipsub_connected_peers_backoff_seconds',\n      help: 'Backoff time in seconds',\n      // Using 1 seconds as minimum as that's close to the heartbeat duration, no need for more resolution.\n      // As per spec, backoff times are 10 seconds for UnsubscribeBackoff and 60 seconds for PruneBackoff.\n      // Higher values of 60 seconds should not occur, but we add 120 seconds just in case\n      // https://github.com/libp2p/specs/blob/master/pubsub/gossipsub/gossipsub-v1.1.md#overview-of-new-parameters\n      buckets: [1, 2, 4, 10, 20, 60, 120]\n    }),\n\n    /* Data structure sizes */\n    /** Unbounded cache sizes */\n    cacheSize: register.gauge<{ cache: string }>({\n      name: 'gossipsub_cache_size',\n      help: 'Unbounded cache sizes',\n      labelNames: ['cache']\n    }),\n    /** Current mcache msg count */\n    mcacheSize: register.gauge({\n      name: 'gossipsub_mcache_size',\n      help: 'Current mcache msg count'\n    }),\n    mcacheNotValidatedCount: register.gauge({\n      name: 'gossipsub_mcache_not_validated_count',\n      help: 'Current mcache msg count not validated'\n    }),\n\n    fastMsgIdCacheCollision: register.gauge({\n      name: 'gossipsub_fastmsgid_cache_collision_total',\n      help: 'Total count of key collisions on fastmsgid cache put'\n    }),\n\n    newConnectionCount: register.gauge<{ status: string }>({\n      name: 'gossipsub_new_connection_total',\n      help: 'Total new connection by status',\n      labelNames: ['status']\n    }),\n\n    topicStrToLabel: topicStrToLabel,\n\n    toTopic(topicStr: TopicStr): TopicLabel {\n      return this.topicStrToLabel.get(topicStr) ?? topicStr\n    },\n\n    /** We joined a topic */\n    onJoin(topicStr: TopicStr): void {\n      this.topicSubscriptionStatus.set({ topicStr }, 1)\n      this.meshPeerCounts.set({ topicStr }, 0) // Reset count\n    },\n\n    /** We left a topic */\n    onLeave(topicStr: TopicStr): void {\n      this.topicSubscriptionStatus.set({ topicStr }, 0)\n      this.meshPeerCounts.set({ topicStr }, 0) // Reset count\n    },\n\n    /** Register the inclusion of peers in our mesh due to some reason. */\n    onAddToMesh(topicStr: TopicStr, reason: InclusionReason, count: number): void {\n      const topic = this.toTopic(topicStr)\n      switch (reason) {\n        case InclusionReason.Fanout:\n          this.meshPeerInclusionEventsFanout.inc({ topic }, count)\n          break\n        case InclusionReason.Random:\n          this.meshPeerInclusionEventsRandom.inc({ topic }, count)\n          break\n        case InclusionReason.Subscribed:\n          this.meshPeerInclusionEventsSubscribed.inc({ topic }, count)\n          break\n        case InclusionReason.Outbound:\n          this.meshPeerInclusionEventsOutbound.inc({ topic }, count)\n          break\n        case InclusionReason.NotEnough:\n          this.meshPeerInclusionEventsNotEnough.inc({ topic }, count)\n          break\n        case InclusionReason.Opportunistic:\n          this.meshPeerInclusionEventsOpportunistic.inc({ topic }, count)\n          break\n        default:\n          this.meshPeerInclusionEventsUnknown.inc({ topic }, count)\n          break\n      }\n    },\n\n    /** Register the removal of peers in our mesh due to some reason */\n    // - remove_peer_from_mesh()\n    // - heartbeat() Churn::BadScore\n    // - heartbeat() Churn::Excess\n    // - on_disconnect() Churn::Ds\n    onRemoveFromMesh(topicStr: TopicStr, reason: ChurnReason, count: number): void {\n      const topic = this.toTopic(topicStr)\n      switch (reason) {\n        case ChurnReason.Dc:\n          this.meshPeerChurnEventsDisconnected.inc({ topic }, count)\n          break\n        case ChurnReason.BadScore:\n          this.meshPeerChurnEventsBadScore.inc({ topic }, count)\n          break\n        case ChurnReason.Prune:\n          this.meshPeerChurnEventsPrune.inc({ topic }, count)\n          break\n        case ChurnReason.Excess:\n          this.meshPeerChurnEventsExcess.inc({ topic }, count)\n          break\n        default:\n          this.meshPeerChurnEventsUnknown.inc({ topic }, count)\n          break\n      }\n    },\n\n    /**\n     * Update validation result to metrics\n     * @param messageRecord null means the message's mcache record was not known at the time of acceptance report\n     */\n    onReportValidation(\n      messageRecord: { message: { topic: TopicStr } } | null,\n      acceptance: TopicValidatorResult,\n      firstSeenTimestampMs: number | null\n    ): void {\n      this.asyncValidationMcacheHit.inc({ hit: messageRecord != null ? 'hit' : 'miss' })\n\n      if (messageRecord != null) {\n        const topic = this.toTopic(messageRecord.message.topic)\n        switch (acceptance) {\n          case TopicValidatorResult.Accept:\n            this.acceptedMessagesTotal.inc({ topic })\n            break\n          case TopicValidatorResult.Ignore:\n            this.ignoredMessagesTotal.inc({ topic })\n            break\n          case TopicValidatorResult.Reject:\n            this.rejectedMessagesTotal.inc({ topic })\n            break\n          default:\n            this.unknownValidationResultsTotal.inc({ topic })\n            break\n        }\n      }\n\n      if (firstSeenTimestampMs != null) {\n        this.asyncValidationDelayFromFirstSeenSec.observe((Date.now() - firstSeenTimestampMs) / 1000)\n      } else {\n        this.asyncValidationUnknownFirstSeen.inc()\n      }\n    },\n\n    /**\n     * - in handle_graft() Penalty::GraftBackoff\n     * - in apply_iwant_penalties() Penalty::BrokenPromise\n     * - in metric_score() P3 Penalty::MessageDeficit\n     * - in metric_score() P6 Penalty::IPColocation\n     */\n    onScorePenalty(penalty: ScorePenalty): void {\n      // Can this be labeled by topic too?\n      this.scoringPenalties.inc({ penalty }, 1)\n    },\n\n    onIhaveRcv(topicStr: TopicStr, ihave: number, idonthave: number): void {\n      const topic = this.toTopic(topicStr)\n      this.ihaveRcvMsgids.inc({ topic }, ihave)\n      this.ihaveRcvNotSeenMsgids.inc({ topic }, idonthave)\n    },\n\n    onIwantRcv(iwantByTopic: Map<TopicStr, number>, iwantDonthave: number): void {\n      for (const [topicStr, iwant] of iwantByTopic) {\n        const topic = this.toTopic(topicStr)\n        this.iwantRcvMsgids.inc({ topic }, iwant)\n      }\n\n      this.iwantRcvDonthaveMsgids.inc(iwantDonthave)\n    },\n\n    onForwardMsg(topicStr: TopicStr, tosendCount: number): void {\n      const topic = this.toTopic(topicStr)\n      this.msgForwardCount.inc({ topic }, 1)\n      this.msgForwardPeers.inc({ topic }, tosendCount)\n    },\n\n    onPublishMsg(\n      topicStr: TopicStr,\n      tosendGroupCount: ToSendGroupCount,\n      tosendCount: number,\n      dataLen: number,\n      ms: number\n    ): void {\n      const topic = this.toTopic(topicStr)\n      this.msgPublishCount.inc({ topic }, 1)\n      this.msgPublishBytes.inc({ topic }, tosendCount * dataLen)\n      this.msgPublishPeersByTopic.inc({ topic }, tosendCount)\n      this.directPeersPublishedTotal.inc({ topic }, tosendGroupCount.direct)\n      this.floodsubPeersPublishedTotal.inc({ topic }, tosendGroupCount.floodsub)\n      this.meshPeersPublishedTotal.inc({ topic }, tosendGroupCount.mesh)\n      this.fanoutPeersPublishedTotal.inc({ topic }, tosendGroupCount.fanout)\n      this.msgPublishTime.observe({ topic }, ms / 1000)\n    },\n\n    onMsgRecvPreValidation(topicStr: TopicStr): void {\n      const topic = this.toTopic(topicStr)\n      this.msgReceivedPreValidation.inc({ topic }, 1)\n    },\n\n    onMsgRecvError(topicStr: TopicStr): void {\n      const topic = this.toTopic(topicStr)\n      this.msgReceivedError.inc({ topic }, 1)\n    },\n\n    onPrevalidationResult(topicStr: TopicStr, status: MessageStatus): void {\n      const topic = this.toTopic(topicStr)\n      switch (status) {\n        case MessageStatus.duplicate:\n          this.prevalidationDuplicateTotal.inc({ topic })\n          break\n        case MessageStatus.invalid:\n          this.prevalidationInvalidTotal.inc({ topic })\n          break\n        case MessageStatus.valid:\n          this.prevalidationValidTotal.inc({ topic })\n          break\n        default:\n          this.prevalidationUnknownTotal.inc({ topic })\n          break\n      }\n    },\n\n    onMsgRecvInvalid(topicStr: TopicStr, reason: RejectReasonObj): void {\n      const topic = this.toTopic(topicStr)\n\n      const error = reason.reason === RejectReason.Error ? reason.error : reason.reason\n      this.msgReceivedInvalid.inc({ error }, 1)\n      this.msgReceivedInvalidByTopic.inc({ topic }, 1)\n    },\n\n    onDuplicateMsgDelivery(topicStr: TopicStr, deliveryDelayMs: number, isLateDelivery: boolean): void {\n      this.duplicateMsgDeliveryDelay.observe(deliveryDelayMs / 1000)\n      if (isLateDelivery) {\n        const topic = this.toTopic(topicStr)\n        this.duplicateMsgLateDelivery.inc({ topic }, 1)\n      }\n    },\n\n    onPublishDuplicateMsg(topicStr: TopicStr): void {\n      const topic = this.toTopic(topicStr)\n      this.duplicateMsgIgnored.inc({ topic }, 1)\n    },\n\n    onPeerReadStreamError(): void {\n      this.peerReadStreamError.inc(1)\n    },\n\n    onRpcRecvError(): void {\n      this.rpcRecvError.inc(1)\n    },\n\n    onRpcDataError(): void {\n      this.rpcDataError.inc(1)\n    },\n\n    onRpcRecv(rpc: IRPC, rpcBytes: number): void {\n      this.rpcRecvBytes.inc(rpcBytes)\n      this.rpcRecvCount.inc(1)\n      if (rpc.subscriptions) this.rpcRecvSubscription.inc(rpc.subscriptions.length)\n      if (rpc.messages) this.rpcRecvMessage.inc(rpc.messages.length)\n      if (rpc.control) {\n        this.rpcRecvControl.inc(1)\n        if (rpc.control.ihave) this.rpcRecvIHave.inc(rpc.control.ihave.length)\n        if (rpc.control.iwant) this.rpcRecvIWant.inc(rpc.control.iwant.length)\n        if (rpc.control.graft) this.rpcRecvGraft.inc(rpc.control.graft.length)\n        if (rpc.control.prune) this.rpcRecvPrune.inc(rpc.control.prune.length)\n      }\n    },\n\n    onRpcSent(rpc: IRPC, rpcBytes: number): void {\n      this.rpcSentBytes.inc(rpcBytes)\n      this.rpcSentCount.inc(1)\n      if (rpc.subscriptions) this.rpcSentSubscription.inc(rpc.subscriptions.length)\n      if (rpc.messages) this.rpcSentMessage.inc(rpc.messages.length)\n      if (rpc.control) {\n        const ihave = rpc.control.ihave?.length ?? 0\n        const iwant = rpc.control.iwant?.length ?? 0\n        const graft = rpc.control.graft?.length ?? 0\n        const prune = rpc.control.prune?.length ?? 0\n        if (ihave > 0) this.rpcSentIHave.inc(ihave)\n        if (iwant > 0) this.rpcSentIWant.inc(iwant)\n        if (graft > 0) this.rpcSentGraft.inc(graft)\n        if (prune > 0) this.rpcSentPrune.inc(prune)\n        if (ihave > 0 || iwant > 0 || graft > 0 || prune > 0) this.rpcSentControl.inc(1)\n      }\n    },\n\n    registerScores(scores: number[], scoreThresholds: PeerScoreThresholds): void {\n      let graylist = 0\n      let publish = 0\n      let gossip = 0\n      let mesh = 0\n\n      for (const score of scores) {\n        if (score >= scoreThresholds.graylistThreshold) graylist++\n        if (score >= scoreThresholds.publishThreshold) publish++\n        if (score >= scoreThresholds.gossipThreshold) gossip++\n        if (score >= 0) mesh++\n      }\n\n      this.peersByScoreThreshold.set({ threshold: ScoreThreshold.graylist }, graylist)\n      this.peersByScoreThreshold.set({ threshold: ScoreThreshold.publish }, publish)\n      this.peersByScoreThreshold.set({ threshold: ScoreThreshold.gossip }, gossip)\n      this.peersByScoreThreshold.set({ threshold: ScoreThreshold.mesh }, mesh)\n\n      // Register full score too\n      this.score.set(scores)\n    },\n\n    registerScoreWeights(sw: ScoreWeights<number[]>): void {\n      for (const [topic, wsTopic] of sw.byTopic) {\n        this.scoreWeights.set({ topic, p: 'p1' }, wsTopic.p1w)\n        this.scoreWeights.set({ topic, p: 'p2' }, wsTopic.p2w)\n        this.scoreWeights.set({ topic, p: 'p3' }, wsTopic.p3w)\n        this.scoreWeights.set({ topic, p: 'p3b' }, wsTopic.p3bw)\n        this.scoreWeights.set({ topic, p: 'p4' }, wsTopic.p4w)\n      }\n\n      this.scoreWeights.set({ p: 'p5' }, sw.p5w)\n      this.scoreWeights.set({ p: 'p6' }, sw.p6w)\n      this.scoreWeights.set({ p: 'p7' }, sw.p7w)\n    },\n\n    registerScorePerMesh(mesh: Map<TopicStr, Set<PeerIdStr>>, scoreByPeer: Map<PeerIdStr, number>): void {\n      const peersPerTopicLabel = new Map<TopicLabel, Set<PeerIdStr>>()\n\n      mesh.forEach((peers, topicStr) => {\n        // Aggregate by known topicLabel or throw to 'unknown'. This prevent too high cardinality\n        const topicLabel = this.topicStrToLabel.get(topicStr) ?? 'unknown'\n        let peersInMesh = peersPerTopicLabel.get(topicLabel)\n        if (!peersInMesh) {\n          peersInMesh = new Set()\n          peersPerTopicLabel.set(topicLabel, peersInMesh)\n        }\n        peers.forEach((p) => peersInMesh?.add(p))\n      })\n\n      for (const [topic, peers] of peersPerTopicLabel) {\n        const meshScores: number[] = []\n        peers.forEach((peer) => {\n          meshScores.push(scoreByPeer.get(peer) ?? 0)\n        })\n        this.scorePerMesh.set({ topic }, meshScores)\n      }\n    }\n  }\n}\n", "import 'node-forge/lib/aes.js'\n// @ts-expect-error types are missing\nimport forge from 'node-forge/lib/forge.js'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\n\nexport interface Cipher {\n  update(data: Uint8Array): Uint8Array\n}\n\nexport function createCipheriv (mode: any, key: Uint8Array, iv: Uint8Array): Cipher {\n  const cipher2 = forge.cipher.createCipher('AES-CTR', uint8ArrayToString(key, 'ascii'))\n  cipher2.start({ iv: uint8ArrayToString(iv, 'ascii') })\n  return {\n    update: (data: Uint8Array) => {\n      cipher2.update(forge.util.createBuffer(uint8ArrayToString(data, 'ascii')))\n      return uint8ArrayFromString(cipher2.output.getBytes(), 'ascii')\n    }\n  }\n}\n\nexport function createDecipheriv (mode: any, key: Uint8Array, iv: Uint8Array): Cipher {\n  const cipher2 = forge.cipher.createDecipher('AES-CTR', uint8ArrayToString(key, 'ascii'))\n  cipher2.start({ iv: uint8ArrayToString(iv, 'ascii') })\n  return {\n    update: (data: Uint8Array) => {\n      cipher2.update(forge.util.createBuffer(uint8ArrayToString(data, 'ascii')))\n      return uint8ArrayFromString(cipher2.output.getBytes(), 'ascii')\n    }\n  }\n}\n", "import { CodeError } from '@libp2p/interface/errors'\n// @ts-expect-error types are missing\nimport forgePbkdf2 from 'node-forge/lib/pbkdf2.js'\n// @ts-expect-error types are missing\nimport forgeUtil from 'node-forge/lib/util.js'\n\n/**\n * Maps an IPFS hash name to its node-forge equivalent.\n *\n * See https://github.com/multiformats/multihash/blob/master/hashtable.csv\n *\n * @private\n */\nconst hashName = {\n  sha1: 'sha1',\n  'sha2-256': 'sha256',\n  'sha2-512': 'sha512'\n}\n\n/**\n * Computes the Password-Based Key Derivation Function 2.\n */\nexport default function pbkdf2 (password: string, salt: string, iterations: number, keySize: number, hash: string): string {\n  if (hash !== 'sha1' && hash !== 'sha2-256' && hash !== 'sha2-512') {\n    const types = Object.keys(hashName).join(' / ')\n    throw new CodeError(`Hash '${hash}' is unknown or not supported. Must be ${types}`, 'ERR_UNSUPPORTED_HASH_TYPE')\n  }\n\n  const hasher = hashName[hash]\n  const dek = forgePbkdf2(\n    password,\n    salt,\n    iterations,\n    keySize,\n    hasher\n  )\n\n  return forgeUtil.encode64(dek, null)\n}\n", "import { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { marshalPublicKey, unmarshalPublicKey } from '@libp2p/crypto/keys'\nimport { randomBytes } from '@libp2p/crypto'\nimport { peerIdFromBytes } from '@libp2p/peer-id'\nimport type { PublicKey } from '@libp2p/interface/keys'\nimport type { PeerId } from '@libp2p/interface/peer-id'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { RPC } from '../message/rpc.js'\nimport { type PublishConfig, PublishConfigType, type TopicStr, ValidateError } from '../types.js'\nimport { StrictSign, StrictNoSign, type Message } from '@libp2p/interface/pubsub'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\n\nexport const SignPrefix = uint8ArrayFromString('libp2p-pubsub:')\n\nexport type RawMessageAndMessage = {\n  raw: RPC.IMessage\n  msg: Message\n}\n\nexport async function buildRawMessage(\n  publishConfig: PublishConfig,\n  topic: TopicStr,\n  originalData: Uint8Array,\n  transformedData: Uint8Array\n): Promise<RawMessageAndMessage> {\n  switch (publishConfig.type) {\n    case PublishConfigType.Signing: {\n      const rpcMsg: RPC.IMessage = {\n        from: publishConfig.author.toBytes(),\n        data: transformedData,\n        seqno: randomBytes(8),\n        topic,\n        signature: undefined, // Exclude signature field for signing\n        key: undefined // Exclude key field for signing\n      }\n\n      // Get the message in bytes, and prepend with the pubsub prefix\n      // the signature is over the bytes \"libp2p-pubsub:<protobuf-message>\"\n      const bytes = uint8ArrayConcat([SignPrefix, RPC.Message.encode(rpcMsg).finish()])\n\n      rpcMsg.signature = await publishConfig.privateKey.sign(bytes)\n      rpcMsg.key = publishConfig.key\n\n      const msg: Message = {\n        type: 'signed',\n        from: publishConfig.author,\n        data: originalData,\n        sequenceNumber: BigInt(`0x${uint8ArrayToString(rpcMsg.seqno as Uint8Array, 'base16')}`),\n        topic,\n        signature: rpcMsg.signature,\n        key: rpcMsg.key\n      }\n      return {\n        raw: rpcMsg,\n        msg: msg\n      }\n    }\n\n    case PublishConfigType.Anonymous: {\n      return {\n        raw: {\n          from: undefined,\n          data: transformedData,\n          seqno: undefined,\n          topic,\n          signature: undefined,\n          key: undefined\n        },\n        msg: {\n          type: 'unsigned',\n          data: originalData,\n          topic\n        }\n      }\n    }\n  }\n}\n\nexport type ValidationResult = { valid: true; message: Message } | { valid: false; error: ValidateError }\n\nexport async function validateToRawMessage(\n  signaturePolicy: typeof StrictNoSign | typeof StrictSign,\n  msg: RPC.IMessage\n): Promise<ValidationResult> {\n  // If strict-sign, verify all\n  // If anonymous (no-sign), ensure no preven\n\n  switch (signaturePolicy) {\n    case StrictNoSign:\n      if (msg.signature != null) return { valid: false, error: ValidateError.SignaturePresent }\n      if (msg.seqno != null) return { valid: false, error: ValidateError.SeqnoPresent }\n      if (msg.key != null) return { valid: false, error: ValidateError.FromPresent }\n\n      return { valid: true, message: { type: 'unsigned', topic: msg.topic, data: msg.data ?? new Uint8Array(0) } }\n\n    case StrictSign: {\n      // Verify seqno\n      if (msg.seqno == null) return { valid: false, error: ValidateError.InvalidSeqno }\n      if (msg.seqno.length !== 8) {\n        return { valid: false, error: ValidateError.InvalidSeqno }\n      }\n\n      if (msg.signature == null) return { valid: false, error: ValidateError.InvalidSignature }\n      if (msg.from == null) return { valid: false, error: ValidateError.InvalidPeerId }\n\n      let fromPeerId: PeerId\n      try {\n        // TODO: Fix PeerId types\n        fromPeerId = peerIdFromBytes(msg.from)\n      } catch (e) {\n        return { valid: false, error: ValidateError.InvalidPeerId }\n      }\n\n      // - check from defined\n      // - transform source to PeerId\n      // - parse signature\n      // - get .key, else from source\n      // - check key == source if present\n      // - verify sig\n\n      let publicKey: PublicKey\n      if (msg.key) {\n        publicKey = unmarshalPublicKey(msg.key)\n        // TODO: Should `fromPeerId.pubKey` be optional?\n        if (fromPeerId.publicKey !== undefined && !uint8ArrayEquals(publicKey.bytes, fromPeerId.publicKey)) {\n          return { valid: false, error: ValidateError.InvalidPeerId }\n        }\n      } else {\n        if (fromPeerId.publicKey == null) {\n          return { valid: false, error: ValidateError.InvalidPeerId }\n        }\n        publicKey = unmarshalPublicKey(fromPeerId.publicKey)\n      }\n\n      const rpcMsgPreSign: RPC.IMessage = {\n        from: msg.from,\n        data: msg.data,\n        seqno: msg.seqno,\n        topic: msg.topic,\n        signature: undefined, // Exclude signature field for signing\n        key: undefined // Exclude key field for signing\n      }\n\n      // Get the message in bytes, and prepend with the pubsub prefix\n      // the signature is over the bytes \"libp2p-pubsub:<protobuf-message>\"\n      const bytes = uint8ArrayConcat([SignPrefix, RPC.Message.encode(rpcMsgPreSign).finish()])\n\n      if (!(await publicKey.verify(bytes, msg.signature))) {\n        return { valid: false, error: ValidateError.InvalidSignature }\n      }\n\n      return {\n        valid: true,\n        message: {\n          type: 'signed',\n          from: fromPeerId,\n          data: msg.data ?? new Uint8Array(0),\n          sequenceNumber: BigInt(`0x${uint8ArrayToString(msg.seqno, 'base16')}`),\n          topic: msg.topic,\n          signature: msg.signature,\n          key: msg.key ?? marshalPublicKey(publicKey)\n        }\n      }\n    }\n  }\n}\n", "const empty = new Uint8Array(0)\n\n/**\n * @param {Uint8Array} d\n */\nconst toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')\n\n/**\n * @param {string} hex\n */\nconst fromHex = hex => {\n  const hexes = hex.match(/../g)\n  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty\n}\n\n/**\n * @param {Uint8Array} aa\n * @param {Uint8Array} bb\n */\nconst equals = (aa, bb) => {\n  if (aa === bb) return true\n  if (aa.byteLength !== bb.byteLength) {\n    return false\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @param {ArrayBufferView|ArrayBuffer|Uint8Array} o\n * @returns {Uint8Array}\n */\nconst coerce = o => {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o\n  if (o instanceof ArrayBuffer) return new Uint8Array(o)\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)\n  }\n  throw new Error('Unknown type, must be binary type')\n}\n\n/**\n * @param {any} o\n * @returns {o is ArrayBuffer|ArrayBufferView}\n */\nconst isBinary = o =>\n  o instanceof ArrayBuffer || ArrayBuffer.isView(o)\n\n/**\n * @param {string} str\n * @returns {Uint8Array}\n */\nconst fromString = str => (new TextEncoder()).encode(str)\n\n/**\n * @param {Uint8Array} b\n * @returns {string}\n */\nconst toString = b => (new TextDecoder()).decode(b)\n\nexport { equals, coerce, isBinary, fromHex, toHex, fromString, toString, empty }\n", "var encode_1 = encode;\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31);\n\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num /= 128;\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  \n  encode.bytes = offset - oldOffset + 1;\n  \n  return out\n}\n\nvar decode = read;\n\nvar MSB$1 = 0x80\n  , REST$1 = 0x7F;\n\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length;\n\n  do {\n    if (counter >= l) {\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++];\n    res += shift < 28\n      ? (b & REST$1) << shift\n      : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1)\n\n  read.bytes = counter - offset;\n\n  return res\n}\n\nvar N1 = Math.pow(2,  7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\n\nvar length = function (value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n};\n\nvar varint = {\n    encode: encode_1\n  , decode: decode\n  , encodingLength: length\n};\n\nvar _brrp_varint = varint;\n\nexport default _brrp_varint;\n", "import varint from '../vendor/varint.js'\n\n/**\n * @param {Uint8Array} data\n * @param {number} [offset=0]\n * @returns {[number, number]}\n */\nexport const decode = (data, offset = 0) => {\n  const code = varint.decode(data, offset)\n  return [code, varint.decode.bytes]\n}\n\n/**\n * @param {number} int\n * @param {Uint8Array} target\n * @param {number} [offset=0]\n */\nexport const encodeTo = (int, target, offset = 0) => {\n  varint.encode(int, target, offset)\n  return target\n}\n\n/**\n * @param {number} int\n * @returns {number}\n */\nexport const encodingLength = (int) => {\n  return varint.encodingLength(int)\n}\n", "import { coerce, equals as equalBytes } from '../bytes.js'\nimport * as varint from '../varint.js'\n\n/**\n * Creates a multihash digest.\n *\n * @template {number} Code\n * @param {Code} code\n * @param {Uint8Array} digest\n */\nexport const create = (code, digest) => {\n  const size = digest.byteLength\n  const sizeOffset = varint.encodingLength(code)\n  const digestOffset = sizeOffset + varint.encodingLength(size)\n\n  const bytes = new Uint8Array(digestOffset + size)\n  varint.encodeTo(code, bytes, 0)\n  varint.encodeTo(size, bytes, sizeOffset)\n  bytes.set(digest, digestOffset)\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * Turns bytes representation of multihash digest into an instance.\n *\n * @param {Uint8Array} multihash\n * @returns {MultihashDigest}\n */\nexport const decode = (multihash) => {\n  const bytes = coerce(multihash)\n  const [code, sizeOffset] = varint.decode(bytes)\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset))\n  const digest = bytes.subarray(sizeOffset + digestOffset)\n\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length')\n  }\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * @param {MultihashDigest} a\n * @param {unknown} b\n * @returns {b is MultihashDigest}\n */\nexport const equals = (a, b) => {\n  if (a === b) {\n    return true\n  } else {\n    const data = /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */(b)\n\n    return (\n      a.code === data.code &&\n      a.size === data.size &&\n      data.bytes instanceof Uint8Array &&\n      equalBytes(a.bytes, data.bytes)\n    )\n  }\n}\n\n/**\n * @typedef {import('./interface.js').MultihashDigest} MultihashDigest\n */\n\n/**\n * Represents a multihash digest which carries information about the\n * hashing algorithm and an actual hash digest.\n *\n * @template {number} Code\n * @template {number} Size\n * @class\n * @implements {MultihashDigest}\n */\nexport class Digest {\n  /**\n   * Creates a multihash digest.\n   *\n   * @param {Code} code\n   * @param {Size} size\n   * @param {Uint8Array} digest\n   * @param {Uint8Array} bytes\n   */\n  constructor (code, size, digest, bytes) {\n    this.code = code\n    this.size = size\n    this.digest = digest\n    this.bytes = bytes\n  }\n}\n", "import * as Digest from './digest.js'\n\n/**\n * @template {string} Name\n * @template {number} Code\n * @param {object} options\n * @param {Name} options.name\n * @param {Code} options.code\n * @param {(input: Uint8Array) => Await<Uint8Array>} options.encode\n */\nexport const from = ({ name, code, encode }) => new Hasher(name, code, encode)\n\n/**\n * Hasher represents a hashing algorithm implementation that produces as\n * `MultihashDigest`.\n *\n * @template {string} Name\n * @template {number} Code\n * @class\n * @implements {MultihashHasher<Code>}\n */\nexport class Hasher {\n  /**\n   *\n   * @param {Name} name\n   * @param {Code} code\n   * @param {(input: Uint8Array) => Await<Uint8Array>} encode\n   */\n  constructor (name, code, encode) {\n    this.name = name\n    this.code = code\n    this.encode = encode\n  }\n\n  /**\n   * @param {Uint8Array} input\n   * @returns {Await<Digest.Digest<Code, number>>}\n   */\n  digest (input) {\n    if (input instanceof Uint8Array) {\n      const result = this.encode(input)\n      return result instanceof Uint8Array\n        ? Digest.create(this.code, result)\n        /* c8 ignore next 1 */\n        : result.then(digest => Digest.create(this.code, digest))\n    } else {\n      throw Error('Unknown type, must be binary type')\n      /* c8 ignore next 1 */\n    }\n  }\n}\n\n/**\n * @template {number} Alg\n * @typedef {import('./interface.js').MultihashHasher} MultihashHasher\n */\n\n/**\n * @template T\n * @typedef {Promise<T>|T} Await\n */\n", "/* global crypto */\n\nimport { from } from './hasher.js'\n\n/**\n * @param {AlgorithmIdentifier} name\n */\nconst sha = name =>\n  /**\n   * @param {Uint8Array} data\n   */\n  async data => new Uint8Array(await crypto.subtle.digest(name, data))\n\nexport const sha256 = from({\n  name: 'sha2-256',\n  code: 0x12,\n  encode: sha('SHA-256')\n})\n\nexport const sha512 = from({\n  name: 'sha2-512',\n  code: 0x13,\n  encode: sha('SHA-512')\n})\n", "const empty = new Uint8Array(0)\n\n/**\n * @param {Uint8Array} d\n */\nconst toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')\n\n/**\n * @param {string} hex\n */\nconst fromHex = hex => {\n  const hexes = hex.match(/../g)\n  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty\n}\n\n/**\n * @param {Uint8Array} aa\n * @param {Uint8Array} bb\n */\nconst equals = (aa, bb) => {\n  if (aa === bb) return true\n  if (aa.byteLength !== bb.byteLength) {\n    return false\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @param {ArrayBufferView|ArrayBuffer|Uint8Array} o\n * @returns {Uint8Array}\n */\nconst coerce = o => {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o\n  if (o instanceof ArrayBuffer) return new Uint8Array(o)\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)\n  }\n  throw new Error('Unknown type, must be binary type')\n}\n\n/**\n * @param {any} o\n * @returns {o is ArrayBuffer|ArrayBufferView}\n */\nconst isBinary = o =>\n  o instanceof ArrayBuffer || ArrayBuffer.isView(o)\n\n/**\n * @param {string} str\n * @returns {Uint8Array}\n */\nconst fromString = str => (new TextEncoder()).encode(str)\n\n/**\n * @param {Uint8Array} b\n * @returns {string}\n */\nconst toString = b => (new TextDecoder()).decode(b)\n\nexport { equals, coerce, isBinary, fromHex, toHex, fromString, toString, empty }\n", "var encode_1 = encode;\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31);\n\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num /= 128;\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  \n  encode.bytes = offset - oldOffset + 1;\n  \n  return out\n}\n\nvar decode = read;\n\nvar MSB$1 = 0x80\n  , REST$1 = 0x7F;\n\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length;\n\n  do {\n    if (counter >= l) {\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++];\n    res += shift < 28\n      ? (b & REST$1) << shift\n      : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1)\n\n  read.bytes = counter - offset;\n\n  return res\n}\n\nvar N1 = Math.pow(2,  7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\n\nvar length = function (value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n};\n\nvar varint = {\n    encode: encode_1\n  , decode: decode\n  , encodingLength: length\n};\n\nvar _brrp_varint = varint;\n\nexport default _brrp_varint;\n", "import varint from '../vendor/varint.js'\n\n/**\n * @param {Uint8Array} data\n * @param {number} [offset=0]\n * @returns {[number, number]}\n */\nexport const decode = (data, offset = 0) => {\n  const code = varint.decode(data, offset)\n  return [code, varint.decode.bytes]\n}\n\n/**\n * @param {number} int\n * @param {Uint8Array} target\n * @param {number} [offset=0]\n */\nexport const encodeTo = (int, target, offset = 0) => {\n  varint.encode(int, target, offset)\n  return target\n}\n\n/**\n * @param {number} int\n * @returns {number}\n */\nexport const encodingLength = (int) => {\n  return varint.encodingLength(int)\n}\n", "import { coerce, equals as equalBytes } from '../bytes.js'\nimport * as varint from '../varint.js'\n\n/**\n * Creates a multihash digest.\n *\n * @template {number} Code\n * @param {Code} code\n * @param {Uint8Array} digest\n */\nexport const create = (code, digest) => {\n  const size = digest.byteLength\n  const sizeOffset = varint.encodingLength(code)\n  const digestOffset = sizeOffset + varint.encodingLength(size)\n\n  const bytes = new Uint8Array(digestOffset + size)\n  varint.encodeTo(code, bytes, 0)\n  varint.encodeTo(size, bytes, sizeOffset)\n  bytes.set(digest, digestOffset)\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * Turns bytes representation of multihash digest into an instance.\n *\n * @param {Uint8Array} multihash\n * @returns {MultihashDigest}\n */\nexport const decode = (multihash) => {\n  const bytes = coerce(multihash)\n  const [code, sizeOffset] = varint.decode(bytes)\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset))\n  const digest = bytes.subarray(sizeOffset + digestOffset)\n\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length')\n  }\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * @param {MultihashDigest} a\n * @param {unknown} b\n * @returns {b is MultihashDigest}\n */\nexport const equals = (a, b) => {\n  if (a === b) {\n    return true\n  } else {\n    const data = /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */(b)\n\n    return (\n      a.code === data.code &&\n      a.size === data.size &&\n      data.bytes instanceof Uint8Array &&\n      equalBytes(a.bytes, data.bytes)\n    )\n  }\n}\n\n/**\n * @typedef {import('./interface.js').MultihashDigest} MultihashDigest\n */\n\n/**\n * Represents a multihash digest which carries information about the\n * hashing algorithm and an actual hash digest.\n *\n * @template {number} Code\n * @template {number} Size\n * @class\n * @implements {MultihashDigest}\n */\nexport class Digest {\n  /**\n   * Creates a multihash digest.\n   *\n   * @param {Code} code\n   * @param {Size} size\n   * @param {Uint8Array} digest\n   * @param {Uint8Array} bytes\n   */\n  constructor (code, size, digest, bytes) {\n    this.code = code\n    this.size = size\n    this.digest = digest\n    this.bytes = bytes\n  }\n}\n", "import * as Digest from './digest.js'\n\n/**\n * @template {string} Name\n * @template {number} Code\n * @param {object} options\n * @param {Name} options.name\n * @param {Code} options.code\n * @param {(input: Uint8Array) => Await<Uint8Array>} options.encode\n */\nexport const from = ({ name, code, encode }) => new Hasher(name, code, encode)\n\n/**\n * Hasher represents a hashing algorithm implementation that produces as\n * `MultihashDigest`.\n *\n * @template {string} Name\n * @template {number} Code\n * @class\n * @implements {MultihashHasher<Code>}\n */\nexport class Hasher {\n  /**\n   *\n   * @param {Name} name\n   * @param {Code} code\n   * @param {(input: Uint8Array) => Await<Uint8Array>} encode\n   */\n  constructor (name, code, encode) {\n    this.name = name\n    this.code = code\n    this.encode = encode\n  }\n\n  /**\n   * @param {Uint8Array} input\n   * @returns {Await<Digest.Digest<Code, number>>}\n   */\n  digest (input) {\n    if (input instanceof Uint8Array) {\n      const result = this.encode(input)\n      return result instanceof Uint8Array\n        ? Digest.create(this.code, result)\n        /* c8 ignore next 1 */\n        : result.then(digest => Digest.create(this.code, digest))\n    } else {\n      throw Error('Unknown type, must be binary type')\n      /* c8 ignore next 1 */\n    }\n  }\n}\n\n/**\n * @template {number} Alg\n * @typedef {import('./interface.js').MultihashHasher} MultihashHasher\n */\n\n/**\n * @template T\n * @typedef {Promise<T>|T} Await\n */\n", "/* global crypto */\n\nimport { from } from './hasher.js'\n\n/**\n * @param {AlgorithmIdentifier} name\n */\nconst sha = name =>\n  /**\n   * @param {Uint8Array} data\n   */\n  async data => new Uint8Array(await crypto.subtle.digest(name, data))\n\nexport const sha256 = from({\n  name: 'sha2-256',\n  code: 0x12,\n  encode: sha('SHA-256')\n})\n\nexport const sha512 = from({\n  name: 'sha2-512',\n  code: 0x13,\n  encode: sha('SHA-512')\n})\n", "import { randomBytes } from '@libp2p/crypto'\nimport { CodeError } from '@libp2p/interface/errors'\nimport { peerIdFromBytes, peerIdFromKeys } from '@libp2p/peer-id'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { codes } from './errors.js'\nimport type { Message, PubSubRPCMessage } from '@libp2p/interface/pubsub'\n\n/**\n * Generate a random sequence number\n */\nexport function randomSeqno (): bigint {\n  return BigInt(`0x${uint8ArrayToString(randomBytes(8), 'base16')}`)\n}\n\n/**\n * Generate a message id, based on the `key` and `seqno`\n */\nexport const msgId = (key: Uint8Array, seqno: bigint): Uint8Array => {\n  const seqnoBytes = uint8ArrayFromString(seqno.toString(16).padStart(16, '0'), 'base16')\n\n  const msgId = new Uint8Array(key.length + seqnoBytes.length)\n  msgId.set(key, 0)\n  msgId.set(seqnoBytes, key.length)\n\n  return msgId\n}\n\n/**\n * Generate a message id, based on message `data`\n */\nexport const noSignMsgId = (data: Uint8Array): Uint8Array | Promise<Uint8Array> => {\n  return sha256.encode(data)\n}\n\n/**\n * Check if any member of the first set is also a member\n * of the second set\n */\nexport const anyMatch = (a: Set<number> | number[], b: Set<number> | number[]): boolean => {\n  let bHas\n  if (Array.isArray(b)) {\n    bHas = (val: number) => b.includes(val)\n  } else {\n    bHas = (val: number) => b.has(val)\n  }\n\n  for (const val of a) {\n    if (bHas(val)) {\n      return true\n    }\n  }\n\n  return false\n}\n\n/**\n * Make everything an array\n */\nexport const ensureArray = function <T> (maybeArray: T | T[]): T[] {\n  if (!Array.isArray(maybeArray)) {\n    return [maybeArray]\n  }\n\n  return maybeArray\n}\n\nconst isSigned = async (message: PubSubRPCMessage): Promise<boolean> => {\n  if ((message.sequenceNumber == null) || (message.from == null) || (message.signature == null)) {\n    return false\n  }\n  // if a public key is present in the `from` field, the message should be signed\n  const fromID = peerIdFromBytes(message.from)\n  if (fromID.publicKey != null) {\n    return true\n  }\n\n  if (message.key != null) {\n    const signingID = await peerIdFromKeys(message.key)\n    return signingID.equals(fromID)\n  }\n\n  return false\n}\n\nexport const toMessage = async (message: PubSubRPCMessage): Promise<Message> => {\n  if (message.from == null) {\n    throw new CodeError('RPC message was missing from', codes.ERR_MISSING_FROM)\n  }\n\n  if (!await isSigned(message)) {\n    return {\n      type: 'unsigned',\n      topic: message.topic ?? '',\n      data: message.data ?? new Uint8Array(0)\n    }\n  }\n\n  const from = peerIdFromBytes(message.from)\n\n  const msg: Message = {\n    type: 'signed',\n    from: peerIdFromBytes(message.from),\n    topic: message.topic ?? '',\n    sequenceNumber: bigIntFromBytes(message.sequenceNumber ?? new Uint8Array(0)),\n    data: message.data ?? new Uint8Array(0),\n    signature: message.signature ?? new Uint8Array(0),\n    key: message.key ?? from.publicKey ?? new Uint8Array(0)\n  }\n\n  if (msg.key.length === 0) {\n    throw new CodeError('Signed RPC message was missing key', codes.ERR_MISSING_KEY)\n  }\n\n  return msg\n}\n\nexport const toRpcMessage = (message: Message): PubSubRPCMessage => {\n  if (message.type === 'signed') {\n    return {\n      from: message.from.multihash.bytes,\n      data: message.data,\n      sequenceNumber: bigIntToBytes(message.sequenceNumber),\n      topic: message.topic,\n      signature: message.signature,\n      key: message.key\n    }\n  }\n\n  return {\n    data: message.data,\n    topic: message.topic\n  }\n}\n\nexport const bigIntToBytes = (num: bigint): Uint8Array => {\n  let str = num.toString(16)\n\n  if (str.length % 2 !== 0) {\n    str = `0${str}`\n  }\n\n  return uint8ArrayFromString(str, 'base16')\n}\n\nexport const bigIntFromBytes = (num: Uint8Array): bigint => {\n  return BigInt(`0x${uint8ArrayToString(num, 'base16')}`)\n}\n", "import { sha256 } from 'multiformats/hashes/sha2'\nimport type { Message } from '@libp2p/interface/pubsub'\nimport { msgId } from '@libp2p/pubsub/utils'\n\n/**\n * Generate a message id, based on the `key` and `seqno`\n */\nexport function msgIdFnStrictSign(msg: Message): Uint8Array {\n  if (msg.type !== 'signed') {\n    throw new Error('expected signed message type')\n  }\n  // Should never happen\n  if (msg.sequenceNumber == null) throw Error('missing seqno field')\n\n  // TODO: Should use .from here or key?\n  return msgId(msg.from.toBytes(), msg.sequenceNumber)\n}\n\n/**\n * Generate a message id, based on message `data`\n */\nexport async function msgIdFnStrictNoSign(msg: Message): Promise<Uint8Array> {\n  return await sha256.encode(msg.data)\n}\n", "import type { PeerScoreParams } from './peer-score-params.js'\nimport type { PeerStats } from './peer-stats.js'\n\ntype TopicLabel = string\ntype TopicStr = string\ntype TopicStrToLabel = Map<TopicStr, TopicLabel>\n\nexport interface TopicScoreWeights<T> {\n  p1w: T\n  p2w: T\n  p3w: T\n  p3bw: T\n  p4w: T\n}\nexport interface ScoreWeights<T> {\n  byTopic: Map<TopicLabel, TopicScoreWeights<T>>\n  p5w: T\n  p6w: T\n  p7w: T\n  score: T\n}\n\nexport function computeScoreWeights(\n  peer: string,\n  pstats: PeerStats,\n  params: PeerScoreParams,\n  peerIPs: Map<string, Set<string>>,\n  topicStrToLabel: TopicStrToLabel\n): ScoreWeights<number> {\n  let score = 0\n\n  const byTopic = new Map<TopicLabel, TopicScoreWeights<number>>()\n\n  // topic stores\n  Object.entries(pstats.topics).forEach(([topic, tstats]) => {\n    // the topic parameters\n    // Aggregate by known topicLabel or throw to 'unknown'. This prevent too high cardinality\n    const topicLabel = topicStrToLabel.get(topic) ?? 'unknown'\n    const topicParams = params.topics[topic]\n    if (topicParams === undefined) {\n      // we are not scoring this topic\n      return\n    }\n\n    let topicScores = byTopic.get(topicLabel)\n    if (!topicScores) {\n      topicScores = {\n        p1w: 0,\n        p2w: 0,\n        p3w: 0,\n        p3bw: 0,\n        p4w: 0\n      }\n      byTopic.set(topicLabel, topicScores)\n    }\n\n    let p1w = 0\n    let p2w = 0\n    let p3w = 0\n    let p3bw = 0\n    let p4w = 0\n\n    // P1: time in Mesh\n    if (tstats.inMesh) {\n      const p1 = Math.max(tstats.meshTime / topicParams.timeInMeshQuantum, topicParams.timeInMeshCap)\n      p1w += p1 * topicParams.timeInMeshWeight\n    }\n\n    // P2: first message deliveries\n    let p2 = tstats.firstMessageDeliveries\n    if (p2 > topicParams.firstMessageDeliveriesCap) {\n      p2 = topicParams.firstMessageDeliveriesCap\n    }\n    p2w += p2 * topicParams.firstMessageDeliveriesWeight\n\n    // P3: mesh message deliveries\n    if (\n      tstats.meshMessageDeliveriesActive &&\n      tstats.meshMessageDeliveries < topicParams.meshMessageDeliveriesThreshold\n    ) {\n      const deficit = topicParams.meshMessageDeliveriesThreshold - tstats.meshMessageDeliveries\n      const p3 = deficit * deficit\n      p3w += p3 * topicParams.meshMessageDeliveriesWeight\n    }\n\n    // P3b:\n    // NOTE: the weight of P3b is negative (validated in validateTopicScoreParams) so this detracts\n    const p3b = tstats.meshFailurePenalty\n    p3bw += p3b * topicParams.meshFailurePenaltyWeight\n\n    // P4: invalid messages\n    // NOTE: the weight of P4 is negative (validated in validateTopicScoreParams) so this detracts\n    const p4 = tstats.invalidMessageDeliveries * tstats.invalidMessageDeliveries\n    p4w += p4 * topicParams.invalidMessageDeliveriesWeight\n\n    // update score, mixing with topic weight\n    score += (p1w + p2w + p3w + p3bw + p4w) * topicParams.topicWeight\n\n    topicScores.p1w += p1w\n    topicScores.p2w += p2w\n    topicScores.p3w += p3w\n    topicScores.p3bw += p3bw\n    topicScores.p4w += p4w\n  })\n\n  // apply the topic score cap, if any\n  if (params.topicScoreCap > 0 && score > params.topicScoreCap) {\n    score = params.topicScoreCap\n\n    // Proportionally apply cap to all individual contributions\n    const capF = params.topicScoreCap / score\n    for (const ws of byTopic.values()) {\n      ws.p1w *= capF\n      ws.p2w *= capF\n      ws.p3w *= capF\n      ws.p3bw *= capF\n      ws.p4w *= capF\n    }\n  }\n\n  let p5w = 0\n  let p6w = 0\n  let p7w = 0\n\n  // P5: application-specific score\n  const p5 = params.appSpecificScore(peer)\n  p5w += p5 * params.appSpecificWeight\n\n  // P6: IP colocation factor\n  pstats.knownIPs.forEach((ip) => {\n    if (params.IPColocationFactorWhitelist.has(ip)) {\n      return\n    }\n\n    // P6 has a cliff (IPColocationFactorThreshold)\n    // It's only applied if at least that many peers are connected to us from that source IP addr.\n    // It is quadratic, and the weight is negative (validated in validatePeerScoreParams)\n    const peersInIP = peerIPs.get(ip)\n    const numPeersInIP = peersInIP ? peersInIP.size : 0\n    if (numPeersInIP > params.IPColocationFactorThreshold) {\n      const surplus = numPeersInIP - params.IPColocationFactorThreshold\n      const p6 = surplus * surplus\n      p6w += p6 * params.IPColocationFactorWeight\n    }\n  })\n\n  // P7: behavioural pattern penalty\n  const p7 = pstats.behaviourPenalty * pstats.behaviourPenalty\n  p7w += p7 * params.behaviourPenaltyWeight\n\n  score += p5w + p6w + p7w\n\n  return {\n    byTopic,\n    p5w,\n    p6w,\n    p7w,\n    score\n  }\n}\n\nexport function computeAllPeersScoreWeights(\n  peerIdStrs: Iterable<string>,\n  peerStats: Map<string, PeerStats>,\n  params: PeerScoreParams,\n  peerIPs: Map<string, Set<string>>,\n  topicStrToLabel: TopicStrToLabel\n): ScoreWeights<number[]> {\n  const sw: ScoreWeights<number[]> = {\n    byTopic: new Map(),\n    p5w: [],\n    p6w: [],\n    p7w: [],\n    score: []\n  }\n\n  for (const peerIdStr of peerIdStrs) {\n    const pstats = peerStats.get(peerIdStr)\n    if (pstats) {\n      const swPeer = computeScoreWeights(peerIdStr, pstats, params, peerIPs, topicStrToLabel)\n\n      for (const [topic, swPeerTopic] of swPeer.byTopic) {\n        let swTopic = sw.byTopic.get(topic)\n        if (!swTopic) {\n          swTopic = {\n            p1w: [],\n            p2w: [],\n            p3w: [],\n            p3bw: [],\n            p4w: []\n          }\n          sw.byTopic.set(topic, swTopic)\n        }\n\n        swTopic.p1w.push(swPeerTopic.p1w)\n        swTopic.p2w.push(swPeerTopic.p2w)\n        swTopic.p3w.push(swPeerTopic.p3w)\n        swTopic.p3bw.push(swPeerTopic.p3bw)\n        swTopic.p4w.push(swPeerTopic.p4w)\n      }\n\n      sw.p5w.push(swPeer.p5w)\n      sw.p6w.push(swPeer.p6w)\n      sw.p7w.push(swPeer.p7w)\n      sw.score.push(swPeer.score)\n    } else {\n      sw.p5w.push(0)\n      sw.p6w.push(0)\n      sw.p7w.push(0)\n      sw.score.push(0)\n    }\n  }\n\n  return sw\n}\n", "import type { Stream } from '@libp2p/interface/connection'\nimport { abortableSource } from 'abortable-iterator'\nimport { pipe } from 'it-pipe'\nimport { pushable, type Pushable } from 'it-pushable'\nimport { encode, decode } from 'it-length-prefixed'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\ntype OutboundStreamOpts = {\n  /** Max size in bytes for pushable buffer. If full, will throw on .push */\n  maxBufferSize?: number\n}\n\ntype InboundStreamOpts = {\n  /** Max size in bytes for reading messages from the stream */\n  maxDataLength?: number\n}\n\nexport class OutboundStream {\n  private readonly pushable: Pushable<Uint8Array>\n  private readonly closeController: AbortController\n  private readonly maxBufferSize: number\n\n  constructor(private readonly rawStream: Stream, errCallback: (e: Error) => void, opts: OutboundStreamOpts) {\n    this.pushable = pushable({ objectMode: false })\n    this.closeController = new AbortController()\n    this.maxBufferSize = opts.maxBufferSize ?? Infinity\n\n    pipe(\n      abortableSource(this.pushable, this.closeController.signal, { returnOnAbort: true }),\n      (source) => encode(source),\n      this.rawStream\n    ).catch(errCallback)\n  }\n\n  get protocol(): string {\n    // TODO remove this non-nullish assertion after https://github.com/libp2p/js-libp2p-interfaces/pull/265 is incorporated\n    return this.rawStream.protocol!\n  }\n\n  push(data: Uint8Array): void {\n    if (this.pushable.readableLength > this.maxBufferSize) {\n      throw Error(`OutboundStream buffer full, size > ${this.maxBufferSize}`)\n    }\n\n    this.pushable.push(data)\n  }\n\n  close(): void {\n    this.closeController.abort()\n    // similar to pushable.end() but clear the internal buffer\n    this.pushable.return()\n    this.rawStream.close()\n  }\n}\n\nexport class InboundStream {\n  public readonly source: AsyncIterable<Uint8ArrayList>\n\n  private readonly rawStream: Stream\n  private readonly closeController: AbortController\n\n  constructor(rawStream: Stream, opts: InboundStreamOpts = {}) {\n    this.rawStream = rawStream\n    this.closeController = new AbortController()\n\n    this.source = abortableSource(\n      pipe(this.rawStream, (source) => decode(source, opts)),\n      this.closeController.signal,\n      {\n        returnOnAbort: true\n      }\n    )\n  }\n\n  close(): void {\n    this.closeController.abort()\n    this.rawStream.close()\n  }\n}\n", "import type { IRPC, RPC } from './rpc.js'\nimport protobuf from 'protobufjs/minimal.js'\n\nexport type DecodeRPCLimits = {\n  maxSubscriptions: number\n  maxMessages: number\n  maxIhaveMessageIDs: number\n  maxIwantMessageIDs: number\n  maxControlMessages: number\n  maxPeerInfos: number\n}\n\nexport const defaultDecodeRpcLimits: DecodeRPCLimits = {\n  maxSubscriptions: Infinity,\n  maxMessages: Infinity,\n  maxIhaveMessageIDs: Infinity,\n  maxIwantMessageIDs: Infinity,\n  maxControlMessages: Infinity,\n  maxPeerInfos: Infinity\n}\n\n/**\n * Copied code from src/message/rpc.cjs but with decode limits to prevent OOM attacks\n */\nexport function decodeRpc(bytes: Uint8Array, opts: DecodeRPCLimits): IRPC {\n  // Mutate to use the option as stateful counter. Must limit the total count of messageIDs across all IWANT, IHAVE\n  // else one count put 100 messageIDs into each 100 IWANT and \"get around\" the limit\n  opts = { ...opts }\n\n  const r = protobuf.Reader.create(bytes)\n  const l = bytes.length\n\n  const c = l === undefined ? r.len : r.pos + l\n  const m: IRPC = {}\n  while (r.pos < c) {\n    const t = r.uint32()\n    switch (t >>> 3) {\n      case 1:\n        if (!(m.subscriptions && m.subscriptions.length)) m.subscriptions = []\n        if (m.subscriptions.length < opts.maxSubscriptions) m.subscriptions.push(decodeSubOpts(r, r.uint32()))\n        else r.skipType(t & 7)\n        break\n      case 2:\n        if (!(m.messages && m.messages.length)) m.messages = []\n        if (m.messages.length < opts.maxMessages) m.messages.push(decodeMessage(r, r.uint32()))\n        else r.skipType(t & 7)\n        break\n      case 3:\n        m.control = decodeControlMessage(r, r.uint32(), opts)\n        break\n      default:\n        r.skipType(t & 7)\n        break\n    }\n  }\n  return m\n}\n\nfunction decodeSubOpts(r: protobuf.Reader, l: number) {\n  const c = l === undefined ? r.len : r.pos + l\n  const m: RPC.ISubOpts = {}\n  while (r.pos < c) {\n    const t = r.uint32()\n    switch (t >>> 3) {\n      case 1:\n        m.subscribe = r.bool()\n        break\n      case 2:\n        m.topic = r.string()\n        break\n      default:\n        r.skipType(t & 7)\n        break\n    }\n  }\n  return m\n}\n\nfunction decodeMessage(r: protobuf.Reader, l: number) {\n  const c = l === undefined ? r.len : r.pos + l\n  const m = {} as RPC.IMessage\n  while (r.pos < c) {\n    const t = r.uint32()\n    switch (t >>> 3) {\n      case 1:\n        m.from = r.bytes()\n        break\n      case 2:\n        m.data = r.bytes()\n        break\n      case 3:\n        m.seqno = r.bytes()\n        break\n      case 4:\n        m.topic = r.string()\n        break\n      case 5:\n        m.signature = r.bytes()\n        break\n      case 6:\n        m.key = r.bytes()\n        break\n      default:\n        r.skipType(t & 7)\n        break\n    }\n  }\n  if (!m.topic) throw Error(\"missing required 'topic'\")\n  return m\n}\n\nfunction decodeControlMessage(r: protobuf.Reader, l: number, opts: DecodeRPCLimits) {\n  const c = l === undefined ? r.len : r.pos + l\n  const m = {} as RPC.IControlMessage\n  while (r.pos < c) {\n    const t = r.uint32()\n    switch (t >>> 3) {\n      case 1:\n        if (!(m.ihave && m.ihave.length)) m.ihave = []\n        if (m.ihave.length < opts.maxControlMessages) m.ihave.push(decodeControlIHave(r, r.uint32(), opts))\n        else r.skipType(t & 7)\n        break\n      case 2:\n        if (!(m.iwant && m.iwant.length)) m.iwant = []\n        if (m.iwant.length < opts.maxControlMessages) m.iwant.push(decodeControlIWant(r, r.uint32(), opts))\n        else r.skipType(t & 7)\n        break\n      case 3:\n        if (!(m.graft && m.graft.length)) m.graft = []\n        if (m.graft.length < opts.maxControlMessages) m.graft.push(decodeControlGraft(r, r.uint32()))\n        else r.skipType(t & 7)\n        break\n      case 4:\n        if (!(m.prune && m.prune.length)) m.prune = []\n        if (m.prune.length < opts.maxControlMessages) m.prune.push(decodeControlPrune(r, r.uint32(), opts))\n        else r.skipType(t & 7)\n        break\n      default:\n        r.skipType(t & 7)\n        break\n    }\n  }\n  return m\n}\n\nfunction decodeControlIHave(r: protobuf.Reader, l: number, opts: DecodeRPCLimits) {\n  const c = l === undefined ? r.len : r.pos + l\n  const m = {} as RPC.IControlIHave\n  while (r.pos < c) {\n    const t = r.uint32()\n    switch (t >>> 3) {\n      case 1:\n        m.topicID = r.string()\n        break\n      case 2:\n        if (!(m.messageIDs && m.messageIDs.length)) m.messageIDs = []\n        if (opts.maxIhaveMessageIDs-- > 0) m.messageIDs.push(r.bytes())\n        else r.skipType(t & 7)\n        break\n      default:\n        r.skipType(t & 7)\n        break\n    }\n  }\n  return m\n}\n\nfunction decodeControlIWant(r: protobuf.Reader, l: number, opts: DecodeRPCLimits) {\n  const c = l === undefined ? r.len : r.pos + l\n  const m = {} as RPC.IControlIWant\n  while (r.pos < c) {\n    const t = r.uint32()\n    switch (t >>> 3) {\n      case 1:\n        if (!(m.messageIDs && m.messageIDs.length)) m.messageIDs = []\n        if (opts.maxIwantMessageIDs-- > 0) m.messageIDs.push(r.bytes())\n        else r.skipType(t & 7)\n        break\n      default:\n        r.skipType(t & 7)\n        break\n    }\n  }\n  return m\n}\n\nfunction decodeControlGraft(r: protobuf.Reader, l: number) {\n  const c = l === undefined ? r.len : r.pos + l\n  const m = {} as RPC.IControlGraft\n  while (r.pos < c) {\n    const t = r.uint32()\n    switch (t >>> 3) {\n      case 1:\n        m.topicID = r.string()\n        break\n      default:\n        r.skipType(t & 7)\n        break\n    }\n  }\n  return m\n}\n\nfunction decodeControlPrune(r: protobuf.Reader, l: number, opts: DecodeRPCLimits) {\n  const c = l === undefined ? r.len : r.pos + l\n  const m = {} as RPC.IControlPrune\n  while (r.pos < c) {\n    const t = r.uint32()\n    switch (t >>> 3) {\n      case 1:\n        m.topicID = r.string()\n        break\n      case 2:\n        if (!(m.peers && m.peers.length)) m.peers = []\n        if (opts.maxPeerInfos-- > 0) m.peers.push(decodePeerInfo(r, r.uint32()))\n        else r.skipType(t & 7)\n        break\n      case 3:\n        m.backoff = r.uint64() as unknown as number\n        break\n      default:\n        r.skipType(t & 7)\n        break\n    }\n  }\n  return m\n}\n\nfunction decodePeerInfo(r: protobuf.Reader, l: number) {\n  const c = l === undefined ? r.len : r.pos + l\n  const m = {} as RPC.IPeerInfo\n  while (r.pos < c) {\n    const t = r.uint32()\n    switch (t >>> 3) {\n      case 1:\n        m.peerID = r.bytes()\n        break\n      case 2:\n        m.signedPeerRecord = r.bytes()\n        break\n      default:\n        r.skipType(t & 7)\n        break\n    }\n  }\n  return m\n}\n", "import type { Multiaddr } from '@multiformats/multiaddr'\nimport { convertToString } from '@multiformats/multiaddr/convert'\n\n// Protocols https://github.com/multiformats/multiaddr/blob/master/protocols.csv\n// code  size  name\n// 4     32    ip4\n// 41    128   ip6\nenum Protocol {\n  ip4 = 4,\n  ip6 = 41\n}\n\nexport function multiaddrToIPStr(multiaddr: Multiaddr): string | null {\n  for (const tuple of multiaddr.tuples()) {\n    switch (tuple[0]) {\n      case Protocol.ip4:\n      case Protocol.ip6:\n        return convertToString(tuple[0], tuple[1]!)\n    }\n  }\n\n  return null\n}\n", "import { pipe } from 'it-pipe'\nimport type { Connection, Stream } from '@libp2p/interface/connection'\nimport { peerIdFromBytes, peerIdFromString } from '@libp2p/peer-id'\nimport { type Logger, logger } from '@libp2p/logger'\nimport type { PeerId } from '@libp2p/interface/peer-id'\nimport { CustomEvent, EventEmitter } from '@libp2p/interface/events'\n\nimport { MessageCache, type MessageCacheRecord } from './message-cache.js'\nimport { RPC, type IRPC } from './message/rpc.js'\nimport * as constants from './constants.js'\nimport { shuffle, messageIdToString } from './utils/index.js'\nimport {\n  PeerScore,\n  type PeerScoreParams,\n  type PeerScoreThresholds,\n  createPeerScoreParams,\n  createPeerScoreThresholds,\n  type PeerScoreStatsDump\n} from './score/index.js'\nimport { IWantTracer } from './tracer.js'\nimport { SimpleTimeCache } from './utils/time-cache.js'\nimport {\n  ACCEPT_FROM_WHITELIST_DURATION_MS,\n  ACCEPT_FROM_WHITELIST_MAX_MESSAGES,\n  ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE,\n  BACKOFF_SLACK\n} from './constants.js'\nimport {\n  ChurnReason,\n  getMetrics,\n  IHaveIgnoreReason,\n  InclusionReason,\n  type Metrics,\n  type MetricsRegister,\n  ScorePenalty,\n  type TopicStrToLabel,\n  type ToSendGroupCount\n} from './metrics.js'\nimport {\n  type MsgIdFn,\n  type PublishConfig,\n  type TopicStr,\n  type MsgIdStr,\n  ValidateError,\n  type PeerIdStr,\n  MessageStatus,\n  RejectReason,\n  type RejectReasonObj,\n  type FastMsgIdFn,\n  type AddrInfo,\n  type DataTransform,\n  rejectReasonFromAcceptance,\n  type MsgIdToStrFn,\n  type MessageId,\n  type PublishOpts\n} from './types.js'\nimport { buildRawMessage, validateToRawMessage } from './utils/buildRawMessage.js'\nimport { msgIdFnStrictNoSign, msgIdFnStrictSign } from './utils/msgIdFn.js'\nimport { computeAllPeersScoreWeights } from './score/scoreMetrics.js'\nimport { getPublishConfigFromPeerId } from './utils/publishConfig.js'\nimport type { GossipsubOptsSpec } from './config.js'\nimport type {\n  Message,\n  PublishResult,\n  PubSub,\n  PubSubEvents,\n  PubSubInit,\n  SubscriptionChangeData,\n  TopicValidatorFn\n} from '@libp2p/interface/pubsub'\nimport { StrictSign, StrictNoSign, TopicValidatorResult } from '@libp2p/interface/pubsub'\nimport type { IncomingStreamData, Registrar } from '@libp2p/interface-internal/registrar'\nimport { removeFirstNItemsFromSet, removeItemsFromSet } from './utils/set.js'\nimport { pushable } from 'it-pushable'\nimport { InboundStream, OutboundStream } from './stream.js'\nimport type { Uint8ArrayList } from 'uint8arraylist'\nimport { decodeRpc, type DecodeRPCLimits, defaultDecodeRpcLimits } from './message/decodeRpc.js'\nimport type { ConnectionManager } from '@libp2p/interface-internal/connection-manager'\nimport type { Peer, PeerStore } from '@libp2p/interface/peer-store'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport { multiaddrToIPStr } from './utils/multiaddr.js'\n\ntype ConnectionDirection = 'inbound' | 'outbound'\n\ntype ReceivedMessageResult =\n  | { code: MessageStatus.duplicate; msgIdStr: MsgIdStr }\n  | ({ code: MessageStatus.invalid; msgIdStr?: MsgIdStr } & RejectReasonObj)\n  | { code: MessageStatus.valid; messageId: MessageId; msg: Message }\n\nexport const multicodec: string = constants.GossipsubIDv11\n\nexport interface GossipsubOpts extends GossipsubOptsSpec, PubSubInit {\n  /** if dial should fallback to floodsub */\n  fallbackToFloodsub: boolean\n  /** if self-published messages should be sent to all peers */\n  floodPublish: boolean\n  /** whether PX is enabled; this should be enabled in bootstrappers and other well connected/trusted nodes. */\n  doPX: boolean\n  /** peers with which we will maintain direct connections */\n  directPeers: AddrInfo[]\n  /**\n   * If true will not forward messages to mesh peers until reportMessageValidationResult() is called.\n   * Messages will be cached in mcache for some time after which they are evicted. Calling\n   * reportMessageValidationResult() after the message is dropped from mcache won't forward the message.\n   */\n  asyncValidation: boolean\n  /** Do not throw `InsufficientPeers` error if publishing to zero peers */\n  allowPublishToZeroPeers: boolean\n  /** Do not throw `PublishError.Duplicate` if publishing duplicate messages */\n  ignoreDuplicatePublishError: boolean\n  /** For a single stream, await processing each RPC before processing the next */\n  awaitRpcHandler: boolean\n  /** For a single RPC, await processing each message before processing the next */\n  awaitRpcMessageHandler: boolean\n\n  /** message id function */\n  msgIdFn: MsgIdFn\n  /** fast message id function */\n  fastMsgIdFn: FastMsgIdFn\n  /** Uint8Array message id to string function */\n  msgIdToStrFn: MsgIdToStrFn\n  /** override the default MessageCache */\n  messageCache: MessageCache\n  /** peer score parameters */\n  scoreParams: Partial<PeerScoreParams>\n  /** peer score thresholds */\n  scoreThresholds: Partial<PeerScoreThresholds>\n  /** customize GossipsubIWantFollowupTime in order not to apply IWANT penalties */\n  gossipsubIWantFollowupMs: number\n\n  /** override constants for fine tuning */\n  prunePeers?: number\n  pruneBackoff?: number\n  unsubcribeBackoff?: number\n  graftFloodThreshold?: number\n  opportunisticGraftPeers?: number\n  opportunisticGraftTicks?: number\n  directConnectTicks?: number\n\n  dataTransform?: DataTransform\n  metricsRegister?: MetricsRegister | null\n  metricsTopicStrToLabel?: TopicStrToLabel\n\n  // Debug\n  /** Prefix tag for debug logs */\n  debugName?: string\n\n  /**\n   * Specify the maximum number of inbound gossipsub protocol\n   * streams that are allowed to be open concurrently\n   */\n  maxInboundStreams?: number\n\n  /**\n   * Specify the maximum number of outbound gossipsub protocol\n   * streams that are allowed to be open concurrently\n   */\n  maxOutboundStreams?: number\n\n  /**\n   * Specify max buffer size in bytes for OutboundStream.\n   * If full it will throw and reject sending any more data.\n   */\n  maxOutboundBufferSize?: number\n\n  /**\n   * Specify max size to skip decoding messages whose data\n   * section exceeds this size.\n   *\n   */\n  maxInboundDataLength?: number\n\n  /**\n   * If provided, only allow topics in this list\n   */\n  allowedTopics?: string[] | Set<string>\n\n  /**\n   * Limits to bound protobuf decoding\n   */\n  decodeRpcLimits?: DecodeRPCLimits\n}\n\nexport interface GossipsubMessage {\n  propagationSource: PeerId\n  msgId: MsgIdStr\n  msg: Message\n}\n\nexport interface GossipsubEvents extends PubSubEvents {\n  'gossipsub:heartbeat': CustomEvent\n  'gossipsub:message': CustomEvent<GossipsubMessage>\n}\n\nenum GossipStatusCode {\n  started,\n  stopped\n}\n\ntype GossipStatus =\n  | {\n      code: GossipStatusCode.started\n      registrarTopologyIds: string[]\n      heartbeatTimeout: ReturnType<typeof setTimeout>\n      hearbeatStartMs: number\n    }\n  | {\n      code: GossipStatusCode.stopped\n    }\n\ninterface GossipOptions extends GossipsubOpts {\n  scoreParams: PeerScoreParams\n  scoreThresholds: PeerScoreThresholds\n}\n\ninterface AcceptFromWhitelistEntry {\n  /** number of messages accepted since recomputing the peer's score */\n  messagesAccepted: number\n  /** have to recompute score after this time */\n  acceptUntil: number\n}\n\nexport interface GossipSubComponents {\n  peerId: PeerId\n  peerStore: PeerStore\n  registrar: Registrar\n  connectionManager: ConnectionManager\n}\n\nexport class GossipSub extends EventEmitter<GossipsubEvents> implements PubSub<GossipsubEvents> {\n  /**\n   * The signature policy to follow by default\n   */\n  public readonly globalSignaturePolicy: typeof StrictSign | typeof StrictNoSign\n  public multicodecs: string[] = [constants.GossipsubIDv11, constants.GossipsubIDv10]\n\n  private publishConfig: PublishConfig | undefined\n\n  private readonly dataTransform: DataTransform | undefined\n\n  // State\n\n  public readonly peers = new Set<PeerIdStr>()\n  public readonly streamsInbound = new Map<PeerIdStr, InboundStream>()\n  public readonly streamsOutbound = new Map<PeerIdStr, OutboundStream>()\n\n  /** Ensures outbound streams are created sequentially */\n  private outboundInflightQueue = pushable<{ peerId: PeerId; connection: Connection }>({ objectMode: true })\n\n  /** Direct peers */\n  public readonly direct = new Set<PeerIdStr>()\n\n  /** Floodsub peers */\n  private readonly floodsubPeers = new Set<PeerIdStr>()\n\n  /** Cache of seen messages */\n  private readonly seenCache: SimpleTimeCache<void>\n\n  /**\n   * Map of peer id and AcceptRequestWhileListEntry\n   */\n  private readonly acceptFromWhitelist = new Map<PeerIdStr, AcceptFromWhitelistEntry>()\n\n  /**\n   * Map of topics to which peers are subscribed to\n   */\n  private readonly topics = new Map<TopicStr, Set<PeerIdStr>>()\n\n  /**\n   * List of our subscriptions\n   */\n  private readonly subscriptions = new Set<TopicStr>()\n\n  /**\n   * Map of topic meshes\n   * topic => peer id set\n   */\n  public readonly mesh = new Map<TopicStr, Set<PeerIdStr>>()\n\n  /**\n   * Map of topics to set of peers. These mesh peers are the ones to which we are publishing without a topic membership\n   * topic => peer id set\n   */\n  public readonly fanout = new Map<TopicStr, Set<PeerIdStr>>()\n\n  /**\n   * Map of last publish time for fanout topics\n   * topic => last publish time\n   */\n  private readonly fanoutLastpub = new Map<TopicStr, number>()\n\n  /**\n   * Map of pending messages to gossip\n   * peer id => control messages\n   */\n  public readonly gossip = new Map<PeerIdStr, RPC.IControlIHave[]>()\n\n  /**\n   * Map of control messages\n   * peer id => control message\n   */\n  public readonly control = new Map<PeerIdStr, RPC.IControlMessage>()\n\n  /**\n   * Number of IHAVEs received from peer in the last heartbeat\n   */\n  private readonly peerhave = new Map<PeerIdStr, number>()\n\n  /** Number of messages we have asked from peer in the last heartbeat */\n  private readonly iasked = new Map<PeerIdStr, number>()\n\n  /** Prune backoff map */\n  private readonly backoff = new Map<TopicStr, Map<PeerIdStr, number>>()\n\n  /**\n   * Connection direction cache, marks peers with outbound connections\n   * peer id => direction\n   */\n  private readonly outbound = new Map<PeerIdStr, boolean>()\n  private readonly msgIdFn: MsgIdFn\n\n  /**\n   * A fast message id function used for internal message de-duplication\n   */\n  private readonly fastMsgIdFn: FastMsgIdFn | undefined\n\n  private readonly msgIdToStrFn: MsgIdToStrFn\n\n  /** Maps fast message-id to canonical message-id */\n  private readonly fastMsgIdCache: SimpleTimeCache<MsgIdStr> | undefined\n\n  /**\n   * Short term cache for published message ids. This is used for penalizing peers sending\n   * our own messages back if the messages are anonymous or use a random author.\n   */\n  private readonly publishedMessageIds: SimpleTimeCache<void>\n\n  /**\n   * A message cache that contains the messages for last few heartbeat ticks\n   */\n  private readonly mcache: MessageCache\n\n  /** Peer score tracking */\n  public readonly score: PeerScore\n\n  /**\n   * Custom validator function per topic.\n   * Must return or resolve quickly (< 100ms) to prevent causing penalties for late messages.\n   * If you need to apply validation that may require longer times use `asyncValidation` option and callback the\n   * validation result through `Gossipsub.reportValidationResult`\n   */\n  public readonly topicValidators = new Map<TopicStr, TopicValidatorFn>()\n\n  /**\n   * Make this protected so child class may want to redirect to its own log.\n   */\n  protected readonly log: Logger\n\n  /**\n   * Number of heartbeats since the beginning of time\n   * This allows us to amortize some resource cleanup -- eg: backoff cleanup\n   */\n  private heartbeatTicks = 0\n\n  /**\n   * Tracks IHAVE/IWANT promises broken by peers\n   */\n  readonly gossipTracer: IWantTracer\n\n  private readonly components: GossipSubComponents\n\n  private directPeerInitial: ReturnType<typeof setTimeout> | null = null\n\n  public static multicodec: string = constants.GossipsubIDv11\n\n  // Options\n  readonly opts: Required<GossipOptions>\n  private readonly decodeRpcLimits: DecodeRPCLimits\n\n  private readonly metrics: Metrics | null\n  private status: GossipStatus = { code: GossipStatusCode.stopped }\n  private maxInboundStreams?: number\n  private maxOutboundStreams?: number\n  private allowedTopics: Set<TopicStr> | null\n\n  private heartbeatTimer: {\n    _intervalId: ReturnType<typeof setInterval> | undefined\n    runPeriodically: (fn: () => void, period: number) => void\n    cancel: () => void\n  } | null = null\n\n  constructor(components: GossipSubComponents, options: Partial<GossipsubOpts> = {}) {\n    super()\n\n    const opts = {\n      fallbackToFloodsub: true,\n      floodPublish: true,\n      doPX: false,\n      directPeers: [],\n      D: constants.GossipsubD,\n      Dlo: constants.GossipsubDlo,\n      Dhi: constants.GossipsubDhi,\n      Dscore: constants.GossipsubDscore,\n      Dout: constants.GossipsubDout,\n      Dlazy: constants.GossipsubDlazy,\n      heartbeatInterval: constants.GossipsubHeartbeatInterval,\n      fanoutTTL: constants.GossipsubFanoutTTL,\n      mcacheLength: constants.GossipsubHistoryLength,\n      mcacheGossip: constants.GossipsubHistoryGossip,\n      seenTTL: constants.GossipsubSeenTTL,\n      gossipsubIWantFollowupMs: constants.GossipsubIWantFollowupTime,\n      prunePeers: constants.GossipsubPrunePeers,\n      pruneBackoff: constants.GossipsubPruneBackoff,\n      unsubcribeBackoff: constants.GossipsubUnsubscribeBackoff,\n      graftFloodThreshold: constants.GossipsubGraftFloodThreshold,\n      opportunisticGraftPeers: constants.GossipsubOpportunisticGraftPeers,\n      opportunisticGraftTicks: constants.GossipsubOpportunisticGraftTicks,\n      directConnectTicks: constants.GossipsubDirectConnectTicks,\n      ...options,\n      scoreParams: createPeerScoreParams(options.scoreParams),\n      scoreThresholds: createPeerScoreThresholds(options.scoreThresholds)\n    }\n\n    this.components = components\n    this.decodeRpcLimits = opts.decodeRpcLimits ?? defaultDecodeRpcLimits\n\n    this.globalSignaturePolicy = opts.globalSignaturePolicy ?? StrictSign\n\n    // Also wants to get notified of peers connected using floodsub\n    if (opts.fallbackToFloodsub) {\n      this.multicodecs.push(constants.FloodsubID)\n    }\n\n    // From pubsub\n    this.log = logger(opts.debugName ?? 'libp2p:gossipsub')\n\n    // Gossipsub\n\n    this.opts = opts as Required<GossipOptions>\n    this.direct = new Set(opts.directPeers.map((p) => p.id.toString()))\n    this.seenCache = new SimpleTimeCache<void>({ validityMs: opts.seenTTL })\n    this.publishedMessageIds = new SimpleTimeCache<void>({ validityMs: opts.seenTTL })\n\n    if (options.msgIdFn) {\n      // Use custom function\n      this.msgIdFn = options.msgIdFn\n    } else {\n      switch (this.globalSignaturePolicy) {\n        case StrictSign:\n          this.msgIdFn = msgIdFnStrictSign\n          break\n        case StrictNoSign:\n          this.msgIdFn = msgIdFnStrictNoSign\n          break\n      }\n    }\n\n    if (options.fastMsgIdFn) {\n      this.fastMsgIdFn = options.fastMsgIdFn\n      this.fastMsgIdCache = new SimpleTimeCache<MsgIdStr>({ validityMs: opts.seenTTL })\n    }\n\n    // By default, gossipsub only provide a browser friendly function to convert Uint8Array message id to string.\n    this.msgIdToStrFn = options.msgIdToStrFn ?? messageIdToString\n\n    this.mcache = options.messageCache || new MessageCache(opts.mcacheGossip, opts.mcacheLength, this.msgIdToStrFn)\n\n    if (options.dataTransform) {\n      this.dataTransform = options.dataTransform\n    }\n\n    if (options.metricsRegister) {\n      if (!options.metricsTopicStrToLabel) {\n        throw Error('Must set metricsTopicStrToLabel with metrics')\n      }\n\n      // in theory, each topic has its own meshMessageDeliveriesWindow param\n      // however in lodestar, we configure it mostly the same so just pick the max of positive ones\n      // (some topics have meshMessageDeliveriesWindow as 0)\n      const maxMeshMessageDeliveriesWindowMs = Math.max(\n        ...Object.values(opts.scoreParams.topics).map((topicParam) => topicParam.meshMessageDeliveriesWindow),\n        constants.DEFAULT_METRIC_MESH_MESSAGE_DELIVERIES_WINDOWS\n      )\n\n      const metrics = getMetrics(options.metricsRegister, options.metricsTopicStrToLabel, {\n        gossipPromiseExpireSec: this.opts.gossipsubIWantFollowupMs / 1000,\n        behaviourPenaltyThreshold: opts.scoreParams.behaviourPenaltyThreshold,\n        maxMeshMessageDeliveriesWindowSec: maxMeshMessageDeliveriesWindowMs / 1000\n      })\n\n      metrics.mcacheSize.addCollect(() => this.onScrapeMetrics(metrics))\n      for (const protocol of this.multicodecs) {\n        metrics.protocolsEnabled.set({ protocol }, 1)\n      }\n\n      this.metrics = metrics\n    } else {\n      this.metrics = null\n    }\n\n    this.gossipTracer = new IWantTracer(this.opts.gossipsubIWantFollowupMs, this.msgIdToStrFn, this.metrics)\n\n    /**\n     * libp2p\n     */\n    this.score = new PeerScore(this.opts.scoreParams, this.metrics, {\n      scoreCacheValidityMs: opts.heartbeatInterval\n    })\n\n    this.maxInboundStreams = options.maxInboundStreams\n    this.maxOutboundStreams = options.maxOutboundStreams\n\n    this.allowedTopics = opts.allowedTopics ? new Set(opts.allowedTopics) : null\n  }\n\n  getPeers(): PeerId[] {\n    return [...this.peers.keys()].map((str) => peerIdFromString(str))\n  }\n\n  isStarted(): boolean {\n    return this.status.code === GossipStatusCode.started\n  }\n\n  // LIFECYCLE METHODS\n\n  /**\n   * Mounts the gossipsub protocol onto the libp2p node and sends our\n   * our subscriptions to every peer connected\n   */\n  async start(): Promise<void> {\n    // From pubsub\n    if (this.isStarted()) {\n      return\n    }\n\n    this.log('starting')\n\n    this.publishConfig = await getPublishConfigFromPeerId(this.globalSignaturePolicy, this.components.peerId)\n\n    // Create the outbound inflight queue\n    // This ensures that outbound stream creation happens sequentially\n    this.outboundInflightQueue = pushable({ objectMode: true })\n    pipe(this.outboundInflightQueue, async (source) => {\n      for await (const { peerId, connection } of source) {\n        await this.createOutboundStream(peerId, connection)\n      }\n    }).catch((e) => this.log.error('outbound inflight queue error', e))\n\n    // set direct peer addresses in the address book\n    await Promise.all(\n      this.opts.directPeers.map(async (p) => {\n        await this.components.peerStore.merge(p.id, {\n          multiaddrs: p.addrs\n        })\n      })\n    )\n\n    const registrar = this.components.registrar\n    // Incoming streams\n    // Called after a peer dials us\n    await Promise.all(\n      this.multicodecs.map((multicodec) =>\n        registrar.handle(multicodec, this.onIncomingStream.bind(this), {\n          maxInboundStreams: this.maxInboundStreams,\n          maxOutboundStreams: this.maxOutboundStreams\n        })\n      )\n    )\n\n    // # How does Gossipsub interact with libp2p? Rough guide from Mar 2022\n    //\n    // ## Setup:\n    // Gossipsub requests libp2p to callback, TBD\n    //\n    // `this.libp2p.handle()` registers a handler for `/meshsub/1.1.0` and other Gossipsub protocols\n    // The handler callback is registered in libp2p Upgrader.protocols map.\n    //\n    // Upgrader receives an inbound connection from some transport and (`Upgrader.upgradeInbound`):\n    // - Adds encryption (NOISE in our case)\n    // - Multiplex stream\n    // - Create a muxer and register that for each new stream call Upgrader.protocols handler\n    //\n    // ## Topology\n    // - new instance of Topology (unlinked to libp2p) with handlers\n    // - registar.register(topology)\n\n    // register protocol with topology\n    // Topology callbacks called on connection manager changes\n    const topology = {\n      onConnect: this.onPeerConnected.bind(this),\n      onDisconnect: this.onPeerDisconnected.bind(this)\n    }\n    const registrarTopologyIds = await Promise.all(\n      this.multicodecs.map((multicodec) => registrar.register(multicodec, topology))\n    )\n\n    // Schedule to start heartbeat after `GossipsubHeartbeatInitialDelay`\n    const heartbeatTimeout = setTimeout(this.runHeartbeat, constants.GossipsubHeartbeatInitialDelay)\n    // Then, run heartbeat every `heartbeatInterval` offset by `GossipsubHeartbeatInitialDelay`\n\n    this.status = {\n      code: GossipStatusCode.started,\n      registrarTopologyIds,\n      heartbeatTimeout: heartbeatTimeout,\n      hearbeatStartMs: Date.now() + constants.GossipsubHeartbeatInitialDelay\n    }\n\n    this.score.start()\n    // connect to direct peers\n    this.directPeerInitial = setTimeout(() => {\n      Promise.resolve()\n        .then(async () => {\n          await Promise.all(Array.from(this.direct).map(async (id) => await this.connect(id)))\n        })\n        .catch((err) => {\n          this.log(err)\n        })\n    }, constants.GossipsubDirectConnectInitialDelay)\n\n    this.log('started')\n  }\n\n  /**\n   * Unmounts the gossipsub protocol and shuts down every connection\n   */\n  async stop(): Promise<void> {\n    this.log('stopping')\n    // From pubsub\n\n    if (this.status.code !== GossipStatusCode.started) {\n      return\n    }\n\n    const { registrarTopologyIds } = this.status\n    this.status = { code: GossipStatusCode.stopped }\n\n    // unregister protocol and handlers\n    const registrar = this.components.registrar\n    await Promise.all(this.multicodecs.map((multicodec) => registrar.unhandle(multicodec)))\n    registrarTopologyIds.forEach((id) => registrar.unregister(id))\n\n    this.outboundInflightQueue.end()\n\n    for (const outboundStream of this.streamsOutbound.values()) {\n      outboundStream.close()\n    }\n    this.streamsOutbound.clear()\n\n    for (const inboundStream of this.streamsInbound.values()) {\n      inboundStream.close()\n    }\n    this.streamsInbound.clear()\n\n    this.peers.clear()\n    this.subscriptions.clear()\n\n    // Gossipsub\n\n    if (this.heartbeatTimer) {\n      this.heartbeatTimer.cancel()\n      this.heartbeatTimer = null\n    }\n\n    this.score.stop()\n\n    this.mesh.clear()\n    this.fanout.clear()\n    this.fanoutLastpub.clear()\n    this.gossip.clear()\n    this.control.clear()\n    this.peerhave.clear()\n    this.iasked.clear()\n    this.backoff.clear()\n    this.outbound.clear()\n    this.gossipTracer.clear()\n    this.seenCache.clear()\n    if (this.fastMsgIdCache) this.fastMsgIdCache.clear()\n    if (this.directPeerInitial) clearTimeout(this.directPeerInitial)\n\n    this.log('stopped')\n  }\n\n  /** FOR DEBUG ONLY - Dump peer stats for all peers. Data is cloned, safe to mutate */\n  dumpPeerScoreStats(): PeerScoreStatsDump {\n    return this.score.dumpPeerScoreStats()\n  }\n\n  /**\n   * On an inbound stream opened\n   */\n  private onIncomingStream({ stream, connection }: IncomingStreamData) {\n    if (!this.isStarted()) {\n      return\n    }\n\n    const peerId = connection.remotePeer\n    // add peer to router\n    this.addPeer(peerId, connection.direction, connection.remoteAddr)\n    // create inbound stream\n    this.createInboundStream(peerId, stream)\n    // attempt to create outbound stream\n    this.outboundInflightQueue.push({ peerId, connection })\n  }\n\n  /**\n   * Registrar notifies an established connection with pubsub protocol\n   */\n  private onPeerConnected(peerId: PeerId, connection: Connection): void {\n    this.metrics?.newConnectionCount.inc({ status: connection.status })\n    // libp2p may emit a closed connection and never issue peer:disconnect event\n    // see https://github.com/ChainSafe/js-libp2p-gossipsub/issues/398\n    if (!this.isStarted() || connection.status !== 'open') {\n      return\n    }\n\n    this.addPeer(peerId, connection.direction, connection.remoteAddr)\n    this.outboundInflightQueue.push({ peerId, connection })\n  }\n\n  /**\n   * Registrar notifies a closing connection with pubsub protocol\n   */\n  private onPeerDisconnected(peerId: PeerId): void {\n    this.log('connection ended %p', peerId)\n    this.removePeer(peerId)\n  }\n\n  private async createOutboundStream(peerId: PeerId, connection: Connection): Promise<void> {\n    if (!this.isStarted()) {\n      return\n    }\n\n    const id = peerId.toString()\n\n    if (!this.peers.has(id)) {\n      return\n    }\n\n    // TODO make this behavior more robust\n    // This behavior is different than for inbound streams\n    // If an outbound stream already exists, don't create a new stream\n    if (this.streamsOutbound.has(id)) {\n      return\n    }\n\n    try {\n      const stream = new OutboundStream(\n        await connection.newStream(this.multicodecs),\n        (e) => this.log.error('outbound pipe error', e),\n        { maxBufferSize: this.opts.maxOutboundBufferSize }\n      )\n\n      this.log('create outbound stream %p', peerId)\n\n      this.streamsOutbound.set(id, stream)\n\n      const protocol = stream.protocol\n      if (protocol === constants.FloodsubID) {\n        this.floodsubPeers.add(id)\n      }\n      this.metrics?.peersPerProtocol.inc({ protocol }, 1)\n\n      // Immediately send own subscriptions via the newly attached stream\n      if (this.subscriptions.size > 0) {\n        this.log('send subscriptions to', id)\n        this.sendSubscriptions(id, Array.from(this.subscriptions), true)\n      }\n    } catch (e) {\n      this.log.error('createOutboundStream error', e)\n    }\n  }\n\n  private async createInboundStream(peerId: PeerId, stream: Stream): Promise<void> {\n    if (!this.isStarted()) {\n      return\n    }\n\n    const id = peerId.toString()\n\n    if (!this.peers.has(id)) {\n      return\n    }\n\n    // TODO make this behavior more robust\n    // This behavior is different than for outbound streams\n    // If a peer initiates a new inbound connection\n    // we assume that one is the new canonical inbound stream\n    const priorInboundStream = this.streamsInbound.get(id)\n    if (priorInboundStream !== undefined) {\n      this.log('replacing existing inbound steam %s', id)\n      priorInboundStream.close()\n    }\n\n    this.log('create inbound stream %s', id)\n\n    const inboundStream = new InboundStream(stream, { maxDataLength: this.opts.maxInboundDataLength })\n    this.streamsInbound.set(id, inboundStream)\n\n    this.pipePeerReadStream(peerId, inboundStream.source).catch((err) => this.log(err))\n  }\n\n  /**\n   * Add a peer to the router\n   */\n  private addPeer(peerId: PeerId, direction: ConnectionDirection, addr: Multiaddr): void {\n    const id = peerId.toString()\n\n    if (!this.peers.has(id)) {\n      this.log('new peer %p', peerId)\n\n      this.peers.add(id)\n\n      // Add to peer scoring\n      this.score.addPeer(id)\n      const currentIP = multiaddrToIPStr(addr)\n      if (currentIP !== null) {\n        this.score.addIP(id, currentIP)\n      } else {\n        this.log('Added peer has no IP in current address %s %s', id, addr.toString())\n      }\n\n      // track the connection direction. Don't allow to unset outbound\n      if (!this.outbound.has(id)) {\n        this.outbound.set(id, direction === 'outbound')\n      }\n    }\n  }\n\n  /**\n   * Removes a peer from the router\n   */\n  private removePeer(peerId: PeerId): void {\n    const id = peerId.toString()\n\n    if (!this.peers.has(id)) {\n      return\n    }\n\n    // delete peer\n    this.log('delete peer %p', peerId)\n    this.peers.delete(id)\n\n    const outboundStream = this.streamsOutbound.get(id)\n    const inboundStream = this.streamsInbound.get(id)\n\n    if (outboundStream) {\n      this.metrics?.peersPerProtocol.inc({ protocol: outboundStream.protocol }, -1)\n    }\n\n    // close streams\n    outboundStream?.close()\n    inboundStream?.close()\n\n    // remove streams\n    this.streamsOutbound.delete(id)\n    this.streamsInbound.delete(id)\n\n    // remove peer from topics map\n    for (const peers of this.topics.values()) {\n      peers.delete(id)\n    }\n\n    // Remove this peer from the mesh\n    for (const [topicStr, peers] of this.mesh) {\n      if (peers.delete(id) === true) {\n        this.metrics?.onRemoveFromMesh(topicStr, ChurnReason.Dc, 1)\n      }\n    }\n\n    // Remove this peer from the fanout\n    for (const peers of this.fanout.values()) {\n      peers.delete(id)\n    }\n\n    // Remove from floodsubPeers\n    this.floodsubPeers.delete(id)\n    // Remove from gossip mapping\n    this.gossip.delete(id)\n    // Remove from control mapping\n    this.control.delete(id)\n    // Remove from backoff mapping\n    this.outbound.delete(id)\n\n    // Remove from peer scoring\n    this.score.removePeer(id)\n\n    this.acceptFromWhitelist.delete(id)\n  }\n\n  // API METHODS\n\n  get started(): boolean {\n    return this.status.code === GossipStatusCode.started\n  }\n\n  /**\n   * Get a the peer-ids in a topic mesh\n   */\n  getMeshPeers(topic: TopicStr): PeerIdStr[] {\n    const peersInTopic = this.mesh.get(topic)\n    return peersInTopic ? Array.from(peersInTopic) : []\n  }\n\n  /**\n   * Get a list of the peer-ids that are subscribed to one topic.\n   */\n  getSubscribers(topic: TopicStr): PeerId[] {\n    const peersInTopic = this.topics.get(topic)\n    return (peersInTopic ? Array.from(peersInTopic) : []).map((str) => peerIdFromString(str))\n  }\n\n  /**\n   * Get the list of topics which the peer is subscribed to.\n   */\n  getTopics(): TopicStr[] {\n    return Array.from(this.subscriptions)\n  }\n\n  // TODO: Reviewing Pubsub API\n\n  // MESSAGE METHODS\n\n  /**\n   * Responsible for processing each RPC message received by other peers.\n   */\n  private async pipePeerReadStream(peerId: PeerId, stream: AsyncIterable<Uint8ArrayList>): Promise<void> {\n    try {\n      await pipe(stream, async (source) => {\n        for await (const data of source) {\n          try {\n            // TODO: Check max gossip message size, before decodeRpc()\n            const rpcBytes = data.subarray()\n            // Note: This function may throw, it must be wrapped in a try {} catch {} to prevent closing the stream.\n            // TODO: What should we do if the entire RPC is invalid?\n            const rpc = decodeRpc(rpcBytes, this.decodeRpcLimits)\n\n            this.metrics?.onRpcRecv(rpc, rpcBytes.length)\n\n            // Since processRpc may be overridden entirely in unsafe ways,\n            // the simplest/safest option here is to wrap in a function and capture all errors\n            // to prevent a top-level unhandled exception\n            // This processing of rpc messages should happen without awaiting full validation/execution of prior messages\n            if (this.opts.awaitRpcHandler) {\n              try {\n                await this.handleReceivedRpc(peerId, rpc)\n              } catch (err) {\n                this.metrics?.onRpcRecvError()\n                this.log(err)\n              }\n            } else {\n              this.handleReceivedRpc(peerId, rpc).catch((err) => {\n                this.metrics?.onRpcRecvError()\n                this.log(err)\n              })\n            }\n          } catch (e) {\n            this.metrics?.onRpcDataError()\n            this.log(e as Error)\n          }\n        }\n      })\n    } catch (err) {\n      this.metrics?.onPeerReadStreamError()\n      this.handlePeerReadStreamError(err as Error, peerId)\n    }\n  }\n\n  /**\n   * Handle error when read stream pipe throws, less of the functional use but more\n   * to for testing purposes to spy on the error handling\n   * */\n  private handlePeerReadStreamError(err: Error, peerId: PeerId): void {\n    this.log.error(err)\n    this.onPeerDisconnected(peerId)\n  }\n\n  /**\n   * Handles an rpc request from a peer\n   */\n  public async handleReceivedRpc(from: PeerId, rpc: IRPC): Promise<void> {\n    // Check if peer is graylisted in which case we ignore the event\n    if (!this.acceptFrom(from.toString())) {\n      this.log('received message from unacceptable peer %p', from)\n      this.metrics?.rpcRecvNotAccepted.inc()\n      return\n    }\n\n    const subscriptions = rpc.subscriptions ? rpc.subscriptions.length : 0\n    const messages = rpc.messages ? rpc.messages.length : 0\n    let ihave = 0\n    let iwant = 0\n    let graft = 0\n    let prune = 0\n    if (rpc.control) {\n      if (rpc.control.ihave) ihave = rpc.control.ihave.length\n      if (rpc.control.iwant) iwant = rpc.control.iwant.length\n      if (rpc.control.graft) graft = rpc.control.graft.length\n      if (rpc.control.prune) prune = rpc.control.prune.length\n    }\n    this.log(\n      `rpc.from ${from.toString()} subscriptions ${subscriptions} messages ${messages} ihave ${ihave} iwant ${iwant} graft ${graft} prune ${prune}`\n    )\n\n    // Handle received subscriptions\n    if (rpc.subscriptions && rpc.subscriptions.length > 0) {\n      // update peer subscriptions\n\n      const subscriptions: { topic: TopicStr; subscribe: boolean }[] = []\n\n      rpc.subscriptions.forEach((subOpt) => {\n        const topic = subOpt.topic\n        const subscribe = subOpt.subscribe === true\n\n        if (topic != null) {\n          if (this.allowedTopics && !this.allowedTopics.has(topic)) {\n            // Not allowed: subscription data-structures are not bounded by topic count\n            // TODO: Should apply behaviour penalties?\n            return\n          }\n\n          this.handleReceivedSubscription(from, topic, subscribe)\n\n          subscriptions.push({ topic, subscribe })\n        }\n      })\n\n      this.dispatchEvent(\n        new CustomEvent<SubscriptionChangeData>('subscription-change', {\n          detail: { peerId: from, subscriptions }\n        })\n      )\n    }\n\n    // Handle messages\n    // TODO: (up to limit)\n    if (rpc.messages) {\n      for (const message of rpc.messages) {\n        if (this.allowedTopics && !this.allowedTopics.has(message.topic)) {\n          // Not allowed: message cache data-structures are not bounded by topic count\n          // TODO: Should apply behaviour penalties?\n          continue\n        }\n\n        const handleReceivedMessagePromise = this.handleReceivedMessage(from, message)\n          // Should never throw, but handle just in case\n          .catch((err) => {\n            this.metrics?.onMsgRecvError(message.topic)\n            this.log(err)\n          })\n\n        if (this.opts.awaitRpcMessageHandler) {\n          await handleReceivedMessagePromise\n        }\n      }\n    }\n\n    // Handle control messages\n    if (rpc.control) {\n      await this.handleControlMessage(from.toString(), rpc.control)\n    }\n  }\n\n  /**\n   * Handles a subscription change from a peer\n   */\n  private handleReceivedSubscription(from: PeerId, topic: TopicStr, subscribe: boolean): void {\n    this.log('subscription update from %p topic %s', from, topic)\n\n    let topicSet = this.topics.get(topic)\n    if (topicSet == null) {\n      topicSet = new Set()\n      this.topics.set(topic, topicSet)\n    }\n\n    if (subscribe) {\n      // subscribe peer to new topic\n      topicSet.add(from.toString())\n    } else {\n      // unsubscribe from existing topic\n      topicSet.delete(from.toString())\n    }\n\n    // TODO: rust-libp2p has A LOT more logic here\n  }\n\n  /**\n   * Handles a newly received message from an RPC.\n   * May forward to all peers in the mesh.\n   */\n  private async handleReceivedMessage(from: PeerId, rpcMsg: RPC.IMessage): Promise<void> {\n    this.metrics?.onMsgRecvPreValidation(rpcMsg.topic)\n\n    const validationResult = await this.validateReceivedMessage(from, rpcMsg)\n\n    this.metrics?.onPrevalidationResult(rpcMsg.topic, validationResult.code)\n\n    switch (validationResult.code) {\n      case MessageStatus.duplicate:\n        // Report the duplicate\n        this.score.duplicateMessage(from.toString(), validationResult.msgIdStr, rpcMsg.topic)\n        // due to the collision of fastMsgIdFn, 2 different messages may end up the same fastMsgId\n        // so we need to also mark the duplicate message as delivered or the promise is not resolved\n        // and peer gets penalized. See https://github.com/ChainSafe/js-libp2p-gossipsub/pull/385\n        this.gossipTracer.deliverMessage(validationResult.msgIdStr, true)\n        this.mcache.observeDuplicate(validationResult.msgIdStr, from.toString())\n        return\n\n      case MessageStatus.invalid:\n        // invalid messages received\n        // metrics.register_invalid_message(&raw_message.topic)\n        // Tell peer_score about reject\n        // Reject the original source, and any duplicates we've seen from other peers.\n        if (validationResult.msgIdStr) {\n          const msgIdStr = validationResult.msgIdStr\n          this.score.rejectMessage(from.toString(), msgIdStr, rpcMsg.topic, validationResult.reason)\n          this.gossipTracer.rejectMessage(msgIdStr, validationResult.reason)\n        } else {\n          this.score.rejectInvalidMessage(from.toString(), rpcMsg.topic)\n        }\n\n        this.metrics?.onMsgRecvInvalid(rpcMsg.topic, validationResult)\n        return\n\n      case MessageStatus.valid:\n        // Tells score that message arrived (but is maybe not fully validated yet).\n        // Consider the message as delivered for gossip promises.\n        this.score.validateMessage(validationResult.messageId.msgIdStr)\n        this.gossipTracer.deliverMessage(validationResult.messageId.msgIdStr)\n\n        // Add the message to our memcache\n        // if no validation is required, mark the message as validated\n        this.mcache.put(validationResult.messageId, rpcMsg, !this.opts.asyncValidation)\n\n        // Dispatch the message to the user if we are subscribed to the topic\n        if (this.subscriptions.has(rpcMsg.topic)) {\n          const isFromSelf = this.components.peerId.equals(from)\n\n          if (!isFromSelf || this.opts.emitSelf) {\n            super.dispatchEvent(\n              new CustomEvent<GossipsubMessage>('gossipsub:message', {\n                detail: {\n                  propagationSource: from,\n                  msgId: validationResult.messageId.msgIdStr,\n                  msg: validationResult.msg\n                }\n              })\n            )\n            // TODO: Add option to switch between emit per topic or all messages in one\n            super.dispatchEvent(new CustomEvent<Message>('message', { detail: validationResult.msg }))\n          }\n        }\n\n        // Forward the message to mesh peers, if no validation is required\n        // If asyncValidation is ON, expect the app layer to call reportMessageValidationResult(), then forward\n        if (!this.opts.asyncValidation) {\n          // TODO: in rust-libp2p\n          // .forward_msg(&msg_id, raw_message, Some(propagation_source))\n          this.forwardMessage(validationResult.messageId.msgIdStr, rpcMsg, from.toString())\n        }\n    }\n  }\n\n  /**\n   * Handles a newly received message from an RPC.\n   * May forward to all peers in the mesh.\n   */\n  private async validateReceivedMessage(\n    propagationSource: PeerId,\n    rpcMsg: RPC.IMessage\n  ): Promise<ReceivedMessageResult> {\n    // Fast message ID stuff\n    const fastMsgIdStr = this.fastMsgIdFn?.(rpcMsg)\n    const msgIdCached = fastMsgIdStr !== undefined ? this.fastMsgIdCache?.get(fastMsgIdStr) : undefined\n\n    if (msgIdCached) {\n      // This message has been seen previously. Ignore it\n      return { code: MessageStatus.duplicate, msgIdStr: msgIdCached }\n    }\n\n    // Perform basic validation on message and convert to RawGossipsubMessage for fastMsgIdFn()\n    const validationResult = await validateToRawMessage(this.globalSignaturePolicy, rpcMsg)\n\n    if (!validationResult.valid) {\n      return { code: MessageStatus.invalid, reason: RejectReason.Error, error: validationResult.error }\n    }\n\n    const msg = validationResult.message\n\n    // Try and perform the data transform to the message. If it fails, consider it invalid.\n    try {\n      if (this.dataTransform) {\n        msg.data = this.dataTransform.inboundTransform(rpcMsg.topic, msg.data)\n      }\n    } catch (e) {\n      this.log('Invalid message, transform failed', e)\n      return { code: MessageStatus.invalid, reason: RejectReason.Error, error: ValidateError.TransformFailed }\n    }\n\n    // TODO: Check if message is from a blacklisted source or propagation origin\n    // - Reject any message from a blacklisted peer\n    // - Also reject any message that originated from a blacklisted peer\n    // - reject messages claiming to be from ourselves but not locally published\n\n    // Calculate the message id on the transformed data.\n    const msgId = await this.msgIdFn(msg)\n    const msgIdStr = this.msgIdToStrFn(msgId)\n    const messageId = { msgId, msgIdStr }\n\n    // Add the message to the duplicate caches\n    if (fastMsgIdStr !== undefined && this.fastMsgIdCache) {\n      const collision = this.fastMsgIdCache.put(fastMsgIdStr, msgIdStr)\n      if (collision) {\n        this.metrics?.fastMsgIdCacheCollision.inc()\n      }\n    }\n\n    if (this.seenCache.has(msgIdStr)) {\n      return { code: MessageStatus.duplicate, msgIdStr }\n    } else {\n      this.seenCache.put(msgIdStr)\n    }\n\n    // (Optional) Provide custom validation here with dynamic validators per topic\n    // NOTE: This custom topicValidator() must resolve fast (< 100ms) to allow scores\n    // to not penalize peers for long validation times.\n    const topicValidator = this.topicValidators.get(rpcMsg.topic)\n    if (topicValidator != null) {\n      let acceptance: TopicValidatorResult\n      // Use try {} catch {} in case topicValidator() is synchronous\n      try {\n        acceptance = await topicValidator(propagationSource, msg)\n      } catch (e) {\n        const errCode = (e as { code: string }).code\n        if (errCode === constants.ERR_TOPIC_VALIDATOR_IGNORE) acceptance = TopicValidatorResult.Ignore\n        if (errCode === constants.ERR_TOPIC_VALIDATOR_REJECT) acceptance = TopicValidatorResult.Reject\n        else acceptance = TopicValidatorResult.Ignore\n      }\n\n      if (acceptance !== TopicValidatorResult.Accept) {\n        return { code: MessageStatus.invalid, reason: rejectReasonFromAcceptance(acceptance), msgIdStr }\n      }\n    }\n\n    return { code: MessageStatus.valid, messageId, msg }\n  }\n\n  /**\n   * Return score of a peer.\n   */\n  getScore(peerId: PeerIdStr): number {\n    return this.score.score(peerId)\n  }\n\n  /**\n   * Send an rpc object to a peer with subscriptions\n   */\n  private sendSubscriptions(toPeer: PeerIdStr, topics: string[], subscribe: boolean): void {\n    this.sendRpc(toPeer, {\n      subscriptions: topics.map((topic) => ({ topic, subscribe }))\n    })\n  }\n\n  /**\n   * Handles an rpc control message from a peer\n   */\n  private async handleControlMessage(id: PeerIdStr, controlMsg: RPC.IControlMessage): Promise<void> {\n    if (controlMsg === undefined) {\n      return\n    }\n\n    const iwant = controlMsg.ihave ? this.handleIHave(id, controlMsg.ihave) : []\n    const ihave = controlMsg.iwant ? this.handleIWant(id, controlMsg.iwant) : []\n    const prune = controlMsg.graft ? await this.handleGraft(id, controlMsg.graft) : []\n    controlMsg.prune && (await this.handlePrune(id, controlMsg.prune))\n\n    if (!iwant.length && !ihave.length && !prune.length) {\n      return\n    }\n\n    const sent = this.sendRpc(id, { messages: ihave, control: { iwant, prune } })\n    const iwantMessageIds = iwant[0]?.messageIDs\n    if (iwantMessageIds) {\n      if (sent) {\n        this.gossipTracer.addPromise(id, iwantMessageIds)\n      } else {\n        this.metrics?.iwantPromiseUntracked.inc(1)\n      }\n    }\n  }\n\n  /**\n   * Whether to accept a message from a peer\n   */\n  public acceptFrom(id: PeerIdStr): boolean {\n    if (this.direct.has(id)) {\n      return true\n    }\n\n    const now = Date.now()\n    const entry = this.acceptFromWhitelist.get(id)\n\n    if (entry && entry.messagesAccepted < ACCEPT_FROM_WHITELIST_MAX_MESSAGES && entry.acceptUntil >= now) {\n      entry.messagesAccepted += 1\n      return true\n    }\n\n    const score = this.score.score(id)\n    if (score >= ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE) {\n      // peer is unlikely to be able to drop its score to `graylistThreshold`\n      // after 128 messages or 1s\n      this.acceptFromWhitelist.set(id, {\n        messagesAccepted: 0,\n        acceptUntil: now + ACCEPT_FROM_WHITELIST_DURATION_MS\n      })\n    } else {\n      this.acceptFromWhitelist.delete(id)\n    }\n\n    return score >= this.opts.scoreThresholds.graylistThreshold\n  }\n\n  /**\n   * Handles IHAVE messages\n   */\n  private handleIHave(id: PeerIdStr, ihave: RPC.IControlIHave[]): RPC.IControlIWant[] {\n    if (!ihave.length) {\n      return []\n    }\n\n    // we ignore IHAVE gossip from any peer whose score is below the gossips threshold\n    const score = this.score.score(id)\n    if (score < this.opts.scoreThresholds.gossipThreshold) {\n      this.log('IHAVE: ignoring peer %s with score below threshold [ score = %d ]', id, score)\n      this.metrics?.ihaveRcvIgnored.inc({ reason: IHaveIgnoreReason.LowScore })\n      return []\n    }\n\n    // IHAVE flood protection\n    const peerhave = (this.peerhave.get(id) ?? 0) + 1\n    this.peerhave.set(id, peerhave)\n    if (peerhave > constants.GossipsubMaxIHaveMessages) {\n      this.log(\n        'IHAVE: peer %s has advertised too many times (%d) within this heartbeat interval; ignoring',\n        id,\n        peerhave\n      )\n      this.metrics?.ihaveRcvIgnored.inc({ reason: IHaveIgnoreReason.MaxIhave })\n      return []\n    }\n\n    const iasked = this.iasked.get(id) ?? 0\n    if (iasked >= constants.GossipsubMaxIHaveLength) {\n      this.log('IHAVE: peer %s has already advertised too many messages (%d); ignoring', id, iasked)\n      this.metrics?.ihaveRcvIgnored.inc({ reason: IHaveIgnoreReason.MaxIasked })\n      return []\n    }\n\n    // string msgId => msgId\n    const iwant = new Map<MsgIdStr, Uint8Array>()\n\n    ihave.forEach(({ topicID, messageIDs }) => {\n      if (!topicID || !messageIDs || !this.mesh.has(topicID)) {\n        return\n      }\n\n      let idonthave = 0\n\n      messageIDs.forEach((msgId) => {\n        const msgIdStr = this.msgIdToStrFn(msgId)\n        if (!this.seenCache.has(msgIdStr)) {\n          iwant.set(msgIdStr, msgId)\n          idonthave++\n        }\n      })\n\n      this.metrics?.onIhaveRcv(topicID, messageIDs.length, idonthave)\n    })\n\n    if (!iwant.size) {\n      return []\n    }\n\n    let iask = iwant.size\n    if (iask + iasked > constants.GossipsubMaxIHaveLength) {\n      iask = constants.GossipsubMaxIHaveLength - iasked\n    }\n\n    this.log('IHAVE: Asking for %d out of %d messages from %s', iask, iwant.size, id)\n\n    let iwantList = Array.from(iwant.values())\n    // ask in random order\n    shuffle(iwantList)\n\n    // truncate to the messages we are actually asking for and update the iasked counter\n    iwantList = iwantList.slice(0, iask)\n    this.iasked.set(id, iasked + iask)\n\n    // do not add gossipTracer promise here until a successful sendRpc()\n\n    return [\n      {\n        messageIDs: iwantList\n      }\n    ]\n  }\n\n  /**\n   * Handles IWANT messages\n   * Returns messages to send back to peer\n   */\n  private handleIWant(id: PeerIdStr, iwant: RPC.IControlIWant[]): RPC.IMessage[] {\n    if (!iwant.length) {\n      return []\n    }\n\n    // we don't respond to IWANT requests from any per whose score is below the gossip threshold\n    const score = this.score.score(id)\n    if (score < this.opts.scoreThresholds.gossipThreshold) {\n      this.log('IWANT: ignoring peer %s with score below threshold [score = %d]', id, score)\n      return []\n    }\n\n    const ihave = new Map<MsgIdStr, RPC.IMessage>()\n    const iwantByTopic = new Map<TopicStr, number>()\n    let iwantDonthave = 0\n\n    iwant.forEach(({ messageIDs }) => {\n      messageIDs &&\n        messageIDs.forEach((msgId) => {\n          const msgIdStr = this.msgIdToStrFn(msgId)\n          const entry = this.mcache.getWithIWantCount(msgIdStr, id)\n          if (entry == null) {\n            iwantDonthave++\n            return\n          }\n\n          iwantByTopic.set(entry.msg.topic, 1 + (iwantByTopic.get(entry.msg.topic) ?? 0))\n\n          if (entry.count > constants.GossipsubGossipRetransmission) {\n            this.log('IWANT: Peer %s has asked for message %s too many times: ignoring request', id, msgId)\n            return\n          }\n\n          ihave.set(msgIdStr, entry.msg)\n        })\n    })\n\n    this.metrics?.onIwantRcv(iwantByTopic, iwantDonthave)\n\n    if (!ihave.size) {\n      this.log('IWANT: Could not provide any wanted messages to %s', id)\n      return []\n    }\n\n    this.log('IWANT: Sending %d messages to %s', ihave.size, id)\n\n    return Array.from(ihave.values())\n  }\n\n  /**\n   * Handles Graft messages\n   */\n  private async handleGraft(id: PeerIdStr, graft: RPC.IControlGraft[]): Promise<RPC.IControlPrune[]> {\n    const prune: TopicStr[] = []\n    const score = this.score.score(id)\n    const now = Date.now()\n    let doPX = this.opts.doPX\n\n    graft.forEach(({ topicID }) => {\n      if (!topicID) {\n        return\n      }\n      const peersInMesh = this.mesh.get(topicID)\n      if (!peersInMesh) {\n        // don't do PX when there is an unknown topic to avoid leaking our peers\n        doPX = false\n        // spam hardening: ignore GRAFTs for unknown topics\n        return\n      }\n\n      // check if peer is already in the mesh; if so do nothing\n      if (peersInMesh.has(id)) {\n        return\n      }\n\n      // we don't GRAFT to/from direct peers; complain loudly if this happens\n      if (this.direct.has(id)) {\n        this.log('GRAFT: ignoring request from direct peer %s', id)\n        // this is possibly a bug from a non-reciprical configuration; send a PRUNE\n        prune.push(topicID)\n        // but don't px\n        doPX = false\n        return\n      }\n\n      // make sure we are not backing off that peer\n      const expire = this.backoff.get(topicID)?.get(id)\n      if (typeof expire === 'number' && now < expire) {\n        this.log('GRAFT: ignoring backed off peer %s', id)\n        // add behavioral penalty\n        this.score.addPenalty(id, 1, ScorePenalty.GraftBackoff)\n        // no PX\n        doPX = false\n        // check the flood cutoff -- is the GRAFT coming too fast?\n        const floodCutoff = expire + this.opts.graftFloodThreshold - this.opts.pruneBackoff\n        if (now < floodCutoff) {\n          // extra penalty\n          this.score.addPenalty(id, 1, ScorePenalty.GraftBackoff)\n        }\n        // refresh the backoff\n        this.addBackoff(id, topicID)\n        prune.push(topicID)\n        return\n      }\n\n      // check the score\n      if (score < 0) {\n        // we don't GRAFT peers with negative score\n        this.log('GRAFT: ignoring peer %s with negative score: score=%d, topic=%s', id, score, topicID)\n        // we do send them PRUNE however, because it's a matter of protocol correctness\n        prune.push(topicID)\n        // but we won't PX to them\n        doPX = false\n        // add/refresh backoff so that we don't reGRAFT too early even if the score decays\n        this.addBackoff(id, topicID)\n        return\n      }\n\n      // check the number of mesh peers; if it is at (or over) Dhi, we only accept grafts\n      // from peers with outbound connections; this is a defensive check to restrict potential\n      // mesh takeover attacks combined with love bombing\n      if (peersInMesh.size >= this.opts.Dhi && !this.outbound.get(id)) {\n        prune.push(topicID)\n        this.addBackoff(id, topicID)\n        return\n      }\n\n      this.log('GRAFT: Add mesh link from %s in %s', id, topicID)\n      this.score.graft(id, topicID)\n      peersInMesh.add(id)\n\n      this.metrics?.onAddToMesh(topicID, InclusionReason.Subscribed, 1)\n    })\n\n    if (!prune.length) {\n      return []\n    }\n\n    const onUnsubscribe = false\n    return await Promise.all(prune.map((topic) => this.makePrune(id, topic, doPX, onUnsubscribe)))\n  }\n\n  /**\n   * Handles Prune messages\n   */\n  private async handlePrune(id: PeerIdStr, prune: RPC.IControlPrune[]): Promise<void> {\n    const score = this.score.score(id)\n\n    for (const { topicID, backoff, peers } of prune) {\n      if (topicID == null) {\n        continue\n      }\n\n      const peersInMesh = this.mesh.get(topicID)\n      if (!peersInMesh) {\n        return\n      }\n\n      this.log('PRUNE: Remove mesh link to %s in %s', id, topicID)\n      this.score.prune(id, topicID)\n      if (peersInMesh.has(id)) {\n        peersInMesh.delete(id)\n        this.metrics?.onRemoveFromMesh(topicID, ChurnReason.Prune, 1)\n      }\n\n      // is there a backoff specified by the peer? if so obey it\n      if (typeof backoff === 'number' && backoff > 0) {\n        this.doAddBackoff(id, topicID, backoff * 1000)\n      } else {\n        this.addBackoff(id, topicID)\n      }\n\n      // PX\n      if (peers && peers.length) {\n        // we ignore PX from peers with insufficient scores\n        if (score < this.opts.scoreThresholds.acceptPXThreshold) {\n          this.log(\n            'PRUNE: ignoring PX from peer %s with insufficient score [score = %d, topic = %s]',\n            id,\n            score,\n            topicID\n          )\n          continue\n        }\n        await this.pxConnect(peers)\n      }\n    }\n  }\n\n  /**\n   * Add standard backoff log for a peer in a topic\n   */\n  private addBackoff(id: PeerIdStr, topic: TopicStr): void {\n    this.doAddBackoff(id, topic, this.opts.pruneBackoff)\n  }\n\n  /**\n   * Add backoff expiry interval for a peer in a topic\n   *\n   * @param id\n   * @param topic\n   * @param intervalMs - backoff duration in milliseconds\n   */\n  private doAddBackoff(id: PeerIdStr, topic: TopicStr, intervalMs: number): void {\n    let backoff = this.backoff.get(topic)\n    if (!backoff) {\n      backoff = new Map()\n      this.backoff.set(topic, backoff)\n    }\n    const expire = Date.now() + intervalMs\n    const existingExpire = backoff.get(id) ?? 0\n    if (existingExpire < expire) {\n      backoff.set(id, expire)\n    }\n  }\n\n  /**\n   * Apply penalties from broken IHAVE/IWANT promises\n   */\n  private applyIwantPenalties(): void {\n    this.gossipTracer.getBrokenPromises().forEach((count, p) => {\n      this.log(\"peer %s didn't follow up in %d IWANT requests; adding penalty\", p, count)\n      this.score.addPenalty(p, count, ScorePenalty.BrokenPromise)\n    })\n  }\n\n  /**\n   * Clear expired backoff expiries\n   */\n  private clearBackoff(): void {\n    // we only clear once every GossipsubPruneBackoffTicks ticks to avoid iterating over the maps too much\n    if (this.heartbeatTicks % constants.GossipsubPruneBackoffTicks !== 0) {\n      return\n    }\n\n    const now = Date.now()\n    this.backoff.forEach((backoff, topic) => {\n      backoff.forEach((expire, id) => {\n        // add some slack time to the expiration, see https://github.com/libp2p/specs/pull/289\n        if (expire + BACKOFF_SLACK * this.opts.heartbeatInterval < now) {\n          backoff.delete(id)\n        }\n      })\n      if (backoff.size === 0) {\n        this.backoff.delete(topic)\n      }\n    })\n  }\n\n  /**\n   * Maybe reconnect to direct peers\n   */\n  private async directConnect(): Promise<void> {\n    const toconnect: string[] = []\n    this.direct.forEach((id) => {\n      if (!this.streamsOutbound.has(id)) {\n        toconnect.push(id)\n      }\n    })\n\n    await Promise.all(toconnect.map(async (id) => await this.connect(id)))\n  }\n\n  /**\n   * Maybe attempt connection given signed peer records\n   */\n  private async pxConnect(peers: RPC.IPeerInfo[]): Promise<void> {\n    if (peers.length > this.opts.prunePeers) {\n      shuffle(peers)\n      peers = peers.slice(0, this.opts.prunePeers)\n    }\n    const toconnect: string[] = []\n\n    await Promise.all(\n      peers.map(async (pi) => {\n        if (!pi.peerID) {\n          return\n        }\n\n        const peer = peerIdFromBytes(pi.peerID)\n        const p = peer.toString()\n\n        if (this.peers.has(p)) {\n          return\n        }\n\n        if (!pi.signedPeerRecord) {\n          toconnect.push(p)\n          return\n        }\n\n        // The peer sent us a signed record\n        // This is not a record from the peer who sent the record, but another peer who is connected with it\n        // Ensure that it is valid\n        try {\n          if (!(await this.components.peerStore.consumePeerRecord(pi.signedPeerRecord, peer))) {\n            this.log('bogus peer record obtained through px: could not add peer record to address book')\n            return\n          }\n          toconnect.push(p)\n        } catch (e) {\n          this.log('bogus peer record obtained through px: invalid signature or not a peer record')\n        }\n      })\n    )\n\n    if (!toconnect.length) {\n      return\n    }\n\n    await Promise.all(toconnect.map(async (id) => await this.connect(id)))\n  }\n\n  /**\n   * Connect to a peer using the gossipsub protocol\n   */\n  private async connect(id: PeerIdStr): Promise<void> {\n    this.log('Initiating connection with %s', id)\n    const peerId = peerIdFromString(id)\n    const connection = await this.components.connectionManager.openConnection(peerId)\n    for (const multicodec of this.multicodecs) {\n      for (const topology of this.components.registrar.getTopologies(multicodec)) {\n        topology.onConnect?.(peerId, connection)\n      }\n    }\n  }\n\n  /**\n   * Subscribes to a topic\n   */\n  subscribe(topic: TopicStr): void {\n    if (this.status.code !== GossipStatusCode.started) {\n      throw new Error('Pubsub has not started')\n    }\n\n    if (!this.subscriptions.has(topic)) {\n      this.subscriptions.add(topic)\n\n      for (const peerId of this.peers.keys()) {\n        this.sendSubscriptions(peerId, [topic], true)\n      }\n    }\n\n    this.join(topic)\n  }\n\n  /**\n   * Unsubscribe to a topic\n   */\n  unsubscribe(topic: TopicStr): void {\n    if (this.status.code !== GossipStatusCode.started) {\n      throw new Error('Pubsub is not started')\n    }\n\n    const wasSubscribed = this.subscriptions.delete(topic)\n\n    this.log('unsubscribe from %s - am subscribed %s', topic, wasSubscribed)\n\n    if (wasSubscribed) {\n      for (const peerId of this.peers.keys()) {\n        this.sendSubscriptions(peerId, [topic], false)\n      }\n    }\n\n    this.leave(topic)\n  }\n\n  /**\n   * Join topic\n   */\n  private join(topic: TopicStr): void {\n    if (this.status.code !== GossipStatusCode.started) {\n      throw new Error('Gossipsub has not started')\n    }\n\n    // if we are already in the mesh, return\n    if (this.mesh.has(topic)) {\n      return\n    }\n\n    this.log('JOIN %s', topic)\n    this.metrics?.onJoin(topic)\n\n    const toAdd = new Set<PeerIdStr>()\n    const backoff = this.backoff.get(topic)\n\n    // check if we have mesh_n peers in fanout[topic] and add them to the mesh if we do,\n    // removing the fanout entry.\n    const fanoutPeers = this.fanout.get(topic)\n    if (fanoutPeers) {\n      // Remove fanout entry and the last published time\n      this.fanout.delete(topic)\n      this.fanoutLastpub.delete(topic)\n\n      // remove explicit peers, peers with negative scores, and backoffed peers\n      fanoutPeers.forEach((id) => {\n        if (!this.direct.has(id) && this.score.score(id) >= 0 && (!backoff || !backoff.has(id))) {\n          toAdd.add(id)\n        }\n      })\n\n      this.metrics?.onAddToMesh(topic, InclusionReason.Fanout, toAdd.size)\n    }\n\n    // check if we need to get more peers, which we randomly select\n    if (toAdd.size < this.opts.D) {\n      const fanoutCount = toAdd.size\n      const newPeers = this.getRandomGossipPeers(\n        topic,\n        this.opts.D,\n        (id: PeerIdStr): boolean =>\n          // filter direct peers and peers with negative score\n          !toAdd.has(id) && !this.direct.has(id) && this.score.score(id) >= 0 && (!backoff || !backoff.has(id))\n      )\n\n      newPeers.forEach((peer) => {\n        toAdd.add(peer)\n      })\n\n      this.metrics?.onAddToMesh(topic, InclusionReason.Random, toAdd.size - fanoutCount)\n    }\n\n    this.mesh.set(topic, toAdd)\n\n    toAdd.forEach((id) => {\n      this.log('JOIN: Add mesh link to %s in %s', id, topic)\n      this.sendGraft(id, topic)\n\n      // rust-libp2p\n      // - peer_score.graft()\n      // - Self::control_pool_add()\n      // - peer_added_to_mesh()\n    })\n  }\n\n  /**\n   * Leave topic\n   */\n  private leave(topic: TopicStr): void {\n    if (this.status.code !== GossipStatusCode.started) {\n      throw new Error('Gossipsub has not started')\n    }\n\n    this.log('LEAVE %s', topic)\n    this.metrics?.onLeave(topic)\n\n    // Send PRUNE to mesh peers\n    const meshPeers = this.mesh.get(topic)\n    if (meshPeers) {\n      Promise.all(\n        Array.from(meshPeers).map(async (id) => {\n          this.log('LEAVE: Remove mesh link to %s in %s', id, topic)\n          return await this.sendPrune(id, topic)\n        })\n      ).catch((err) => {\n        this.log('Error sending prunes to mesh peers', err)\n      })\n      this.mesh.delete(topic)\n    }\n  }\n\n  private selectPeersToForward(topic: TopicStr, propagationSource?: PeerIdStr, excludePeers?: Set<PeerIdStr>) {\n    const tosend = new Set<PeerIdStr>()\n\n    // Add explicit peers\n    const peersInTopic = this.topics.get(topic)\n    if (peersInTopic) {\n      this.direct.forEach((peer) => {\n        if (peersInTopic.has(peer) && propagationSource !== peer && !excludePeers?.has(peer)) {\n          tosend.add(peer)\n        }\n      })\n\n      // As of Mar 2022, spec + golang-libp2p include this while rust-libp2p does not\n      // rust-libp2p: https://github.com/libp2p/rust-libp2p/blob/6cc3b4ec52c922bfcf562a29b5805c3150e37c75/protocols/gossipsub/src/behaviour.rs#L2693\n      // spec: https://github.com/libp2p/specs/blob/10712c55ab309086a52eec7d25f294df4fa96528/pubsub/gossipsub/gossipsub-v1.0.md?plain=1#L361\n      this.floodsubPeers.forEach((peer) => {\n        if (\n          peersInTopic.has(peer) &&\n          propagationSource !== peer &&\n          !excludePeers?.has(peer) &&\n          this.score.score(peer) >= this.opts.scoreThresholds.publishThreshold\n        ) {\n          tosend.add(peer)\n        }\n      })\n    }\n\n    // add mesh peers\n    const meshPeers = this.mesh.get(topic)\n    if (meshPeers && meshPeers.size > 0) {\n      meshPeers.forEach((peer) => {\n        if (propagationSource !== peer && !excludePeers?.has(peer)) {\n          tosend.add(peer)\n        }\n      })\n    }\n\n    return tosend\n  }\n\n  private selectPeersToPublish(topic: TopicStr): {\n    tosend: Set<PeerIdStr>\n    tosendCount: ToSendGroupCount\n  } {\n    const tosend = new Set<PeerIdStr>()\n    const tosendCount: ToSendGroupCount = {\n      direct: 0,\n      floodsub: 0,\n      mesh: 0,\n      fanout: 0\n    }\n\n    const peersInTopic = this.topics.get(topic)\n    if (peersInTopic) {\n      // flood-publish behavior\n      // send to direct peers and _all_ peers meeting the publishThreshold\n      if (this.opts.floodPublish) {\n        peersInTopic.forEach((id) => {\n          if (this.direct.has(id)) {\n            tosend.add(id)\n            tosendCount.direct++\n          } else if (this.score.score(id) >= this.opts.scoreThresholds.publishThreshold) {\n            tosend.add(id)\n            tosendCount.floodsub++\n          }\n        })\n      } else {\n        // non-flood-publish behavior\n        // send to direct peers, subscribed floodsub peers\n        // and some mesh peers above publishThreshold\n\n        // direct peers (if subscribed)\n        this.direct.forEach((id) => {\n          if (peersInTopic.has(id)) {\n            tosend.add(id)\n            tosendCount.direct++\n          }\n        })\n\n        // floodsub peers\n        // Note: if there are no floodsub peers, we save a loop through peersInTopic Map\n        this.floodsubPeers.forEach((id) => {\n          if (peersInTopic.has(id) && this.score.score(id) >= this.opts.scoreThresholds.publishThreshold) {\n            tosend.add(id)\n            tosendCount.floodsub++\n          }\n        })\n\n        // Gossipsub peers handling\n        const meshPeers = this.mesh.get(topic)\n        if (meshPeers && meshPeers.size > 0) {\n          meshPeers.forEach((peer) => {\n            tosend.add(peer)\n            tosendCount.mesh++\n          })\n        }\n\n        // We are not in the mesh for topic, use fanout peers\n        else {\n          const fanoutPeers = this.fanout.get(topic)\n          if (fanoutPeers && fanoutPeers.size > 0) {\n            fanoutPeers.forEach((peer) => {\n              tosend.add(peer)\n              tosendCount.fanout++\n            })\n          }\n\n          // We have no fanout peers, select mesh_n of them and add them to the fanout\n          else {\n            // If we are not in the fanout, then pick peers in topic above the publishThreshold\n            const newFanoutPeers = this.getRandomGossipPeers(topic, this.opts.D, (id) => {\n              return this.score.score(id) >= this.opts.scoreThresholds.publishThreshold\n            })\n\n            if (newFanoutPeers.size > 0) {\n              // eslint-disable-line max-depth\n              this.fanout.set(topic, newFanoutPeers)\n\n              newFanoutPeers.forEach((peer) => {\n                // eslint-disable-line max-depth\n                tosend.add(peer)\n                tosendCount.fanout++\n              })\n            }\n          }\n\n          // We are publishing to fanout peers - update the time we published\n          this.fanoutLastpub.set(topic, Date.now())\n        }\n      }\n    }\n\n    return { tosend, tosendCount }\n  }\n\n  /**\n   * Forwards a message from our peers.\n   *\n   * For messages published by us (the app layer), this class uses `publish`\n   */\n  private forwardMessage(\n    msgIdStr: string,\n    rawMsg: RPC.IMessage,\n    propagationSource?: PeerIdStr,\n    excludePeers?: Set<PeerIdStr>\n  ): void {\n    // message is fully validated inform peer_score\n    if (propagationSource) {\n      this.score.deliverMessage(propagationSource, msgIdStr, rawMsg.topic)\n    }\n\n    const tosend = this.selectPeersToForward(rawMsg.topic, propagationSource, excludePeers)\n\n    // Note: Don't throw if tosend is empty, we can have a mesh with a single peer\n\n    // forward the message to peers\n    tosend.forEach((id) => {\n      // sendRpc may mutate RPC message on piggyback, create a new message for each peer\n      this.sendRpc(id, { messages: [rawMsg] })\n    })\n\n    this.metrics?.onForwardMsg(rawMsg.topic, tosend.size)\n  }\n\n  /**\n   * App layer publishes a message to peers, return number of peers this message is published to\n   * Note: `async` due to crypto only if `StrictSign`, otherwise it's a sync fn.\n   *\n   * For messages not from us, this class uses `forwardMessage`.\n   */\n  async publish(topic: TopicStr, data: Uint8Array, opts?: PublishOpts): Promise<PublishResult> {\n    const startMs = Date.now()\n    const transformedData = this.dataTransform ? this.dataTransform.outboundTransform(topic, data) : data\n\n    if (this.publishConfig == null) {\n      throw Error('PublishError.Uninitialized')\n    }\n\n    // Prepare raw message with user's publishConfig\n    const { raw: rawMsg, msg } = await buildRawMessage(this.publishConfig, topic, data, transformedData)\n\n    // calculate the message id from the un-transformed data\n    const msgId = await this.msgIdFn(msg)\n    const msgIdStr = this.msgIdToStrFn(msgId)\n\n    // Current publish opt takes precedence global opts, while preserving false value\n    const ignoreDuplicatePublishError = opts?.ignoreDuplicatePublishError ?? this.opts.ignoreDuplicatePublishError\n\n    if (this.seenCache.has(msgIdStr)) {\n      // This message has already been seen. We don't re-publish messages that have already\n      // been published on the network.\n      if (ignoreDuplicatePublishError) {\n        this.metrics?.onPublishDuplicateMsg(topic)\n        return { recipients: [] }\n      }\n      throw Error('PublishError.Duplicate')\n    }\n\n    const { tosend, tosendCount } = this.selectPeersToPublish(topic)\n    const willSendToSelf = this.opts.emitSelf === true && this.subscriptions.has(topic)\n\n    // Current publish opt takes precedence global opts, while preserving false value\n    const allowPublishToZeroPeers = opts?.allowPublishToZeroPeers ?? this.opts.allowPublishToZeroPeers\n\n    if (tosend.size === 0 && !allowPublishToZeroPeers && !willSendToSelf) {\n      throw Error('PublishError.InsufficientPeers')\n    }\n\n    // If the message isn't a duplicate and we have sent it to some peers add it to the\n    // duplicate cache and memcache.\n    this.seenCache.put(msgIdStr)\n    // all published messages are valid\n    this.mcache.put({ msgId, msgIdStr }, rawMsg, true)\n\n    // If the message is anonymous or has a random author add it to the published message ids cache.\n    this.publishedMessageIds.put(msgIdStr)\n\n    // Send to set of peers aggregated from direct, mesh, fanout\n    for (const id of tosend) {\n      // sendRpc may mutate RPC message on piggyback, create a new message for each peer\n      const sent = this.sendRpc(id, { messages: [rawMsg] })\n\n      // did not actually send the message\n      if (!sent) {\n        tosend.delete(id)\n      }\n    }\n\n    const durationMs = Date.now() - startMs\n    this.metrics?.onPublishMsg(\n      topic,\n      tosendCount,\n      tosend.size,\n      rawMsg.data != null ? rawMsg.data.length : 0,\n      durationMs\n    )\n\n    // Dispatch the message to the user if we are subscribed to the topic\n    if (willSendToSelf) {\n      tosend.add(this.components.peerId.toString())\n\n      super.dispatchEvent(\n        new CustomEvent<GossipsubMessage>('gossipsub:message', {\n          detail: {\n            propagationSource: this.components.peerId,\n            msgId: msgIdStr,\n            msg\n          }\n        })\n      )\n      // TODO: Add option to switch between emit per topic or all messages in one\n      super.dispatchEvent(new CustomEvent<Message>('message', { detail: msg }))\n    }\n\n    return {\n      recipients: Array.from(tosend.values()).map((str) => peerIdFromString(str))\n    }\n  }\n\n  /**\n   * This function should be called when `asyncValidation` is `true` after\n   * the message got validated by the caller. Messages are stored in the `mcache` and\n   * validation is expected to be fast enough that the messages should still exist in the cache.\n   * There are three possible validation outcomes and the outcome is given in acceptance.\n   *\n   * If acceptance = `MessageAcceptance.Accept` the message will get propagated to the\n   * network. The `propagation_source` parameter indicates who the message was received by and\n   * will not be forwarded back to that peer.\n   *\n   * If acceptance = `MessageAcceptance.Reject` the message will be deleted from the memcache\n   * and the P₄ penalty will be applied to the `propagationSource`.\n   *\n   * If acceptance = `MessageAcceptance.Ignore` the message will be deleted from the memcache\n   * but no P₄ penalty will be applied.\n   *\n   * This function will return true if the message was found in the cache and false if was not\n   * in the cache anymore.\n   *\n   * This should only be called once per message.\n   */\n  reportMessageValidationResult(msgId: MsgIdStr, propagationSource: PeerIdStr, acceptance: TopicValidatorResult): void {\n    let cacheEntry: MessageCacheRecord | null\n\n    if (acceptance === TopicValidatorResult.Accept) {\n      cacheEntry = this.mcache.validate(msgId)\n\n      if (cacheEntry != null) {\n        const { message: rawMsg, originatingPeers } = cacheEntry\n        // message is fully validated inform peer_score\n        this.score.deliverMessage(propagationSource, msgId, rawMsg.topic)\n\n        this.forwardMessage(msgId, cacheEntry.message, propagationSource, originatingPeers)\n      }\n      // else, Message not in cache. Ignoring forwarding\n    }\n\n    // Not valid\n    else {\n      cacheEntry = this.mcache.remove(msgId)\n\n      if (cacheEntry) {\n        const rejectReason = rejectReasonFromAcceptance(acceptance)\n        const { message: rawMsg, originatingPeers } = cacheEntry\n\n        // Tell peer_score about reject\n        // Reject the original source, and any duplicates we've seen from other peers.\n        this.score.rejectMessage(propagationSource, msgId, rawMsg.topic, rejectReason)\n        for (const peer of originatingPeers) {\n          this.score.rejectMessage(peer, msgId, rawMsg.topic, rejectReason)\n        }\n      }\n      // else, Message not in cache. Ignoring forwarding\n    }\n\n    const firstSeenTimestampMs = this.score.messageFirstSeenTimestampMs(msgId)\n    this.metrics?.onReportValidation(cacheEntry, acceptance, firstSeenTimestampMs)\n  }\n\n  /**\n   * Sends a GRAFT message to a peer\n   */\n  private sendGraft(id: PeerIdStr, topic: string): void {\n    const graft = [\n      {\n        topicID: topic\n      }\n    ]\n\n    this.sendRpc(id, { control: { graft } })\n  }\n\n  /**\n   * Sends a PRUNE message to a peer\n   */\n  private async sendPrune(id: PeerIdStr, topic: string): Promise<void> {\n    // this is only called from leave() function\n    const onUnsubscribe = true\n    const prune = [await this.makePrune(id, topic, this.opts.doPX, onUnsubscribe)]\n\n    this.sendRpc(id, { control: { prune } })\n  }\n\n  /**\n   * Send an rpc object to a peer\n   */\n  private sendRpc(id: PeerIdStr, rpc: IRPC): boolean {\n    const outboundStream = this.streamsOutbound.get(id)\n    if (!outboundStream) {\n      this.log(`Cannot send RPC to ${id} as there is no open stream to it available`)\n      return false\n    }\n\n    // piggyback control message retries\n    const ctrl = this.control.get(id)\n    if (ctrl) {\n      this.piggybackControl(id, rpc, ctrl)\n      this.control.delete(id)\n    }\n\n    // piggyback gossip\n    const ihave = this.gossip.get(id)\n    if (ihave) {\n      this.piggybackGossip(id, rpc, ihave)\n      this.gossip.delete(id)\n    }\n\n    const rpcBytes = RPC.encode(rpc).finish()\n    try {\n      outboundStream.push(rpcBytes)\n    } catch (e) {\n      this.log.error(`Cannot send rpc to ${id}`, e)\n\n      // if the peer had control messages or gossip, re-attach\n      if (ctrl) {\n        this.control.set(id, ctrl)\n      }\n      if (ihave) {\n        this.gossip.set(id, ihave)\n      }\n\n      return false\n    }\n\n    this.metrics?.onRpcSent(rpc, rpcBytes.length)\n\n    return true\n  }\n\n  /** Mutates `outRpc` adding graft and prune control messages */\n  public piggybackControl(id: PeerIdStr, outRpc: IRPC, ctrl: RPC.IControlMessage): void {\n    if (ctrl.graft) {\n      if (!outRpc.control) outRpc.control = {}\n      if (!outRpc.control.graft) outRpc.control.graft = []\n      for (const graft of ctrl.graft) {\n        if (graft.topicID && this.mesh.get(graft.topicID)?.has(id)) {\n          outRpc.control.graft.push(graft)\n        }\n      }\n    }\n\n    if (ctrl.prune) {\n      if (!outRpc.control) outRpc.control = {}\n      if (!outRpc.control.prune) outRpc.control.prune = []\n      for (const prune of ctrl.prune) {\n        if (prune.topicID && !this.mesh.get(prune.topicID)?.has(id)) {\n          outRpc.control.prune.push(prune)\n        }\n      }\n    }\n  }\n\n  /** Mutates `outRpc` adding ihave control messages */\n  private piggybackGossip(id: PeerIdStr, outRpc: IRPC, ihave: RPC.IControlIHave[]): void {\n    if (!outRpc.control) outRpc.control = {}\n    outRpc.control.ihave = ihave\n  }\n\n  /**\n   * Send graft and prune messages\n   *\n   * @param tograft - peer id => topic[]\n   * @param toprune - peer id => topic[]\n   */\n  private async sendGraftPrune(\n    tograft: Map<string, string[]>,\n    toprune: Map<string, string[]>,\n    noPX: Map<string, boolean>\n  ): Promise<void> {\n    const doPX = this.opts.doPX\n    const onUnsubscribe = false\n    for (const [id, topics] of tograft) {\n      const graft = topics.map((topicID) => ({ topicID }))\n      let prune: RPC.IControlPrune[] = []\n      // If a peer also has prunes, process them now\n      const pruning = toprune.get(id)\n      if (pruning) {\n        prune = await Promise.all(\n          pruning.map(\n            async (topicID) => await this.makePrune(id, topicID, doPX && !(noPX.get(id) ?? false), onUnsubscribe)\n          )\n        )\n        toprune.delete(id)\n      }\n\n      this.sendRpc(id, { control: { graft, prune } })\n    }\n    for (const [id, topics] of toprune) {\n      const prune = await Promise.all(\n        topics.map(\n          async (topicID) => await this.makePrune(id, topicID, doPX && !(noPX.get(id) ?? false), onUnsubscribe)\n        )\n      )\n      this.sendRpc(id, { control: { prune } })\n    }\n  }\n\n  /**\n   * Emits gossip - Send IHAVE messages to a random set of gossip peers\n   */\n  private emitGossip(peersToGossipByTopic: Map<string, Set<PeerIdStr>>): void {\n    const gossipIDsByTopic = this.mcache.getGossipIDs(new Set(peersToGossipByTopic.keys()))\n    for (const [topic, peersToGossip] of peersToGossipByTopic) {\n      this.doEmitGossip(topic, peersToGossip, gossipIDsByTopic.get(topic) ?? [])\n    }\n  }\n\n  /**\n   * Send gossip messages to GossipFactor peers above threshold with a minimum of D_lazy\n   * Peers are randomly selected from the heartbeat which exclude mesh + fanout peers\n   * We also exclude direct peers, as there is no reason to emit gossip to them\n   * @param topic\n   * @param candidateToGossip - peers to gossip\n   * @param messageIDs - message ids to gossip\n   */\n  private doEmitGossip(topic: string, candidateToGossip: Set<PeerIdStr>, messageIDs: Uint8Array[]): void {\n    if (!messageIDs.length) {\n      return\n    }\n\n    // shuffle to emit in random order\n    shuffle(messageIDs)\n\n    // if we are emitting more than GossipsubMaxIHaveLength ids, truncate the list\n    if (messageIDs.length > constants.GossipsubMaxIHaveLength) {\n      // we do the truncation (with shuffling) per peer below\n      this.log('too many messages for gossip; will truncate IHAVE list (%d messages)', messageIDs.length)\n    }\n\n    if (!candidateToGossip.size) return\n    let target = this.opts.Dlazy\n    const factor = constants.GossipsubGossipFactor * candidateToGossip.size\n    let peersToGossip: Set<PeerIdStr> | PeerIdStr[] = candidateToGossip\n    if (factor > target) {\n      target = factor\n    }\n    if (target > peersToGossip.size) {\n      target = peersToGossip.size\n    } else {\n      // only shuffle if needed\n      peersToGossip = shuffle(Array.from(peersToGossip)).slice(0, target)\n    }\n\n    // Emit the IHAVE gossip to the selected peers up to the target\n    peersToGossip.forEach((id) => {\n      let peerMessageIDs = messageIDs\n      if (messageIDs.length > constants.GossipsubMaxIHaveLength) {\n        // shuffle and slice message IDs per peer so that we emit a different set for each peer\n        // we have enough reduncancy in the system that this will significantly increase the message\n        // coverage when we do truncate\n        peerMessageIDs = shuffle(peerMessageIDs.slice()).slice(0, constants.GossipsubMaxIHaveLength)\n      }\n      this.pushGossip(id, {\n        topicID: topic,\n        messageIDs: peerMessageIDs\n      })\n    })\n  }\n\n  /**\n   * Flush gossip and control messages\n   */\n  private flush(): void {\n    // send gossip first, which will also piggyback control\n    for (const [peer, ihave] of this.gossip.entries()) {\n      this.gossip.delete(peer)\n      this.sendRpc(peer, { control: { ihave } })\n    }\n    // send the remaining control messages\n    for (const [peer, control] of this.control.entries()) {\n      this.control.delete(peer)\n      this.sendRpc(peer, { control: { graft: control.graft, prune: control.prune } })\n    }\n  }\n\n  /**\n   * Adds new IHAVE messages to pending gossip\n   */\n  private pushGossip(id: PeerIdStr, controlIHaveMsgs: RPC.IControlIHave): void {\n    this.log('Add gossip to %s', id)\n    const gossip = this.gossip.get(id) || []\n    this.gossip.set(id, gossip.concat(controlIHaveMsgs))\n  }\n\n  /**\n   * Make a PRUNE control message for a peer in a topic\n   */\n  private async makePrune(\n    id: PeerIdStr,\n    topic: string,\n    doPX: boolean,\n    onUnsubscribe: boolean\n  ): Promise<RPC.IControlPrune> {\n    this.score.prune(id, topic)\n    if (this.streamsOutbound.get(id)!.protocol === constants.GossipsubIDv10) {\n      // Gossipsub v1.0 -- no backoff, the peer won't be able to parse it anyway\n      return {\n        topicID: topic,\n        peers: []\n      }\n    }\n    // backoff is measured in seconds\n    // GossipsubPruneBackoff and GossipsubUnsubscribeBackoff are measured in milliseconds\n    // The protobuf has it as a uint64\n    const backoffMs = onUnsubscribe ? this.opts.unsubcribeBackoff : this.opts.pruneBackoff\n    const backoff = backoffMs / 1000\n    this.doAddBackoff(id, topic, backoffMs)\n\n    if (!doPX) {\n      return {\n        topicID: topic,\n        peers: [],\n        backoff: backoff\n      }\n    }\n\n    // select peers for Peer eXchange\n    const peers = this.getRandomGossipPeers(topic, this.opts.prunePeers, (xid) => {\n      return xid !== id && this.score.score(xid) >= 0\n    })\n    const px = await Promise.all(\n      Array.from(peers).map(async (peerId) => {\n        // see if we have a signed record to send back; if we don't, just send\n        // the peer ID and let the pruned peer find them in the DHT -- we can't trust\n        // unsigned address records through PX anyways\n        // Finding signed records in the DHT is not supported at the time of writing in js-libp2p\n        const id = peerIdFromString(peerId)\n        let peerInfo: Peer | undefined\n\n        try {\n          peerInfo = await this.components.peerStore.get(id)\n        } catch (err: any) {\n          if (err.code !== 'ERR_NOT_FOUND') {\n            throw err\n          }\n        }\n\n        return {\n          peerID: id.toBytes(),\n          signedPeerRecord: peerInfo?.peerRecordEnvelope\n        }\n      })\n    )\n    return {\n      topicID: topic,\n      peers: px,\n      backoff: backoff\n    }\n  }\n\n  private readonly runHeartbeat = () => {\n    const timer = this.metrics?.heartbeatDuration.startTimer()\n\n    this.heartbeat()\n      .catch((err) => {\n        this.log('Error running heartbeat', err)\n      })\n      .finally(() => {\n        if (timer != null) {\n          timer()\n        }\n\n        // Schedule the next run if still in started status\n        if (this.status.code === GossipStatusCode.started) {\n          // Clear previous timeout before overwriting `status.heartbeatTimeout`, it should be completed tho.\n          clearTimeout(this.status.heartbeatTimeout)\n\n          // NodeJS setInterval function is innexact, calls drift by a few miliseconds on each call.\n          // To run the heartbeat precisely setTimeout() must be used recomputing the delay on every loop.\n          let msToNextHeartbeat =\n            this.opts.heartbeatInterval - ((Date.now() - this.status.hearbeatStartMs) % this.opts.heartbeatInterval)\n\n          // If too close to next heartbeat, skip one\n          if (msToNextHeartbeat < this.opts.heartbeatInterval * 0.25) {\n            msToNextHeartbeat += this.opts.heartbeatInterval\n            this.metrics?.heartbeatSkipped.inc()\n          }\n\n          this.status.heartbeatTimeout = setTimeout(this.runHeartbeat, msToNextHeartbeat)\n        }\n      })\n  }\n\n  /**\n   * Maintains the mesh and fanout maps in gossipsub.\n   */\n  public async heartbeat(): Promise<void> {\n    const { D, Dlo, Dhi, Dscore, Dout, fanoutTTL } = this.opts\n\n    this.heartbeatTicks++\n\n    // cache scores throught the heartbeat\n    const scores = new Map<string, number>()\n    const getScore = (id: string): number => {\n      let s = scores.get(id)\n      if (s === undefined) {\n        s = this.score.score(id)\n        scores.set(id, s)\n      }\n      return s\n    }\n\n    // peer id => topic[]\n    const tograft = new Map<string, string[]>()\n    // peer id => topic[]\n    const toprune = new Map<string, string[]>()\n    // peer id => don't px\n    const noPX = new Map<string, boolean>()\n\n    // clean up expired backoffs\n    this.clearBackoff()\n\n    // clean up peerhave/iasked counters\n    this.peerhave.clear()\n    this.metrics?.cacheSize.set({ cache: 'iasked' }, this.iasked.size)\n    this.iasked.clear()\n\n    // apply IWANT request penalties\n    this.applyIwantPenalties()\n\n    // ensure direct peers are connected\n    if (this.heartbeatTicks % this.opts.directConnectTicks === 0) {\n      // we only do this every few ticks to allow pending connections to complete and account for restarts/downtime\n      await this.directConnect()\n    }\n\n    // EXTRA: Prune caches\n    this.fastMsgIdCache?.prune()\n    this.seenCache.prune()\n    this.gossipTracer.prune()\n    this.publishedMessageIds.prune()\n\n    /**\n     * Instead of calling getRandomGossipPeers multiple times to:\n     *   + get more mesh peers\n     *   + more outbound peers\n     *   + oppportunistic grafting\n     *   + emitGossip\n     *\n     * We want to loop through the topic peers only a single time and prepare gossip peers for all topics to improve the performance\n     */\n\n    const peersToGossipByTopic = new Map<string, Set<PeerIdStr>>()\n    // maintain the mesh for topics we have joined\n    this.mesh.forEach((peers, topic) => {\n      const peersInTopic = this.topics.get(topic)\n      const candidateMeshPeers = new Set<PeerIdStr>()\n      const peersToGossip = new Set<PeerIdStr>()\n      peersToGossipByTopic.set(topic, peersToGossip)\n\n      if (peersInTopic) {\n        const shuffledPeers = shuffle(Array.from(peersInTopic))\n        const backoff = this.backoff.get(topic)\n        for (const id of shuffledPeers) {\n          const peerStreams = this.streamsOutbound.get(id)\n          if (\n            peerStreams &&\n            this.multicodecs.includes(peerStreams.protocol) &&\n            !peers.has(id) &&\n            !this.direct.has(id)\n          ) {\n            const score = getScore(id)\n            if ((!backoff || !backoff.has(id)) && score >= 0) candidateMeshPeers.add(id)\n            // instead of having to find gossip peers after heartbeat which require another loop\n            // we prepare peers to gossip in a topic within heartbeat to improve performance\n            if (score >= this.opts.scoreThresholds.gossipThreshold) peersToGossip.add(id)\n          }\n        }\n      }\n\n      // prune/graft helper functions (defined per topic)\n      const prunePeer = (id: PeerIdStr, reason: ChurnReason): void => {\n        this.log('HEARTBEAT: Remove mesh link to %s in %s', id, topic)\n        // no need to update peer score here as we do it in makePrune\n        // add prune backoff record\n        this.addBackoff(id, topic)\n        // remove peer from mesh\n        peers.delete(id)\n        // after pruning a peer from mesh, we want to gossip topic to it if its score meet the gossip threshold\n        if (getScore(id) >= this.opts.scoreThresholds.gossipThreshold) peersToGossip.add(id)\n        this.metrics?.onRemoveFromMesh(topic, reason, 1)\n        // add to toprune\n        const topics = toprune.get(id)\n        if (!topics) {\n          toprune.set(id, [topic])\n        } else {\n          topics.push(topic)\n        }\n      }\n\n      const graftPeer = (id: PeerIdStr, reason: InclusionReason): void => {\n        this.log('HEARTBEAT: Add mesh link to %s in %s', id, topic)\n        // update peer score\n        this.score.graft(id, topic)\n        // add peer to mesh\n        peers.add(id)\n        // when we add a new mesh peer, we don't want to gossip messages to it\n        peersToGossip.delete(id)\n        this.metrics?.onAddToMesh(topic, reason, 1)\n        // add to tograft\n        const topics = tograft.get(id)\n        if (!topics) {\n          tograft.set(id, [topic])\n        } else {\n          topics.push(topic)\n        }\n      }\n\n      // drop all peers with negative score, without PX\n      peers.forEach((id) => {\n        const score = getScore(id)\n\n        // Record the score\n\n        if (score < 0) {\n          this.log('HEARTBEAT: Prune peer %s with negative score: score=%d, topic=%s', id, score, topic)\n          prunePeer(id, ChurnReason.BadScore)\n          noPX.set(id, true)\n        }\n      })\n\n      // do we have enough peers?\n      if (peers.size < Dlo) {\n        const ineed = D - peers.size\n        // slice up to first `ineed` items and remove them from candidateMeshPeers\n        // same to `const newMeshPeers = candidateMeshPeers.slice(0, ineed)`\n        const newMeshPeers = removeFirstNItemsFromSet(candidateMeshPeers, ineed)\n\n        newMeshPeers.forEach((p) => {\n          graftPeer(p, InclusionReason.NotEnough)\n        })\n      }\n\n      // do we have to many peers?\n      if (peers.size > Dhi) {\n        let peersArray = Array.from(peers)\n        // sort by score\n        peersArray.sort((a, b) => getScore(b) - getScore(a))\n        // We keep the first D_score peers by score and the remaining up to D randomly\n        // under the constraint that we keep D_out peers in the mesh (if we have that many)\n        peersArray = peersArray.slice(0, Dscore).concat(shuffle(peersArray.slice(Dscore)))\n\n        // count the outbound peers we are keeping\n        let outbound = 0\n        peersArray.slice(0, D).forEach((p) => {\n          if (this.outbound.get(p)) {\n            outbound++\n          }\n        })\n\n        // if it's less than D_out, bubble up some outbound peers from the random selection\n        if (outbound < Dout) {\n          const rotate = (i: number): void => {\n            // rotate the peersArray to the right and put the ith peer in the front\n            const p = peersArray[i]\n            for (let j = i; j > 0; j--) {\n              peersArray[j] = peersArray[j - 1]\n            }\n            peersArray[0] = p\n          }\n\n          // first bubble up all outbound peers already in the selection to the front\n          if (outbound > 0) {\n            let ihave = outbound\n            for (let i = 1; i < D && ihave > 0; i++) {\n              if (this.outbound.get(peersArray[i])) {\n                rotate(i)\n                ihave--\n              }\n            }\n          }\n\n          // now bubble up enough outbound peers outside the selection to the front\n          let ineed = D - outbound\n          for (let i = D; i < peersArray.length && ineed > 0; i++) {\n            if (this.outbound.get(peersArray[i])) {\n              rotate(i)\n              ineed--\n            }\n          }\n        }\n\n        // prune the excess peers\n        peersArray.slice(D).forEach((p) => {\n          prunePeer(p, ChurnReason.Excess)\n        })\n      }\n\n      // do we have enough outbound peers?\n      if (peers.size >= Dlo) {\n        // count the outbound peers we have\n        let outbound = 0\n        peers.forEach((p) => {\n          if (this.outbound.get(p)) {\n            outbound++\n          }\n        })\n\n        // if it's less than D_out, select some peers with outbound connections and graft them\n        if (outbound < Dout) {\n          const ineed = Dout - outbound\n          const newMeshPeers = removeItemsFromSet(candidateMeshPeers, ineed, (id) => this.outbound.get(id) === true)\n\n          newMeshPeers.forEach((p) => {\n            graftPeer(p, InclusionReason.Outbound)\n          })\n        }\n      }\n\n      // should we try to improve the mesh with opportunistic grafting?\n      if (this.heartbeatTicks % this.opts.opportunisticGraftTicks === 0 && peers.size > 1) {\n        // Opportunistic grafting works as follows: we check the median score of peers in the\n        // mesh; if this score is below the opportunisticGraftThreshold, we select a few peers at\n        // random with score over the median.\n        // The intention is to (slowly) improve an underperforming mesh by introducing good\n        // scoring peers that may have been gossiping at us. This allows us to get out of sticky\n        // situations where we are stuck with poor peers and also recover from churn of good peers.\n\n        // now compute the median peer score in the mesh\n        const peersList = Array.from(peers).sort((a, b) => getScore(a) - getScore(b))\n        const medianIndex = Math.floor(peers.size / 2)\n        const medianScore = getScore(peersList[medianIndex])\n\n        // if the median score is below the threshold, select a better peer (if any) and GRAFT\n        if (medianScore < this.opts.scoreThresholds.opportunisticGraftThreshold) {\n          const ineed = this.opts.opportunisticGraftPeers\n          const newMeshPeers = removeItemsFromSet(candidateMeshPeers, ineed, (id) => getScore(id) > medianScore)\n          for (const id of newMeshPeers) {\n            this.log('HEARTBEAT: Opportunistically graft peer %s on topic %s', id, topic)\n            graftPeer(id, InclusionReason.Opportunistic)\n          }\n        }\n      }\n    })\n\n    // expire fanout for topics we haven't published to in a while\n    const now = Date.now()\n    this.fanoutLastpub.forEach((lastpb, topic) => {\n      if (lastpb + fanoutTTL < now) {\n        this.fanout.delete(topic)\n        this.fanoutLastpub.delete(topic)\n      }\n    })\n\n    // maintain our fanout for topics we are publishing but we have not joined\n    this.fanout.forEach((fanoutPeers, topic) => {\n      // checks whether our peers are still in the topic and have a score above the publish threshold\n      const topicPeers = this.topics.get(topic)\n      fanoutPeers.forEach((id) => {\n        if (!topicPeers!.has(id) || getScore(id) < this.opts.scoreThresholds.publishThreshold) {\n          fanoutPeers.delete(id)\n        }\n      })\n\n      const peersInTopic = this.topics.get(topic)\n      const candidateFanoutPeers = []\n      // the fanout map contains topics to which we are not subscribed.\n      const peersToGossip = new Set<PeerIdStr>()\n      peersToGossipByTopic.set(topic, peersToGossip)\n\n      if (peersInTopic) {\n        const shuffledPeers = shuffle(Array.from(peersInTopic))\n        for (const id of shuffledPeers) {\n          const peerStreams = this.streamsOutbound.get(id)\n          if (\n            peerStreams &&\n            this.multicodecs.includes(peerStreams.protocol) &&\n            !fanoutPeers.has(id) &&\n            !this.direct.has(id)\n          ) {\n            const score = getScore(id)\n            if (score >= this.opts.scoreThresholds.publishThreshold) candidateFanoutPeers.push(id)\n            // instead of having to find gossip peers after heartbeat which require another loop\n            // we prepare peers to gossip in a topic within heartbeat to improve performance\n            if (score >= this.opts.scoreThresholds.gossipThreshold) peersToGossip.add(id)\n          }\n        }\n      }\n\n      // do we need more peers?\n      if (fanoutPeers.size < D) {\n        const ineed = D - fanoutPeers.size\n        candidateFanoutPeers.slice(0, ineed).forEach((id) => {\n          fanoutPeers.add(id)\n          peersToGossip?.delete(id)\n        })\n      }\n    })\n\n    this.emitGossip(peersToGossipByTopic)\n\n    // send coalesced GRAFT/PRUNE messages (will piggyback gossip)\n    await this.sendGraftPrune(tograft, toprune, noPX)\n\n    // flush pending gossip that wasn't piggybacked above\n    this.flush()\n\n    // advance the message history window\n    this.mcache.shift()\n\n    this.dispatchEvent(new CustomEvent('gossipsub:heartbeat'))\n  }\n\n  /**\n   * Given a topic, returns up to count peers subscribed to that topic\n   * that pass an optional filter function\n   *\n   * @param topic\n   * @param count\n   * @param filter - a function to filter acceptable peers\n   */\n  private getRandomGossipPeers(\n    topic: string,\n    count: number,\n    filter: (id: string) => boolean = () => true\n  ): Set<string> {\n    const peersInTopic = this.topics.get(topic)\n\n    if (!peersInTopic) {\n      return new Set()\n    }\n\n    // Adds all peers using our protocol\n    // that also pass the filter function\n    let peers: string[] = []\n    peersInTopic.forEach((id) => {\n      const peerStreams = this.streamsOutbound.get(id)\n      if (!peerStreams) {\n        return\n      }\n      if (this.multicodecs.includes(peerStreams.protocol) && filter(id)) {\n        peers.push(id)\n      }\n    })\n\n    // Pseudo-randomly shuffles peers\n    peers = shuffle(peers)\n    if (count > 0 && peers.length > count) {\n      peers = peers.slice(0, count)\n    }\n\n    return new Set(peers)\n  }\n\n  private onScrapeMetrics(metrics: Metrics): void {\n    /* Data structure sizes */\n    metrics.mcacheSize.set(this.mcache.size)\n    metrics.mcacheNotValidatedCount.set(this.mcache.notValidatedCount)\n    // Arbitrary size\n    metrics.cacheSize.set({ cache: 'direct' }, this.direct.size)\n    metrics.cacheSize.set({ cache: 'seenCache' }, this.seenCache.size)\n    metrics.cacheSize.set({ cache: 'fastMsgIdCache' }, this.fastMsgIdCache?.size ?? 0)\n    metrics.cacheSize.set({ cache: 'publishedMessageIds' }, this.publishedMessageIds.size)\n    metrics.cacheSize.set({ cache: 'mcache' }, this.mcache.size)\n    metrics.cacheSize.set({ cache: 'score' }, this.score.size)\n    metrics.cacheSize.set({ cache: 'gossipTracer.promises' }, this.gossipTracer.size)\n    metrics.cacheSize.set({ cache: 'gossipTracer.requests' }, this.gossipTracer.requestMsByMsgSize)\n    // Bounded by topic\n    metrics.cacheSize.set({ cache: 'topics' }, this.topics.size)\n    metrics.cacheSize.set({ cache: 'subscriptions' }, this.subscriptions.size)\n    metrics.cacheSize.set({ cache: 'mesh' }, this.mesh.size)\n    metrics.cacheSize.set({ cache: 'fanout' }, this.fanout.size)\n    // Bounded by peer\n    metrics.cacheSize.set({ cache: 'peers' }, this.peers.size)\n    metrics.cacheSize.set({ cache: 'streamsOutbound' }, this.streamsOutbound.size)\n    metrics.cacheSize.set({ cache: 'streamsInbound' }, this.streamsInbound.size)\n    metrics.cacheSize.set({ cache: 'acceptFromWhitelist' }, this.acceptFromWhitelist.size)\n    metrics.cacheSize.set({ cache: 'gossip' }, this.gossip.size)\n    metrics.cacheSize.set({ cache: 'control' }, this.control.size)\n    metrics.cacheSize.set({ cache: 'peerhave' }, this.peerhave.size)\n    metrics.cacheSize.set({ cache: 'outbound' }, this.outbound.size)\n\n    // 2D nested data structure\n    let backoffSize = 0\n    const now = Date.now()\n    metrics.connectedPeersBackoffSec.reset()\n    for (const backoff of this.backoff.values()) {\n      backoffSize += backoff.size\n      for (const [peer, expiredMs] of backoff.entries()) {\n        if (this.peers.has(peer)) {\n          metrics.connectedPeersBackoffSec.observe(Math.max(0, expiredMs - now) / 1000)\n        }\n      }\n    }\n    metrics.cacheSize.set({ cache: 'backoff' }, backoffSize)\n\n    // Peer counts\n\n    for (const [topicStr, peers] of this.topics) {\n      metrics.topicPeersCount.set({ topicStr }, peers.size)\n    }\n\n    for (const [topicStr, peers] of this.mesh) {\n      metrics.meshPeerCounts.set({ topicStr }, peers.size)\n    }\n\n    // Peer scores\n\n    const scores: number[] = []\n    const scoreByPeer = new Map<PeerIdStr, number>()\n    metrics.behaviourPenalty.reset()\n\n    for (const peerIdStr of this.peers.keys()) {\n      const score = this.score.score(peerIdStr)\n      scores.push(score)\n      scoreByPeer.set(peerIdStr, score)\n      metrics.behaviourPenalty.observe(this.score.peerStats.get(peerIdStr)?.behaviourPenalty ?? 0)\n    }\n\n    metrics.registerScores(scores, this.opts.scoreThresholds)\n\n    // Breakdown score per mesh topicLabel\n\n    metrics.registerScorePerMesh(this.mesh, scoreByPeer)\n\n    // Breakdown on each score weight\n\n    const sw = computeAllPeersScoreWeights(\n      this.peers.keys(),\n      this.score.peerStats,\n      this.score.params,\n      this.score.peerIPs,\n      metrics.topicStrToLabel\n    )\n\n    metrics.registerScoreWeights(sw)\n  }\n}\n\nexport function gossipsub(\n  init: Partial<GossipsubOpts> = {}\n): (components: GossipSubComponents) => PubSub<GossipsubEvents> {\n  return (components: GossipSubComponents) => new GossipSub(components, init)\n}\n", "export const second = 1000;\nexport const minute = 60 * second;\n\n/**\n * RelayCodec is the libp2p identifier for the waku relay protocol\n */\nexport const RelayCodecs = [\"/vac/waku/relay/2.0.0\"];\n\n/**\n * RelayGossipFactor affects how many peers we will emit gossip to at each heartbeat.\n * We will send gossip to RelayGossipFactor * (total number of non-mesh peers), or\n * RelayDlazy, whichever is greater.\n */\nexport const RelayGossipFactor = 0.25;\n\n/**\n * GossipsubHeartbeatInitialDelay is the short delay before the heartbeat timer begins\n * after the router is initialized.\n */\nexport const RelayHeartbeatInitialDelay = 100;\n\n/**\n * RelayHeartbeatInterval controls the time between heartbeats.\n */\nexport const RelayHeartbeatInterval = second;\n\n/**\n * RelayPrunePeers controls the number of peers to include in prune Peer eXchange.\n * When we prune a peer that's eligible for PX (has a good score, etc), we will try to\n * send them signed peer records for up to RelayPrunePeers other peers that we\n * know of.\n */\nexport const RelayPrunePeers = 16;\n\n/**\n * RelayPruneBackoff controls the backoff time for pruned peers. This is how long\n * a peer must wait before attempting to graft into our mesh again after being pruned.\n * When pruning a peer, we send them our value of RelayPruneBackoff so they know\n * the minimum time to wait. Peers running older versions may not send a backoff time,\n * so if we receive a prune message without one, we will wait at least RelayPruneBackoff\n * before attempting to re-graft.\n */\nexport const RelayPruneBackoff = minute;\n\n/**\n * RelayFanoutTTL controls how long we keep track of the fanout state. If it's been\n * RelayFanoutTTL since we've published to a topic that we're not subscribed to,\n * we'll delete the fanout map for that topic.\n */\nexport const RelayFanoutTTL = minute;\n\n/**\n * RelayOpportunisticGraftTicks is the number of heartbeat ticks for attempting to improve the mesh\n * with opportunistic grafting. Every RelayOpportunisticGraftTicks we will attempt to select some\n * high-scoring mesh peers to replace lower-scoring ones, if the median score of our mesh peers falls\n * below a threshold\n */\nexport const RelayOpportunisticGraftTicks = 60;\n\n/**\n * RelayOpportunisticGraftPeers is the number of peers to opportunistically graft.\n */\nexport const RelayOpportunisticGraftPeers = 2;\n\n/**\n * RelayMaxIHaveLength is the maximum number of messages to include in an IHAVE message.\n * Also controls the maximum number of IHAVE ids we will accept and request with IWANT from a\n * peer within a heartbeat, to protect from IHAVE floods. You should adjust this value from the\n * default if your system is pushing more than 5000 messages in GossipsubHistoryGossip heartbeats;\n * with the defaults this is 1666 messages/s.\n */\nexport const RelayMaxIHaveLength = 5000;\n", "import type { PeerId } from \"@libp2p/interface/peer-id\";\nimport type { Message } from \"@libp2p/interface/pubsub\";\nimport { TopicValidatorResult } from \"@libp2p/interface/pubsub\";\nimport { proto_message as proto } from \"@waku/proto\";\nimport { Logger } from \"@waku/utils\";\n\nconst log = new Logger(\"relay\");\n\nexport function messageValidator(\n  peer: PeerId,\n  message: Message\n): TopicValidatorResult {\n  const startTime = performance.now();\n  log.info(`validating message from ${peer} received on ${message.topic}`);\n  let result = TopicValidatorResult.Accept;\n\n  try {\n    const protoMessage = proto.WakuMessage.decode(message.data);\n\n    if (\n      !protoMessage.contentTopic ||\n      !protoMessage.contentTopic.length ||\n      !protoMessage.payload ||\n      !protoMessage.payload.length\n    ) {\n      result = TopicValidatorResult.Reject;\n    }\n  } catch (e) {\n    result = TopicValidatorResult.Reject;\n  }\n\n  const endTime = performance.now();\n\n  const timeTakenMs = endTime - startTime;\n\n  if (timeTakenMs > 100) {\n    log.warn(\n      `message validation took ${timeTakenMs}ms for peer ${peer} on topic ${message.topic}. This should be less than 100ms.`\n    );\n  } else {\n    log.info(\n      `message validation took ${timeTakenMs}ms for peer ${peer} on topic ${message.topic}`\n    );\n  }\n\n  return result;\n}\n", "import { DefaultPubSubTopic } from \"@waku/core\";\nimport type {\n  IDecodedMessage,\n  IDecoder,\n  IProtoMessage\n} from \"@waku/interfaces\";\nimport { TopicOnlyMessage as ProtoTopicOnlyMessage } from \"@waku/proto\";\n\nexport class TopicOnlyMessage implements IDecodedMessage {\n  public payload: Uint8Array = new Uint8Array();\n  public rateLimitProof: undefined;\n  public timestamp: undefined;\n  public meta: undefined;\n  public ephemeral: undefined;\n\n  constructor(\n    public pubsubTopic: string,\n    private proto: ProtoTopicOnlyMessage\n  ) {}\n\n  get contentTopic(): string {\n    return this.proto.contentTopic;\n  }\n}\n\nexport class TopicOnlyDecoder implements IDecoder<TopicOnlyMessage> {\n  pubsubTopic = DefaultPubSubTopic;\n  public contentTopic = \"\";\n\n  fromWireToProtoObj(bytes: Uint8Array): Promise<IProtoMessage | undefined> {\n    const protoMessage = ProtoTopicOnlyMessage.decode(bytes);\n    return Promise.resolve({\n      contentTopic: protoMessage.contentTopic,\n      payload: new Uint8Array(),\n      rateLimitProof: undefined,\n      timestamp: undefined,\n      meta: undefined,\n      version: undefined,\n      ephemeral: undefined\n    });\n  }\n\n  async fromProtoObj(\n    pubsubTopic: string,\n    proto: IProtoMessage\n  ): Promise<TopicOnlyMessage | undefined> {\n    return new TopicOnlyMessage(pubsubTopic, proto);\n  }\n}\n", "import type { AbortOptions } from '../index.js'\nimport type { PeerInfo } from '../peer-info/index.js'\nimport type { CID } from 'multiformats/cid'\n\n/**\n * Any object that implements this Symbol as a property should return a\n * ContentRouting instance as the property value, similar to how\n * `Symbol.Iterable` can be used to return an `Iterable` from an `Iterator`.\n *\n * @example\n *\n * ```js\n * import { contentRouting, ContentRouting } from '@libp2p/content-routing'\n *\n * class MyContentRouter implements ContentRouting {\n *   get [contentRouting] () {\n *     return this\n *   }\n *\n *   // ...other methods\n * }\n * ```\n */\nexport const contentRouting = Symbol.for('@libp2p/content-routing')\n\nexport interface ContentRouting {\n  /**\n   * The implementation of this method should ensure that network peers know the\n   * caller can provide content that corresponds to the passed CID.\n   *\n   * @example\n   *\n   * ```js\n   * // ...\n   * await contentRouting.provide(cid)\n   * ```\n   */\n  provide(cid: CID, options?: AbortOptions): Promise<void>\n\n  /**\n   * Find the providers of the passed CID.\n   *\n   * @example\n   *\n   * ```js\n   * // Iterate over the providers found for the given cid\n   * for await (const provider of contentRouting.findProviders(cid)) {\n   *  console.log(provider.id, provider.multiaddrs)\n   * }\n   * ```\n   */\n  findProviders(cid: CID, options?: AbortOptions): AsyncIterable<PeerInfo>\n\n  /**\n   * Puts a value corresponding to the passed key in a way that can later be\n   * retrieved by another network peer using the get method.\n   *\n   * @example\n   *\n   * ```js\n   * // ...\n   * const key = '/key'\n   * const value = uint8ArrayFromString('oh hello there')\n   *\n   * await contentRouting.put(key, value)\n   * ```\n   */\n  put(key: Uint8Array, value: Uint8Array, options?: AbortOptions): Promise<void>\n\n  /**\n   * Retrieves a value from the network corresponding to the passed key.\n   *\n   * @example\n   *\n   * ```js\n   * // ...\n   *\n   * const key = '/key'\n   * const value = await contentRouting.get(key)\n   * ```\n   */\n  get(key: Uint8Array, options?: AbortOptions): Promise<Uint8Array>\n}\n", "import type { AbortOptions } from '../index.js'\nimport type { PeerId } from '../peer-id/index.js'\nimport type { PeerInfo } from '../peer-info/index.js'\n\n/**\n * Any object that implements this Symbol as a property should return a\n * PeerRouting instance as the property value, similar to how\n * `Symbol.Iterable` can be used to return an `Iterable` from an `Iterator`.\n *\n * @example\n *\n * ```js\n * import { peerRouting, PeerRouting } from '@libp2p/peer-routing'\n *\n * class MyPeerRouter implements PeerRouting {\n *   get [peerRouting] () {\n *     return this\n *   }\n *\n *   // ...other methods\n * }\n * ```\n */\nexport const peerRouting = Symbol.for('@libp2p/peer-routing')\n\nexport interface PeerRouting {\n  /**\n   * Searches the network for peer info corresponding to the passed peer id.\n   *\n   * @example\n   *\n   * ```js\n   * // ...\n   * const peer = await peerRouting.findPeer(peerId, options)\n   * ```\n   */\n  findPeer(peerId: PeerId, options?: AbortOptions): Promise<PeerInfo>\n\n  /**\n   * Search the network for peers that are closer to the passed key. Peer\n   * info should be yielded in ever-increasing closeness to the key.\n   *\n   * @example\n   *\n   * ```js\n   * // Iterate over the closest peers found for the given key\n   * for await (const peer of peerRouting.getClosestPeers(key)) {\n   *   console.log(peer.id, peer.multiaddrs)\n   * }\n   * ```\n   */\n  getClosestPeers(key: Uint8Array, options?: AbortOptions): AsyncIterable<PeerInfo>\n}\n", "export { urlAlphabet } from './url-alphabet/index.js'\nexport let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\nexport let customRandom = (alphabet, defaultSize, getRandom) => {\n  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1\n  let step = -~((1.6 * mask * defaultSize) / alphabet.length)\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      let j = step\n      while (j--) {\n        id += alphabet[bytes[j] & mask] || ''\n        if (id.length === size) return id\n      }\n    }\n  }\n}\nexport let customAlphabet = (alphabet, size = 21) =>\n  customRandom(alphabet, size, random)\nexport let nanoid = (size = 21) =>\n  crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {\n    byte &= 63\n    if (byte < 36) {\n      id += byte.toString(36)\n    } else if (byte < 62) {\n      id += (byte - 26).toString(36).toUpperCase()\n    } else if (byte > 62) {\n      id += '-'\n    } else {\n      id += '_'\n    }\n    return id\n  }, '')\n", "import { nanoid } from 'nanoid'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { type SupportedEncodings, toString as uint8ArrayToString } from 'uint8arrays/to-string'\n\nconst pathSepS = '/'\nconst pathSepB = new TextEncoder().encode(pathSepS)\nconst pathSep = pathSepB[0]\n\n/**\n * A Key represents the unique identifier of an object.\n * Our Key scheme is inspired by file systems and Google App Engine key model.\n * Keys are meant to be unique across a system. Keys are hierarchical,\n * incorporating more and more specific namespaces. Thus keys can be deemed\n * 'children' or 'ancestors' of other keys:\n * - `new Key('/Comedy')`\n * - `new Key('/Comedy/MontyPython')`\n * Also, every namespace can be parametrized to embed relevant object\n * information. For example, the Key `name` (most specific namespace) could\n * include the object type:\n * - `new Key('/Comedy/MontyPython/Actor:JohnCleese')`\n * - `new Key('/Comedy/MontyPython/Sketch:CheeseShop')`\n * - `new Key('/Comedy/MontyPython/Sketch:CheeseShop/Character:Mousebender')`\n *\n */\nexport class Key {\n  private _buf: Uint8Array\n\n  /**\n   * @param {string | Uint8Array} s\n   * @param {boolean} [clean]\n   */\n  constructor (s: string | Uint8Array, clean?: boolean) {\n    if (typeof s === 'string') {\n      this._buf = uint8ArrayFromString(s)\n    } else if (s instanceof Uint8Array) {\n      this._buf = s\n    } else {\n      throw new Error('Invalid key, should be String of Uint8Array')\n    }\n\n    if (clean == null) {\n      clean = true\n    }\n\n    if (clean) {\n      this.clean()\n    }\n\n    if (this._buf.byteLength === 0 || this._buf[0] !== pathSep) {\n      throw new Error('Invalid key')\n    }\n  }\n\n  /**\n   * Convert to the string representation\n   *\n   * @param {import('uint8arrays/to-string').SupportedEncodings} [encoding='utf8'] - The encoding to use.\n   * @returns {string}\n   */\n  toString (encoding: SupportedEncodings = 'utf8'): string {\n    return uint8ArrayToString(this._buf, encoding)\n  }\n\n  /**\n   * Return the Uint8Array representation of the key\n   *\n   * @returns {Uint8Array}\n   */\n  uint8Array (): Uint8Array {\n    return this._buf\n  }\n\n  /**\n   * Return string representation of the key\n   *\n   * @returns {string}\n   */\n  get [Symbol.toStringTag] (): string {\n    return `Key(${this.toString()})`\n  }\n\n  /**\n   * Constructs a key out of a namespace array.\n   *\n   * @param {Array<string>} list - The array of namespaces\n   * @returns {Key}\n   *\n   * @example\n   * ```js\n   * Key.withNamespaces(['one', 'two'])\n   * // => Key('/one/two')\n   * ```\n   */\n  static withNamespaces (list: string[]): Key {\n    return new Key(list.join(pathSepS))\n  }\n\n  /**\n   * Returns a randomly (uuid) generated key.\n   *\n   * @returns {Key}\n   *\n   * @example\n   * ```js\n   * Key.random()\n   * // => Key('/f98719ea086343f7b71f32ea9d9d521d')\n   * ```\n   */\n  static random (): Key {\n    return new Key(nanoid().replace(/-/g, ''))\n  }\n\n  /**\n   * @param {*} other\n   */\n  static asKey (other: any): Key | null {\n    if (other instanceof Uint8Array || typeof other === 'string') {\n      // we can create a key from this\n      return new Key(other)\n    }\n\n    if (typeof other.uint8Array === 'function') {\n      // this is an older version or may have crossed the esm/cjs boundary\n      return new Key(other.uint8Array())\n    }\n\n    return null\n  }\n\n  /**\n   * Cleanup the current key\n   *\n   * @returns {void}\n   */\n  clean (): void {\n    if (this._buf == null || this._buf.byteLength === 0) {\n      this._buf = pathSepB\n    }\n\n    if (this._buf[0] !== pathSep) {\n      const bytes = new Uint8Array(this._buf.byteLength + 1)\n      bytes.fill(pathSep, 0, 1)\n      bytes.set(this._buf, 1)\n      this._buf = bytes\n    }\n\n    // normalize does not remove trailing slashes\n    while (this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === pathSep) {\n      this._buf = this._buf.subarray(0, -1)\n    }\n  }\n\n  /**\n   * Check if the given key is sorted lower than ourself.\n   *\n   * @param {Key} key - The other Key to check against\n   * @returns {boolean}\n   */\n  less (key: Key): boolean {\n    const list1 = this.list()\n    const list2 = key.list()\n\n    for (let i = 0; i < list1.length; i++) {\n      if (list2.length < i + 1) {\n        return false\n      }\n\n      const c1 = list1[i]\n      const c2 = list2[i]\n\n      if (c1 < c2) {\n        return true\n      } else if (c1 > c2) {\n        return false\n      }\n    }\n\n    return list1.length < list2.length\n  }\n\n  /**\n   * Returns the key with all parts in reversed order.\n   *\n   * @returns {Key}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').reverse()\n   * // => Key('/Actor:JohnCleese/MontyPython/Comedy')\n   * ```\n   */\n  reverse (): Key {\n    return Key.withNamespaces(this.list().slice().reverse())\n  }\n\n  /**\n   * Returns the `namespaces` making up this Key.\n   *\n   * @returns {Array<string>}\n   */\n  namespaces (): string[] {\n    return this.list()\n  }\n\n  /** Returns the \"base\" namespace of this key.\n   *\n   * @returns {string}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').baseNamespace()\n   * // => 'Actor:JohnCleese'\n   * ```\n   */\n  baseNamespace (): string {\n    const ns = this.namespaces()\n    return ns[ns.length - 1]\n  }\n\n  /**\n   * Returns the `list` representation of this key.\n   *\n   * @returns {Array<string>}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').list()\n   * // => ['Comedy', 'MontyPythong', 'Actor:JohnCleese']\n   * ```\n   */\n  list (): string[] {\n    return this.toString().split(pathSepS).slice(1)\n  }\n\n  /**\n   * Returns the \"type\" of this key (value of last namespace).\n   *\n   * @returns {string}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').type()\n   * // => 'Actor'\n   * ```\n   */\n  type (): string {\n    return namespaceType(this.baseNamespace())\n  }\n\n  /**\n   * Returns the \"name\" of this key (field of last namespace).\n   *\n   * @returns {string}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').name()\n   * // => 'JohnCleese'\n   * ```\n   */\n  name (): string {\n    return namespaceValue(this.baseNamespace())\n  }\n\n  /**\n   * Returns an \"instance\" of this type key (appends value to namespace).\n   *\n   * @param {string} s - The string to append.\n   * @returns {Key}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython/Actor').instance('JohnClesse')\n   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')\n   * ```\n   */\n  instance (s: string): Key {\n    return new Key(this.toString() + ':' + s)\n  }\n\n  /**\n   * Returns the \"path\" of this key (parent + type).\n   *\n   * @returns {Key}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').path()\n   * // => Key('/Comedy/MontyPython/Actor')\n   * ```\n   */\n  path (): Key {\n    let p = this.parent().toString()\n    if (!p.endsWith(pathSepS)) {\n      p += pathSepS\n    }\n    p += this.type()\n    return new Key(p)\n  }\n\n  /**\n   * Returns the `parent` Key of this Key.\n   *\n   * @returns {Key}\n   *\n   * @example\n   * ```js\n   * new Key(\"/Comedy/MontyPython/Actor:JohnCleese\").parent()\n   * // => Key(\"/Comedy/MontyPython\")\n   * ```\n   */\n  parent (): Key {\n    const list = this.list()\n    if (list.length === 1) {\n      return new Key(pathSepS)\n    }\n\n    return new Key(list.slice(0, -1).join(pathSepS))\n  }\n\n  /**\n   * Returns the `child` Key of this Key.\n   *\n   * @param {Key} key - The child Key to add\n   * @returns {Key}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython').child(new Key('Actor:JohnCleese'))\n   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')\n   * ```\n   */\n  child (key: Key): Key {\n    if (this.toString() === pathSepS) {\n      return key\n    } else if (key.toString() === pathSepS) {\n      return this\n    }\n\n    return new Key(this.toString() + key.toString(), false)\n  }\n\n  /**\n   * Returns whether this key is a prefix of `other`\n   *\n   * @param {Key} other - The other key to test against\n   * @returns {boolean}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy').isAncestorOf('/Comedy/MontyPython')\n   * // => true\n   * ```\n   */\n  isAncestorOf (other: Key): boolean {\n    if (other.toString() === this.toString()) {\n      return false\n    }\n\n    return other.toString().startsWith(this.toString())\n  }\n\n  /**\n   * Returns whether this key is a contains another as prefix.\n   *\n   * @param {Key} other - The other Key to test against\n   * @returns {boolean}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython').isDecendantOf('/Comedy')\n   * // => true\n   * ```\n   */\n  isDecendantOf (other: Key): boolean {\n    if (other.toString() === this.toString()) {\n      return false\n    }\n\n    return this.toString().startsWith(other.toString())\n  }\n\n  /**\n   * Checks if this key has only one namespace.\n   *\n   * @returns {boolean}\n   */\n  isTopLevel (): boolean {\n    return this.list().length === 1\n  }\n\n  /**\n   * Concats one or more Keys into one new Key.\n   *\n   * @param {Array<Key>} keys - The array of keys to concatenate\n   * @returns {Key}\n   */\n  concat (...keys: Key[]): Key {\n    return Key.withNamespaces([...this.namespaces(), ...flatten(keys.map(key => key.namespaces()))])\n  }\n}\n\n/**\n * The first component of a namespace. `foo` in `foo:bar`\n *\n * @param {string} ns\n * @returns {string}\n */\nfunction namespaceType (ns: string): string {\n  const parts = ns.split(':')\n  if (parts.length < 2) {\n    return ''\n  }\n  return parts.slice(0, -1).join(':')\n}\n\n/**\n * The last component of a namespace, `baz` in `foo:bar:baz`.\n *\n * @param {string} ns\n * @returns {string}\n */\nfunction namespaceValue (ns: string): string {\n  const parts = ns.split(':')\n  return parts[parts.length - 1]\n}\n\n/**\n * Flatten array of arrays (only one level)\n *\n * @template T\n * @param {Array<any>} arr\n * @returns {T[]}\n */\nfunction flatten (arr: any[]): string[] {\n  return ([]).concat(...arr)\n}\n", "/**\n * @packageDocumentation\n *\n * - Manages the lifecycle of a key\n * - Keys are encrypted at rest\n * - Enforces the use of safe key names\n * - Uses encrypted PKCS 8 for key storage\n * - Uses PBKDF2 for a \"stetched\" key encryption key\n * - Enforces NIST SP 800-131A and NIST SP 800-132\n * - Delays reporting errors to slow down brute force attacks\n *\n * ## KeyInfo\n *\n * The key management and naming service API all return a `KeyInfo` object.  The `id` is a universally unique identifier for the key.  The `name` is local to the key chain.\n *\n * ```js\n * {\n *   name: 'rsa-key',\n *   id: 'QmYWYSUZ4PV6MRFYpdtEDJBiGs4UrmE6g8wmAWSePekXVW'\n * }\n * ```\n *\n * The **key id** is the SHA-256 [multihash](https://github.com/multiformats/multihash) of its public key.\n *\n * The *public key* is a [protobuf encoding](https://github.com/libp2p/js-libp2p-crypto/blob/master/src/keys/keys.proto.js) containing a type and the [DER encoding](https://en.wikipedia.org/wiki/X.690) of the PKCS [SubjectPublicKeyInfo](https://www.ietf.org/rfc/rfc3279.txt).\n *\n * ## Private key storage\n *\n * A private key is stored as an encrypted PKCS 8 structure in the PEM format. It is protected by a key generated from the key chain's *passPhrase* using **PBKDF2**.\n *\n * The default options for generating the derived encryption key are in the `dek` object.  This, along with the passPhrase, is the input to a `PBKDF2` function.\n *\n * ```js\n * const defaultOptions = {\n * // See https://cryptosense.com/parameter-choice-for-pbkdf2/\n *   dek: {\n *     keyLength: 512 / 8,\n *     iterationCount: 1000,\n *     salt: 'at least 16 characters long',\n *     hash: 'sha2-512'\n *   }\n * }\n * ```\n * ![key storage](./doc/private-key.png?raw=true)\n *\n * ## Physical storage\n *\n * The actual physical storage of an encrypted key is left to implementations of [interface-datastore](https://github.com/ipfs/interface-datastore/).\n *\n * A key benefit is that now the key chain can be used in browser with the [js-datastore-level](https://github.com/ipfs/js-datastore-level) implementation.\n */\n\n/* eslint max-nested-callbacks: [\"error\", 5] */\n\nimport { pbkdf2, randomBytes } from '@libp2p/crypto'\nimport { generateKeyPair, importKey, unmarshalPrivateKey } from '@libp2p/crypto/keys'\nimport { CodeError } from '@libp2p/interface/errors'\nimport { logger } from '@libp2p/logger'\nimport { peerIdFromKeys } from '@libp2p/peer-id'\nimport { Key } from 'interface-datastore/key'\nimport mergeOptions from 'merge-options'\nimport sanitize from 'sanitize-filename'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { codes } from './errors.js'\nimport type { KeyChain, KeyInfo } from '@libp2p/interface/keychain'\nimport type { KeyType } from '@libp2p/interface/keys'\nimport type { PeerId } from '@libp2p/interface/peer-id'\nimport type { Datastore } from 'interface-datastore'\n\nconst log = logger('libp2p:keychain')\n\nexport interface DEKConfig {\n  hash: string\n  salt: string\n  iterationCount: number\n  keyLength: number\n}\n\nexport interface KeyChainInit {\n  pass?: string\n  dek?: DEKConfig\n}\n\nconst keyPrefix = '/pkcs8/'\nconst infoPrefix = '/info/'\nconst privates = new WeakMap<object, { dek: string }>()\n\n// NIST SP 800-132\nconst NIST = {\n  minKeyLength: 112 / 8,\n  minSaltLength: 128 / 8,\n  minIterationCount: 1000\n}\n\nconst defaultOptions = {\n  // See https://cryptosense.com/parametesr-choice-for-pbkdf2/\n  dek: {\n    keyLength: 512 / 8,\n    iterationCount: 10000,\n    salt: 'you should override this value with a crypto secure random number',\n    hash: 'sha2-512'\n  }\n}\n\nfunction validateKeyName (name: string): boolean {\n  if (name == null) {\n    return false\n  }\n  if (typeof name !== 'string') {\n    return false\n  }\n  return name === sanitize(name.trim()) && name.length > 0\n}\n\n/**\n * Throws an error after a delay\n *\n * This assumes than an error indicates that the keychain is under attack. Delay returning an\n * error to make brute force attacks harder.\n */\nasync function randomDelay (): Promise<void> {\n  const min = 200\n  const max = 1000\n  const delay = Math.random() * (max - min) + min\n\n  await new Promise(resolve => setTimeout(resolve, delay))\n}\n\n/**\n * Converts a key name into a datastore name\n */\nfunction DsName (name: string): Key {\n  return new Key(keyPrefix + name)\n}\n\n/**\n * Converts a key name into a datastore info name\n */\nfunction DsInfoName (name: string): Key {\n  return new Key(infoPrefix + name)\n}\n\nexport interface KeyChainComponents {\n  datastore: Datastore\n}\n\n/**\n * Manages the lifecycle of a key. Keys are encrypted at rest using PKCS #8.\n *\n * A key in the store has two entries\n * - '/info/*key-name*', contains the KeyInfo for the key\n * - '/pkcs8/*key-name*', contains the PKCS #8 for the key\n *\n */\nexport class DefaultKeyChain implements KeyChain {\n  private readonly components: KeyChainComponents\n  private readonly init: KeyChainInit\n\n  /**\n   * Creates a new instance of a key chain\n   */\n  constructor (components: KeyChainComponents, init: KeyChainInit) {\n    this.components = components\n    this.init = mergeOptions(defaultOptions, init)\n\n    // Enforce NIST SP 800-132\n    if (this.init.pass != null && this.init.pass?.length < 20) {\n      throw new Error('pass must be least 20 characters')\n    }\n    if (this.init.dek?.keyLength != null && this.init.dek.keyLength < NIST.minKeyLength) {\n      throw new Error(`dek.keyLength must be least ${NIST.minKeyLength} bytes`)\n    }\n    if (this.init.dek?.salt?.length != null && this.init.dek.salt.length < NIST.minSaltLength) {\n      throw new Error(`dek.saltLength must be least ${NIST.minSaltLength} bytes`)\n    }\n    if (this.init.dek?.iterationCount != null && this.init.dek.iterationCount < NIST.minIterationCount) {\n      throw new Error(`dek.iterationCount must be least ${NIST.minIterationCount}`)\n    }\n\n    const dek = this.init.pass != null && this.init.dek?.salt != null\n      ? pbkdf2(\n        this.init.pass,\n        this.init.dek?.salt,\n        this.init.dek?.iterationCount,\n        this.init.dek?.keyLength,\n        this.init.dek?.hash)\n      : ''\n\n    privates.set(this, { dek })\n  }\n\n  /**\n   * Generates the options for a keychain.  A random salt is produced.\n   *\n   * @returns {object}\n   */\n  static generateOptions (): KeyChainInit {\n    const options = Object.assign({}, defaultOptions)\n    const saltLength = Math.ceil(NIST.minSaltLength / 3) * 3 // no base64 padding\n    options.dek.salt = uint8ArrayToString(randomBytes(saltLength), 'base64')\n    return options\n  }\n\n  /**\n   * Gets an object that can encrypt/decrypt protected data.\n   * The default options for a keychain.\n   *\n   * @returns {object}\n   */\n  static get options (): typeof defaultOptions {\n    return defaultOptions\n  }\n\n  /**\n   * Create a new key.\n   *\n   * @param {string} name - The local key name; cannot already exist.\n   * @param {string} type - One of the key types; 'rsa'.\n   * @param {number} [size = 2048] - The key size in bits. Used for rsa keys only\n   */\n  async createKey (name: string, type: KeyType, size = 2048): Promise<KeyInfo> {\n    if (!validateKeyName(name) || name === 'self') {\n      await randomDelay()\n      throw new CodeError('Invalid key name', codes.ERR_INVALID_KEY_NAME)\n    }\n\n    if (typeof type !== 'string') {\n      await randomDelay()\n      throw new CodeError('Invalid key type', codes.ERR_INVALID_KEY_TYPE)\n    }\n\n    const dsname = DsName(name)\n    const exists = await this.components.datastore.has(dsname)\n    if (exists) {\n      await randomDelay()\n      throw new CodeError('Key name already exists', codes.ERR_KEY_ALREADY_EXISTS)\n    }\n\n    switch (type.toLowerCase()) {\n      case 'rsa':\n        if (!Number.isSafeInteger(size) || size < 2048) {\n          await randomDelay()\n          throw new CodeError('Invalid RSA key size', codes.ERR_INVALID_KEY_SIZE)\n        }\n        break\n      default:\n        break\n    }\n\n    let keyInfo\n    try {\n      const keypair = await generateKeyPair(type, size)\n      const kid = await keypair.id()\n      const cached = privates.get(this)\n\n      if (cached == null) {\n        throw new CodeError('dek missing', codes.ERR_INVALID_PARAMETERS)\n      }\n\n      const dek = cached.dek\n      const pem = await keypair.export(dek)\n      keyInfo = {\n        name,\n        id: kid\n      }\n      const batch = this.components.datastore.batch()\n      batch.put(dsname, uint8ArrayFromString(pem))\n      batch.put(DsInfoName(name), uint8ArrayFromString(JSON.stringify(keyInfo)))\n\n      await batch.commit()\n    } catch (err: any) {\n      await randomDelay()\n      throw err\n    }\n\n    return keyInfo\n  }\n\n  /**\n   * List all the keys.\n   *\n   * @returns {Promise<KeyInfo[]>}\n   */\n  async listKeys (): Promise<KeyInfo[]> {\n    const query = {\n      prefix: infoPrefix\n    }\n\n    const info = []\n    for await (const value of this.components.datastore.query(query)) {\n      info.push(JSON.parse(uint8ArrayToString(value.value)))\n    }\n\n    return info\n  }\n\n  /**\n   * Find a key by it's id\n   */\n  async findKeyById (id: string): Promise<KeyInfo> {\n    try {\n      const keys = await this.listKeys()\n      const key = keys.find((k) => k.id === id)\n\n      if (key == null) {\n        throw new CodeError(`Key with id '${id}' does not exist.`, codes.ERR_KEY_NOT_FOUND)\n      }\n\n      return key\n    } catch (err: any) {\n      await randomDelay()\n      throw err\n    }\n  }\n\n  /**\n   * Find a key by it's name.\n   *\n   * @param {string} name - The local key name.\n   * @returns {Promise<KeyInfo>}\n   */\n  async findKeyByName (name: string): Promise<KeyInfo> {\n    if (!validateKeyName(name)) {\n      await randomDelay()\n      throw new CodeError(`Invalid key name '${name}'`, codes.ERR_INVALID_KEY_NAME)\n    }\n\n    const dsname = DsInfoName(name)\n    try {\n      const res = await this.components.datastore.get(dsname)\n      return JSON.parse(uint8ArrayToString(res))\n    } catch (err: any) {\n      await randomDelay()\n      log.error(err)\n      throw new CodeError(`Key '${name}' does not exist.`, codes.ERR_KEY_NOT_FOUND)\n    }\n  }\n\n  /**\n   * Remove an existing key.\n   *\n   * @param {string} name - The local key name; must already exist.\n   * @returns {Promise<KeyInfo>}\n   */\n  async removeKey (name: string): Promise<KeyInfo> {\n    if (!validateKeyName(name) || name === 'self') {\n      await randomDelay()\n      throw new CodeError(`Invalid key name '${name}'`, codes.ERR_INVALID_KEY_NAME)\n    }\n    const dsname = DsName(name)\n    const keyInfo = await this.findKeyByName(name)\n    const batch = this.components.datastore.batch()\n    batch.delete(dsname)\n    batch.delete(DsInfoName(name))\n    await batch.commit()\n    return keyInfo\n  }\n\n  /**\n   * Rename a key\n   *\n   * @param {string} oldName - The old local key name; must already exist.\n   * @param {string} newName - The new local key name; must not already exist.\n   * @returns {Promise<KeyInfo>}\n   */\n  async renameKey (oldName: string, newName: string): Promise<KeyInfo> {\n    if (!validateKeyName(oldName) || oldName === 'self') {\n      await randomDelay()\n      throw new CodeError(`Invalid old key name '${oldName}'`, codes.ERR_OLD_KEY_NAME_INVALID)\n    }\n    if (!validateKeyName(newName) || newName === 'self') {\n      await randomDelay()\n      throw new CodeError(`Invalid new key name '${newName}'`, codes.ERR_NEW_KEY_NAME_INVALID)\n    }\n    const oldDsname = DsName(oldName)\n    const newDsname = DsName(newName)\n    const oldInfoName = DsInfoName(oldName)\n    const newInfoName = DsInfoName(newName)\n\n    const exists = await this.components.datastore.has(newDsname)\n    if (exists) {\n      await randomDelay()\n      throw new CodeError(`Key '${newName}' already exists`, codes.ERR_KEY_ALREADY_EXISTS)\n    }\n\n    try {\n      const pem = await this.components.datastore.get(oldDsname)\n      const res = await this.components.datastore.get(oldInfoName)\n\n      const keyInfo = JSON.parse(uint8ArrayToString(res))\n      keyInfo.name = newName\n      const batch = this.components.datastore.batch()\n      batch.put(newDsname, pem)\n      batch.put(newInfoName, uint8ArrayFromString(JSON.stringify(keyInfo)))\n      batch.delete(oldDsname)\n      batch.delete(oldInfoName)\n      await batch.commit()\n      return keyInfo\n    } catch (err: any) {\n      await randomDelay()\n      throw err\n    }\n  }\n\n  /**\n   * Export an existing key as a PEM encrypted PKCS #8 string\n   */\n  async exportKey (name: string, password: string): Promise<string> {\n    if (!validateKeyName(name)) {\n      await randomDelay()\n      throw new CodeError(`Invalid key name '${name}'`, codes.ERR_INVALID_KEY_NAME)\n    }\n    if (password == null) {\n      await randomDelay()\n      throw new CodeError('Password is required', codes.ERR_PASSWORD_REQUIRED)\n    }\n\n    const dsname = DsName(name)\n    try {\n      const res = await this.components.datastore.get(dsname)\n      const pem = uint8ArrayToString(res)\n      const cached = privates.get(this)\n\n      if (cached == null) {\n        throw new CodeError('dek missing', codes.ERR_INVALID_PARAMETERS)\n      }\n\n      const dek = cached.dek\n      const privateKey = await importKey(pem, dek)\n      const keyString = await privateKey.export(password)\n\n      return keyString\n    } catch (err: any) {\n      await randomDelay()\n      throw err\n    }\n  }\n\n  /**\n   * Export an existing key as a PeerId\n   */\n  async exportPeerId (name: string): Promise<PeerId> {\n    const password = 'temporary-password'\n    const pem = await this.exportKey(name, password)\n    const privateKey = await importKey(pem, password)\n\n    return peerIdFromKeys(privateKey.public.bytes, privateKey.bytes)\n  }\n\n  /**\n   * Import a new key from a PEM encoded PKCS #8 string\n   *\n   * @param {string} name - The local key name; must not already exist.\n   * @param {string} pem - The PEM encoded PKCS #8 string\n   * @param {string} password - The password.\n   * @returns {Promise<KeyInfo>}\n   */\n  async importKey (name: string, pem: string, password: string): Promise<KeyInfo> {\n    if (!validateKeyName(name) || name === 'self') {\n      await randomDelay()\n      throw new CodeError(`Invalid key name '${name}'`, codes.ERR_INVALID_KEY_NAME)\n    }\n    if (pem == null) {\n      await randomDelay()\n      throw new CodeError('PEM encoded key is required', codes.ERR_PEM_REQUIRED)\n    }\n    const dsname = DsName(name)\n    const exists = await this.components.datastore.has(dsname)\n    if (exists) {\n      await randomDelay()\n      throw new CodeError(`Key '${name}' already exists`, codes.ERR_KEY_ALREADY_EXISTS)\n    }\n\n    let privateKey\n    try {\n      privateKey = await importKey(pem, password)\n    } catch (err: any) {\n      await randomDelay()\n      throw new CodeError('Cannot read the key, most likely the password is wrong', codes.ERR_CANNOT_READ_KEY)\n    }\n\n    let kid\n    try {\n      kid = await privateKey.id()\n      const cached = privates.get(this)\n\n      if (cached == null) {\n        throw new CodeError('dek missing', codes.ERR_INVALID_PARAMETERS)\n      }\n\n      const dek = cached.dek\n      pem = await privateKey.export(dek)\n    } catch (err: any) {\n      await randomDelay()\n      throw err\n    }\n\n    const keyInfo = {\n      name,\n      id: kid\n    }\n    const batch = this.components.datastore.batch()\n    batch.put(dsname, uint8ArrayFromString(pem))\n    batch.put(DsInfoName(name), uint8ArrayFromString(JSON.stringify(keyInfo)))\n    await batch.commit()\n\n    return keyInfo\n  }\n\n  /**\n   * Import a peer key\n   */\n  async importPeer (name: string, peer: PeerId): Promise<KeyInfo> {\n    try {\n      if (!validateKeyName(name)) {\n        throw new CodeError(`Invalid key name '${name}'`, codes.ERR_INVALID_KEY_NAME)\n      }\n      if (peer == null) {\n        throw new CodeError('PeerId is required', codes.ERR_MISSING_PRIVATE_KEY)\n      }\n      if (peer.privateKey == null) {\n        throw new CodeError('PeerId.privKey is required', codes.ERR_MISSING_PRIVATE_KEY)\n      }\n\n      const privateKey = await unmarshalPrivateKey(peer.privateKey)\n\n      const dsname = DsName(name)\n      const exists = await this.components.datastore.has(dsname)\n      if (exists) {\n        await randomDelay()\n        throw new CodeError(`Key '${name}' already exists`, codes.ERR_KEY_ALREADY_EXISTS)\n      }\n\n      const cached = privates.get(this)\n\n      if (cached == null) {\n        throw new CodeError('dek missing', codes.ERR_INVALID_PARAMETERS)\n      }\n\n      const dek = cached.dek\n      const pem = await privateKey.export(dek)\n      const keyInfo: KeyInfo = {\n        name,\n        id: peer.toString()\n      }\n      const batch = this.components.datastore.batch()\n      batch.put(dsname, uint8ArrayFromString(pem))\n      batch.put(DsInfoName(name), uint8ArrayFromString(JSON.stringify(keyInfo)))\n      await batch.commit()\n      return keyInfo\n    } catch (err: any) {\n      await randomDelay()\n      throw err\n    }\n  }\n\n  /**\n   * Gets the private key as PEM encoded PKCS #8 string\n   */\n  async getPrivateKey (name: string): Promise<string> {\n    if (!validateKeyName(name)) {\n      await randomDelay()\n      throw new CodeError(`Invalid key name '${name}'`, codes.ERR_INVALID_KEY_NAME)\n    }\n\n    try {\n      const dsname = DsName(name)\n      const res = await this.components.datastore.get(dsname)\n      return uint8ArrayToString(res)\n    } catch (err: any) {\n      await randomDelay()\n      log.error(err)\n      throw new CodeError(`Key '${name}' does not exist.`, codes.ERR_KEY_NOT_FOUND)\n    }\n  }\n\n  /**\n   * Rotate keychain password and re-encrypt all associated keys\n   */\n  async rotateKeychainPass (oldPass: string, newPass: string): Promise<void> {\n    if (typeof oldPass !== 'string') {\n      await randomDelay()\n      throw new CodeError(`Invalid old pass type '${typeof oldPass}'`, codes.ERR_INVALID_OLD_PASS_TYPE)\n    }\n    if (typeof newPass !== 'string') {\n      await randomDelay()\n      throw new CodeError(`Invalid new pass type '${typeof newPass}'`, codes.ERR_INVALID_NEW_PASS_TYPE)\n    }\n    if (newPass.length < 20) {\n      await randomDelay()\n      throw new CodeError(`Invalid pass length ${newPass.length}`, codes.ERR_INVALID_PASS_LENGTH)\n    }\n    log('recreating keychain')\n    const cached = privates.get(this)\n\n    if (cached == null) {\n      throw new CodeError('dek missing', codes.ERR_INVALID_PARAMETERS)\n    }\n\n    const oldDek = cached.dek\n    this.init.pass = newPass\n    const newDek = newPass != null && this.init.dek?.salt != null\n      ? pbkdf2(\n        newPass,\n        this.init.dek.salt,\n        this.init.dek?.iterationCount,\n        this.init.dek?.keyLength,\n        this.init.dek?.hash)\n      : ''\n    privates.set(this, { dek: newDek })\n    const keys = await this.listKeys()\n    for (const key of keys) {\n      const res = await this.components.datastore.get(DsName(key.name))\n      const pem = uint8ArrayToString(res)\n      const privateKey = await importKey(pem, oldDek)\n      const password = newDek.toString()\n      const keyAsPEM = await privateKey.export(password)\n\n      // Update stored key\n      const batch = this.components.datastore.batch()\n      const keyInfo = {\n        name: key.name,\n        id: key.id\n      }\n      batch.put(DsName(key.name), uint8ArrayFromString(keyAsPEM))\n      batch.put(DsInfoName(key.name), uint8ArrayFromString(JSON.stringify(keyInfo)))\n      await batch.commit()\n    }\n    log('keychain reconstructed')\n  }\n}\n", "export enum codes {\n  ERR_INVALID_PARAMETERS = 'ERR_INVALID_PARAMETERS',\n  ERR_INVALID_KEY_NAME = 'ERR_INVALID_KEY_NAME',\n  ERR_INVALID_KEY_TYPE = 'ERR_INVALID_KEY_TYPE',\n  ERR_KEY_ALREADY_EXISTS = 'ERR_KEY_ALREADY_EXISTS',\n  ERR_INVALID_KEY_SIZE = 'ERR_INVALID_KEY_SIZE',\n  ERR_KEY_NOT_FOUND = 'ERR_KEY_NOT_FOUND',\n  ERR_OLD_KEY_NAME_INVALID = 'ERR_OLD_KEY_NAME_INVALID',\n  ERR_NEW_KEY_NAME_INVALID = 'ERR_NEW_KEY_NAME_INVALID',\n  ERR_PASSWORD_REQUIRED = 'ERR_PASSWORD_REQUIRED',\n  ERR_PEM_REQUIRED = 'ERR_PEM_REQUIRED',\n  ERR_CANNOT_READ_KEY = 'ERR_CANNOT_READ_KEY',\n  ERR_MISSING_PRIVATE_KEY = 'ERR_MISSING_PRIVATE_KEY',\n  ERR_INVALID_OLD_PASS_TYPE = 'ERR_INVALID_OLD_PASS_TYPE',\n  ERR_INVALID_NEW_PASS_TYPE = 'ERR_INVALID_NEW_PASS_TYPE',\n  ERR_INVALID_PASS_LENGTH = 'ERR_INVALID_PASS_LENGTH'\n}\n", "/**\n * Calls the passed map function on every entry of the passed iterable iterator\n */\nexport function mapIterable <T, R> (iter: IterableIterator<T>, map: (val: T) => R): IterableIterator<R> {\n  const iterator: IterableIterator<R> = {\n    [Symbol.iterator]: () => {\n      return iterator\n    },\n    next: () => {\n      const next = iter.next()\n      const val = next.value\n\n      if (next.done === true || val == null) {\n        const result: IteratorReturnResult<any> = {\n          done: true,\n          value: undefined\n        }\n\n        return result\n      }\n\n      return {\n        done: false,\n        value: map(val)\n      }\n    }\n  }\n\n  return iterator\n}\n", "import { peerIdFromString } from '@libp2p/peer-id'\nimport { mapIterable } from './util.js'\nimport type { PeerId } from '@libp2p/interface/peer-id'\n\n/**\n * We can't use PeerIds as map keys because map keys are\n * compared using same-value-zero equality, so this is just\n * a map that stringifies the PeerIds before storing them.\n *\n * PeerIds cache stringified versions of themselves so this\n * should be a cheap operation.\n *\n * @example\n *\n * ```JavaScript\n * import { peerMap } from '@libp2p/peer-collections'\n *\n * const map = peerMap<string>()\n * map.set(peerId, 'value')\n * ```\n */\nexport class PeerMap <T> {\n  private readonly map: Map<string, T>\n\n  constructor (map?: PeerMap<T>) {\n    this.map = new Map()\n\n    if (map != null) {\n      for (const [key, value] of map.entries()) {\n        this.map.set(key.toString(), value)\n      }\n    }\n  }\n\n  [Symbol.iterator] (): IterableIterator<[PeerId, T]> {\n    return this.entries()\n  }\n\n  clear (): void {\n    this.map.clear()\n  }\n\n  delete (peer: PeerId): void {\n    this.map.delete(peer.toString())\n  }\n\n  entries (): IterableIterator<[PeerId, T]> {\n    return mapIterable<[string, T], [PeerId, T]>(\n      this.map.entries(),\n      (val) => {\n        return [peerIdFromString(val[0]), val[1]]\n      }\n    )\n  }\n\n  forEach (fn: (value: T, key: PeerId, map: PeerMap<T>) => void): void {\n    this.map.forEach((value, key) => {\n      fn(value, peerIdFromString(key), this)\n    })\n  }\n\n  get (peer: PeerId): T | undefined {\n    return this.map.get(peer.toString())\n  }\n\n  has (peer: PeerId): boolean {\n    return this.map.has(peer.toString())\n  }\n\n  set (peer: PeerId, value: T): void {\n    this.map.set(peer.toString(), value)\n  }\n\n  keys (): IterableIterator<PeerId> {\n    return mapIterable<string, PeerId>(\n      this.map.keys(),\n      (val) => {\n        return peerIdFromString(val)\n      }\n    )\n  }\n\n  values (): IterableIterator<T> {\n    return this.map.values()\n  }\n\n  get size (): number {\n    return this.map.size\n  }\n}\n", "import { peerIdFromString } from '@libp2p/peer-id'\nimport { mapIterable } from './util.js'\nimport type { PeerId } from '@libp2p/interface/peer-id'\n\n/**\n * We can't use PeerIds as set entries because set entries are\n * compared using same-value-zero equality, so this is just\n * a map that stringifies the PeerIds before storing them.\n *\n * PeerIds cache stringified versions of themselves so this\n * should be a cheap operation.\n *\n * @example\n *\n * ```JavaScript\n * import { peerSet } from '@libp2p/peer-collections'\n *\n * const set = peerSet()\n * set.add(peerId)\n * ```\n */\nexport class PeerSet {\n  private readonly set: Set<string>\n\n  constructor (set?: PeerSet | Iterable<PeerId>) {\n    this.set = new Set()\n\n    if (set != null) {\n      for (const key of set) {\n        this.set.add(key.toString())\n      }\n    }\n  }\n\n  get size (): number {\n    return this.set.size\n  }\n\n  [Symbol.iterator] (): IterableIterator<PeerId> {\n    return this.values()\n  }\n\n  add (peer: PeerId): void {\n    this.set.add(peer.toString())\n  }\n\n  clear (): void {\n    this.set.clear()\n  }\n\n  delete (peer: PeerId): void {\n    this.set.delete(peer.toString())\n  }\n\n  entries (): IterableIterator<[PeerId, PeerId]> {\n    return mapIterable<[string, string], [PeerId, PeerId]>(\n      this.set.entries(),\n      (val) => {\n        const peerId = peerIdFromString(val[0])\n\n        return [peerId, peerId]\n      }\n    )\n  }\n\n  forEach (predicate: (peerId: PeerId, index: PeerId, set: PeerSet) => void): void {\n    this.set.forEach((str) => {\n      const id = peerIdFromString(str)\n\n      predicate(id, id, this)\n    })\n  }\n\n  has (peer: PeerId): boolean {\n    return this.set.has(peer.toString())\n  }\n\n  values (): IterableIterator<PeerId> {\n    return mapIterable<string, PeerId>(\n      this.set.values(),\n      (val) => {\n        return peerIdFromString(val)\n      }\n    )\n  }\n\n  intersection (other: PeerSet): PeerSet {\n    const output = new PeerSet()\n\n    for (const peerId of other) {\n      if (this.has(peerId)) {\n        output.add(peerId)\n      }\n    }\n\n    return output\n  }\n\n  difference (other: PeerSet): PeerSet {\n    const output = new PeerSet()\n\n    for (const peerId of this) {\n      if (!other.has(peerId)) {\n        output.add(peerId)\n      }\n    }\n\n    return output\n  }\n\n  union (other: PeerSet): PeerSet {\n    const output = new PeerSet()\n\n    for (const peerId of other) {\n      output.add(peerId)\n    }\n\n    for (const peerId of this) {\n      output.add(peerId)\n    }\n\n    return output\n  }\n}\n", "import { peerIdFromString } from '@libp2p/peer-id'\nimport { mapIterable } from './util.js'\nimport type { PeerId } from '@libp2p/interface/peer-id'\n\n/**\n * We can't use PeerIds as list entries because list entries are\n * compared using same-value-zero equality, so this is just\n * a map that stringifies the PeerIds before storing them.\n *\n * PeerIds cache stringified versions of themselves so this\n * should be a cheap operation.\n *\n * @example\n *\n * ```JavaScript\n * import { peerList } from '@libp2p/peer-collections'\n *\n * const list = peerList()\n * list.push(peerId)\n * ```\n */\nexport class PeerList {\n  private readonly list: string[]\n\n  constructor (list?: PeerList | Iterable<PeerId>) {\n    this.list = []\n\n    if (list != null) {\n      for (const value of list) {\n        this.list.push(value.toString())\n      }\n    }\n  }\n\n  [Symbol.iterator] (): IterableIterator<PeerId> {\n    return mapIterable<[number, string], PeerId>(\n      this.list.entries(),\n      (val) => {\n        return peerIdFromString(val[1])\n      }\n    )\n  }\n\n  concat (list: PeerList): PeerList {\n    const output = new PeerList(this)\n\n    for (const value of list) {\n      output.push(value)\n    }\n\n    return output\n  }\n\n  entries (): IterableIterator<[number, PeerId]> {\n    return mapIterable<[number, string], [number, PeerId]>(\n      this.list.entries(),\n      (val) => {\n        return [val[0], peerIdFromString(val[1])]\n      }\n    )\n  }\n\n  every (predicate: (peerId: PeerId, index: number, arr: PeerList) => boolean): boolean {\n    return this.list.every((str, index) => {\n      return predicate(peerIdFromString(str), index, this)\n    })\n  }\n\n  filter (predicate: (peerId: PeerId, index: number, arr: PeerList) => boolean): PeerList {\n    const output = new PeerList()\n\n    this.list.forEach((str, index) => {\n      const peerId = peerIdFromString(str)\n\n      if (predicate(peerId, index, this)) {\n        output.push(peerId)\n      }\n    })\n\n    return output\n  }\n\n  find (predicate: (peerId: PeerId, index: number, arr: PeerList) => boolean): PeerId | undefined {\n    const str = this.list.find((str, index) => {\n      return predicate(peerIdFromString(str), index, this)\n    })\n\n    if (str == null) {\n      return undefined\n    }\n\n    return peerIdFromString(str)\n  }\n\n  findIndex (predicate: (peerId: PeerId, index: number, arr: PeerList) => boolean): number {\n    return this.list.findIndex((str, index) => {\n      return predicate(peerIdFromString(str), index, this)\n    })\n  }\n\n  forEach (predicate: (peerId: PeerId, index: number, arr: PeerList) => void): void {\n    this.list.forEach((str, index) => {\n      predicate(peerIdFromString(str), index, this)\n    })\n  }\n\n  includes (peerId: PeerId): boolean {\n    return this.list.includes(peerId.toString())\n  }\n\n  indexOf (peerId: PeerId): number {\n    return this.list.indexOf(peerId.toString())\n  }\n\n  pop (): PeerId | undefined {\n    const str = this.list.pop()\n\n    if (str == null) {\n      return undefined\n    }\n\n    return peerIdFromString(str)\n  }\n\n  push (...peerIds: PeerId[]): void {\n    for (const peerId of peerIds) {\n      this.list.push(peerId.toString())\n    }\n  }\n\n  shift (): PeerId | undefined {\n    const str = this.list.shift()\n\n    if (str == null) {\n      return undefined\n    }\n\n    return peerIdFromString(str)\n  }\n\n  unshift (...peerIds: PeerId[]): number {\n    let len = this.list.length\n\n    for (let i = peerIds.length - 1; i > -1; i--) {\n      len = this.list.unshift(peerIds[i].toString())\n    }\n\n    return len\n  }\n\n  get length (): number {\n    return this.list.length\n  }\n}\n", "/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nimport { encodeMessage, decodeMessage, message } from 'protons-runtime'\nimport type { Codec } from 'protons-runtime'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface PeerIdProto {\n  id?: Uint8Array\n  pubKey?: Uint8Array\n  privKey?: Uint8Array\n}\n\nexport namespace PeerIdProto {\n  let _codec: Codec<PeerIdProto>\n\n  export const codec = (): Codec<PeerIdProto> => {\n    if (_codec == null) {\n      _codec = message<PeerIdProto>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.id != null) {\n          w.uint32(10)\n          w.bytes(obj.id)\n        }\n\n        if (obj.pubKey != null) {\n          w.uint32(18)\n          w.bytes(obj.pubKey)\n        }\n\n        if (obj.privKey != null) {\n          w.uint32(26)\n          w.bytes(obj.privKey)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {}\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.id = reader.bytes()\n              break\n            case 2:\n              obj.pubKey = reader.bytes()\n              break\n            case 3:\n              obj.privKey = reader.bytes()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<PeerIdProto>): Uint8Array => {\n    return encodeMessage(obj, PeerIdProto.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): PeerIdProto => {\n    return decodeMessage(buf, PeerIdProto.codec())\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * Generate, import, and export PeerIDs, for use with [IPFS](https://github.com/ipfs/ipfs).\n *\n * A Peer ID is the SHA-256 [multihash](https://github.com/multiformats/multihash) of a public key.\n *\n * The public key is a base64 encoded string of a protobuf containing an RSA DER buffer. This uses a node buffer to pass the base64 encoded public key protobuf to the multihash for ID generation.\n *\n * @example\n *\n * ```JavaScript\n * import { createEd25519PeerId } from '@libp2p/peer-id-factory'\n *\n * const peerId = await createEd25519PeerId()\n * console.log(id.toString())\n * ```\n *\n * ```bash\n * 12D3KooWRm8J3iL796zPFi2EtGGtUJn58AG67gcqzMFHZnnsTzqD\n * ```\n */\n\nimport { generateKeyPair, marshalPrivateKey, unmarshalPrivateKey, marshalPublicKey, unmarshalPublicKey } from '@libp2p/crypto/keys'\nimport { peerIdFromKeys, peerIdFromBytes } from '@libp2p/peer-id'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { PeerIdProto } from './proto.js'\nimport type { PublicKey, PrivateKey } from '@libp2p/interface/keys'\nimport type { RSAPeerId, Ed25519PeerId, Secp256k1PeerId, PeerId } from '@libp2p/interface/peer-id'\n\nexport const createEd25519PeerId = async (): Promise<Ed25519PeerId> => {\n  const key = await generateKeyPair('Ed25519')\n  const id = await createFromPrivKey(key)\n\n  if (id.type === 'Ed25519') {\n    return id\n  }\n\n  throw new Error(`Generated unexpected PeerId type \"${id.type}\"`)\n}\n\nexport const createSecp256k1PeerId = async (): Promise<Secp256k1PeerId> => {\n  const key = await generateKeyPair('secp256k1')\n  const id = await createFromPrivKey(key)\n\n  if (id.type === 'secp256k1') {\n    return id\n  }\n\n  throw new Error(`Generated unexpected PeerId type \"${id.type}\"`)\n}\n\nexport const createRSAPeerId = async (opts?: { bits: number }): Promise<RSAPeerId> => {\n  const key = await generateKeyPair('RSA', opts?.bits ?? 2048)\n  const id = await createFromPrivKey(key)\n\n  if (id.type === 'RSA') {\n    return id\n  }\n\n  throw new Error(`Generated unexpected PeerId type \"${id.type}\"`)\n}\n\nexport async function createFromPubKey (publicKey: PublicKey): Promise<PeerId> {\n  return peerIdFromKeys(marshalPublicKey(publicKey))\n}\n\nexport async function createFromPrivKey (privateKey: PrivateKey): Promise<PeerId> {\n  return peerIdFromKeys(marshalPublicKey(privateKey.public), marshalPrivateKey(privateKey))\n}\n\nexport function exportToProtobuf (peerId: RSAPeerId | Ed25519PeerId | Secp256k1PeerId, excludePrivateKey?: boolean): Uint8Array {\n  return PeerIdProto.encode({\n    id: peerId.multihash.bytes,\n    pubKey: peerId.publicKey,\n    privKey: excludePrivateKey === true || peerId.privateKey == null ? undefined : peerId.privateKey\n  })\n}\n\nexport async function createFromProtobuf (buf: Uint8Array): Promise<PeerId> {\n  const {\n    id,\n    privKey,\n    pubKey\n  } = PeerIdProto.decode(buf)\n\n  return createFromParts(\n    id ?? new Uint8Array(0),\n    privKey,\n    pubKey\n  )\n}\n\nexport async function createFromJSON (obj: { id: string, privKey?: string, pubKey?: string }): Promise<PeerId> {\n  return createFromParts(\n    uint8ArrayFromString(obj.id, 'base58btc'),\n    obj.privKey != null ? uint8ArrayFromString(obj.privKey, 'base64pad') : undefined,\n    obj.pubKey != null ? uint8ArrayFromString(obj.pubKey, 'base64pad') : undefined\n  )\n}\n\nasync function createFromParts (multihash: Uint8Array, privKey?: Uint8Array, pubKey?: Uint8Array): Promise<PeerId> {\n  if (privKey != null) {\n    const key = await unmarshalPrivateKey(privKey)\n\n    return createFromPrivKey(key)\n  } else if (pubKey != null) {\n    const key = unmarshalPublicKey(pubKey)\n\n    return createFromPubKey(key)\n  }\n\n  return peerIdFromBytes(multihash)\n}\n", "export const codes = {\n  ERR_SIGNATURE_NOT_VALID: 'ERR_SIGNATURE_NOT_VALID'\n}\n", "/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nimport { encodeMessage, decodeMessage, message } from 'protons-runtime'\nimport type { Codec } from 'protons-runtime'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface Envelope {\n  publicKey: Uint8Array\n  payloadType: Uint8Array\n  payload: Uint8Array\n  signature: Uint8Array\n}\n\nexport namespace Envelope {\n  let _codec: Codec<Envelope>\n\n  export const codec = (): Codec<Envelope> => {\n    if (_codec == null) {\n      _codec = message<Envelope>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if ((obj.publicKey != null && obj.publicKey.byteLength > 0)) {\n          w.uint32(10)\n          w.bytes(obj.publicKey)\n        }\n\n        if ((obj.payloadType != null && obj.payloadType.byteLength > 0)) {\n          w.uint32(18)\n          w.bytes(obj.payloadType)\n        }\n\n        if ((obj.payload != null && obj.payload.byteLength > 0)) {\n          w.uint32(26)\n          w.bytes(obj.payload)\n        }\n\n        if ((obj.signature != null && obj.signature.byteLength > 0)) {\n          w.uint32(42)\n          w.bytes(obj.signature)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {\n          publicKey: new Uint8Array(0),\n          payloadType: new Uint8Array(0),\n          payload: new Uint8Array(0),\n          signature: new Uint8Array(0)\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.publicKey = reader.bytes()\n              break\n            case 2:\n              obj.payloadType = reader.bytes()\n              break\n            case 3:\n              obj.payload = reader.bytes()\n              break\n            case 5:\n              obj.signature = reader.bytes()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Envelope>): Uint8Array => {\n    return encodeMessage(obj, Envelope.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): Envelope => {\n    return decodeMessage(buf, Envelope.codec())\n  }\n}\n", "import { unmarshalPrivateKey, unmarshalPublicKey } from '@libp2p/crypto/keys'\nimport { CodeError } from '@libp2p/interface/errors'\nimport { peerIdFromKeys } from '@libp2p/peer-id'\nimport * as varint from 'uint8-varint'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { fromString as uint8arraysFromString } from 'uint8arrays/from-string'\nimport { codes } from '../errors.js'\nimport { Envelope as Protobuf } from './envelope.js'\nimport type { PeerId } from '@libp2p/interface/peer-id'\nimport type { Record, Envelope } from '@libp2p/interface/record'\n\nexport interface RecordEnvelopeInit {\n  peerId: PeerId\n  payloadType: Uint8Array\n  payload: Uint8Array\n  signature: Uint8Array\n}\n\nexport class RecordEnvelope implements Envelope {\n  /**\n   * Unmarshal a serialized Envelope protobuf message\n   */\n  static createFromProtobuf = async (data: Uint8Array | Uint8ArrayList): Promise<RecordEnvelope> => {\n    const envelopeData = Protobuf.decode(data)\n    const peerId = await peerIdFromKeys(envelopeData.publicKey)\n\n    return new RecordEnvelope({\n      peerId,\n      payloadType: envelopeData.payloadType,\n      payload: envelopeData.payload,\n      signature: envelopeData.signature\n    })\n  }\n\n  /**\n   * Seal marshals the given Record, places the marshaled bytes inside an Envelope\n   * and signs it with the given peerId's private key\n   */\n  static seal = async (record: Record, peerId: PeerId): Promise<RecordEnvelope> => {\n    if (peerId.privateKey == null) {\n      throw new Error('Missing private key')\n    }\n\n    const domain = record.domain\n    const payloadType = record.codec\n    const payload = record.marshal()\n    const signData = formatSignaturePayload(domain, payloadType, payload)\n    const key = await unmarshalPrivateKey(peerId.privateKey)\n    const signature = await key.sign(signData.subarray())\n\n    return new RecordEnvelope({\n      peerId,\n      payloadType,\n      payload,\n      signature\n    })\n  }\n\n  /**\n   * Open and certify a given marshalled envelope.\n   * Data is unmarshalled and the signature validated for the given domain.\n   */\n  static openAndCertify = async (data: Uint8Array | Uint8ArrayList, domain: string): Promise<RecordEnvelope> => {\n    const envelope = await RecordEnvelope.createFromProtobuf(data)\n    const valid = await envelope.validate(domain)\n\n    if (!valid) {\n      throw new CodeError('envelope signature is not valid for the given domain', codes.ERR_SIGNATURE_NOT_VALID)\n    }\n\n    return envelope\n  }\n\n  public peerId: PeerId\n  public payloadType: Uint8Array\n  public payload: Uint8Array\n  public signature: Uint8Array\n  public marshaled?: Uint8Array\n\n  /**\n   * The Envelope is responsible for keeping an arbitrary signed record\n   * by a libp2p peer.\n   */\n  constructor (init: RecordEnvelopeInit) {\n    const { peerId, payloadType, payload, signature } = init\n\n    this.peerId = peerId\n    this.payloadType = payloadType\n    this.payload = payload\n    this.signature = signature\n  }\n\n  /**\n   * Marshal the envelope content\n   */\n  marshal (): Uint8Array {\n    if (this.peerId.publicKey == null) {\n      throw new Error('Missing public key')\n    }\n\n    if (this.marshaled == null) {\n      this.marshaled = Protobuf.encode({\n        publicKey: this.peerId.publicKey,\n        payloadType: this.payloadType,\n        payload: this.payload.subarray(),\n        signature: this.signature\n      })\n    }\n\n    return this.marshaled\n  }\n\n  /**\n   * Verifies if the other Envelope is identical to this one\n   */\n  equals (other: Envelope): boolean {\n    return uint8ArrayEquals(this.marshal(), other.marshal())\n  }\n\n  /**\n   * Validate envelope data signature for the given domain\n   */\n  async validate (domain: string): Promise<boolean> {\n    const signData = formatSignaturePayload(domain, this.payloadType, this.payload)\n\n    if (this.peerId.publicKey == null) {\n      throw new Error('Missing public key')\n    }\n\n    const key = unmarshalPublicKey(this.peerId.publicKey)\n\n    return key.verify(signData.subarray(), this.signature)\n  }\n}\n\n/**\n * Helper function that prepares a Uint8Array to sign or verify a signature\n */\nconst formatSignaturePayload = (domain: string, payloadType: Uint8Array, payload: Uint8Array | Uint8ArrayList): Uint8ArrayList => {\n  // When signing, a peer will prepare a Uint8Array by concatenating the following:\n  // - The length of the domain separation string string in bytes\n  // - The domain separation string, encoded as UTF-8\n  // - The length of the payload_type field in bytes\n  // - The value of the payload_type field\n  // - The length of the payload field in bytes\n  // - The value of the payload field\n\n  const domainUint8Array = uint8arraysFromString(domain)\n  const domainLength = varint.encode(domainUint8Array.byteLength)\n  const payloadTypeLength = varint.encode(payloadType.length)\n  const payloadLength = varint.encode(payload.length)\n\n  return new Uint8ArrayList(\n    domainLength,\n    domainUint8Array,\n    payloadTypeLength,\n    payloadType,\n    payloadLength,\n    payload\n  )\n}\n", "/**\n * @packageDocumentation\n *\n * Provides strategies ensure arrays are equivalent.\n *\n * @example\n *\n * ```typescript\n * import { arrayEquals } from '@libp2p/utils/array-equals'\n * import { multiaddr } from '@multformats/multiaddr'\n *\n * const ma1 = multiaddr('/ip4/127.0.0.1/tcp/9000'),\n * const ma2 = multiaddr('/ip4/82.41.53.1/tcp/9000')\n *\n * console.info(arrayEquals([ma1], [ma1])) // true\n * console.info(arrayEquals([ma1], [ma2])) // false\n * ```\n */\n\n/**\n * Verify if two arrays of non primitive types with the \"equals\" function are equal.\n * Compatible with multiaddr, peer-id and others.\n */\nexport function arrayEquals (a: any[], b: any[]): boolean {\n  const sort = (a: any, b: any): number => a.toString().localeCompare(b.toString())\n\n  if (a.length !== b.length) {\n    return false\n  }\n\n  b.sort(sort)\n\n  return a.sort(sort).every((item, index) => b[index].equals(item))\n}\n", "// The domain string used for peer records contained in a Envelope.\nexport const ENVELOPE_DOMAIN_PEER_RECORD = 'libp2p-peer-record'\n\n// The type hint used to identify peer records in a Envelope.\n// Defined in https://github.com/multiformats/multicodec/blob/master/table.csv\n// with name \"libp2p-peer-record\"\nexport const ENVELOPE_PAYLOAD_TYPE_PEER_RECORD = Uint8Array.from([3, 1])\n", "/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nimport { encodeMessage, decodeMessage, message } from 'protons-runtime'\nimport type { Codec } from 'protons-runtime'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface PeerRecord {\n  peerId: Uint8Array\n  seq: bigint\n  addresses: PeerRecord.AddressInfo[]\n}\n\nexport namespace PeerRecord {\n  export interface AddressInfo {\n    multiaddr: Uint8Array\n  }\n\n  export namespace AddressInfo {\n    let _codec: Codec<AddressInfo>\n\n    export const codec = (): Codec<AddressInfo> => {\n      if (_codec == null) {\n        _codec = message<AddressInfo>((obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork()\n          }\n\n          if ((obj.multiaddr != null && obj.multiaddr.byteLength > 0)) {\n            w.uint32(10)\n            w.bytes(obj.multiaddr)\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim()\n          }\n        }, (reader, length) => {\n          const obj: any = {\n            multiaddr: new Uint8Array(0)\n          }\n\n          const end = length == null ? reader.len : reader.pos + length\n\n          while (reader.pos < end) {\n            const tag = reader.uint32()\n\n            switch (tag >>> 3) {\n              case 1:\n                obj.multiaddr = reader.bytes()\n                break\n              default:\n                reader.skipType(tag & 7)\n                break\n            }\n          }\n\n          return obj\n        })\n      }\n\n      return _codec\n    }\n\n    export const encode = (obj: Partial<AddressInfo>): Uint8Array => {\n      return encodeMessage(obj, AddressInfo.codec())\n    }\n\n    export const decode = (buf: Uint8Array | Uint8ArrayList): AddressInfo => {\n      return decodeMessage(buf, AddressInfo.codec())\n    }\n  }\n\n  let _codec: Codec<PeerRecord>\n\n  export const codec = (): Codec<PeerRecord> => {\n    if (_codec == null) {\n      _codec = message<PeerRecord>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if ((obj.peerId != null && obj.peerId.byteLength > 0)) {\n          w.uint32(10)\n          w.bytes(obj.peerId)\n        }\n\n        if ((obj.seq != null && obj.seq !== 0n)) {\n          w.uint32(16)\n          w.uint64(obj.seq)\n        }\n\n        if (obj.addresses != null) {\n          for (const value of obj.addresses) {\n            w.uint32(26)\n            PeerRecord.AddressInfo.codec().encode(value, w)\n          }\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {\n          peerId: new Uint8Array(0),\n          seq: 0n,\n          addresses: []\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.peerId = reader.bytes()\n              break\n            case 2:\n              obj.seq = reader.uint64()\n              break\n            case 3:\n              obj.addresses.push(PeerRecord.AddressInfo.codec().decode(reader, reader.uint32()))\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<PeerRecord>): Uint8Array => {\n    return encodeMessage(obj, PeerRecord.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): PeerRecord => {\n    return decodeMessage(buf, PeerRecord.codec())\n  }\n}\n", "import { peerIdFromBytes } from '@libp2p/peer-id'\nimport { arrayEquals } from '@libp2p/utils/array-equals'\nimport { multiaddr } from '@multiformats/multiaddr'\nimport {\n  ENVELOPE_DOMAIN_PEER_RECORD,\n  ENVELOPE_PAYLOAD_TYPE_PEER_RECORD\n} from './consts.js'\nimport { PeerRecord as Protobuf } from './peer-record.js'\nimport type { PeerId } from '@libp2p/interface/peer-id'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface PeerRecordInit {\n  peerId: PeerId\n\n  /**\n   * Addresses of the associated peer.\n   */\n  multiaddrs?: Multiaddr[]\n\n  /**\n   * Monotonically-increasing sequence counter that's used to order PeerRecords in time.\n   */\n  seqNumber?: bigint\n}\n\n/**\n * The PeerRecord is used for distributing peer routing records across the network.\n * It contains the peer's reachable listen addresses.\n */\nexport class PeerRecord {\n  /**\n   * Unmarshal Peer Record Protobuf\n   */\n  static createFromProtobuf = (buf: Uint8Array | Uint8ArrayList): PeerRecord => {\n    const peerRecord = Protobuf.decode(buf)\n    const peerId = peerIdFromBytes(peerRecord.peerId)\n    const multiaddrs = (peerRecord.addresses ?? []).map((a) => multiaddr(a.multiaddr))\n    const seqNumber = peerRecord.seq\n\n    return new PeerRecord({ peerId, multiaddrs, seqNumber })\n  }\n\n  static DOMAIN = ENVELOPE_DOMAIN_PEER_RECORD\n  static CODEC = ENVELOPE_PAYLOAD_TYPE_PEER_RECORD\n\n  public peerId: PeerId\n  public multiaddrs: Multiaddr[]\n  public seqNumber: bigint\n  public domain = PeerRecord.DOMAIN\n  public codec = PeerRecord.CODEC\n  private marshaled?: Uint8Array\n\n  constructor (init: PeerRecordInit) {\n    const { peerId, multiaddrs, seqNumber } = init\n\n    this.peerId = peerId\n    this.multiaddrs = multiaddrs ?? []\n    this.seqNumber = seqNumber ?? BigInt(Date.now())\n  }\n\n  /**\n   * Marshal a record to be used in an envelope\n   */\n  marshal (): Uint8Array {\n    if (this.marshaled == null) {\n      this.marshaled = Protobuf.encode({\n        peerId: this.peerId.toBytes(),\n        seq: BigInt(this.seqNumber),\n        addresses: this.multiaddrs.map((m) => ({\n          multiaddr: m.bytes\n        }))\n      })\n    }\n\n    return this.marshaled\n  }\n\n  /**\n   * Returns true if `this` record equals the `other`\n   */\n  equals (other: unknown): boolean {\n    if (!(other instanceof PeerRecord)) {\n      return false\n    }\n\n    // Validate PeerId\n    if (!this.peerId.equals(other.peerId)) {\n      return false\n    }\n\n    // Validate seqNumber\n    if (this.seqNumber !== other.seqNumber) {\n      return false\n    }\n\n    // Validate multiaddrs\n    if (!arrayEquals(this.multiaddrs, other.multiaddrs)) {\n      return false\n    }\n\n    return true\n  }\n}\n", "import EventEmitter from './index.js'\n\nexport { EventEmitter }\nexport default EventEmitter\n", "export class TimeoutError extends Error {\n\tconstructor(message) {\n\t\tsuper(message);\n\t\tthis.name = 'TimeoutError';\n\t}\n}\n\n/**\nAn error to be thrown when the request is aborted by AbortController.\nDOMException is thrown instead of this Error when DOMException is available.\n*/\nexport class AbortError extends Error {\n\tconstructor(message) {\n\t\tsuper();\n\t\tthis.name = 'AbortError';\n\t\tthis.message = message;\n\t}\n}\n\n/**\nTODO: Remove AbortError and just throw DOMException when targeting Node 18.\n*/\nconst getDOMException = errorMessage => globalThis.DOMException === undefined ?\n\tnew AbortError(errorMessage) :\n\tnew DOMException(errorMessage);\n\n/**\nTODO: Remove below function and just 'reject(signal.reason)' when targeting Node 18.\n*/\nconst getAbortedReason = signal => {\n\tconst reason = signal.reason === undefined ?\n\t\tgetDOMException('This operation was aborted.') :\n\t\tsignal.reason;\n\n\treturn reason instanceof Error ? reason : getDOMException(reason);\n};\n\nexport default function pTimeout(promise, milliseconds, fallback, options) {\n\tlet timer;\n\n\tconst cancelablePromise = new Promise((resolve, reject) => {\n\t\tif (typeof milliseconds !== 'number' || Math.sign(milliseconds) !== 1) {\n\t\t\tthrow new TypeError(`Expected \\`milliseconds\\` to be a positive number, got \\`${milliseconds}\\``);\n\t\t}\n\n\t\tif (milliseconds === Number.POSITIVE_INFINITY) {\n\t\t\tresolve(promise);\n\t\t\treturn;\n\t\t}\n\n\t\toptions = {\n\t\t\tcustomTimers: {setTimeout, clearTimeout},\n\t\t\t...options\n\t\t};\n\n\t\tif (options.signal) {\n\t\t\tconst {signal} = options;\n\t\t\tif (signal.aborted) {\n\t\t\t\treject(getAbortedReason(signal));\n\t\t\t}\n\n\t\t\tsignal.addEventListener('abort', () => {\n\t\t\t\treject(getAbortedReason(signal));\n\t\t\t});\n\t\t}\n\n\t\ttimer = options.customTimers.setTimeout.call(undefined, () => {\n\t\t\tif (typeof fallback === 'function') {\n\t\t\t\ttry {\n\t\t\t\t\tresolve(fallback());\n\t\t\t\t} catch (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst message = typeof fallback === 'string' ? fallback : `Promise timed out after ${milliseconds} milliseconds`;\n\t\t\tconst timeoutError = fallback instanceof Error ? fallback : new TimeoutError(message);\n\n\t\t\tif (typeof promise.cancel === 'function') {\n\t\t\t\tpromise.cancel();\n\t\t\t}\n\n\t\t\treject(timeoutError);\n\t\t}, milliseconds);\n\n\t\t(async () => {\n\t\t\ttry {\n\t\t\t\tresolve(await promise);\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t} finally {\n\t\t\t\toptions.customTimers.clearTimeout.call(undefined, timer);\n\t\t\t}\n\t\t})();\n\t});\n\n\tcancelablePromise.clear = () => {\n\t\tclearTimeout(timer);\n\t\ttimer = undefined;\n\t};\n\n\treturn cancelablePromise;\n}\n", "// Port of lower_bound from https://en.cppreference.com/w/cpp/algorithm/lower_bound\n// Used to compute insertion index to keep queue sorted after insertion\nexport default function lowerBound(array, value, comparator) {\n    let first = 0;\n    let count = array.length;\n    while (count > 0) {\n        const step = Math.trunc(count / 2);\n        let it = first + step;\n        if (comparator(array[it], value) <= 0) {\n            first = ++it;\n            count -= step + 1;\n        }\n        else {\n            count = step;\n        }\n    }\n    return first;\n}\n", "var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _PriorityQueue_queue;\nimport lowerBound from './lower-bound.js';\nclass PriorityQueue {\n    constructor() {\n        _PriorityQueue_queue.set(this, []);\n    }\n    enqueue(run, options) {\n        options = {\n            priority: 0,\n            ...options,\n        };\n        const element = {\n            priority: options.priority,\n            run,\n        };\n        if (this.size && __classPrivateFieldGet(this, _PriorityQueue_queue, \"f\")[this.size - 1].priority >= options.priority) {\n            __classPrivateFieldGet(this, _PriorityQueue_queue, \"f\").push(element);\n            return;\n        }\n        const index = lowerBound(__classPrivateFieldGet(this, _PriorityQueue_queue, \"f\"), element, (a, b) => b.priority - a.priority);\n        __classPrivateFieldGet(this, _PriorityQueue_queue, \"f\").splice(index, 0, element);\n    }\n    dequeue() {\n        const item = __classPrivateFieldGet(this, _PriorityQueue_queue, \"f\").shift();\n        return item === null || item === void 0 ? void 0 : item.run;\n    }\n    filter(options) {\n        return __classPrivateFieldGet(this, _PriorityQueue_queue, \"f\").filter((element) => element.priority === options.priority).map((element) => element.run);\n    }\n    get size() {\n        return __classPrivateFieldGet(this, _PriorityQueue_queue, \"f\").length;\n    }\n}\n_PriorityQueue_queue = new WeakMap();\nexport default PriorityQueue;\n", "var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _PQueue_instances, _PQueue_carryoverConcurrencyCount, _PQueue_isIntervalIgnored, _PQueue_intervalCount, _PQueue_intervalCap, _PQueue_interval, _PQueue_intervalEnd, _PQueue_intervalId, _PQueue_timeoutId, _PQueue_queue, _PQueue_queueClass, _PQueue_pending, _PQueue_concurrency, _PQueue_isPaused, _PQueue_throwOnTimeout, _PQueue_doesIntervalAllowAnother_get, _PQueue_doesConcurrentAllowAnother_get, _PQueue_next, _PQueue_onResumeInterval, _PQueue_isIntervalPaused_get, _PQueue_tryToStartAnother, _PQueue_initializeIntervalIfNeeded, _PQueue_onInterval, _PQueue_processQueue, _PQueue_throwOnAbort, _PQueue_onEvent;\nimport { EventEmitter } from 'eventemitter3';\nimport pTimeout, { TimeoutError } from 'p-timeout';\nimport PriorityQueue from './priority-queue.js';\n/**\nThe error thrown by `queue.add()` when a job is aborted before it is run. See `signal`.\n*/\nexport class AbortError extends Error {\n}\n/**\nPromise queue with concurrency control.\n*/\nclass PQueue extends EventEmitter {\n    // TODO: The `throwOnTimeout` option should affect the return types of `add()` and `addAll()`\n    constructor(options) {\n        var _a, _b, _c, _d;\n        super();\n        _PQueue_instances.add(this);\n        _PQueue_carryoverConcurrencyCount.set(this, void 0);\n        _PQueue_isIntervalIgnored.set(this, void 0);\n        _PQueue_intervalCount.set(this, 0);\n        _PQueue_intervalCap.set(this, void 0);\n        _PQueue_interval.set(this, void 0);\n        _PQueue_intervalEnd.set(this, 0);\n        _PQueue_intervalId.set(this, void 0);\n        _PQueue_timeoutId.set(this, void 0);\n        _PQueue_queue.set(this, void 0);\n        _PQueue_queueClass.set(this, void 0);\n        _PQueue_pending.set(this, 0);\n        // The `!` is needed because of https://github.com/microsoft/TypeScript/issues/32194\n        _PQueue_concurrency.set(this, void 0);\n        _PQueue_isPaused.set(this, void 0);\n        _PQueue_throwOnTimeout.set(this, void 0);\n        /**\n        Per-operation timeout in milliseconds. Operations fulfill once `timeout` elapses if they haven't already.\n    \n        Applies to each future operation.\n        */\n        Object.defineProperty(this, \"timeout\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n        options = {\n            carryoverConcurrencyCount: false,\n            intervalCap: Number.POSITIVE_INFINITY,\n            interval: 0,\n            concurrency: Number.POSITIVE_INFINITY,\n            autoStart: true,\n            queueClass: PriorityQueue,\n            ...options,\n        };\n        if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {\n            throw new TypeError(`Expected \\`intervalCap\\` to be a number from 1 and up, got \\`${(_b = (_a = options.intervalCap) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : ''}\\` (${typeof options.intervalCap})`);\n        }\n        if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {\n            throw new TypeError(`Expected \\`interval\\` to be a finite number >= 0, got \\`${(_d = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ''}\\` (${typeof options.interval})`);\n        }\n        __classPrivateFieldSet(this, _PQueue_carryoverConcurrencyCount, options.carryoverConcurrencyCount, \"f\");\n        __classPrivateFieldSet(this, _PQueue_isIntervalIgnored, options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0, \"f\");\n        __classPrivateFieldSet(this, _PQueue_intervalCap, options.intervalCap, \"f\");\n        __classPrivateFieldSet(this, _PQueue_interval, options.interval, \"f\");\n        __classPrivateFieldSet(this, _PQueue_queue, new options.queueClass(), \"f\");\n        __classPrivateFieldSet(this, _PQueue_queueClass, options.queueClass, \"f\");\n        this.concurrency = options.concurrency;\n        this.timeout = options.timeout;\n        __classPrivateFieldSet(this, _PQueue_throwOnTimeout, options.throwOnTimeout === true, \"f\");\n        __classPrivateFieldSet(this, _PQueue_isPaused, options.autoStart === false, \"f\");\n    }\n    get concurrency() {\n        return __classPrivateFieldGet(this, _PQueue_concurrency, \"f\");\n    }\n    set concurrency(newConcurrency) {\n        if (!(typeof newConcurrency === 'number' && newConcurrency >= 1)) {\n            throw new TypeError(`Expected \\`concurrency\\` to be a number from 1 and up, got \\`${newConcurrency}\\` (${typeof newConcurrency})`);\n        }\n        __classPrivateFieldSet(this, _PQueue_concurrency, newConcurrency, \"f\");\n        __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_processQueue).call(this);\n    }\n    async add(function_, options = {}) {\n        options = {\n            timeout: this.timeout,\n            throwOnTimeout: __classPrivateFieldGet(this, _PQueue_throwOnTimeout, \"f\"),\n            ...options,\n        };\n        return new Promise((resolve, reject) => {\n            __classPrivateFieldGet(this, _PQueue_queue, \"f\").enqueue(async () => {\n                var _a;\n                var _b, _c;\n                __classPrivateFieldSet(this, _PQueue_pending, (_b = __classPrivateFieldGet(this, _PQueue_pending, \"f\"), _b++, _b), \"f\");\n                __classPrivateFieldSet(this, _PQueue_intervalCount, (_c = __classPrivateFieldGet(this, _PQueue_intervalCount, \"f\"), _c++, _c), \"f\");\n                try {\n                    // TODO: Use options.signal?.throwIfAborted() when targeting Node.js 18\n                    if ((_a = options.signal) === null || _a === void 0 ? void 0 : _a.aborted) {\n                        // TODO: Use ABORT_ERR code when targeting Node.js 16 (https://nodejs.org/docs/latest-v16.x/api/errors.html#abort_err)\n                        throw new AbortError('The task was aborted.');\n                    }\n                    let operation = function_({ signal: options.signal });\n                    if (options.timeout) {\n                        operation = pTimeout(Promise.resolve(operation), options.timeout);\n                    }\n                    if (options.signal) {\n                        operation = Promise.race([operation, __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_throwOnAbort).call(this, options.signal)]);\n                    }\n                    const result = await operation;\n                    resolve(result);\n                    this.emit('completed', result);\n                }\n                catch (error) {\n                    if (error instanceof TimeoutError && !options.throwOnTimeout) {\n                        resolve();\n                        return;\n                    }\n                    reject(error);\n                    this.emit('error', error);\n                }\n                finally {\n                    __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_next).call(this);\n                }\n            }, options);\n            this.emit('add');\n            __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_tryToStartAnother).call(this);\n        });\n    }\n    async addAll(functions, options) {\n        return Promise.all(functions.map(async (function_) => this.add(function_, options)));\n    }\n    /**\n    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)\n    */\n    start() {\n        if (!__classPrivateFieldGet(this, _PQueue_isPaused, \"f\")) {\n            return this;\n        }\n        __classPrivateFieldSet(this, _PQueue_isPaused, false, \"f\");\n        __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_processQueue).call(this);\n        return this;\n    }\n    /**\n    Put queue execution on hold.\n    */\n    pause() {\n        __classPrivateFieldSet(this, _PQueue_isPaused, true, \"f\");\n    }\n    /**\n    Clear the queue.\n    */\n    clear() {\n        __classPrivateFieldSet(this, _PQueue_queue, new (__classPrivateFieldGet(this, _PQueue_queueClass, \"f\"))(), \"f\");\n    }\n    /**\n    Can be called multiple times. Useful if you for example add additional items at a later time.\n\n    @returns A promise that settles when the queue becomes empty.\n    */\n    async onEmpty() {\n        // Instantly resolve if the queue is empty\n        if (__classPrivateFieldGet(this, _PQueue_queue, \"f\").size === 0) {\n            return;\n        }\n        await __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onEvent).call(this, 'empty');\n    }\n    /**\n    @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.\n\n    If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.\n\n    Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.\n    */\n    async onSizeLessThan(limit) {\n        // Instantly resolve if the queue is empty.\n        if (__classPrivateFieldGet(this, _PQueue_queue, \"f\").size < limit) {\n            return;\n        }\n        await __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onEvent).call(this, 'next', () => __classPrivateFieldGet(this, _PQueue_queue, \"f\").size < limit);\n    }\n    /**\n    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.\n\n    @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.\n    */\n    async onIdle() {\n        // Instantly resolve if none pending and if nothing else is queued\n        if (__classPrivateFieldGet(this, _PQueue_pending, \"f\") === 0 && __classPrivateFieldGet(this, _PQueue_queue, \"f\").size === 0) {\n            return;\n        }\n        await __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onEvent).call(this, 'idle');\n    }\n    /**\n    Size of the queue, the number of queued items waiting to run.\n    */\n    get size() {\n        return __classPrivateFieldGet(this, _PQueue_queue, \"f\").size;\n    }\n    /**\n    Size of the queue, filtered by the given options.\n\n    For example, this can be used to find the number of items remaining in the queue with a specific priority level.\n    */\n    sizeBy(options) {\n        // eslint-disable-next-line unicorn/no-array-callback-reference\n        return __classPrivateFieldGet(this, _PQueue_queue, \"f\").filter(options).length;\n    }\n    /**\n    Number of running items (no longer in the queue).\n    */\n    get pending() {\n        return __classPrivateFieldGet(this, _PQueue_pending, \"f\");\n    }\n    /**\n    Whether the queue is currently paused.\n    */\n    get isPaused() {\n        return __classPrivateFieldGet(this, _PQueue_isPaused, \"f\");\n    }\n}\n_PQueue_carryoverConcurrencyCount = new WeakMap(), _PQueue_isIntervalIgnored = new WeakMap(), _PQueue_intervalCount = new WeakMap(), _PQueue_intervalCap = new WeakMap(), _PQueue_interval = new WeakMap(), _PQueue_intervalEnd = new WeakMap(), _PQueue_intervalId = new WeakMap(), _PQueue_timeoutId = new WeakMap(), _PQueue_queue = new WeakMap(), _PQueue_queueClass = new WeakMap(), _PQueue_pending = new WeakMap(), _PQueue_concurrency = new WeakMap(), _PQueue_isPaused = new WeakMap(), _PQueue_throwOnTimeout = new WeakMap(), _PQueue_instances = new WeakSet(), _PQueue_doesIntervalAllowAnother_get = function _PQueue_doesIntervalAllowAnother_get() {\n    return __classPrivateFieldGet(this, _PQueue_isIntervalIgnored, \"f\") || __classPrivateFieldGet(this, _PQueue_intervalCount, \"f\") < __classPrivateFieldGet(this, _PQueue_intervalCap, \"f\");\n}, _PQueue_doesConcurrentAllowAnother_get = function _PQueue_doesConcurrentAllowAnother_get() {\n    return __classPrivateFieldGet(this, _PQueue_pending, \"f\") < __classPrivateFieldGet(this, _PQueue_concurrency, \"f\");\n}, _PQueue_next = function _PQueue_next() {\n    var _a;\n    __classPrivateFieldSet(this, _PQueue_pending, (_a = __classPrivateFieldGet(this, _PQueue_pending, \"f\"), _a--, _a), \"f\");\n    __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_tryToStartAnother).call(this);\n    this.emit('next');\n}, _PQueue_onResumeInterval = function _PQueue_onResumeInterval() {\n    __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onInterval).call(this);\n    __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_initializeIntervalIfNeeded).call(this);\n    __classPrivateFieldSet(this, _PQueue_timeoutId, undefined, \"f\");\n}, _PQueue_isIntervalPaused_get = function _PQueue_isIntervalPaused_get() {\n    const now = Date.now();\n    if (__classPrivateFieldGet(this, _PQueue_intervalId, \"f\") === undefined) {\n        const delay = __classPrivateFieldGet(this, _PQueue_intervalEnd, \"f\") - now;\n        if (delay < 0) {\n            // Act as the interval was done\n            // We don't need to resume it here because it will be resumed on line 160\n            __classPrivateFieldSet(this, _PQueue_intervalCount, (__classPrivateFieldGet(this, _PQueue_carryoverConcurrencyCount, \"f\")) ? __classPrivateFieldGet(this, _PQueue_pending, \"f\") : 0, \"f\");\n        }\n        else {\n            // Act as the interval is pending\n            if (__classPrivateFieldGet(this, _PQueue_timeoutId, \"f\") === undefined) {\n                __classPrivateFieldSet(this, _PQueue_timeoutId, setTimeout(() => {\n                    __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onResumeInterval).call(this);\n                }, delay), \"f\");\n            }\n            return true;\n        }\n    }\n    return false;\n}, _PQueue_tryToStartAnother = function _PQueue_tryToStartAnother() {\n    if (__classPrivateFieldGet(this, _PQueue_queue, \"f\").size === 0) {\n        // We can clear the interval (\"pause\")\n        // Because we can redo it later (\"resume\")\n        if (__classPrivateFieldGet(this, _PQueue_intervalId, \"f\")) {\n            clearInterval(__classPrivateFieldGet(this, _PQueue_intervalId, \"f\"));\n        }\n        __classPrivateFieldSet(this, _PQueue_intervalId, undefined, \"f\");\n        this.emit('empty');\n        if (__classPrivateFieldGet(this, _PQueue_pending, \"f\") === 0) {\n            this.emit('idle');\n        }\n        return false;\n    }\n    if (!__classPrivateFieldGet(this, _PQueue_isPaused, \"f\")) {\n        const canInitializeInterval = !__classPrivateFieldGet(this, _PQueue_instances, \"a\", _PQueue_isIntervalPaused_get);\n        if (__classPrivateFieldGet(this, _PQueue_instances, \"a\", _PQueue_doesIntervalAllowAnother_get) && __classPrivateFieldGet(this, _PQueue_instances, \"a\", _PQueue_doesConcurrentAllowAnother_get)) {\n            const job = __classPrivateFieldGet(this, _PQueue_queue, \"f\").dequeue();\n            if (!job) {\n                return false;\n            }\n            this.emit('active');\n            job();\n            if (canInitializeInterval) {\n                __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_initializeIntervalIfNeeded).call(this);\n            }\n            return true;\n        }\n    }\n    return false;\n}, _PQueue_initializeIntervalIfNeeded = function _PQueue_initializeIntervalIfNeeded() {\n    if (__classPrivateFieldGet(this, _PQueue_isIntervalIgnored, \"f\") || __classPrivateFieldGet(this, _PQueue_intervalId, \"f\") !== undefined) {\n        return;\n    }\n    __classPrivateFieldSet(this, _PQueue_intervalId, setInterval(() => {\n        __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onInterval).call(this);\n    }, __classPrivateFieldGet(this, _PQueue_interval, \"f\")), \"f\");\n    __classPrivateFieldSet(this, _PQueue_intervalEnd, Date.now() + __classPrivateFieldGet(this, _PQueue_interval, \"f\"), \"f\");\n}, _PQueue_onInterval = function _PQueue_onInterval() {\n    if (__classPrivateFieldGet(this, _PQueue_intervalCount, \"f\") === 0 && __classPrivateFieldGet(this, _PQueue_pending, \"f\") === 0 && __classPrivateFieldGet(this, _PQueue_intervalId, \"f\")) {\n        clearInterval(__classPrivateFieldGet(this, _PQueue_intervalId, \"f\"));\n        __classPrivateFieldSet(this, _PQueue_intervalId, undefined, \"f\");\n    }\n    __classPrivateFieldSet(this, _PQueue_intervalCount, __classPrivateFieldGet(this, _PQueue_carryoverConcurrencyCount, \"f\") ? __classPrivateFieldGet(this, _PQueue_pending, \"f\") : 0, \"f\");\n    __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_processQueue).call(this);\n}, _PQueue_processQueue = function _PQueue_processQueue() {\n    // eslint-disable-next-line no-empty\n    while (__classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_tryToStartAnother).call(this)) { }\n}, _PQueue_throwOnAbort = async function _PQueue_throwOnAbort(signal) {\n    return new Promise((_resolve, reject) => {\n        signal.addEventListener('abort', () => {\n            // TODO: Reject with signal.throwIfAborted() when targeting Node.js 18\n            // TODO: Use ABORT_ERR code when targeting Node.js 16 (https://nodejs.org/docs/latest-v16.x/api/errors.html#abort_err)\n            reject(new AbortError('The task was aborted.'));\n        }, { once: true });\n    });\n}, _PQueue_onEvent = async function _PQueue_onEvent(event, filter) {\n    return new Promise(resolve => {\n        const listener = () => {\n            if (filter && !filter()) {\n                return;\n            }\n            this.off(event, listener);\n            resolve();\n        };\n        this.on(event, listener);\n    });\n};\nexport default PQueue;\n", "export { urlAlphabet } from './url-alphabet/index.js'\nexport let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\nexport let customRandom = (alphabet, defaultSize, getRandom) => {\n  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1\n  let step = -~((1.6 * mask * defaultSize) / alphabet.length)\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      let j = step\n      while (j--) {\n        id += alphabet[bytes[j] & mask] || ''\n        if (id.length === size) return id\n      }\n    }\n  }\n}\nexport let customAlphabet = (alphabet, size = 21) =>\n  customRandom(alphabet, size, random)\nexport let nanoid = (size = 21) =>\n  crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {\n    byte &= 63\n    if (byte < 36) {\n      id += byte.toString(36)\n    } else if (byte < 62) {\n      id += (byte - 26).toString(36).toUpperCase()\n    } else if (byte > 62) {\n      id += '-'\n    } else {\n      id += '_'\n    }\n    return id\n  }, '')\n", "\nexport const WORKER_REQUEST_READ_LOCK = 'lock:worker:request-read'\nexport const WORKER_RELEASE_READ_LOCK = 'lock:worker:release-read'\nexport const MASTER_GRANT_READ_LOCK = 'lock:master:grant-read'\n\nexport const WORKER_REQUEST_WRITE_LOCK = 'lock:worker:request-write'\nexport const WORKER_RELEASE_WRITE_LOCK = 'lock:worker:release-write'\nexport const MASTER_GRANT_WRITE_LOCK = 'lock:master:grant-write'\n", "export interface WebworkerEventListener <T = any> {\n  (worker: Worker, event: MessageEvent<T>): void\n}\n\nconst events: Record<string, WebworkerEventListener[]> = {}\n\nconst observable = (worker: Worker & { port?: any }) => {\n  worker.addEventListener('message', (event) => {\n    observable.dispatchEvent('message', worker, event)\n  })\n\n  if (worker.port != null) {\n    worker.port.addEventListener('message', (event: any) => {\n      observable.dispatchEvent('message', worker, event)\n    })\n  }\n}\n\nobservable.addEventListener = (type: string, fn: WebworkerEventListener) => {\n  if (events[type] == null) {\n    events[type] = []\n  }\n\n  events[type].push(fn)\n}\n\nobservable.removeEventListener = (type: string, fn: WebworkerEventListener) => {\n  if (events[type] == null) {\n    return\n  }\n\n  events[type] = events[type]\n    .filter(listener => listener === fn)\n}\n\nobservable.dispatchEvent = function (type: string, worker: Worker, event: MessageEvent<any>) {\n  if (events[type] == null) {\n    return\n  }\n\n  events[type].forEach(fn => fn(worker, event))\n}\n\nexport default observable\n", "import { nanoid } from 'nanoid'\nimport {\n  WORKER_REQUEST_READ_LOCK,\n  WORKER_RELEASE_READ_LOCK,\n  MASTER_GRANT_READ_LOCK,\n  WORKER_REQUEST_WRITE_LOCK,\n  WORKER_RELEASE_WRITE_LOCK,\n  MASTER_GRANT_WRITE_LOCK\n} from './constants.js'\nimport observer from 'observable-webworkers'\nimport type { MorticeImplementation, MorticeOptions, Release } from './index.js'\n\nconst handleWorkerLockRequest = (emitter: EventTarget, masterEvent: string, requestType: string, releaseType: string, grantType: string) => {\n  return (worker: Worker, event: MessageEvent) => {\n    if (event.data.type !== requestType) {\n      return\n    }\n\n    const requestEvent = {\n      type: event.data.type,\n      name: event.data.name,\n      identifier: event.data.identifier\n    }\n\n    emitter.dispatchEvent(new MessageEvent(masterEvent, {\n      data: {\n        name: requestEvent.name,\n        handler: async (): Promise<void> => {\n          // grant lock to worker\n          worker.postMessage({\n            type: grantType,\n            name: requestEvent.name,\n            identifier: requestEvent.identifier\n          })\n\n          // wait for worker to finish\n          return await new Promise<void>((resolve) => {\n            const releaseEventListener = (event: MessageEvent) => {\n              if (event == null || event.data == null) {\n                return\n              }\n\n              const releaseEvent = {\n                type: event.data.type,\n                name: event.data.name,\n                identifier: event.data.identifier\n              }\n\n              if (releaseEvent.type === releaseType && releaseEvent.identifier === requestEvent.identifier) {\n                worker.removeEventListener('message', releaseEventListener)\n                resolve()\n              }\n            }\n\n            worker.addEventListener('message', releaseEventListener)\n          })\n        }\n      }\n    }))\n  }\n}\n\nconst makeWorkerLockRequest = (name: string, requestType: string, grantType: string, releaseType: string) => {\n  return async () => {\n    const id = nanoid()\n\n    globalThis.postMessage({\n      type: requestType,\n      identifier: id,\n      name\n    })\n\n    return await new Promise<Release>((resolve) => {\n      const listener = (event: MessageEvent) => {\n        if (event == null || event.data == null) {\n          return\n        }\n\n        const responseEvent = {\n          type: event.data.type,\n          identifier: event.data.identifier\n        }\n\n        if (responseEvent.type === grantType && responseEvent.identifier === id) {\n          globalThis.removeEventListener('message', listener)\n\n          // grant lock\n          resolve(() => {\n            // release lock\n            globalThis.postMessage({\n              type: releaseType,\n              identifier: id,\n              name\n            })\n          })\n        }\n      }\n\n      globalThis.addEventListener('message', listener)\n    })\n  }\n}\n\nconst defaultOptions = {\n  singleProcess: false\n}\n\nexport default (options: Required<MorticeOptions>): MorticeImplementation | EventTarget => {\n  options = Object.assign({}, defaultOptions, options)\n  const isPrimary = Boolean(globalThis.document) || options.singleProcess\n\n  if (isPrimary) {\n    const emitter = new EventTarget()\n\n    observer.addEventListener('message', handleWorkerLockRequest(emitter, 'requestReadLock', WORKER_REQUEST_READ_LOCK, WORKER_RELEASE_READ_LOCK, MASTER_GRANT_READ_LOCK))\n    observer.addEventListener('message', handleWorkerLockRequest(emitter, 'requestWriteLock', WORKER_REQUEST_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK))\n\n    return emitter\n  }\n\n  return {\n    isWorker: true,\n    readLock: (name) => makeWorkerLockRequest(name, WORKER_REQUEST_READ_LOCK, MASTER_GRANT_READ_LOCK, WORKER_RELEASE_READ_LOCK),\n    writeLock: (name) => makeWorkerLockRequest(name, WORKER_REQUEST_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK)\n  }\n}\n", "import PQueue from 'p-queue'\nimport pTimeout from 'p-timeout'\nimport impl from './node.js'\n\nexport interface MorticeOptions {\n  name?: string\n  timeout?: number\n  concurrency?: number\n  singleProcess?: boolean\n}\n\nexport interface Mortice {\n  readLock: () => Promise<Release>\n  writeLock: () => Promise<Release>\n}\n\nexport interface Release {\n  (): void\n}\n\nexport interface MorticeImplementation {\n  isWorker: boolean\n  readLock: (name: string, options: MorticeOptions) => Mortice['readLock']\n  writeLock: (name: string, options: MorticeOptions) => Mortice['writeLock']\n}\n\nconst mutexes: Record<string, Mortice> = {}\nlet implementation: any\n\nasync function createReleaseable (queue: PQueue, options: Required<MorticeOptions>): Promise<Release> {\n  let res: (release: Release) => void\n\n  const p = new Promise<Release>((resolve) => {\n    res = resolve\n  })\n\n  void queue.add(async () => await pTimeout((async () => {\n    return await new Promise<void>((resolve) => {\n      res(() => {\n        resolve()\n      })\n    })\n  })(), {\n    milliseconds: options.timeout\n  }))\n\n  return await p\n}\n\nconst createMutex = (name: string, options: Required<MorticeOptions>): Mortice => {\n  if (implementation.isWorker === true) {\n    return {\n      readLock: implementation.readLock(name, options),\n      writeLock: implementation.writeLock(name, options)\n    }\n  }\n\n  const masterQueue = new PQueue({ concurrency: 1 })\n  let readQueue: PQueue | null\n\n  return {\n    async readLock () {\n      // If there's already a read queue, just add the task to it\n      if (readQueue != null) {\n        return await createReleaseable(readQueue, options)\n      }\n\n      // Create a new read queue\n      readQueue = new PQueue({\n        concurrency: options.concurrency,\n        autoStart: false\n      })\n      const localReadQueue = readQueue\n\n      // Add the task to the read queue\n      const readPromise = createReleaseable(readQueue, options)\n\n      void masterQueue.add(async () => {\n        // Start the task only once the master queue has completed processing\n        // any previous tasks\n        localReadQueue.start()\n\n        // Once all the tasks in the read queue have completed, remove it so\n        // that the next read lock will occur after any write locks that were\n        // started in the interim\n        return await localReadQueue.onIdle()\n          .then(() => {\n            if (readQueue === localReadQueue) {\n              readQueue = null\n            }\n          })\n      })\n\n      return await readPromise\n    },\n    async writeLock () {\n      // Remove the read queue reference, so that any later read locks will be\n      // added to a new queue that starts after this write lock has been\n      // released\n      readQueue = null\n\n      return await createReleaseable(masterQueue, options)\n    }\n  }\n}\n\nconst defaultOptions = {\n  name: 'lock',\n  concurrency: Infinity,\n  timeout: 84600000,\n  singleProcess: false\n}\n\ninterface EventData {\n  name: string\n  handler: () => Promise<void>\n}\n\nexport default function createMortice (options?: MorticeOptions) {\n  const opts: Required<MorticeOptions> = Object.assign({}, defaultOptions, options)\n\n  if (implementation == null) {\n    implementation = impl(opts)\n\n    if (implementation.isWorker !== true) {\n      // we are master, set up worker requests\n      implementation.addEventListener('requestReadLock', (event: MessageEvent<EventData>) => {\n        if (mutexes[event.data.name] == null) {\n          return\n        }\n\n        void mutexes[event.data.name].readLock()\n          .then(async release => await event.data.handler().finally(() => release()))\n      })\n\n      implementation.addEventListener('requestWriteLock', async (event: MessageEvent<EventData>) => {\n        if (mutexes[event.data.name] == null) {\n          return\n        }\n\n        void mutexes[event.data.name].writeLock()\n          .then(async release => await event.data.handler().finally(() => release()))\n      })\n    }\n  }\n\n  if (mutexes[opts.name] == null) {\n    mutexes[opts.name] = createMutex(opts.name, opts)\n  }\n\n  return mutexes[opts.name]\n}\n", "const empty = new Uint8Array(0)\n\n/**\n * @param {Uint8Array} d\n */\nconst toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')\n\n/**\n * @param {string} hex\n */\nconst fromHex = hex => {\n  const hexes = hex.match(/../g)\n  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty\n}\n\n/**\n * @param {Uint8Array} aa\n * @param {Uint8Array} bb\n */\nconst equals = (aa, bb) => {\n  if (aa === bb) return true\n  if (aa.byteLength !== bb.byteLength) {\n    return false\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @param {ArrayBufferView|ArrayBuffer|Uint8Array} o\n * @returns {Uint8Array}\n */\nconst coerce = o => {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o\n  if (o instanceof ArrayBuffer) return new Uint8Array(o)\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)\n  }\n  throw new Error('Unknown type, must be binary type')\n}\n\n/**\n * @param {any} o\n * @returns {o is ArrayBuffer|ArrayBufferView}\n */\nconst isBinary = o =>\n  o instanceof ArrayBuffer || ArrayBuffer.isView(o)\n\n/**\n * @param {string} str\n * @returns {Uint8Array}\n */\nconst fromString = str => (new TextEncoder()).encode(str)\n\n/**\n * @param {Uint8Array} b\n * @returns {string}\n */\nconst toString = b => (new TextDecoder()).decode(b)\n\nexport { equals, coerce, isBinary, fromHex, toHex, fromString, toString, empty }\n", "import basex from '../../vendor/base-x.js'\nimport { coerce } from '../bytes.js'\n// Linter can't see that API is used in types.\n// eslint-disable-next-line\nimport * as API from './interface.js'\n\n/**\n * Class represents both BaseEncoder and MultibaseEncoder meaning it\n * can be used to encode to multibase or base encode without multibase\n * prefix.\n *\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseEncoder<Prefix>}\n * @implements {API.BaseEncoder}\n */\nclass Encoder {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(bytes:Uint8Array) => string} baseEncode\n   */\n  constructor (name, prefix, baseEncode) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n  }\n\n  /**\n   * @param {Uint8Array} bytes\n   * @returns {API.Multibase<Prefix>}\n   */\n  encode (bytes) {\n    if (bytes instanceof Uint8Array) {\n      return `${this.prefix}${this.baseEncode(bytes)}`\n    } else {\n      throw Error('Unknown type, must be binary type')\n    }\n  }\n}\n\n/**\n * @template {string} Prefix\n */\n/**\n * Class represents both BaseDecoder and MultibaseDecoder so it could be used\n * to decode multibases (with matching prefix) or just base decode strings\n * with corresponding base encoding.\n *\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.UnibaseDecoder<Prefix>}\n * @implements {API.BaseDecoder}\n */\nclass Decoder {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(text:string) => Uint8Array} baseDecode\n   */\n  constructor (name, prefix, baseDecode) {\n    this.name = name\n    this.prefix = prefix\n    /* c8 ignore next 3 */\n    if (prefix.codePointAt(0) === undefined) {\n      throw new Error('Invalid prefix character')\n    }\n    /** @private */\n    this.prefixCodePoint = /** @type {number} */ (prefix.codePointAt(0))\n    this.baseDecode = baseDecode\n  }\n\n  /**\n   * @param {string} text\n   */\n  decode (text) {\n    if (typeof text === 'string') {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`)\n      }\n      return this.baseDecode(text.slice(this.prefix.length))\n    } else {\n      throw Error('Can only multibase decode strings')\n    }\n  }\n\n  /**\n   * @template {string} OtherPrefix\n   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder\n   * @returns {ComposedDecoder<Prefix|OtherPrefix>}\n   */\n  or (decoder) {\n    return or(this, decoder)\n  }\n}\n\n/**\n * @template {string} Prefix\n * @typedef {Record<Prefix, API.UnibaseDecoder<Prefix>>} Decoders\n */\n\n/**\n * @template {string} Prefix\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.CombobaseDecoder<Prefix>}\n */\nclass ComposedDecoder {\n  /**\n   * @param {Decoders<Prefix>} decoders\n   */\n  constructor (decoders) {\n    this.decoders = decoders\n  }\n\n  /**\n   * @template {string} OtherPrefix\n   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder\n   * @returns {ComposedDecoder<Prefix|OtherPrefix>}\n   */\n  or (decoder) {\n    return or(this, decoder)\n  }\n\n  /**\n   * @param {string} input\n   * @returns {Uint8Array}\n   */\n  decode (input) {\n    const prefix = /** @type {Prefix} */ (input[0])\n    const decoder = this.decoders[prefix]\n    if (decoder) {\n      return decoder.decode(input)\n    } else {\n      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)\n    }\n  }\n}\n\n/**\n * @template {string} L\n * @template {string} R\n * @param {API.UnibaseDecoder<L>|API.CombobaseDecoder<L>} left\n * @param {API.UnibaseDecoder<R>|API.CombobaseDecoder<R>} right\n * @returns {ComposedDecoder<L|R>}\n */\nexport const or = (left, right) => new ComposedDecoder(/** @type {Decoders<L|R>} */({\n  ...(left.decoders || { [/** @type API.UnibaseDecoder<L> */(left).prefix]: left }),\n  ...(right.decoders || { [/** @type API.UnibaseDecoder<R> */(right).prefix]: right })\n}))\n\n/**\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseCodec<Prefix>}\n * @implements {API.MultibaseEncoder<Prefix>}\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.BaseCodec}\n * @implements {API.BaseEncoder}\n * @implements {API.BaseDecoder}\n */\nexport class Codec {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(bytes:Uint8Array) => string} baseEncode\n   * @param {(text:string) => Uint8Array} baseDecode\n   */\n  constructor (name, prefix, baseEncode, baseDecode) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n    this.baseDecode = baseDecode\n    this.encoder = new Encoder(name, prefix, baseEncode)\n    this.decoder = new Decoder(name, prefix, baseDecode)\n  }\n\n  /**\n   * @param {Uint8Array} input\n   */\n  encode (input) {\n    return this.encoder.encode(input)\n  }\n\n  /**\n   * @param {string} input\n   */\n  decode (input) {\n    return this.decoder.decode(input)\n  }\n}\n\n/**\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {(bytes:Uint8Array) => string} options.encode\n * @param {(input:string) => Uint8Array} options.decode\n * @returns {Codec<Base, Prefix>}\n */\nexport const from = ({ name, prefix, encode, decode }) =>\n  new Codec(name, prefix, encode, decode)\n\n/**\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {string} options.alphabet\n * @returns {Codec<Base, Prefix>}\n */\nexport const baseX = ({ prefix, name, alphabet }) => {\n  const { encode, decode } = basex(alphabet, name)\n  return from({\n    prefix,\n    name,\n    encode,\n    /**\n     * @param {string} text\n     */\n    decode: text => coerce(decode(text))\n  })\n}\n\n/**\n * @param {string} string\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @param {string} name\n * @returns {Uint8Array}\n */\nconst decode = (string, alphabet, bitsPerChar, name) => {\n  // Build the character lookup table:\n  /** @type {Record<string, number>} */\n  const codes = {}\n  for (let i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i\n  }\n\n  // Count the padding bytes:\n  let end = string.length\n  while (string[end - 1] === '=') {\n    --end\n  }\n\n  // Allocate the output:\n  const out = new Uint8Array((end * bitsPerChar / 8) | 0)\n\n  // Parse the data:\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  let written = 0 // Next byte to write\n  for (let i = 0; i < end; ++i) {\n    // Read one character from the string:\n    const value = codes[string[i]]\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${name} character`)\n    }\n\n    // Append the bits to the buffer:\n    buffer = (buffer << bitsPerChar) | value\n    bits += bitsPerChar\n\n    // Write out some bits if the buffer has a byte's worth:\n    if (bits >= 8) {\n      bits -= 8\n      out[written++] = 0xff & (buffer >> bits)\n    }\n  }\n\n  // Verify that we have received just enough bits:\n  if (bits >= bitsPerChar || 0xff & (buffer << (8 - bits))) {\n    throw new SyntaxError('Unexpected end of data')\n  }\n\n  return out\n}\n\n/**\n * @param {Uint8Array} data\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @returns {string}\n */\nconst encode = (data, alphabet, bitsPerChar) => {\n  const pad = alphabet[alphabet.length - 1] === '='\n  const mask = (1 << bitsPerChar) - 1\n  let out = ''\n\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  for (let i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = (buffer << 8) | data[i]\n    bits += 8\n\n    // Write out as much as we can:\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar\n      out += alphabet[mask & (buffer >> bits)]\n    }\n  }\n\n  // Partial character:\n  if (bits) {\n    out += alphabet[mask & (buffer << (bitsPerChar - bits))]\n  }\n\n  // Add padding characters until we hit a byte boundary:\n  if (pad) {\n    while ((out.length * bitsPerChar) & 7) {\n      out += '='\n    }\n  }\n\n  return out\n}\n\n/**\n * RFC4648 Factory\n *\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {string} options.alphabet\n * @param {number} options.bitsPerChar\n */\nexport const rfc4648 = ({ name, prefix, bitsPerChar, alphabet }) => {\n  return from({\n    prefix,\n    name,\n    encode (input) {\n      return encode(input, alphabet, bitsPerChar)\n    },\n    decode (input) {\n      return decode(input, alphabet, bitsPerChar, name)\n    }\n  })\n}\n", "import { rfc4648 } from './base.js'\n\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n})\n\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n})\n\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n})\n\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n})\n\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n})\n\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n})\n\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n})\n\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n})\n\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n})\n", "export const codes = {\n  ERR_INVALID_PARAMETERS: 'ERR_INVALID_PARAMETERS'\n}\n", "/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nimport { encodeMessage, decodeMessage, message } from 'protons-runtime'\nimport type { Codec } from 'protons-runtime'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface Peer {\n  addresses: Address[]\n  protocols: string[]\n  publicKey?: Uint8Array\n  peerRecordEnvelope?: Uint8Array\n  metadata: Map<string, Uint8Array>\n  tags: Map<string, Tag>\n}\n\nexport namespace Peer {\n  export interface Peer$metadataEntry {\n    key: string\n    value: Uint8Array\n  }\n\n  export namespace Peer$metadataEntry {\n    let _codec: Codec<Peer$metadataEntry>\n\n    export const codec = (): Codec<Peer$metadataEntry> => {\n      if (_codec == null) {\n        _codec = message<Peer$metadataEntry>((obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork()\n          }\n\n          if ((obj.key != null && obj.key !== '')) {\n            w.uint32(10)\n            w.string(obj.key)\n          }\n\n          if ((obj.value != null && obj.value.byteLength > 0)) {\n            w.uint32(18)\n            w.bytes(obj.value)\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim()\n          }\n        }, (reader, length) => {\n          const obj: any = {\n            key: '',\n            value: new Uint8Array(0)\n          }\n\n          const end = length == null ? reader.len : reader.pos + length\n\n          while (reader.pos < end) {\n            const tag = reader.uint32()\n\n            switch (tag >>> 3) {\n              case 1:\n                obj.key = reader.string()\n                break\n              case 2:\n                obj.value = reader.bytes()\n                break\n              default:\n                reader.skipType(tag & 7)\n                break\n            }\n          }\n\n          return obj\n        })\n      }\n\n      return _codec\n    }\n\n    export const encode = (obj: Partial<Peer$metadataEntry>): Uint8Array => {\n      return encodeMessage(obj, Peer$metadataEntry.codec())\n    }\n\n    export const decode = (buf: Uint8Array | Uint8ArrayList): Peer$metadataEntry => {\n      return decodeMessage(buf, Peer$metadataEntry.codec())\n    }\n  }\n\n  export interface Peer$tagsEntry {\n    key: string\n    value?: Tag\n  }\n\n  export namespace Peer$tagsEntry {\n    let _codec: Codec<Peer$tagsEntry>\n\n    export const codec = (): Codec<Peer$tagsEntry> => {\n      if (_codec == null) {\n        _codec = message<Peer$tagsEntry>((obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork()\n          }\n\n          if ((obj.key != null && obj.key !== '')) {\n            w.uint32(10)\n            w.string(obj.key)\n          }\n\n          if (obj.value != null) {\n            w.uint32(18)\n            Tag.codec().encode(obj.value, w)\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim()\n          }\n        }, (reader, length) => {\n          const obj: any = {\n            key: ''\n          }\n\n          const end = length == null ? reader.len : reader.pos + length\n\n          while (reader.pos < end) {\n            const tag = reader.uint32()\n\n            switch (tag >>> 3) {\n              case 1:\n                obj.key = reader.string()\n                break\n              case 2:\n                obj.value = Tag.codec().decode(reader, reader.uint32())\n                break\n              default:\n                reader.skipType(tag & 7)\n                break\n            }\n          }\n\n          return obj\n        })\n      }\n\n      return _codec\n    }\n\n    export const encode = (obj: Partial<Peer$tagsEntry>): Uint8Array => {\n      return encodeMessage(obj, Peer$tagsEntry.codec())\n    }\n\n    export const decode = (buf: Uint8Array | Uint8ArrayList): Peer$tagsEntry => {\n      return decodeMessage(buf, Peer$tagsEntry.codec())\n    }\n  }\n\n  let _codec: Codec<Peer>\n\n  export const codec = (): Codec<Peer> => {\n    if (_codec == null) {\n      _codec = message<Peer>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.addresses != null) {\n          for (const value of obj.addresses) {\n            w.uint32(10)\n            Address.codec().encode(value, w)\n          }\n        }\n\n        if (obj.protocols != null) {\n          for (const value of obj.protocols) {\n            w.uint32(18)\n            w.string(value)\n          }\n        }\n\n        if (obj.publicKey != null) {\n          w.uint32(34)\n          w.bytes(obj.publicKey)\n        }\n\n        if (obj.peerRecordEnvelope != null) {\n          w.uint32(42)\n          w.bytes(obj.peerRecordEnvelope)\n        }\n\n        if (obj.metadata != null && obj.metadata.size !== 0) {\n          for (const [key, value] of obj.metadata.entries()) {\n            w.uint32(50)\n            Peer.Peer$metadataEntry.codec().encode({ key, value }, w)\n          }\n        }\n\n        if (obj.tags != null && obj.tags.size !== 0) {\n          for (const [key, value] of obj.tags.entries()) {\n            w.uint32(58)\n            Peer.Peer$tagsEntry.codec().encode({ key, value }, w)\n          }\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {\n          addresses: [],\n          protocols: [],\n          metadata: new Map<string, Uint8Array>(),\n          tags: new Map<string, undefined>()\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.addresses.push(Address.codec().decode(reader, reader.uint32()))\n              break\n            case 2:\n              obj.protocols.push(reader.string())\n              break\n            case 4:\n              obj.publicKey = reader.bytes()\n              break\n            case 5:\n              obj.peerRecordEnvelope = reader.bytes()\n              break\n            case 6: {\n              const entry = Peer.Peer$metadataEntry.codec().decode(reader, reader.uint32())\n              obj.metadata.set(entry.key, entry.value)\n              break\n            }\n            case 7: {\n              const entry = Peer.Peer$tagsEntry.codec().decode(reader, reader.uint32())\n              obj.tags.set(entry.key, entry.value)\n              break\n            }\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Peer>): Uint8Array => {\n    return encodeMessage(obj, Peer.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): Peer => {\n    return decodeMessage(buf, Peer.codec())\n  }\n}\n\nexport interface Address {\n  multiaddr: Uint8Array\n  isCertified?: boolean\n}\n\nexport namespace Address {\n  let _codec: Codec<Address>\n\n  export const codec = (): Codec<Address> => {\n    if (_codec == null) {\n      _codec = message<Address>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if ((obj.multiaddr != null && obj.multiaddr.byteLength > 0)) {\n          w.uint32(10)\n          w.bytes(obj.multiaddr)\n        }\n\n        if (obj.isCertified != null) {\n          w.uint32(16)\n          w.bool(obj.isCertified)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {\n          multiaddr: new Uint8Array(0)\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.multiaddr = reader.bytes()\n              break\n            case 2:\n              obj.isCertified = reader.bool()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Address>): Uint8Array => {\n    return encodeMessage(obj, Address.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): Address => {\n    return decodeMessage(buf, Address.codec())\n  }\n}\n\nexport interface Tag {\n  value: number\n  expiry?: bigint\n}\n\nexport namespace Tag {\n  let _codec: Codec<Tag>\n\n  export const codec = (): Codec<Tag> => {\n    if (_codec == null) {\n      _codec = message<Tag>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if ((obj.value != null && obj.value !== 0)) {\n          w.uint32(8)\n          w.uint32(obj.value)\n        }\n\n        if (obj.expiry != null) {\n          w.uint32(16)\n          w.uint64(obj.expiry)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {\n          value: 0\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.value = reader.uint32()\n              break\n            case 2:\n              obj.expiry = reader.uint64()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Tag>): Uint8Array => {\n    return encodeMessage(obj, Tag.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): Tag => {\n    return decodeMessage(buf, Tag.codec())\n  }\n}\n", "import { peerIdFromPeerId } from '@libp2p/peer-id'\nimport { multiaddr } from '@multiformats/multiaddr'\nimport { Peer as PeerPB } from '../pb/peer.js'\nimport type { PeerId } from '@libp2p/interface/peer-id'\nimport type { Peer, Tag } from '@libp2p/interface/peer-store'\n\nexport function bytesToPeer (peerId: PeerId, buf: Uint8Array): Peer {\n  const peer = PeerPB.decode(buf)\n\n  if (peer.publicKey != null && peerId.publicKey == null) {\n    peerId = peerIdFromPeerId({\n      ...peerId,\n      publicKey: peerId.publicKey\n    })\n  }\n\n  const tags = new Map<string, Tag>()\n\n  // remove any expired tags\n  const now = BigInt(Date.now())\n\n  for (const [key, tag] of peer.tags.entries()) {\n    if (tag.expiry != null && tag.expiry < now) {\n      continue\n    }\n\n    tags.set(key, tag)\n  }\n\n  return {\n    ...peer,\n    id: peerId,\n    addresses: peer.addresses.map(({ multiaddr: ma, isCertified }) => {\n      return {\n        multiaddr: multiaddr(ma),\n        isCertified: isCertified ?? false\n      }\n    }),\n    metadata: peer.metadata,\n    peerRecordEnvelope: peer.peerRecordEnvelope ?? undefined,\n    tags\n  }\n}\n", "import { CodeError } from '@libp2p/interface/errors'\nimport { isPeerId, type PeerId } from '@libp2p/interface/peer-id'\nimport { Key } from 'interface-datastore/key'\nimport { codes } from '../errors.js'\n\nexport const NAMESPACE_COMMON = '/peers/'\n\nexport function peerIdToDatastoreKey (peerId: PeerId): Key {\n  if (!isPeerId(peerId) || peerId.type == null) {\n    throw new CodeError('Invalid PeerId', codes.ERR_INVALID_PARAMETERS)\n  }\n\n  const b32key = peerId.toCID().toString()\n  return new Key(`${NAMESPACE_COMMON}${b32key}`)\n}\n", "import { CodeError } from '@libp2p/interface/errors'\nimport { isMultiaddr, multiaddr } from '@multiformats/multiaddr'\nimport { codes } from '../errors.js'\nimport type { AddressFilter } from '../index.js'\nimport type { Address as AddressPB } from '../pb/peer.js'\nimport type { PeerId } from '@libp2p/interface/peer-id'\nimport type { Address } from '@libp2p/interface/peer-store'\n\nexport async function dedupeFilterAndSortAddresses (peerId: PeerId, filter: AddressFilter, addresses: Array<Address | AddressPB | undefined>): Promise<AddressPB[]> {\n  const addressMap = new Map<string, Address>()\n\n  for (const addr of addresses) {\n    if (addr == null) {\n      continue\n    }\n\n    if (addr.multiaddr instanceof Uint8Array) {\n      addr.multiaddr = multiaddr(addr.multiaddr)\n    }\n\n    if (!isMultiaddr(addr.multiaddr)) {\n      throw new CodeError('Multiaddr was invalid', codes.ERR_INVALID_PARAMETERS)\n    }\n\n    if (!(await filter(peerId, addr.multiaddr))) {\n      continue\n    }\n\n    const isCertified = addr.isCertified ?? false\n    const maStr = addr.multiaddr.toString()\n    const existingAddr = addressMap.get(maStr)\n\n    if (existingAddr != null) {\n      addr.isCertified = existingAddr.isCertified || isCertified\n    } else {\n      addressMap.set(maStr, {\n        multiaddr: addr.multiaddr,\n        isCertified\n      })\n    }\n  }\n\n  return [...addressMap.values()]\n    .sort((a, b) => {\n      return a.multiaddr.toString().localeCompare(b.multiaddr.toString())\n    })\n    .map(({ isCertified, multiaddr }) => ({\n      isCertified,\n      multiaddr: multiaddr.bytes\n    }))\n}\n", "import { CodeError } from '@libp2p/interface/errors'\nimport { equals as uint8arrayEquals } from 'uint8arrays/equals'\nimport { codes } from '../errors.js'\nimport { dedupeFilterAndSortAddresses } from './dedupe-addresses.js'\nimport type { AddressFilter } from '../index.js'\nimport type { Tag, Peer as PeerPB } from '../pb/peer.js'\nimport type { PeerId } from '@libp2p/interface/peer-id'\nimport type { Address, Peer, PeerData, TagOptions } from '@libp2p/interface/peer-store'\n\nexport interface ToPBPeerOptions {\n  addressFilter?: AddressFilter\n  existingPeer?: Peer\n}\n\nexport async function toPeerPB (peerId: PeerId, data: Partial<PeerData>, strategy: 'merge' | 'patch', options: ToPBPeerOptions): Promise<PeerPB> {\n  if (data == null) {\n    throw new CodeError('Invalid PeerData', codes.ERR_INVALID_PARAMETERS)\n  }\n\n  if (data.publicKey != null && peerId.publicKey != null && !uint8arrayEquals(data.publicKey, peerId.publicKey)) {\n    throw new CodeError('publicKey bytes do not match peer id publicKey bytes', codes.ERR_INVALID_PARAMETERS)\n  }\n\n  const existingPeer = options.existingPeer\n\n  if (existingPeer != null && !peerId.equals(existingPeer.id)) {\n    throw new CodeError('peer id did not match existing peer id', codes.ERR_INVALID_PARAMETERS)\n  }\n\n  let addresses: Address[] = existingPeer?.addresses ?? []\n  let protocols = new Set<string>(existingPeer?.protocols ?? [])\n  let metadata: Map<string, Uint8Array> = existingPeer?.metadata ?? new Map()\n  let tags: Map<string, Tag> = existingPeer?.tags ?? new Map()\n  let peerRecordEnvelope: Uint8Array | undefined = existingPeer?.peerRecordEnvelope\n\n  // when patching, we replace the original fields with passed values\n  if (strategy === 'patch') {\n    if (data.multiaddrs != null || data.addresses != null) {\n      addresses = []\n\n      if (data.multiaddrs != null) {\n        addresses.push(...data.multiaddrs.map(multiaddr => ({\n          isCertified: false,\n          multiaddr\n        })))\n      }\n\n      if (data.addresses != null) {\n        addresses.push(...data.addresses)\n      }\n    }\n\n    if (data.protocols != null) {\n      protocols = new Set(data.protocols)\n    }\n\n    if (data.metadata != null) {\n      const metadataEntries = data.metadata instanceof Map ? [...data.metadata.entries()] : Object.entries(data.metadata)\n\n      metadata = createSortedMap(metadataEntries, {\n        validate: validateMetadata\n      })\n    }\n\n    if (data.tags != null) {\n      const tagsEntries = data.tags instanceof Map ? [...data.tags.entries()] : Object.entries(data.tags)\n\n      tags = createSortedMap(tagsEntries, {\n        validate: validateTag,\n        map: mapTag\n      })\n    }\n\n    if (data.peerRecordEnvelope != null) {\n      peerRecordEnvelope = data.peerRecordEnvelope\n    }\n  }\n\n  // when merging, we join the original fields with passed values\n  if (strategy === 'merge') {\n    if (data.multiaddrs != null) {\n      addresses.push(...data.multiaddrs.map(multiaddr => ({\n        isCertified: false,\n        multiaddr\n      })))\n    }\n\n    if (data.addresses != null) {\n      addresses.push(...data.addresses)\n    }\n\n    if (data.protocols != null) {\n      protocols = new Set([...protocols, ...data.protocols])\n    }\n\n    if (data.metadata != null) {\n      const metadataEntries = data.metadata instanceof Map ? [...data.metadata.entries()] : Object.entries(data.metadata)\n\n      for (const [key, value] of metadataEntries) {\n        if (value == null) {\n          metadata.delete(key)\n        } else {\n          metadata.set(key, value)\n        }\n      }\n\n      metadata = createSortedMap([...metadata.entries()], {\n        validate: validateMetadata\n      })\n    }\n\n    if (data.tags != null) {\n      const tagsEntries = data.tags instanceof Map ? [...data.tags.entries()] : Object.entries(data.tags)\n      const mergedTags = new Map<string, Tag | TagOptions>(tags)\n\n      for (const [key, value] of tagsEntries) {\n        if (value == null) {\n          mergedTags.delete(key)\n        } else {\n          mergedTags.set(key, value)\n        }\n      }\n\n      tags = createSortedMap([...mergedTags.entries()], {\n        validate: validateTag,\n        map: mapTag\n      })\n    }\n\n    if (data.peerRecordEnvelope != null) {\n      peerRecordEnvelope = data.peerRecordEnvelope\n    }\n  }\n\n  const output: PeerPB = {\n    addresses: await dedupeFilterAndSortAddresses(peerId, options.addressFilter ?? (async () => true), addresses),\n    protocols: [...protocols.values()].sort((a, b) => {\n      return a.localeCompare(b)\n    }),\n    metadata,\n    tags,\n\n    publicKey: existingPeer?.id.publicKey ?? data.publicKey ?? peerId.publicKey,\n    peerRecordEnvelope\n  }\n\n  // Ed25519 and secp256k1 have their public key embedded in them so no need to duplicate it\n  if (peerId.type !== 'RSA') {\n    delete output.publicKey\n  }\n\n  return output\n}\n\ninterface CreateSortedMapOptions <V, R = V> {\n  validate(key: string, value: V): void\n  map?(key: string, value: V): R\n}\n\n/**\n * In JS maps are ordered by insertion order so create a new map with the\n * keys inserted in alphabetical order.\n */\nfunction createSortedMap <V, R = V> (entries: Array<[string, V | undefined]>, options: CreateSortedMapOptions<V, R>): Map<string, R> {\n  const output = new Map()\n\n  for (const [key, value] of entries) {\n    if (value == null) {\n      continue\n    }\n\n    options.validate(key, value)\n  }\n\n  for (const [key, value] of entries.sort(([a], [b]) => {\n    return a.localeCompare(b)\n  })) {\n    if (value != null) {\n      output.set(key, options.map?.(key, value) ?? value)\n    }\n  }\n\n  return output\n}\n\nfunction validateMetadata (key: string, value: Uint8Array): void {\n  if (typeof key !== 'string') {\n    throw new CodeError('Metadata key must be a string', codes.ERR_INVALID_PARAMETERS)\n  }\n\n  if (!(value instanceof Uint8Array)) {\n    throw new CodeError('Metadata value must be a Uint8Array', codes.ERR_INVALID_PARAMETERS)\n  }\n}\n\nfunction validateTag (key: string, tag: TagOptions): void {\n  if (typeof key !== 'string') {\n    throw new CodeError('Tag name must be a string', codes.ERR_INVALID_PARAMETERS)\n  }\n\n  if (tag.value != null) {\n    if (parseInt(`${tag.value}`, 10) !== tag.value) {\n      throw new CodeError('Tag value must be an integer', codes.ERR_INVALID_PARAMETERS)\n    }\n\n    if (tag.value < 0 || tag.value > 100) {\n      throw new CodeError('Tag value must be between 0-100', codes.ERR_INVALID_PARAMETERS)\n    }\n  }\n\n  if (tag.ttl != null) {\n    if (parseInt(`${tag.ttl}`, 10) !== tag.ttl) {\n      throw new CodeError('Tag ttl must be an integer', codes.ERR_INVALID_PARAMETERS)\n    }\n\n    if (tag.ttl < 0) {\n      throw new CodeError('Tag ttl must be between greater than 0', codes.ERR_INVALID_PARAMETERS)\n    }\n  }\n}\n\nfunction mapTag (key: string, tag: any): Tag {\n  let expiry: bigint | undefined\n\n  if (tag.expiry != null) {\n    expiry = tag.expiry\n  }\n\n  if (tag.ttl != null) {\n    expiry = BigInt(Date.now() + Number(tag.ttl))\n  }\n\n  return {\n    value: tag.value ?? 0,\n    expiry\n  }\n}\n", "import { CodeError } from '@libp2p/interface/errors'\nimport { PeerMap } from '@libp2p/peer-collections'\nimport { peerIdFromBytes } from '@libp2p/peer-id'\nimport mortice, { type Mortice } from 'mortice'\nimport { base32 } from 'multiformats/bases/base32'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { codes } from './errors.js'\nimport { Peer as PeerPB } from './pb/peer.js'\nimport { bytesToPeer } from './utils/bytes-to-peer.js'\nimport { NAMESPACE_COMMON, peerIdToDatastoreKey } from './utils/peer-id-to-datastore-key.js'\nimport { toPeerPB } from './utils/to-peer-pb.js'\nimport type { AddressFilter, PersistentPeerStoreComponents, PersistentPeerStoreInit } from './index.js'\nimport type { PeerUpdate as PeerUpdateExternal } from '@libp2p/interface'\nimport type { PeerId } from '@libp2p/interface/peer-id'\nimport type { Peer, PeerData, PeerQuery } from '@libp2p/interface/peer-store'\nimport type { Datastore, Key, Query } from 'interface-datastore'\n\n/**\n * Event detail emitted when peer data changes\n */\nexport interface PeerUpdate extends PeerUpdateExternal {\n  updated: boolean\n}\n\nfunction decodePeer (key: Key, value: Uint8Array, cache: PeerMap<Peer>): Peer {\n  // /peers/${peer-id-as-libp2p-key-cid-string-in-base-32}\n  const base32Str = key.toString().split('/')[2]\n  const buf = base32.decode(base32Str)\n  const peerId = peerIdFromBytes(buf)\n\n  const cached = cache.get(peerId)\n\n  if (cached != null) {\n    return cached\n  }\n\n  const peer = bytesToPeer(peerId, value)\n\n  cache.set(peerId, peer)\n\n  return peer\n}\n\nfunction mapQuery (query: PeerQuery, cache: PeerMap<Peer>): Query {\n  if (query == null) {\n    return {}\n  }\n\n  return {\n    prefix: NAMESPACE_COMMON,\n    filters: (query.filters ?? []).map(fn => ({ key, value }) => {\n      return fn(decodePeer(key, value, cache))\n    }),\n    orders: (query.orders ?? []).map(fn => (a, b) => {\n      return fn(decodePeer(a.key, a.value, cache), decodePeer(b.key, b.value, cache))\n    })\n  }\n}\n\nexport class PersistentStore {\n  private readonly peerId: PeerId\n  private readonly datastore: Datastore\n  public readonly lock: Mortice\n  private readonly addressFilter?: AddressFilter\n\n  constructor (components: PersistentPeerStoreComponents, init: PersistentPeerStoreInit = {}) {\n    this.peerId = components.peerId\n    this.datastore = components.datastore\n    this.addressFilter = init.addressFilter\n    this.lock = mortice({\n      name: 'peer-store',\n      singleProcess: true\n    })\n  }\n\n  async has (peerId: PeerId): Promise<boolean> {\n    return this.datastore.has(peerIdToDatastoreKey(peerId))\n  }\n\n  async delete (peerId: PeerId): Promise<void> {\n    if (this.peerId.equals(peerId)) {\n      throw new CodeError('Cannot delete self peer', codes.ERR_INVALID_PARAMETERS)\n    }\n\n    await this.datastore.delete(peerIdToDatastoreKey(peerId))\n  }\n\n  async load (peerId: PeerId): Promise<Peer> {\n    const buf = await this.datastore.get(peerIdToDatastoreKey(peerId))\n\n    return bytesToPeer(peerId, buf)\n  }\n\n  async save (peerId: PeerId, data: PeerData): Promise<PeerUpdate> {\n    const {\n      existingBuf,\n      existingPeer\n    } = await this.#findExistingPeer(peerId)\n\n    const peerPb: PeerPB = await toPeerPB(peerId, data, 'patch', {\n      addressFilter: this.addressFilter\n    })\n\n    return this.#saveIfDifferent(peerId, peerPb, existingBuf, existingPeer)\n  }\n\n  async patch (peerId: PeerId, data: Partial<PeerData>): Promise<PeerUpdate> {\n    const {\n      existingBuf,\n      existingPeer\n    } = await this.#findExistingPeer(peerId)\n\n    const peerPb: PeerPB = await toPeerPB(peerId, data, 'patch', {\n      addressFilter: this.addressFilter,\n      existingPeer\n    })\n\n    return this.#saveIfDifferent(peerId, peerPb, existingBuf, existingPeer)\n  }\n\n  async merge (peerId: PeerId, data: PeerData): Promise<PeerUpdate> {\n    const {\n      existingBuf,\n      existingPeer\n    } = await this.#findExistingPeer(peerId)\n\n    const peerPb: PeerPB = await toPeerPB(peerId, data, 'merge', {\n      addressFilter: this.addressFilter,\n      existingPeer\n    })\n\n    return this.#saveIfDifferent(peerId, peerPb, existingBuf, existingPeer)\n  }\n\n  async * all (query?: PeerQuery): AsyncGenerator<Peer, void, unknown> {\n    const peerCache = new PeerMap<Peer>()\n\n    for await (const { key, value } of this.datastore.query(mapQuery(query ?? {}, peerCache))) {\n      const peer = decodePeer(key, value, peerCache)\n\n      if (peer.id.equals(this.peerId)) {\n        // Skip self peer if present\n        continue\n      }\n\n      yield peer\n    }\n  }\n\n  async #findExistingPeer (peerId: PeerId): Promise<{ existingBuf?: Uint8Array, existingPeer?: Peer }> {\n    try {\n      const existingBuf = await this.datastore.get(peerIdToDatastoreKey(peerId))\n      const existingPeer = bytesToPeer(peerId, existingBuf)\n\n      return {\n        existingBuf,\n        existingPeer\n      }\n    } catch (err: any) {\n      if (err.code !== 'ERR_NOT_FOUND') {\n        throw err\n      }\n    }\n\n    return {}\n  }\n\n  async #saveIfDifferent (peerId: PeerId, peer: PeerPB, existingBuf?: Uint8Array, existingPeer?: Peer): Promise<PeerUpdate> {\n    const buf = PeerPB.encode(peer)\n\n    if (existingBuf != null && uint8ArrayEquals(buf, existingBuf)) {\n      return {\n        peer: bytesToPeer(peerId, buf),\n        previous: existingPeer,\n        updated: false\n      }\n    }\n\n    await this.datastore.put(peerIdToDatastoreKey(peerId), buf)\n\n    return {\n      peer: bytesToPeer(peerId, buf),\n      previous: existingPeer,\n      updated: true\n    }\n  }\n}\n", "import { logger } from '@libp2p/logger'\nimport { RecordEnvelope, PeerRecord } from '@libp2p/peer-record'\nimport all from 'it-all'\nimport { PersistentStore, type PeerUpdate } from './store.js'\nimport type { Libp2pEvents } from '@libp2p/interface'\nimport type { TypedEventTarget } from '@libp2p/interface/events'\nimport type { PeerId } from '@libp2p/interface/peer-id'\nimport type { PeerStore, Peer, PeerData, PeerQuery } from '@libp2p/interface/peer-store'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { Datastore } from 'interface-datastore'\n\nconst log = logger('libp2p:peer-store')\n\nexport interface PersistentPeerStoreComponents {\n  peerId: PeerId\n  datastore: Datastore\n  events: TypedEventTarget<Libp2pEvents>\n}\n\n/**\n * Return true to allow storing the passed multiaddr for the passed peer\n */\nexport interface AddressFilter {\n  (peerId: PeerId, multiaddr: Multiaddr): Promise<boolean>\n}\n\nexport interface PersistentPeerStoreInit {\n  addressFilter?: AddressFilter\n}\n\n/**\n * An implementation of PeerStore that stores data in a Datastore\n */\nexport class PersistentPeerStore implements PeerStore {\n  private readonly store: PersistentStore\n  private readonly events: TypedEventTarget<Libp2pEvents>\n  private readonly peerId: PeerId\n\n  constructor (components: PersistentPeerStoreComponents, init: PersistentPeerStoreInit = {}) {\n    this.events = components.events\n    this.peerId = components.peerId\n    this.store = new PersistentStore(components, init)\n  }\n\n  async forEach (fn: (peer: Peer,) => void, query?: PeerQuery): Promise<void> {\n    log.trace('forEach await read lock')\n    const release = await this.store.lock.readLock()\n    log.trace('forEach got read lock')\n\n    try {\n      for await (const peer of this.store.all(query)) {\n        fn(peer)\n      }\n    } finally {\n      log.trace('forEach release read lock')\n      release()\n    }\n  }\n\n  async all (query?: PeerQuery): Promise<Peer[]> {\n    log.trace('all await read lock')\n    const release = await this.store.lock.readLock()\n    log.trace('all got read lock')\n\n    try {\n      return await all(this.store.all(query))\n    } finally {\n      log.trace('all release read lock')\n      release()\n    }\n  }\n\n  async delete (peerId: PeerId): Promise<void> {\n    log.trace('delete await write lock')\n    const release = await this.store.lock.writeLock()\n    log.trace('delete got write lock')\n\n    try {\n      await this.store.delete(peerId)\n    } finally {\n      log.trace('delete release write lock')\n      release()\n    }\n  }\n\n  async has (peerId: PeerId): Promise<boolean> {\n    log.trace('has await read lock')\n    const release = await this.store.lock.readLock()\n    log.trace('has got read lock')\n\n    try {\n      return await this.store.has(peerId)\n    } finally {\n      log.trace('has release read lock')\n      release()\n    }\n  }\n\n  async get (peerId: PeerId): Promise<Peer> {\n    log.trace('get await read lock')\n    const release = await this.store.lock.readLock()\n    log.trace('get got read lock')\n\n    try {\n      return await this.store.load(peerId)\n    } finally {\n      log.trace('get release read lock')\n      release()\n    }\n  }\n\n  async save (id: PeerId, data: PeerData): Promise<Peer> {\n    log.trace('save await write lock')\n    const release = await this.store.lock.writeLock()\n    log.trace('save got write lock')\n\n    try {\n      const result = await this.store.save(id, data)\n\n      this.#emitIfUpdated(id, result)\n\n      return result.peer\n    } finally {\n      log.trace('save release write lock')\n      release()\n    }\n  }\n\n  async patch (id: PeerId, data: PeerData): Promise<Peer> {\n    log.trace('patch await write lock')\n    const release = await this.store.lock.writeLock()\n    log.trace('patch got write lock')\n\n    try {\n      const result = await this.store.patch(id, data)\n\n      this.#emitIfUpdated(id, result)\n\n      return result.peer\n    } finally {\n      log.trace('patch release write lock')\n      release()\n    }\n  }\n\n  async merge (id: PeerId, data: PeerData): Promise<Peer> {\n    log.trace('merge await write lock')\n    const release = await this.store.lock.writeLock()\n    log.trace('merge got write lock')\n\n    try {\n      const result = await this.store.merge(id, data)\n\n      this.#emitIfUpdated(id, result)\n\n      return result.peer\n    } finally {\n      log.trace('merge release write lock')\n      release()\n    }\n  }\n\n  async consumePeerRecord (buf: Uint8Array, expectedPeer?: PeerId): Promise<boolean> {\n    const envelope = await RecordEnvelope.openAndCertify(buf, PeerRecord.DOMAIN)\n\n    if (expectedPeer?.equals(envelope.peerId) === false) {\n      log('envelope peer id was not the expected peer id - expected: %p received: %p', expectedPeer, envelope.peerId)\n      return false\n    }\n\n    const peerRecord = PeerRecord.createFromProtobuf(envelope.payload)\n    let peer: Peer | undefined\n\n    try {\n      peer = await this.get(envelope.peerId)\n    } catch (err: any) {\n      if (err.code !== 'ERR_NOT_FOUND') {\n        throw err\n      }\n    }\n\n    // ensure seq is greater than, or equal to, the last received\n    if (peer?.peerRecordEnvelope != null) {\n      const storedEnvelope = await RecordEnvelope.createFromProtobuf(peer.peerRecordEnvelope)\n      const storedRecord = PeerRecord.createFromProtobuf(storedEnvelope.payload)\n\n      if (storedRecord.seqNumber >= peerRecord.seqNumber) {\n        log('sequence number was lower or equal to existing sequence number - stored: %d received: %d', storedRecord.seqNumber, peerRecord.seqNumber)\n        return false\n      }\n    }\n\n    await this.patch(peerRecord.peerId, {\n      peerRecordEnvelope: buf,\n      addresses: peerRecord.multiaddrs.map(multiaddr => ({\n        isCertified: true,\n        multiaddr\n      }))\n    })\n\n    return true\n  }\n\n  #emitIfUpdated (id: PeerId, result: PeerUpdate): void {\n    if (!result.updated) {\n      return\n    }\n\n    if (this.peerId.equals(id)) {\n      this.events.safeDispatchEvent('self:peer:update', { detail: result })\n    } else {\n      this.events.safeDispatchEvent('peer:update', { detail: result })\n    }\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * Mostly useful for tests or when you want to be explicit about consuming an iterable without doing anything with any yielded values.\n *\n * @example\n *\n * ```javascript\n * import drain from 'it-drain'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * drain(values)\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import drain from 'it-drain'\n *\n * const values = async function * {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * await drain(values())\n * ```\n */\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\n/**\n * Drains an (async) iterable discarding its' content and does not return\n * anything\n */\nfunction drain (source: Iterable<unknown>): void\nfunction drain (source: Iterable<unknown> | AsyncIterable<unknown>): Promise<void>\nfunction drain (source: Iterable<unknown> | AsyncIterable<unknown>): Promise<void> | void {\n  if (isAsyncIterable(source)) {\n    return (async () => {\n      for await (const _ of source) { } // eslint-disable-line no-unused-vars,no-empty,@typescript-eslint/no-unused-vars\n    })()\n  } else {\n    for (const _ of source) { } // eslint-disable-line no-unused-vars,no-empty,@typescript-eslint/no-unused-vars\n  }\n}\n\nexport default drain\n", "/**\n * @packageDocumentation\n *\n * Lets you look at the contents of an async iterator and decide what to do\n *\n * @example\n *\n * ```javascript\n * import peekable from 'it-peekable'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * const it = peekable(value)\n *\n * const first = it.peek()\n *\n * console.info(first) // 0\n *\n * it.push(first)\n *\n * console.info([...it])\n * // [ 0, 1, 2, 3, 4 ]\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import peekable from 'it-peekable'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const it = peekable(values())\n *\n * const first = await it.peek()\n *\n * console.info(first) // 0\n *\n * it.push(first)\n *\n * console.info(await all(it))\n * // [ 0, 1, 2, 3, 4 ]\n * ```\n */\n\nexport interface Peek <T> {\n  peek(): IteratorResult<T, undefined>\n}\n\nexport interface AsyncPeek <T> {\n  peek(): Promise<IteratorResult<T, undefined>>\n}\n\nexport interface Push <T> {\n  push(value: T): void\n}\n\nexport type Peekable <T> = Iterable<T> & Peek<T> & Push<T> & Iterator<T>\n\nexport type AsyncPeekable <T> = AsyncIterable<T> & AsyncPeek<T> & Push<T> & AsyncIterator<T>\n\nfunction peekable <T> (iterable: Iterable<T>): Peekable<T>\nfunction peekable <T> (iterable: AsyncIterable<T>): AsyncPeekable<T>\nfunction peekable <T> (iterable: Iterable<T> | AsyncIterable<T>): Peekable<T> | AsyncPeekable<T> {\n  // @ts-expect-error can't use Symbol.asyncIterator to index iterable since it might be Iterable\n  const [iterator, symbol] = iterable[Symbol.asyncIterator] != null\n    // @ts-expect-error can't use Symbol.asyncIterator to index iterable since it might be Iterable\n    ? [iterable[Symbol.asyncIterator](), Symbol.asyncIterator]\n    // @ts-expect-error can't use Symbol.iterator to index iterable since it might be AsyncIterable\n    : [iterable[Symbol.iterator](), Symbol.iterator]\n\n  const queue: any[] = []\n\n  // @ts-expect-error can't use symbol to index peekable\n  return {\n    peek: () => {\n      return iterator.next()\n    },\n    push: (value: any) => {\n      queue.push(value)\n    },\n    next: () => {\n      if (queue.length > 0) {\n        return {\n          done: false,\n          value: queue.shift()\n        }\n      }\n\n      return iterator.next()\n    },\n    [symbol] () {\n      return this\n    }\n  }\n}\n\nexport default peekable\n", "/**\n * @packageDocumentation\n *\n * Filter values out of an (async)iterable\n *\n * @example\n *\n * ```javascript\n * import all from 'it-all'\n * import filter from 'it-filter'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * const fn = val => val > 2 // Return boolean to keep item\n *\n * const arr = all(filter(values, fn))\n *\n * console.info(arr) // 3, 4\n * ```\n *\n * Async sources and filter functions must be awaited:\n *\n * ```javascript\n * import all from 'it-all'\n * import filter from 'it-filter'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const fn = async val => val > 2 // Return boolean or promise of boolean to keep item\n *\n * const arr = await all(filter(values, fn))\n *\n * console.info(arr) // 3, 4\n * ```\n */\n\nimport peek from 'it-peekable'\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\n/**\n * Filters the passed (async) iterable by using the filter function\n */\nfunction filter <T> (source: Iterable<T>, fn: (val: T) => Promise<boolean>): AsyncGenerator<T, void, undefined>\nfunction filter <T> (source: Iterable<T>, fn: (val: T) => boolean): Generator<T, void, undefined>\nfunction filter <T> (source: Iterable<T> | AsyncIterable<T>, fn: (val: T) => boolean | Promise<boolean>): AsyncGenerator<T, void, undefined>\nfunction filter <T> (source: Iterable<T> | AsyncIterable<T>, fn: (val: T) => boolean | Promise<boolean>): Generator<T, void, undefined> | AsyncGenerator<T, void, undefined> {\n  if (isAsyncIterable(source)) {\n    return (async function * () {\n      for await (const entry of source) {\n        if (await fn(entry)) {\n          yield entry\n        }\n      }\n    })()\n  }\n\n  // if mapping function returns a promise we have to return an async generator\n  const peekable = peek(source)\n  const { value, done } = peekable.next()\n\n  if (done === true) {\n    return (function * () {}())\n  }\n\n  const res = fn(value)\n\n  // @ts-expect-error .then is not present on O\n  if (typeof res.then === 'function') {\n    return (async function * () {\n      if (await res) {\n        yield value\n      }\n\n      for await (const entry of peekable) {\n        if (await fn(entry)) {\n          yield entry\n        }\n      }\n    })()\n  }\n\n  const func = fn as (val: T) => boolean\n\n  return (function * () {\n    if (res === true) {\n      yield value\n    }\n\n    for (const entry of peekable) {\n      if (func(entry)) {\n        yield entry\n      }\n    }\n  })()\n}\n\nexport default filter\n", "/**\n * @packageDocumentation\n *\n * Consumes all values from an (async)iterable and returns them sorted by the passed sort function.\n *\n * @example\n *\n * ```javascript\n * import sort from 'it-sort'\n * import all from 'it-all'\n *\n * const sorter = (a, b) => {\n *   return a.localeCompare(b)\n * }\n *\n * // This can also be an iterator, generator, etc\n * const values = ['foo', 'bar']\n *\n * const arr = all(sort(values, sorter))\n *\n * console.info(arr) // 'bar', 'foo'\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import sort from 'it-sort'\n * import all from 'it-all'\n *\n * const sorter = (a, b) => {\n *   return a.localeCompare(b)\n * }\n *\n * const values = async function * () {\n *   yield * ['foo', 'bar']\n * }\n *\n * const arr = await all(sort(values, sorter))\n *\n * console.info(arr) // 'bar', 'foo'\n * ```\n */\n\nimport all from 'it-all'\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\nexport interface CompareFunction<T> {\n  (a: T, b: T): number\n}\n\n/**\n * Collects all values from an async iterator, sorts them\n * using the passed function and yields them\n */\nfunction sort <T> (source: Iterable<T>, sorter: CompareFunction<T>): Generator<T, void, undefined>\nfunction sort <T> (source: Iterable<T> | AsyncIterable<T>, sorter: CompareFunction<T>): AsyncGenerator<T, void, undefined>\nfunction sort <T> (source: Iterable<T> | AsyncIterable<T>, sorter: CompareFunction<T>): AsyncGenerator<T, void, undefined> | Generator<T, void, undefined> {\n  if (isAsyncIterable(source)) {\n    return (async function * () {\n      const arr = await all(source)\n\n      yield * arr.sort(sorter)\n    })()\n  }\n\n  return (function * () {\n    const arr = all(source)\n\n    yield * arr.sort(sorter)\n  })()\n}\n\nexport default sort\n", "/**\n * @packageDocumentation\n *\n * For when you only want a few values out of an (async)iterable.\n *\n * @example\n *\n * ```javascript\n * import take from 'it-take'\n * import all from 'it-all'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * const arr = all(take(values, 2))\n *\n * console.info(arr) // 0, 1\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import take from 'it-take'\n * import all from 'it-all'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const arr = await all(take(values(), 2))\n *\n * console.info(arr) // 0, 1\n * ```\n */\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\n/**\n * Stop iteration after n items have been received\n */\nfunction take <T> (source: Iterable<T>, limit: number): Generator<T, void, undefined>\nfunction take <T> (source: Iterable<T> | AsyncIterable<T>, limit: number): AsyncGenerator<T, void, undefined>\nfunction take <T> (source: Iterable<T> | AsyncIterable<T>, limit: number): AsyncGenerator<T, void, undefined> | Generator<T, void, undefined> {\n  if (isAsyncIterable(source)) {\n    return (async function * () {\n      let items = 0\n\n      if (limit < 1) {\n        return\n      }\n\n      for await (const entry of source) {\n        yield entry\n\n        items++\n\n        if (items === limit) {\n          return\n        }\n      }\n    })()\n  }\n\n  return (function * () {\n    let items = 0\n\n    if (limit < 1) {\n      return\n    }\n\n    for (const entry of source) {\n      yield entry\n\n      items++\n\n      if (items === limit) {\n        return\n      }\n    }\n  })()\n}\n\nexport default take\n", "import drain from 'it-drain'\nimport filter from 'it-filter'\nimport sort from 'it-sort'\nimport take from 'it-take'\nimport type { Batch, Datastore, Key, KeyQuery, Pair, Query } from 'interface-datastore'\nimport type { AbortOptions, Await, AwaitIterable } from 'interface-store'\n\nexport class BaseDatastore implements Datastore {\n  put (key: Key, val: Uint8Array, options?: AbortOptions): Await<Key> {\n    return Promise.reject(new Error('.put is not implemented'))\n  }\n\n  get (key: Key, options?: AbortOptions): Await<Uint8Array> {\n    return Promise.reject(new Error('.get is not implemented'))\n  }\n\n  has (key: Key, options?: AbortOptions): Await<boolean> {\n    return Promise.reject(new Error('.has is not implemented'))\n  }\n\n  delete (key: Key, options?: AbortOptions): Await<void> {\n    return Promise.reject(new Error('.delete is not implemented'))\n  }\n\n  async * putMany (source: AwaitIterable<Pair>, options: AbortOptions = {}): AwaitIterable<Key> {\n    for await (const { key, value } of source) {\n      await this.put(key, value, options)\n      yield key\n    }\n  }\n\n  async * getMany (source: AwaitIterable<Key>, options: AbortOptions = {}): AwaitIterable<Pair> {\n    for await (const key of source) {\n      yield {\n        key,\n        value: await this.get(key, options)\n      }\n    }\n  }\n\n  async * deleteMany (source: AwaitIterable<Key>, options: AbortOptions = {}): AwaitIterable<Key> {\n    for await (const key of source) {\n      await this.delete(key, options)\n      yield key\n    }\n  }\n\n  batch (): Batch {\n    let puts: Pair[] = []\n    let dels: Key[] = []\n\n    return {\n      put (key, value) {\n        puts.push({ key, value })\n      },\n\n      delete (key) {\n        dels.push(key)\n      },\n      commit: async (options) => {\n        await drain(this.putMany(puts, options))\n        puts = []\n        await drain(this.deleteMany(dels, options))\n        dels = []\n      }\n    }\n  }\n\n  /**\n   * Extending classes should override `query` or implement this method\n   */\n  // eslint-disable-next-line require-yield\n  async * _all (q: Query, options?: AbortOptions): AwaitIterable<Pair> {\n    throw new Error('._all is not implemented')\n  }\n\n  /**\n   * Extending classes should override `queryKeys` or implement this method\n   */\n  // eslint-disable-next-line require-yield\n  async * _allKeys (q: KeyQuery, options?: AbortOptions): AwaitIterable<Key> {\n    throw new Error('._allKeys is not implemented')\n  }\n\n  query (q: Query, options?: AbortOptions): AwaitIterable<Pair> {\n    let it = this._all(q, options)\n\n    if (q.prefix != null) {\n      const prefix = q.prefix\n      it = filter(it, (e) => e.key.toString().startsWith(prefix))\n    }\n\n    if (Array.isArray(q.filters)) {\n      it = q.filters.reduce((it, f) => filter(it, f), it)\n    }\n\n    if (Array.isArray(q.orders)) {\n      it = q.orders.reduce((it, f) => sort(it, f), it)\n    }\n\n    if (q.offset != null) {\n      let i = 0\n      const offset = q.offset\n      it = filter(it, () => i++ >= offset)\n    }\n\n    if (q.limit != null) {\n      it = take(it, q.limit)\n    }\n\n    return it\n  }\n\n  queryKeys (q: KeyQuery, options?: AbortOptions): AwaitIterable<Key> {\n    let it = this._allKeys(q, options)\n\n    if (q.prefix != null) {\n      const prefix = q.prefix\n      it = filter(it, (key) =>\n        key.toString().startsWith(prefix)\n      )\n    }\n\n    if (Array.isArray(q.filters)) {\n      it = q.filters.reduce((it, f) => filter(it, f), it)\n    }\n\n    if (Array.isArray(q.orders)) {\n      it = q.orders.reduce((it, f) => sort(it, f), it)\n    }\n\n    if (q.offset != null) {\n      const offset = q.offset\n      let i = 0\n      it = filter(it, () => i++ >= offset)\n    }\n\n    if (q.limit != null) {\n      it = take(it, q.limit)\n    }\n\n    return it\n  }\n}\n", "import errCode from 'err-code'\n\nexport function dbOpenFailedError (err?: Error): Error {\n  err = err ?? new Error('Cannot open database')\n  return errCode(err, 'ERR_DB_OPEN_FAILED')\n}\n\nexport function dbDeleteFailedError (err?: Error): Error {\n  err = err ?? new Error('Delete failed')\n  return errCode(err, 'ERR_DB_DELETE_FAILED')\n}\n\nexport function dbWriteFailedError (err?: Error): Error {\n  err = err ?? new Error('Write failed')\n  return errCode(err, 'ERR_DB_WRITE_FAILED')\n}\n\nexport function dbReadFailedError (err?: Error): Error {\n  err = err ?? new Error('Read failed')\n  return errCode(err, 'ERR_DB_READ_FAILED')\n}\n\nexport function notFoundError (err?: Error): Error {\n  err = err ?? new Error('Not Found')\n  return errCode(err, 'ERR_NOT_FOUND')\n}\n\nexport function abortedError (err?: Error): Error {\n  err = err ?? new Error('Aborted')\n  return errCode(err, 'ERR_ABORTED')\n}\n", "import { Key } from 'interface-datastore/key'\nimport { BaseDatastore } from './base.js'\nimport * as Errors from './errors.js'\nimport type { Pair } from 'interface-datastore'\nimport type { Await, AwaitIterable } from 'interface-store'\n\nexport class MemoryDatastore extends BaseDatastore {\n  private readonly data: Map<string, Uint8Array>\n\n  constructor () {\n    super()\n\n    this.data = new Map()\n  }\n\n  put (key: Key, val: Uint8Array): Await<Key> { // eslint-disable-line require-await\n    this.data.set(key.toString(), val)\n\n    return key\n  }\n\n  get (key: Key): Await<Uint8Array> {\n    const result = this.data.get(key.toString())\n\n    if (result == null) {\n      throw Errors.notFoundError()\n    }\n\n    return result\n  }\n\n  has (key: Key): Await<boolean> { // eslint-disable-line require-await\n    return this.data.has(key.toString())\n  }\n\n  delete (key: Key): Await<void> { // eslint-disable-line require-await\n    this.data.delete(key.toString())\n  }\n\n  * _all (): AwaitIterable<Pair> {\n    for (const [key, value] of this.data.entries()) {\n      yield { key: new Key(key), value }\n    }\n  }\n\n  * _allKeys (): AwaitIterable<Key> {\n    for (const key of this.data.keys()) {\n      yield new Key(key)\n    }\n  }\n}\n", "export function debounce (func: () => void, wait: number): () => void {\n  let timeout: ReturnType<typeof setTimeout> | undefined\n\n  return function () {\n    const later = function (): void {\n      timeout = undefined\n      func()\n    }\n\n    clearTimeout(timeout)\n    timeout = setTimeout(later, wait)\n  }\n}\n", "import { logger } from '@libp2p/logger'\nimport { peerIdFromString } from '@libp2p/peer-id'\nimport { multiaddr } from '@multiformats/multiaddr'\nimport { debounce } from './utils.js'\nimport type { Libp2pEvents } from '@libp2p/interface'\nimport type { TypedEventTarget } from '@libp2p/interface/events'\nimport type { PeerId } from '@libp2p/interface/peer-id'\nimport type { PeerStore } from '@libp2p/interface/peer-store'\nimport type { TransportManager } from '@libp2p/interface-internal/transport-manager'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nconst log = logger('libp2p:address-manager')\n\nexport interface AddressManagerInit {\n  /**\n   * Pass an function in this field to override the list of addresses\n   * that are announced to the network\n   */\n  announceFilter?: AddressFilter\n\n  /**\n   * list of multiaddrs string representation to listen\n   */\n  listen?: string[]\n\n  /**\n   * list of multiaddrs string representation to announce\n   */\n  announce?: string[]\n\n  /**\n   * list of multiaddrs string representation to never announce\n   */\n  noAnnounce?: string[]\n}\n\nexport interface DefaultAddressManagerComponents {\n  peerId: PeerId\n  transportManager: TransportManager\n  peerStore: PeerStore\n  events: TypedEventTarget<Libp2pEvents>\n}\n\n/**\n * A function that takes a list of multiaddrs and returns a list\n * to announce\n */\nexport interface AddressFilter {\n  (addrs: Multiaddr[]): Multiaddr[]\n}\n\nconst defaultAddressFilter = (addrs: Multiaddr[]): Multiaddr[] => addrs\n\ninterface ObservedAddressMetadata {\n  confident: boolean\n}\n\n/**\n * If the passed multiaddr contains the passed peer id, remove it\n */\nfunction stripPeerId (ma: Multiaddr, peerId: PeerId): Multiaddr {\n  const observedPeerIdStr = ma.getPeerId()\n\n  // strip our peer id if it has been passed\n  if (observedPeerIdStr != null) {\n    const observedPeerId = peerIdFromString(observedPeerIdStr)\n\n    // use same encoding for comparison\n    if (observedPeerId.equals(peerId)) {\n      ma = ma.decapsulate(multiaddr(`/p2p/${peerId.toString()}`))\n    }\n  }\n\n  return ma\n}\n\nexport class DefaultAddressManager {\n  private readonly components: DefaultAddressManagerComponents\n  // this is an array to allow for duplicates, e.g. multiples of `/ip4/0.0.0.0/tcp/0`\n  private readonly listen: string[]\n  private readonly announce: Set<string>\n  private readonly observed: Map<string, ObservedAddressMetadata>\n  private readonly announceFilter: AddressFilter\n\n  /**\n   * Responsible for managing the peer addresses.\n   * Peers can specify their listen and announce addresses.\n   * The listen addresses will be used by the libp2p transports to listen for new connections,\n   * while the announce addresses will be used for the peer addresses' to other peers in the network.\n   */\n  constructor (components: DefaultAddressManagerComponents, init: AddressManagerInit = {}) {\n    const { listen = [], announce = [] } = init\n\n    this.components = components\n    this.listen = listen.map(ma => ma.toString())\n    this.announce = new Set(announce.map(ma => ma.toString()))\n    this.observed = new Map()\n    this.announceFilter = init.announceFilter ?? defaultAddressFilter\n\n    // this method gets called repeatedly on startup when transports start listening so\n    // debounce it so we don't cause multiple self:peer:update events to be emitted\n    this._updatePeerStoreAddresses = debounce(this._updatePeerStoreAddresses.bind(this), 1000)\n\n    // update our stored addresses when new transports listen\n    components.events.addEventListener('transport:listening', () => {\n      this._updatePeerStoreAddresses()\n    })\n    // update our stored addresses when existing transports stop listening\n    components.events.addEventListener('transport:close', () => {\n      this._updatePeerStoreAddresses()\n    })\n  }\n\n  _updatePeerStoreAddresses (): void {\n    // if announce addresses have been configured, ensure they make it into our peer\n    // record for things like identify\n    const addrs = this.getAnnounceAddrs()\n      .concat(this.components.transportManager.getAddrs())\n      .concat(\n        [...this.observed.entries()]\n          .filter(([_, metadata]) => metadata.confident)\n          .map(([str]) => multiaddr(str))\n      ).map(ma => {\n        // strip our peer id if it is present\n        if (ma.getPeerId() === this.components.peerId.toString()) {\n          return ma.decapsulate(`/p2p/${this.components.peerId.toString()}`)\n        }\n\n        return ma\n      })\n\n    this.components.peerStore.patch(this.components.peerId, {\n      multiaddrs: addrs\n    })\n      .catch(err => { log.error('error updating addresses', err) })\n  }\n\n  /**\n   * Get peer listen multiaddrs\n   */\n  getListenAddrs (): Multiaddr[] {\n    return Array.from(this.listen).map((a) => multiaddr(a))\n  }\n\n  /**\n   * Get peer announcing multiaddrs\n   */\n  getAnnounceAddrs (): Multiaddr[] {\n    return Array.from(this.announce).map((a) => multiaddr(a))\n  }\n\n  /**\n   * Get observed multiaddrs\n   */\n  getObservedAddrs (): Multiaddr[] {\n    return Array.from(this.observed).map(([a]) => multiaddr(a))\n  }\n\n  /**\n   * Add peer observed addresses\n   */\n  addObservedAddr (addr: Multiaddr): void {\n    addr = stripPeerId(addr, this.components.peerId)\n    const addrString = addr.toString()\n\n    // do not trigger the change:addresses event if we already know about this address\n    if (this.observed.has(addrString)) {\n      return\n    }\n\n    this.observed.set(addrString, {\n      confident: false\n    })\n  }\n\n  confirmObservedAddr (addr: Multiaddr): void {\n    addr = stripPeerId(addr, this.components.peerId)\n    const addrString = addr.toString()\n\n    const metadata = this.observed.get(addrString) ?? {\n      confident: false\n    }\n\n    const startingConfidence = metadata.confident\n\n    this.observed.set(addrString, {\n      confident: true\n    })\n\n    // only trigger the 'self:peer:update' event if our confidence in an address has changed\n    if (!startingConfidence) {\n      this._updatePeerStoreAddresses()\n    }\n  }\n\n  removeObservedAddr (addr: Multiaddr): void {\n    addr = stripPeerId(addr, this.components.peerId)\n    const addrString = addr.toString()\n\n    this.observed.delete(addrString)\n  }\n\n  getAddresses (): Multiaddr[] {\n    let addrs = this.getAnnounceAddrs().map(ma => ma.toString())\n\n    if (addrs.length === 0) {\n      // no configured announce addrs, add configured listen addresses\n      addrs = this.components.transportManager.getAddrs().map(ma => ma.toString())\n    }\n\n    // add observed addresses we are confident in\n    addrs = addrs.concat(\n      Array.from(this.observed)\n        .filter(([ma, metadata]) => metadata.confident)\n        .map(([ma]) => ma)\n    )\n\n    // dedupe multiaddrs\n    const addrSet = new Set(addrs)\n\n    // Create advertising list\n    return this.announceFilter(Array.from(addrSet)\n      .map(str => multiaddr(str)))\n      .map(ma => {\n        // do not append our peer id to a path multiaddr as it will become invalid\n        if (ma.protos().pop()?.path === true) {\n          return ma\n        }\n\n        if (ma.getPeerId() === this.components.peerId.toString()) {\n          return ma\n        }\n\n        return ma.encapsulate(`/p2p/${this.components.peerId.toString()}`)\n      })\n  }\n}\n", "/**\n * Implemented by components that have a lifecycle\n */\nexport interface Startable {\n  isStarted(): boolean\n\n  /**\n   * If implemented, this method will be invoked before the start method.\n   *\n   * It should not assume any other components have been started.\n   */\n  beforeStart?(): void | Promise<void>\n\n  /**\n   * This method will be invoked to start the component.\n   *\n   * It should not assume that any other components have been started.\n   */\n  start(): void | Promise<void>\n\n  /**\n   * If implemented, this method will be invoked after the start method.\n   *\n   * All other components will have had their start method invoked before this method is called.\n   */\n  afterStart?(): void | Promise<void>\n\n  /**\n   * If implemented, this method will be invoked before the stop method.\n   *\n   * Any other components will still be running when this method is called.\n   */\n  beforeStop?(): void | Promise<void>\n\n  /**\n   * This method will be invoked to stop the component.\n   *\n   * It should not assume any other components are running when it is called.\n   */\n  stop(): void | Promise<void>\n\n  /**\n   * If implemented, this method will be invoked after the stop method.\n   *\n   * All other components will have had their stop method invoked before this method is called.\n   */\n  afterStop?(): void | Promise<void>\n}\n\nexport function isStartable (obj: any): obj is Startable {\n  return obj != null && typeof obj.start === 'function' && typeof obj.stop === 'function'\n}\n\nexport async function start (...objs: any[]): Promise<void> {\n  const startables: Startable[] = []\n\n  for (const obj of objs) {\n    if (isStartable(obj)) {\n      startables.push(obj)\n    }\n  }\n\n  await Promise.all(\n    startables.map(async s => {\n      if (s.beforeStart != null) {\n        await s.beforeStart()\n      }\n    })\n  )\n\n  await Promise.all(\n    startables.map(async s => {\n      await s.start()\n    })\n  )\n\n  await Promise.all(\n    startables.map(async s => {\n      if (s.afterStart != null) {\n        await s.afterStart()\n      }\n    })\n  )\n}\n\nexport async function stop (...objs: any[]): Promise<void> {\n  const startables: Startable[] = []\n\n  for (const obj of objs) {\n    if (isStartable(obj)) {\n      startables.push(obj)\n    }\n  }\n\n  await Promise.all(\n    startables.map(async s => {\n      if (s.beforeStop != null) {\n        await s.beforeStop()\n      }\n    })\n  )\n\n  await Promise.all(\n    startables.map(async s => {\n      await s.stop()\n    })\n  )\n\n  await Promise.all(\n    startables.map(async s => {\n      if (s.afterStop != null) {\n        await s.afterStop()\n      }\n    })\n  )\n}\n", "import { CodeError } from '@libp2p/interface/errors'\nimport { isStartable, type Startable } from '@libp2p/interface/startable'\nimport { defaultLogger } from '@libp2p/logger'\nimport type { Libp2pEvents, ComponentLogger } from '@libp2p/interface'\nimport type { ConnectionProtector } from '@libp2p/interface/connection'\nimport type { ConnectionGater } from '@libp2p/interface/connection-gater'\nimport type { ContentRouting } from '@libp2p/interface/content-routing'\nimport type { TypedEventTarget } from '@libp2p/interface/events'\nimport type { Metrics } from '@libp2p/interface/metrics'\nimport type { PeerId } from '@libp2p/interface/peer-id'\nimport type { PeerRouting } from '@libp2p/interface/peer-routing'\nimport type { PeerStore } from '@libp2p/interface/peer-store'\nimport type { Upgrader } from '@libp2p/interface/transport'\nimport type { AddressManager } from '@libp2p/interface-internal/address-manager'\nimport type { ConnectionManager } from '@libp2p/interface-internal/connection-manager'\nimport type { Registrar } from '@libp2p/interface-internal/registrar'\nimport type { TransportManager } from '@libp2p/interface-internal/transport-manager'\nimport type { Datastore } from 'interface-datastore'\n\nexport interface Components extends Record<string, any>, Startable {\n  peerId: PeerId\n  logger: ComponentLogger\n  events: TypedEventTarget<Libp2pEvents>\n  addressManager: AddressManager\n  peerStore: PeerStore\n  upgrader: Upgrader\n  registrar: Registrar\n  connectionManager: ConnectionManager\n  transportManager: TransportManager\n  connectionGater: ConnectionGater\n  contentRouting: ContentRouting\n  peerRouting: PeerRouting\n  datastore: Datastore\n  connectionProtector?: ConnectionProtector\n  metrics?: Metrics\n}\n\nexport interface ComponentsInit {\n  peerId?: PeerId\n  logger?: ComponentLogger\n  events?: TypedEventTarget<Libp2pEvents>\n  addressManager?: AddressManager\n  peerStore?: PeerStore\n  upgrader?: Upgrader\n  metrics?: Metrics\n  registrar?: Registrar\n  connectionManager?: ConnectionManager\n  transportManager?: TransportManager\n  connectionGater?: ConnectionGater\n  contentRouting?: ContentRouting\n  peerRouting?: PeerRouting\n  datastore?: Datastore\n  connectionProtector?: ConnectionProtector\n}\n\nclass DefaultComponents implements Startable {\n  public components: Record<string, any> = {}\n  private _started = false\n\n  constructor (init: ComponentsInit = {}) {\n    this.components = {}\n\n    for (const [key, value] of Object.entries(init)) {\n      this.components[key] = value\n    }\n\n    if (this.components.logger == null) {\n      this.components.logger = defaultLogger()\n    }\n  }\n\n  isStarted (): boolean {\n    return this._started\n  }\n\n  private async _invokeStartableMethod (methodName: 'beforeStart' | 'start' | 'afterStart' | 'beforeStop' | 'stop' | 'afterStop'): Promise<void> {\n    await Promise.all(\n      Object.values(this.components)\n        .filter(obj => isStartable(obj))\n        .map(async (startable: Startable) => {\n          await startable[methodName]?.()\n        })\n    )\n  }\n\n  async beforeStart (): Promise<void> {\n    await this._invokeStartableMethod('beforeStart')\n  }\n\n  async start (): Promise<void> {\n    await this._invokeStartableMethod('start')\n    this._started = true\n  }\n\n  async afterStart (): Promise<void> {\n    await this._invokeStartableMethod('afterStart')\n  }\n\n  async beforeStop (): Promise<void> {\n    await this._invokeStartableMethod('beforeStop')\n  }\n\n  async stop (): Promise<void> {\n    await this._invokeStartableMethod('stop')\n    this._started = false\n  }\n\n  async afterStop (): Promise<void> {\n    await this._invokeStartableMethod('afterStop')\n  }\n}\n\nconst OPTIONAL_SERVICES = [\n  'metrics',\n  'connectionProtector'\n]\n\nconst NON_SERVICE_PROPERTIES = [\n  'components',\n  'isStarted',\n  'beforeStart',\n  'start',\n  'afterStart',\n  'beforeStop',\n  'stop',\n  'afterStop',\n  'then',\n  '_invokeStartableMethod'\n]\n\nexport function defaultComponents (init: ComponentsInit = {}): Components {\n  const components = new DefaultComponents(init)\n\n  const proxy = new Proxy(components, {\n    get (target, prop, receiver) {\n      if (typeof prop === 'string' && !NON_SERVICE_PROPERTIES.includes(prop)) {\n        const service = components.components[prop]\n\n        if (service == null && !OPTIONAL_SERVICES.includes(prop)) {\n          throw new CodeError(`${prop} not set`, 'ERR_SERVICE_MISSING')\n        }\n\n        return service\n      }\n\n      return Reflect.get(target, prop, receiver)\n    },\n\n    set (target, prop, value) {\n      if (typeof prop === 'string') {\n        components.components[prop] = value\n      } else {\n        Reflect.set(target, prop, value)\n      }\n\n      return true\n    }\n  })\n\n  // @ts-expect-error component keys are proxied\n  return proxy\n}\n", "import { Netmask } from 'netmask';\nimport ip_regex from 'ip-regex';\nimport { isIP } from '@chainsafe/is-ip';\nimport ipaddr from 'ipaddr.js';\nconst { isValid: is_valid, parse } = ipaddr;\nconst PRIVATE_IP_RANGES = [\n    '0.0.0.0/8',\n    '10.0.0.0/8',\n    '100.64.0.0/10',\n    '127.0.0.0/8',\n    '169.254.0.0/16',\n    '172.16.0.0/12',\n    '192.0.0.0/24',\n    '192.0.0.0/29',\n    '192.0.0.8/32',\n    '192.0.0.9/32',\n    '192.0.0.10/32',\n    '192.0.0.170/32',\n    '192.0.0.171/32',\n    '192.0.2.0/24',\n    '192.31.196.0/24',\n    '192.52.193.0/24',\n    '192.88.99.0/24',\n    '192.168.0.0/16',\n    '192.175.48.0/24',\n    '198.18.0.0/15',\n    '198.51.100.0/24',\n    '203.0.113.0/24',\n    '240.0.0.0/4',\n    '255.255.255.255/32'\n];\nconst NETMASK_RANGES = PRIVATE_IP_RANGES.map(ip_range => new Netmask(ip_range));\nfunction ipv4_check(ip_addr) {\n    for (let r of NETMASK_RANGES) {\n        if (r.contains(ip_addr))\n            return true;\n    }\n    return false;\n}\nfunction ipv6_check(ip_addr) {\n    return /^::$/.test(ip_addr) ||\n        /^::1$/.test(ip_addr) ||\n        /^::f{4}:([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})$/.test(ip_addr) ||\n        /^::f{4}:0.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})$/.test(ip_addr) ||\n        /^64:ff9b::([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})$/.test(ip_addr) ||\n        /^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) ||\n        /^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) ||\n        /^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) ||\n        /^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) ||\n        /^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) ||\n        /^f[c-d]([0-9a-fA-F]{2,2}):/i.test(ip_addr) ||\n        /^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(ip_addr) ||\n        /^ff([0-9a-fA-F]{2,2}):/i.test(ip_addr);\n}\nexport default (ip) => {\n    if (is_valid(ip)) {\n        const parsed = parse(ip);\n        if (parsed.kind() === 'ipv4')\n            return ipv4_check(parsed.toNormalizedString());\n        else if (parsed.kind() === 'ipv6')\n            return ipv6_check(ip);\n    }\n    else if (isIP(ip) && ip_regex.v6().test(ip))\n        return ipv6_check(ip);\n    return undefined;\n};\n", "const word = '[a-fA-F\\\\d:]';\n\nconst boundry = options => options && options.includeBoundaries\n\t? `(?:(?<=\\\\s|^)(?=${word})|(?<=${word})(?=\\\\s|$))`\n\t: '';\n\nconst v4 = '(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)){3}';\n\nconst v6segment = '[a-fA-F\\\\d]{1,4}';\n\nconst v6 = `\n(?:\n(?:${v6segment}:){7}(?:${v6segment}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:${v6segment}:){6}(?:${v4}|:${v6segment}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:${v6segment}:){5}(?::${v4}|(?::${v6segment}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:${v6segment}:){4}(?:(?::${v6segment}){0,1}:${v4}|(?::${v6segment}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:${v6segment}:){3}(?:(?::${v6segment}){0,2}:${v4}|(?::${v6segment}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:${v6segment}:){2}(?:(?::${v6segment}){0,3}:${v4}|(?::${v6segment}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:${v6segment}:){1}(?:(?::${v6segment}){0,4}:${v4}|(?::${v6segment}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::${v6segment}){0,5}:${v4}|(?::${v6segment}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n`.replace(/\\s*\\/\\/.*$/gm, '').replace(/\\n/g, '').trim();\n\n// Pre-compile only the exact regexes because adding a global flag make regexes stateful\nconst v46Exact = new RegExp(`(?:^${v4}$)|(?:^${v6}$)`);\nconst v4exact = new RegExp(`^${v4}$`);\nconst v6exact = new RegExp(`^${v6}$`);\n\nconst ipRegex = options => options && options.exact\n\t? v46Exact\n\t: new RegExp(`(?:${boundry(options)}${v4}${boundry(options)})|(?:${boundry(options)}${v6}${boundry(options)})`, 'g');\n\nipRegex.v4 = options => options && options.exact ? v4exact : new RegExp(`${boundry(options)}${v4}${boundry(options)}`, 'g');\nipRegex.v6 = options => options && options.exact ? v6exact : new RegExp(`${boundry(options)}${v6}${boundry(options)}`, 'g');\n\nexport default ipRegex;\n", "'use strict'\n\nimport is_ip_private from './lib/index.js'\nexport default is_ip_private", "import isPrivate from 'private-ip'\nimport type { ConnectionGater } from '@libp2p/interface/connection-gater'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\n/**\n * Returns a connection gater that disallows dialling private addresses by\n * default. Browsers are severely limited in their resource usage so don't\n * waste time trying to dial undiallable addresses.\n */\nexport function connectionGater (gater: ConnectionGater = {}): ConnectionGater {\n  return {\n    denyDialPeer: async () => false,\n    denyDialMultiaddr: async (multiaddr: Multiaddr) => {\n      const tuples = multiaddr.stringTuples()\n\n      if (tuples[0][0] === 4 || tuples[0][0] === 41) {\n        return Boolean(isPrivate(`${tuples[0][1]}`))\n      }\n\n      return false\n    },\n    denyInboundConnection: async () => false,\n    denyOutboundConnection: async () => false,\n    denyInboundEncryptedConnection: async () => false,\n    denyOutboundEncryptedConnection: async () => false,\n    denyInboundUpgradedConnection: async () => false,\n    denyOutboundUpgradedConnection: async () => false,\n    filterMultiaddrForPeer: async () => true,\n    ...gater\n  }\n}\n", "// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET, name) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256);\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255;\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i);\n    var xc = x.charCodeAt(0);\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i;\n  }\n  var BASE = ALPHABET.length;\n  var LEADER = ALPHABET.charAt(0);\n  var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (source instanceof Uint8Array) ; else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source);\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0;\n    var length = 0;\n    var pbegin = 0;\n    var pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++;\n      zeroes++;\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n    var b58 = new Uint8Array(size);\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0;\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0;\n        b58[it1] = (carry % BASE) >>> 0;\n        carry = (carry / BASE) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      pbegin++;\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length;\n    while (it2 !== size && b58[it2] === 0) {\n      it2++;\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes);\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0;\n        // Skip leading spaces.\n    if (source[psz] === ' ') { return }\n        // Skip and count leading '1's.\n    var zeroes = 0;\n    var length = 0;\n    while (source[psz] === LEADER) {\n      zeroes++;\n      psz++;\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size);\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0;\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0;\n        b256[it3] = (carry % 256) >>> 0;\n        carry = (carry / 256) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      psz++;\n    }\n        // Skip trailing spaces.\n    if (source[psz] === ' ') { return }\n        // Skip leading zeroes in b256.\n    var it4 = size - length;\n    while (it4 !== size && b256[it4] === 0) {\n      it4++;\n    }\n    var vch = new Uint8Array(zeroes + (size - it4));\n    var j = zeroes;\n    while (it4 !== size) {\n      vch[j++] = b256[it4++];\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string);\n    if (buffer) { return buffer }\n    throw new Error(`Non-${name} character`)\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nvar src = base;\n\nvar _brrp__multiformats_scope_baseX = src;\n\nexport default _brrp__multiformats_scope_baseX;\n", "const empty = new Uint8Array(0)\n\n/**\n * @param {Uint8Array} d\n */\nconst toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')\n\n/**\n * @param {string} hex\n */\nconst fromHex = hex => {\n  const hexes = hex.match(/../g)\n  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty\n}\n\n/**\n * @param {Uint8Array} aa\n * @param {Uint8Array} bb\n */\nconst equals = (aa, bb) => {\n  if (aa === bb) return true\n  if (aa.byteLength !== bb.byteLength) {\n    return false\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @param {ArrayBufferView|ArrayBuffer|Uint8Array} o\n * @returns {Uint8Array}\n */\nconst coerce = o => {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o\n  if (o instanceof ArrayBuffer) return new Uint8Array(o)\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)\n  }\n  throw new Error('Unknown type, must be binary type')\n}\n\n/**\n * @param {any} o\n * @returns {o is ArrayBuffer|ArrayBufferView}\n */\nconst isBinary = o =>\n  o instanceof ArrayBuffer || ArrayBuffer.isView(o)\n\n/**\n * @param {string} str\n * @returns {Uint8Array}\n */\nconst fromString = str => (new TextEncoder()).encode(str)\n\n/**\n * @param {Uint8Array} b\n * @returns {string}\n */\nconst toString = b => (new TextDecoder()).decode(b)\n\nexport { equals, coerce, isBinary, fromHex, toHex, fromString, toString, empty }\n", "import basex from '../../vendor/base-x.js'\nimport { coerce } from '../bytes.js'\n// Linter can't see that API is used in types.\n// eslint-disable-next-line\nimport * as API from './interface.js'\n\n/**\n * Class represents both BaseEncoder and MultibaseEncoder meaning it\n * can be used to encode to multibase or base encode without multibase\n * prefix.\n *\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseEncoder<Prefix>}\n * @implements {API.BaseEncoder}\n */\nclass Encoder {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(bytes:Uint8Array) => string} baseEncode\n   */\n  constructor (name, prefix, baseEncode) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n  }\n\n  /**\n   * @param {Uint8Array} bytes\n   * @returns {API.Multibase<Prefix>}\n   */\n  encode (bytes) {\n    if (bytes instanceof Uint8Array) {\n      return `${this.prefix}${this.baseEncode(bytes)}`\n    } else {\n      throw Error('Unknown type, must be binary type')\n    }\n  }\n}\n\n/**\n * @template {string} Prefix\n */\n/**\n * Class represents both BaseDecoder and MultibaseDecoder so it could be used\n * to decode multibases (with matching prefix) or just base decode strings\n * with corresponding base encoding.\n *\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.UnibaseDecoder<Prefix>}\n * @implements {API.BaseDecoder}\n */\nclass Decoder {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(text:string) => Uint8Array} baseDecode\n   */\n  constructor (name, prefix, baseDecode) {\n    this.name = name\n    this.prefix = prefix\n    /* c8 ignore next 3 */\n    if (prefix.codePointAt(0) === undefined) {\n      throw new Error('Invalid prefix character')\n    }\n    /** @private */\n    this.prefixCodePoint = /** @type {number} */ (prefix.codePointAt(0))\n    this.baseDecode = baseDecode\n  }\n\n  /**\n   * @param {string} text\n   */\n  decode (text) {\n    if (typeof text === 'string') {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`)\n      }\n      return this.baseDecode(text.slice(this.prefix.length))\n    } else {\n      throw Error('Can only multibase decode strings')\n    }\n  }\n\n  /**\n   * @template {string} OtherPrefix\n   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder\n   * @returns {ComposedDecoder<Prefix|OtherPrefix>}\n   */\n  or (decoder) {\n    return or(this, decoder)\n  }\n}\n\n/**\n * @template {string} Prefix\n * @typedef {Record<Prefix, API.UnibaseDecoder<Prefix>>} Decoders\n */\n\n/**\n * @template {string} Prefix\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.CombobaseDecoder<Prefix>}\n */\nclass ComposedDecoder {\n  /**\n   * @param {Decoders<Prefix>} decoders\n   */\n  constructor (decoders) {\n    this.decoders = decoders\n  }\n\n  /**\n   * @template {string} OtherPrefix\n   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder\n   * @returns {ComposedDecoder<Prefix|OtherPrefix>}\n   */\n  or (decoder) {\n    return or(this, decoder)\n  }\n\n  /**\n   * @param {string} input\n   * @returns {Uint8Array}\n   */\n  decode (input) {\n    const prefix = /** @type {Prefix} */ (input[0])\n    const decoder = this.decoders[prefix]\n    if (decoder) {\n      return decoder.decode(input)\n    } else {\n      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)\n    }\n  }\n}\n\n/**\n * @template {string} L\n * @template {string} R\n * @param {API.UnibaseDecoder<L>|API.CombobaseDecoder<L>} left\n * @param {API.UnibaseDecoder<R>|API.CombobaseDecoder<R>} right\n * @returns {ComposedDecoder<L|R>}\n */\nexport const or = (left, right) => new ComposedDecoder(/** @type {Decoders<L|R>} */({\n  ...(left.decoders || { [/** @type API.UnibaseDecoder<L> */(left).prefix]: left }),\n  ...(right.decoders || { [/** @type API.UnibaseDecoder<R> */(right).prefix]: right })\n}))\n\n/**\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseCodec<Prefix>}\n * @implements {API.MultibaseEncoder<Prefix>}\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.BaseCodec}\n * @implements {API.BaseEncoder}\n * @implements {API.BaseDecoder}\n */\nexport class Codec {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(bytes:Uint8Array) => string} baseEncode\n   * @param {(text:string) => Uint8Array} baseDecode\n   */\n  constructor (name, prefix, baseEncode, baseDecode) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n    this.baseDecode = baseDecode\n    this.encoder = new Encoder(name, prefix, baseEncode)\n    this.decoder = new Decoder(name, prefix, baseDecode)\n  }\n\n  /**\n   * @param {Uint8Array} input\n   */\n  encode (input) {\n    return this.encoder.encode(input)\n  }\n\n  /**\n   * @param {string} input\n   */\n  decode (input) {\n    return this.decoder.decode(input)\n  }\n}\n\n/**\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {(bytes:Uint8Array) => string} options.encode\n * @param {(input:string) => Uint8Array} options.decode\n * @returns {Codec<Base, Prefix>}\n */\nexport const from = ({ name, prefix, encode, decode }) =>\n  new Codec(name, prefix, encode, decode)\n\n/**\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {string} options.alphabet\n * @returns {Codec<Base, Prefix>}\n */\nexport const baseX = ({ prefix, name, alphabet }) => {\n  const { encode, decode } = basex(alphabet, name)\n  return from({\n    prefix,\n    name,\n    encode,\n    /**\n     * @param {string} text\n     */\n    decode: text => coerce(decode(text))\n  })\n}\n\n/**\n * @param {string} string\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @param {string} name\n * @returns {Uint8Array}\n */\nconst decode = (string, alphabet, bitsPerChar, name) => {\n  // Build the character lookup table:\n  /** @type {Record<string, number>} */\n  const codes = {}\n  for (let i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i\n  }\n\n  // Count the padding bytes:\n  let end = string.length\n  while (string[end - 1] === '=') {\n    --end\n  }\n\n  // Allocate the output:\n  const out = new Uint8Array((end * bitsPerChar / 8) | 0)\n\n  // Parse the data:\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  let written = 0 // Next byte to write\n  for (let i = 0; i < end; ++i) {\n    // Read one character from the string:\n    const value = codes[string[i]]\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${name} character`)\n    }\n\n    // Append the bits to the buffer:\n    buffer = (buffer << bitsPerChar) | value\n    bits += bitsPerChar\n\n    // Write out some bits if the buffer has a byte's worth:\n    if (bits >= 8) {\n      bits -= 8\n      out[written++] = 0xff & (buffer >> bits)\n    }\n  }\n\n  // Verify that we have received just enough bits:\n  if (bits >= bitsPerChar || 0xff & (buffer << (8 - bits))) {\n    throw new SyntaxError('Unexpected end of data')\n  }\n\n  return out\n}\n\n/**\n * @param {Uint8Array} data\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @returns {string}\n */\nconst encode = (data, alphabet, bitsPerChar) => {\n  const pad = alphabet[alphabet.length - 1] === '='\n  const mask = (1 << bitsPerChar) - 1\n  let out = ''\n\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  for (let i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = (buffer << 8) | data[i]\n    bits += 8\n\n    // Write out as much as we can:\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar\n      out += alphabet[mask & (buffer >> bits)]\n    }\n  }\n\n  // Partial character:\n  if (bits) {\n    out += alphabet[mask & (buffer << (bitsPerChar - bits))]\n  }\n\n  // Add padding characters until we hit a byte boundary:\n  if (pad) {\n    while ((out.length * bitsPerChar) & 7) {\n      out += '='\n    }\n  }\n\n  return out\n}\n\n/**\n * RFC4648 Factory\n *\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {string} options.alphabet\n * @param {number} options.bitsPerChar\n */\nexport const rfc4648 = ({ name, prefix, bitsPerChar, alphabet }) => {\n  return from({\n    prefix,\n    name,\n    encode (input) {\n      return encode(input, alphabet, bitsPerChar)\n    },\n    decode (input) {\n      return decode(input, alphabet, bitsPerChar, name)\n    }\n  })\n}\n", "import { baseX } from './base.js'\n\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n})\n\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n})\n", "// @ts-check\n\nimport { rfc4648 } from './base.js'\n\nexport const base64 = rfc4648({\n  prefix: 'm',\n  name: 'base64',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n  bitsPerChar: 6\n})\n\nexport const base64pad = rfc4648({\n  prefix: 'M',\n  name: 'base64pad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n  bitsPerChar: 6\n})\n\nexport const base64url = rfc4648({\n  prefix: 'u',\n  name: 'base64url',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n  bitsPerChar: 6\n})\n\nexport const base64urlpad = rfc4648({\n  prefix: 'U',\n  name: 'base64urlpad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',\n  bitsPerChar: 6\n})\n", "/**\n * @packageDocumentation\n *\n * This module exports various matchers that can be used to infer the type of a\n * passed multiaddr.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { DNS } from '@multiformats/multiaddr-matcher'\n *\n * const ma = multiaddr('/dnsaddr/example.org')\n *\n * DNS.matches(ma) // true - this is a multiaddr with a DNS address at the start\n * ```\n *\n * @example\n *\n * The default matching behaviour ignores any subsequent tuples in the multiaddr.\n * If you want stricter matching you can use `.exactMatch`:\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { DNS, Circuit } from '@multiformats/multiaddr-matcher'\n *\n * const ma = multiaddr('/dnsaddr/example.org/p2p/QmFoo/p2p-circuit/p2p/QmBar')\n *\n * DNS.exactMatch(ma) // false - this address has extra tuples after the DNS component\n * Circuit.matches(ma) // true\n * Circuit.exactMatch(ma) // true - the extra tuples are circuit relay related\n * ```\n */\n\nimport { isIPv4, isIPv6 } from '@chainsafe/is-ip'\nimport { type Multiaddr } from '@multiformats/multiaddr'\nimport { base58btc } from 'multiformats/bases/base58'\nimport { base64url } from 'multiformats/bases/base64'\n\n/**\n * Split a multiaddr into path components\n */\nconst toParts = (ma: Multiaddr): string[] => {\n  return ma.toString().split('/').slice(1)\n}\n\n/**\n * A matcher accepts multiaddr components and either fails to match and returns\n * false or returns a sublist of unmatched components\n */\ninterface Matcher {\n  match(parts: string[]): string[] | false\n  pattern: string\n}\n\nconst func = (fn: (val: string) => boolean): Matcher => {\n  return {\n    match: (vals) => {\n      if (vals.length < 1) {\n        return false\n      }\n\n      if (fn(vals[0])) {\n        return vals.slice(1)\n      }\n\n      return false\n    },\n    pattern: 'fn'\n  }\n}\n\nconst literal = (str: string): Matcher => {\n  return {\n    match: (vals) => func((val) => val === str).match(vals),\n    pattern: str\n  }\n}\n\nconst string = (): Matcher => {\n  return {\n    match: (vals) => func((val) => typeof val === 'string').match(vals),\n    pattern: '{string}'\n  }\n}\n\nconst number = (): Matcher => {\n  return {\n    match: (vals) => func((val) => !isNaN(parseInt(val))).match(vals),\n    pattern: '{number}'\n  }\n}\n\nconst peerId = (): Matcher => {\n  return {\n    match: (vals) => {\n      if (vals.length < 2) {\n        return false\n      }\n\n      if (vals[0] !== 'p2p' && vals[0] !== 'ipfs') {\n        return false\n      }\n\n      // Q is RSA, 1 is Ed25519 or Secp256k1\n      if (vals[1].startsWith('Q') || vals[1].startsWith('1')) {\n        try {\n          base58btc.decode(`z${vals[1]}`)\n        } catch (err) {\n          return false\n        }\n      } else {\n        return false\n      }\n\n      return vals.slice(2)\n    },\n    pattern: '/p2p/{peerid}'\n  }\n}\n\nconst certhash = (): Matcher => {\n  return {\n    match: (vals) => {\n      if (vals.length < 2) {\n        return false\n      }\n\n      if (vals[0] !== 'certhash') {\n        return false\n      }\n\n      try {\n        base64url.decode(vals[1])\n      } catch {\n        return false\n      }\n\n      return vals.slice(2)\n    },\n    pattern: '/certhash/{certhash}'\n  }\n}\n\nconst optional = (matcher: Matcher): Matcher => {\n  return {\n    match: (vals) => {\n      const result = matcher.match(vals)\n\n      if (result === false) {\n        return vals\n      }\n\n      return result\n    },\n    pattern: `optional(${matcher.pattern})`\n  }\n}\n\nconst or = (...matchers: Matcher[]): Matcher => {\n  return {\n    match: (vals) => {\n      let matches: string[] | undefined\n\n      for (const matcher of matchers) {\n        const result = matcher.match(vals)\n\n        // no match\n        if (result === false) {\n          continue\n        }\n\n        // choose greediest matcher\n        if (matches == null || result.length < matches.length) {\n          matches = result\n        }\n      }\n\n      if (matches == null) {\n        return false\n      }\n\n      return matches\n    },\n    pattern: `or(${matchers.map(m => m.pattern).join(', ')})`\n  }\n}\n\nconst and = (...matchers: Matcher[]): Matcher => {\n  return {\n    match: (vals) => {\n      for (const matcher of matchers) {\n        // pass what's left of the array\n        const result = matcher.match(vals)\n\n        // no match\n        if (result === false) {\n          return false\n        }\n\n        vals = result\n      }\n\n      return vals\n    },\n    pattern: `and(${matchers.map(m => m.pattern).join(', ')})`\n  }\n}\n\nfunction fmt (...matchers: Matcher[]): MultiaddrMatcher {\n  function match (ma: Multiaddr): string[] | false {\n    let parts = toParts(ma)\n\n    for (const matcher of matchers) {\n      const result = matcher.match(parts)\n\n      if (result === false) {\n        return false\n      }\n\n      parts = result\n    }\n\n    return parts\n  }\n\n  function matches (ma: Multiaddr): boolean {\n    const result = match(ma)\n\n    return result !== false\n  }\n\n  function exactMatch (ma: Multiaddr): boolean {\n    const result = match(ma)\n\n    if (result === false) {\n      return false\n    }\n\n    return result.length === 0\n  }\n\n  return {\n    matches,\n    exactMatch\n  }\n}\n\n/**\n * A MultiaddrMatcher allows interpreting a multiaddr as a certain type of\n * multiaddr\n */\nexport interface MultiaddrMatcher {\n  /**\n   * Returns true if the passed multiaddr can be treated as this type of\n   * multiaddr\n   */\n  matches(ma: Multiaddr): boolean\n\n  /**\n   * Returns true if the passed multiaddr terminates as this type of\n   * multiaddr\n   */\n  exactMatch(ma: Multiaddr): boolean\n}\n\n/**\n * DNS matchers\n */\nconst _DNS4 = and(literal('dns4'), string())\nconst _DNS6 = and(literal('dns6'), string())\nconst _DNSADDR = and(literal('dnsaddr'), string())\nconst _DNS = and(literal('dns'), string())\n\n/**\n * Matches dns4 addresses.\n *\n * Use {@link DNS DNS} instead to match any type of DNS address.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { DNS4 } from '@multiformats/multiaddr-matcher'\n *\n * DNS4.matches(multiaddr('/dns4/example.org')) // true\n * ```\n */\nexport const DNS4 = fmt(_DNS4)\n\n/**\n * Matches dns6 addresses.\n *\n * Use {@link DNS DNS} instead to match any type of DNS address.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { DNS6 } from '@multiformats/multiaddr-matcher'\n *\n * DNS6.matches(multiaddr('/dns6/example.org')) // true\n * ```\n */\nexport const DNS6 = fmt(_DNS6)\n\n/**\n * Matches dnsaddr addresses.\n *\n * Use {@link DNS DNS} instead to match any type of DNS address.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { DNSADDR } from '@multiformats/multiaddr-matcher'\n *\n * DNSADDR.matches(multiaddr('/dnsaddr/example.org')) // true\n * ```\n */\nexport const DNSADDR = fmt(_DNSADDR)\n\n/**\n * Matches any dns address.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { DNS } from '@multiformats/multiaddr-matcher'\n *\n * DNS.matches(multiaddr('/dnsaddr/example.org')) // true\n * DNS.matches(multiaddr('/dns4/example.org')) // true\n * DNS.matches(multiaddr('/dns6/example.org')) // true\n * ```\n */\nexport const DNS = fmt(or(\n  _DNS,\n  _DNSADDR,\n  _DNS4,\n  _DNS6\n))\n\nconst _IP4 = and(literal('ip4'), func(isIPv4))\nconst _IP6 = and(literal('ip6'), func(isIPv6))\nconst _IP = or(\n  _IP4,\n  _IP6\n)\n\nconst _IP_OR_DOMAIN = or(_IP, _DNS, _DNS4, _DNS6, _DNSADDR)\n\n/**\n * A matcher for addresses that start with IP or DNS tuples.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { IP_OR_DOMAIN } from '@multiformats/multiaddr-matcher'\n *\n * IP_OR_DOMAIN.matches(multiaddr('/ip4/123.123.123.123/p2p/QmFoo')) // true\n * IP_OR_DOMAIN.matches(multiaddr('/dns/example.com/p2p/QmFoo')) // true\n * IP_OR_DOMAIN.matches(multiaddr('/p2p/QmFoo')) // false\n * ```\n */\nexport const IP_OR_DOMAIN = fmt(_IP_OR_DOMAIN)\n\n/**\n * Matches ip4 addresses.\n *\n * Use {@link IP IP} instead to match any ip4/ip6 address.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { IP4 } from '@multiformats/multiaddr-matcher'\n *\n * const ma = multiaddr('/ip4/123.123.123.123')\n *\n * IP4.matches(ma) // true\n * ```\n */\nexport const IP4 = fmt(_IP4)\n\n/**\n * Matches ip6 addresses.\n *\n * Use {@link IP IP} instead to match any ip4/ip6 address.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { IP6 } from '@multiformats/multiaddr-matcher'\n *\n * const ma = multiaddr('/ip6/fe80::1cc1:a3b8:322f:cf22')\n *\n * IP6.matches(ma) // true\n * ```\n */\nexport const IP6 = fmt(_IP6)\n\n/**\n * Matches ip4 or ip6 addresses.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { IP } from '@multiformats/multiaddr-matcher'\n *\n * IP.matches(multiaddr('/ip4/123.123.123.123')) // true\n * IP.matches(multiaddr('/ip6/fe80::1cc1:a3b8:322f:cf22')) // true\n * ```\n */\nexport const IP = fmt(_IP)\n\nconst _TCP = and(_IP_OR_DOMAIN, literal('tcp'), number())\nconst _UDP = and(_IP_OR_DOMAIN, literal('udp'), number())\n\nconst TCP_OR_UDP = or(_TCP, _UDP)\n\n/**\n * Matches TCP addresses.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { TCP } from '@multiformats/multiaddr-matcher'\n *\n * TCP.matches(multiaddr('/ip4/123.123.123.123/tcp/1234')) // true\n * ```\n */\nexport const TCP = fmt(_TCP)\n\n/**\n * Matches UDP addresses.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { UDP } from '@multiformats/multiaddr-matcher'\n *\n * UDP.matches(multiaddr('/ip4/123.123.123.123/udp/1234')) // true\n * ```\n */\nexport const UDP = fmt(_UDP)\n\nconst _QUIC = and(_UDP, literal('quic'))\nconst _QUICV1 = and(_UDP, literal('quic-v1'))\n\nconst QUIC_V0_OR_V1 = or(_QUIC, _QUICV1)\n\n/**\n * Matches QUIC addresses.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { QUIC } from '@multiformats/multiaddr-matcher'\n *\n * QUIC.matches(multiaddr('/ip4/123.123.123.123/udp/1234/quic')) // true\n * ```\n */\nexport const QUIC = fmt(_QUIC)\n\n/**\n * Matches QUICv1 addresses.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { QUICV1 } from '@multiformats/multiaddr-matcher'\n *\n * QUICV1.matches(multiaddr('/ip4/123.123.123.123/udp/1234/quic-v1')) // true\n * ```\n */\nexport const QUICV1 = fmt(_QUICV1)\n\nconst _WEB = or(\n  _IP_OR_DOMAIN,\n  _TCP,\n  _UDP,\n  _QUIC,\n  _QUICV1\n)\n\nconst _WebSockets = or(\n  and(_WEB, literal('ws'), optional(peerId()))\n)\n\n/**\n * Matches WebSocket addresses.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { WebSockets } from '@multiformats/multiaddr-matcher'\n *\n * WebSockets.matches(multiaddr('/ip4/123.123.123.123/tcp/1234/ws')) // true\n * ```\n */\nexport const WebSockets = fmt(_WebSockets)\n\nconst _WebSocketsSecure = or(\n  and(_WEB, literal('wss'), optional(peerId())),\n  and(_WEB, literal('tls'), literal('ws'), optional(peerId()))\n)\n\n/**\n * Matches secure WebSocket addresses.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { WebSocketsSecure } from '@multiformats/multiaddr-matcher'\n *\n * WebSocketsSecure.matches(multiaddr('/ip4/123.123.123.123/tcp/1234/wss')) // true\n * ```\n */\nexport const WebSocketsSecure = fmt(_WebSocketsSecure)\n\nconst _WebRTCDirect = and(TCP_OR_UDP, literal('webrtc-direct'), certhash(), optional(certhash()), optional(peerId()))\n\n/**\n * Matches WebRTC-direct addresses.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { WebRTCDirect } from '@multiformats/multiaddr-matcher'\n *\n * WebRTCDirect.matches(multiaddr('/ip4/123.123.123.123/tcp/1234/p2p/QmFoo/webrtc-direct/certhash/u....')) // true\n * ```\n */\nexport const WebRTCDirect = fmt(_WebRTCDirect)\n\nconst _WebTransport = and(_QUICV1, literal('webtransport'), certhash(), certhash(), optional(peerId()))\n\n/**\n * Matches WebTransport addresses.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { WebRTCDirect } from '@multiformats/multiaddr-matcher'\n *\n * WebRTCDirect.matches(multiaddr('/ip4/123.123.123.123/udp/1234/quic-v1/webtransport/certhash/u..../certhash/u..../p2p/QmFoo')) // true\n * ```\n */\nexport const WebTransport = fmt(_WebTransport)\n\nconst _P2P = or(\n  _WebSockets,\n  _WebSocketsSecure,\n  and(_TCP, optional(peerId())),\n  and(QUIC_V0_OR_V1, optional(peerId())),\n  and(_IP_OR_DOMAIN, optional(peerId())),\n  _WebRTCDirect,\n  _WebTransport,\n  peerId()\n)\n\n/**\n * Matches peer addresses\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { P2P } from '@multiformats/multiaddr-matcher'\n *\n * P2P.matches(multiaddr('/ip4/123.123.123.123/tcp/1234/p2p/QmFoo')) // true\n * ```\n */\nexport const P2P = fmt(_P2P)\n\nconst _Circuit = and(_P2P, literal('p2p-circuit'), peerId())\n\n/**\n * Matches circuit relay addresses\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { Circuit } from '@multiformats/multiaddr-matcher'\n *\n * Circuit.matches(multiaddr('/ip4/123.123.123.123/tcp/1234/p2p/QmRelay/p2p-circuit/p2p/QmTarget')) // true\n * ```\n */\nexport const Circuit = fmt(_Circuit)\n\nconst _WebRTC = or(\n  and(_P2P, literal('p2p-circuit'), literal('webrtc'), peerId()),\n  and(_P2P, literal('webrtc'), optional(peerId())),\n  literal('webrtc')\n)\n\n/**\n * Matches WebRTC addresses\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { WebRTC } from '@multiformats/multiaddr-matcher'\n *\n * WebRTC.matches(multiaddr('/ip4/123.123.123.123/tcp/1234/p2p/QmRelay/p2p-circuit/webrtc/p2p/QmTarget')) // true\n * ```\n */\nexport const WebRTC = fmt(_WebRTC)\n", "import isIpPrivate from 'private-ip'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\n/**\n * Check if a given multiaddr has a private address.\n */\nexport function isPrivate (ma: Multiaddr): boolean {\n  try {\n    const { address } = ma.nodeAddress()\n\n    return Boolean(isIpPrivate(address))\n  } catch {\n    return true\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * Provides strategies to sort a list of multiaddrs.\n *\n * @example\n *\n * ```typescript\n * import { publicAddressesFirst } from '@libp2p/utils/address-sort'\n * import { multiaddr } from '@multformats/multiaddr'\n *\n *\n * const addresses = [\n *   multiaddr('/ip4/127.0.0.1/tcp/9000'),\n *   multiaddr('/ip4/82.41.53.1/tcp/9000')\n * ].sort(publicAddressesFirst)\n *\n * console.info(addresses)\n * // ['/ip4/82.41.53.1/tcp/9000', '/ip4/127.0.0.1/tcp/9000']\n * ```\n */\n\nimport { Circuit } from '@multiformats/multiaddr-matcher'\nimport { isPrivate } from './multiaddr/is-private.js'\nimport type { Address } from '@libp2p/interface/peer-store'\n\n/**\n * Compare function for array.sort() that moves public addresses to the start\n * of the array.\n */\nexport function publicAddressesFirst (a: Address, b: Address): -1 | 0 | 1 {\n  const isAPrivate = isPrivate(a.multiaddr)\n  const isBPrivate = isPrivate(b.multiaddr)\n\n  if (isAPrivate && !isBPrivate) {\n    return 1\n  } else if (!isAPrivate && isBPrivate) {\n    return -1\n  }\n\n  return 0\n}\n\n/**\n * Compare function for array.sort() that moves certified addresses to the start\n * of the array.\n */\nexport function certifiedAddressesFirst (a: Address, b: Address): -1 | 0 | 1 {\n  if (a.isCertified && !b.isCertified) {\n    return -1\n  } else if (!a.isCertified && b.isCertified) {\n    return 1\n  }\n\n  return 0\n}\n\n/**\n * Compare function for array.sort() that moves circuit relay addresses to the\n * start of the array.\n */\nexport function circuitRelayAddressesLast (a: Address, b: Address): -1 | 0 | 1 {\n  const isACircuit = Circuit.exactMatch(a.multiaddr)\n  const isBCircuit = Circuit.exactMatch(b.multiaddr)\n\n  if (isACircuit && !isBCircuit) {\n    return 1\n  } else if (!isACircuit && isBCircuit) {\n    return -1\n  }\n\n  return 0\n}\n\nexport function defaultAddressSort (a: Address, b: Address): -1 | 0 | 1 {\n  const publicResult = publicAddressesFirst(a, b)\n\n  if (publicResult !== 0) {\n    return publicResult\n  }\n\n  const relayResult = circuitRelayAddressesLast(a, b)\n\n  if (relayResult !== 0) {\n    return relayResult\n  }\n\n  const certifiedResult = certifiedAddressesFirst(a, b)\n\n  return certifiedResult\n}\n", "import debug from 'debug'\nimport Receptacle from 'receptacle'\nimport * as utils from './utils.js'\nimport type { DNSJSON } from './utils'\n\nconst log = Object.assign(debug('dns-over-http-resolver'), {\n  error: debug('dns-over-http-resolver:error')\n})\n\nexport interface Request { (resource: string, signal: AbortSignal): Promise<DNSJSON> }\n\ninterface ResolverOptions {\n  maxCache?: number\n  request?: Request\n}\n\n/**\n * DNS over HTTP resolver.\n * Uses a list of servers to resolve DNS records with HTTP requests.\n */\nclass Resolver {\n  private readonly _cache: Receptacle<string[]>\n  private readonly _TXTcache: Receptacle<string[][]>\n  private _servers: string[]\n  private readonly _request: Request\n  private _abortControllers: AbortController[]\n\n  /**\n   * @class\n   * @param {object} [options]\n   * @param {number} [options.maxCache = 100] - maximum number of cached dns records\n   * @param {Request} [options.request] - function to return DNSJSON\n   */\n  constructor (options: ResolverOptions = {}) {\n    this._cache = new Receptacle({ max: options?.maxCache ?? 100 })\n    this._TXTcache = new Receptacle({ max: options?.maxCache ?? 100 })\n    this._servers = [\n      'https://cloudflare-dns.com/dns-query',\n      'https://dns.google/resolve'\n    ]\n    this._request = options.request ?? utils.request\n    this._abortControllers = []\n  }\n\n  /**\n   * Cancel all outstanding DNS queries made by this resolver. Any outstanding\n   * requests will be aborted and promises rejected.\n   */\n  cancel (): void {\n    this._abortControllers.forEach(controller => { controller.abort() })\n  }\n\n  /**\n   * Get an array of the IP addresses currently configured for DNS resolution.\n   * These addresses are formatted according to RFC 5952. It can include a custom port.\n   */\n  getServers (): string[] {\n    return this._servers\n  }\n\n  /**\n   * Get a shuffled array of the IP addresses currently configured for DNS resolution.\n   * These addresses are formatted according to RFC 5952. It can include a custom port.\n   */\n  _getShuffledServers (): string[] {\n    const newServers = [...this._servers]\n\n    for (let i = newServers.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * i)\n      const temp = newServers[i]\n      newServers[i] = newServers[j]\n      newServers[j] = temp\n    }\n\n    return newServers\n  }\n\n  /**\n   * Sets the IP address and port of servers to be used when performing DNS resolution.\n   *\n   * @param {string[]} servers - array of RFC 5952 formatted addresses.\n   */\n  setServers (servers: string[]): void {\n    this._servers = servers\n  }\n\n  /**\n   * Uses the DNS protocol to resolve the given host name into the appropriate DNS record\n   *\n   * @param {string} hostname - host name to resolve\n   * @param {string} [rrType = 'A'] - resource record type\n   */\n  async resolve (hostname: string, rrType: 'TXT'): Promise<string[][]>\n  async resolve (hostname: string, rrType: 'A' | 'AAAA'): Promise<string[]>\n  async resolve (hostname: string): Promise<string[]>\n  async resolve (hostname: string, rrType: string = 'A'): Promise<string[] | string[][]> {\n    switch (rrType) {\n      case 'A':\n        return this.resolve4(hostname)\n      case 'AAAA':\n        return this.resolve6(hostname)\n      case 'TXT':\n        return this.resolveTxt(hostname)\n      default:\n        throw new Error(`${rrType} is not supported`)\n    }\n  }\n\n  /**\n   * Uses the DNS protocol to resolve the given host name into IPv4 addresses\n   *\n   * @param {string} hostname - host name to resolve\n   */\n  async resolve4 (hostname: string): Promise<string[]> {\n    const recordType = 'A'\n    const cached = this._cache.get(utils.getCacheKey(hostname, recordType))\n    if (cached != null) {\n      return cached\n    }\n    let aborted = false\n\n    for (const server of this._getShuffledServers()) {\n      const controller = new AbortController()\n      this._abortControllers.push(controller)\n\n      try {\n        const response = await this._request(utils.buildResource(\n          server,\n          hostname,\n          recordType\n        ), controller.signal)\n\n        const data = response.Answer.map(a => a.data)\n        const ttl = Math.min(...response.Answer.map(a => a.TTL))\n\n        this._cache.set(utils.getCacheKey(hostname, recordType), data, { ttl })\n\n        return data\n      } catch (err) {\n        if (controller.signal.aborted) {\n          aborted = true\n        }\n\n        log.error(`${server} could not resolve ${hostname} record ${recordType}`)\n      } finally {\n        this._abortControllers = this._abortControllers.filter(c => c !== controller)\n      }\n    }\n\n    if (aborted) {\n      throw Object.assign(new Error('queryA ECANCELLED'), {\n        code: 'ECANCELLED'\n      })\n    }\n\n    throw new Error(`Could not resolve ${hostname} record ${recordType}`)\n  }\n\n  /**\n   * Uses the DNS protocol to resolve the given host name into IPv6 addresses\n   *\n   * @param {string} hostname - host name to resolve\n   */\n  async resolve6 (hostname: string): Promise<string[]> {\n    const recordType = 'AAAA'\n    const cached = this._cache.get(utils.getCacheKey(hostname, recordType))\n    if (cached != null) {\n      return cached\n    }\n    let aborted = false\n\n    for (const server of this._getShuffledServers()) {\n      const controller = new AbortController()\n      this._abortControllers.push(controller)\n\n      try {\n        const response = await this._request(utils.buildResource(\n          server,\n          hostname,\n          recordType\n        ), controller.signal)\n\n        const data = response.Answer.map(a => a.data)\n        const ttl = Math.min(...response.Answer.map(a => a.TTL))\n\n        this._cache.set(utils.getCacheKey(hostname, recordType), data, { ttl })\n\n        return data\n      } catch (err) {\n        if (controller.signal.aborted) {\n          aborted = true\n        }\n\n        log.error(`${server} could not resolve ${hostname} record ${recordType}`)\n      } finally {\n        this._abortControllers = this._abortControllers.filter(c => c !== controller)\n      }\n    }\n\n    if (aborted) {\n      throw Object.assign(new Error('queryAaaa ECANCELLED'), {\n        code: 'ECANCELLED'\n      })\n    }\n\n    throw new Error(`Could not resolve ${hostname} record ${recordType}`)\n  }\n\n  /**\n   * Uses the DNS protocol to resolve the given host name into a Text record\n   *\n   * @param {string} hostname - host name to resolve\n   */\n  async resolveTxt (hostname: string): Promise<string[][]> {\n    const recordType = 'TXT'\n    const cached = this._TXTcache.get(utils.getCacheKey(hostname, recordType))\n    if (cached != null) {\n      return cached\n    }\n    let aborted = false\n\n    for (const server of this._getShuffledServers()) {\n      const controller = new AbortController()\n      this._abortControllers.push(controller)\n\n      try {\n        const response = await this._request(utils.buildResource(\n          server,\n          hostname,\n          recordType\n        ), controller.signal)\n\n        const data = response.Answer.map(a => [a.data.replace(/['\"]+/g, '')])\n        const ttl = Math.min(...response.Answer.map(a => a.TTL))\n\n        this._TXTcache.set(utils.getCacheKey(hostname, recordType), data, { ttl })\n\n        return data\n      } catch (err) {\n        if (controller.signal.aborted) {\n          aborted = true\n        }\n\n        log.error(`${server} could not resolve ${hostname} record ${recordType}`)\n      } finally {\n        this._abortControllers = this._abortControllers.filter(c => c !== controller)\n      }\n    }\n\n    if (aborted) {\n      throw Object.assign(new Error('queryTxt ECANCELLED'), {\n        code: 'ECANCELLED'\n      })\n    }\n\n    throw new Error(`Could not resolve ${hostname} record ${recordType}`)\n  }\n\n  clearCache (): void {\n    this._cache.clear()\n    this._TXTcache.clear()\n  }\n}\n\nexport default Resolver\n", "/**\n * Build fetch resource for request\n */\nexport function buildResource (serverResolver: string, hostname: string, recordType: string): string {\n  return `${serverResolver}?name=${hostname}&type=${recordType}`\n}\n\nexport interface DNSJSON {\n  Question: Question[]\n  Answer: Answer[]\n}\n\ninterface Question {\n  name: string\n  type: number\n}\n\ninterface Answer {\n  name: string\n  type: number\n  data: string\n  TTL: number\n}\n\n/**\n * Use fetch to find the record\n */\nexport async function request (resource: string, signal: AbortSignal): Promise<DNSJSON> {\n  const req = await fetch(resource, {\n    headers: new Headers({\n      accept: 'application/dns-json'\n    }),\n    signal\n  })\n  const res = await req.json()\n\n  return res as DNSJSON\n}\n\n/**\n * Creates cache key composed by recordType and hostname\n *\n * @param {string} hostname\n * @param {string} recordType\n */\nexport function getCacheKey (hostname: string, recordType: string): string {\n  return `${recordType}_${hostname}`\n}\n", "import dns from 'dns-over-http-resolver'\n\nexport default dns\n", "/**\n * @packageDocumentation\n *\n * Provides strategies for resolving multiaddrs.\n */\n\nimport { getProtocol } from '../protocols-table.js'\nimport Resolver from './dns.js'\nimport type { AbortOptions, Multiaddr } from '../index.js'\n\nconst { code: dnsaddrCode } = getProtocol('dnsaddr')\n\n/**\n * Resolver for dnsaddr addresses.\n *\n * @example\n *\n * ```typescript\n * import { dnsaddrResolver } from '@multiformats/multiaddr/resolvers'\n * import { multiaddr } from '@multiformats/multiaddr'\n *\n * const ma = multiaddr('/dnsaddr/bootstrap.libp2p.io')\n * const addresses = await dnsaddrResolver(ma)\n *\n * console.info(addresses)\n * //[\n * //  '/dnsaddr/am6.bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb',\n * //  '/dnsaddr/ny5.bootstrap.libp2p.io/p2p/QmQCU2EcMqAqQPR2i9bChDtGNJchTbq5TbXJJ16u19uLTa',\n * //  '/dnsaddr/sg1.bootstrap.libp2p.io/p2p/QmcZf59bWwK5XFi76CZX8cbJ4BhTzzA3gU1ZjYZcYW3dwt',\n * //  '/dnsaddr/sv15.bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN'\n * //]\n * ```\n */\nexport async function dnsaddrResolver (addr: Multiaddr, options: AbortOptions = {}): Promise<string[]> {\n  const resolver = new Resolver()\n\n  if (options.signal != null) {\n    options.signal.addEventListener('abort', () => {\n      resolver.cancel()\n    })\n  }\n\n  const peerId = addr.getPeerId()\n  const [, hostname] = addr.stringTuples().find(([proto]) => proto === dnsaddrCode) ?? []\n\n  if (hostname == null) {\n    throw new Error('No hostname found in multiaddr')\n  }\n\n  const records = await resolver.resolveTxt(`_dnsaddr.${hostname}`)\n\n  let addresses = records.flat().map((a) => a.split('=')[1]).filter(Boolean)\n\n  if (peerId != null) {\n    addresses = addresses.filter((entry) => entry.includes(peerId))\n  }\n\n  return addresses\n}\n", "export enum messages {\n  NOT_STARTED_YET = 'The libp2p node is not started yet',\n  DHT_DISABLED = 'DHT is not available',\n  PUBSUB_DISABLED = 'PubSub is not available',\n  CONN_ENCRYPTION_REQUIRED = 'At least one connection encryption module is required',\n  ERR_TRANSPORTS_REQUIRED = 'At least one transport module is required',\n  ERR_PROTECTOR_REQUIRED = 'Private network is enforced, but no protector was provided',\n  NOT_FOUND = 'Not found'\n}\n\nexport enum codes {\n  DHT_DISABLED = 'ERR_DHT_DISABLED',\n  ERR_PUBSUB_DISABLED = 'ERR_PUBSUB_DISABLED',\n  PUBSUB_NOT_STARTED = 'ERR_PUBSUB_NOT_STARTED',\n  DHT_NOT_STARTED = 'ERR_DHT_NOT_STARTED',\n  CONN_ENCRYPTION_REQUIRED = 'ERR_CONN_ENCRYPTION_REQUIRED',\n  ERR_TRANSPORTS_REQUIRED = 'ERR_TRANSPORTS_REQUIRED',\n  ERR_PROTECTOR_REQUIRED = 'ERR_PROTECTOR_REQUIRED',\n  ERR_PEER_DIAL_INTERCEPTED = 'ERR_PEER_DIAL_INTERCEPTED',\n  ERR_CONNECTION_INTERCEPTED = 'ERR_CONNECTION_INTERCEPTED',\n  ERR_INVALID_PROTOCOLS_FOR_STREAM = 'ERR_INVALID_PROTOCOLS_FOR_STREAM',\n  ERR_CONNECTION_ENDED = 'ERR_CONNECTION_ENDED',\n  ERR_CONNECTION_FAILED = 'ERR_CONNECTION_FAILED',\n  ERR_NODE_NOT_STARTED = 'ERR_NODE_NOT_STARTED',\n  ERR_ALREADY_ABORTED = 'ERR_ALREADY_ABORTED',\n  ERR_TOO_MANY_ADDRESSES = 'ERR_TOO_MANY_ADDRESSES',\n  ERR_NO_VALID_ADDRESSES = 'ERR_NO_VALID_ADDRESSES',\n  ERR_RELAYED_DIAL = 'ERR_RELAYED_DIAL',\n  ERR_DIALED_SELF = 'ERR_DIALED_SELF',\n  ERR_DISCOVERED_SELF = 'ERR_DISCOVERED_SELF',\n  ERR_DUPLICATE_TRANSPORT = 'ERR_DUPLICATE_TRANSPORT',\n  ERR_ENCRYPTION_FAILED = 'ERR_ENCRYPTION_FAILED',\n  ERR_HOP_REQUEST_FAILED = 'ERR_HOP_REQUEST_FAILED',\n  ERR_INVALID_KEY = 'ERR_INVALID_KEY',\n  ERR_INVALID_MESSAGE = 'ERR_INVALID_MESSAGE',\n  ERR_INVALID_PARAMETERS = 'ERR_INVALID_PARAMETERS',\n  ERR_INVALID_PEER = 'ERR_INVALID_PEER',\n  ERR_MUXER_UNAVAILABLE = 'ERR_MUXER_UNAVAILABLE',\n  ERR_NOT_FOUND = 'ERR_NOT_FOUND',\n  ERR_TIMEOUT = 'ERR_TIMEOUT',\n  ERR_TRANSPORT_UNAVAILABLE = 'ERR_TRANSPORT_UNAVAILABLE',\n  ERR_TRANSPORT_DIAL_FAILED = 'ERR_TRANSPORT_DIAL_FAILED',\n  ERR_UNSUPPORTED_PROTOCOL = 'ERR_UNSUPPORTED_PROTOCOL',\n  ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED = 'ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED',\n  ERR_INVALID_MULTIADDR = 'ERR_INVALID_MULTIADDR',\n  ERR_SIGNATURE_NOT_VALID = 'ERR_SIGNATURE_NOT_VALID',\n  ERR_FIND_SELF = 'ERR_FIND_SELF',\n  ERR_NO_ROUTERS_AVAILABLE = 'ERR_NO_ROUTERS_AVAILABLE',\n  ERR_CONNECTION_NOT_MULTIPLEXED = 'ERR_CONNECTION_NOT_MULTIPLEXED',\n  ERR_NO_DIAL_TOKENS = 'ERR_NO_DIAL_TOKENS',\n  ERR_KEYCHAIN_REQUIRED = 'ERR_KEYCHAIN_REQUIRED',\n  ERR_INVALID_CMS = 'ERR_INVALID_CMS',\n  ERR_MISSING_KEYS = 'ERR_MISSING_KEYS',\n  ERR_NO_KEY = 'ERR_NO_KEY',\n  ERR_INVALID_KEY_NAME = 'ERR_INVALID_KEY_NAME',\n  ERR_INVALID_KEY_TYPE = 'ERR_INVALID_KEY_TYPE',\n  ERR_KEY_ALREADY_EXISTS = 'ERR_KEY_ALREADY_EXISTS',\n  ERR_INVALID_KEY_SIZE = 'ERR_INVALID_KEY_SIZE',\n  ERR_KEY_NOT_FOUND = 'ERR_KEY_NOT_FOUND',\n  ERR_OLD_KEY_NAME_INVALID = 'ERR_OLD_KEY_NAME_INVALID',\n  ERR_NEW_KEY_NAME_INVALID = 'ERR_NEW_KEY_NAME_INVALID',\n  ERR_PASSWORD_REQUIRED = 'ERR_PASSWORD_REQUIRED',\n  ERR_PEM_REQUIRED = 'ERR_PEM_REQUIRED',\n  ERR_CANNOT_READ_KEY = 'ERR_CANNOT_READ_KEY',\n  ERR_MISSING_PRIVATE_KEY = 'ERR_MISSING_PRIVATE_KEY',\n  ERR_MISSING_PUBLIC_KEY = 'ERR_MISSING_PUBLIC_KEY',\n  ERR_INVALID_OLD_PASS_TYPE = 'ERR_INVALID_OLD_PASS_TYPE',\n  ERR_INVALID_NEW_PASS_TYPE = 'ERR_INVALID_NEW_PASS_TYPE',\n  ERR_INVALID_PASS_LENGTH = 'ERR_INVALID_PASS_LENGTH',\n  ERR_NOT_IMPLEMENTED = 'ERR_NOT_IMPLEMENTED',\n  ERR_WRONG_PING_ACK = 'ERR_WRONG_PING_ACK',\n  ERR_INVALID_RECORD = 'ERR_INVALID_RECORD',\n  ERR_ALREADY_SUCCEEDED = 'ERR_ALREADY_SUCCEEDED',\n  ERR_NO_HANDLER_FOR_PROTOCOL = 'ERR_NO_HANDLER_FOR_PROTOCOL',\n  ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS = 'ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS',\n  ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS = 'ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS',\n  ERR_CONNECTION_DENIED = 'ERR_CONNECTION_DENIED',\n  ERR_TRANSFER_LIMIT_EXCEEDED = 'ERR_TRANSFER_LIMIT_EXCEEDED'\n}\n", "import { CodeError } from '@libp2p/interface/errors'\nimport { FaultTolerance } from '@libp2p/interface/transport'\nimport { defaultAddressSort } from '@libp2p/utils/address-sort'\nimport { dnsaddrResolver } from '@multiformats/multiaddr/resolvers'\nimport mergeOptions from 'merge-options'\nimport { codes, messages } from './errors.js'\nimport type { Libp2pInit } from './index.js'\nimport type { ServiceMap, RecursivePartial } from '@libp2p/interface'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nconst DefaultConfig: Partial<Libp2pInit> = {\n  addresses: {\n    listen: [],\n    announce: [],\n    noAnnounce: [],\n    announceFilter: (multiaddrs: Multiaddr[]) => multiaddrs\n  },\n  connectionManager: {\n    resolvers: {\n      dnsaddr: dnsaddrResolver\n    },\n    addressSorter: defaultAddressSort\n  },\n  transportManager: {\n    faultTolerance: FaultTolerance.FATAL_ALL\n  }\n}\n\nexport function validateConfig <T extends ServiceMap = Record<string, unknown>> (opts: RecursivePartial<Libp2pInit<T>>): Libp2pInit<T> {\n  const resultingOptions: Libp2pInit<T> = mergeOptions(DefaultConfig, opts)\n\n  if (resultingOptions.transports == null || resultingOptions.transports.length < 1) {\n    throw new CodeError(messages.ERR_TRANSPORTS_REQUIRED, codes.ERR_TRANSPORTS_REQUIRED)\n  }\n\n  if (resultingOptions.connectionProtector === null && globalThis.process?.env?.LIBP2P_FORCE_PNET != null) { // eslint-disable-line no-undef\n    throw new CodeError(messages.ERR_PROTECTOR_REQUIRED, codes.ERR_PROTECTOR_REQUIRED)\n  }\n\n  return resultingOptions\n}\n", "export const KEEP_ALIVE = 'keep-alive'\n", "import { CodeError } from '@libp2p/interface/errors'\nimport { KEEP_ALIVE } from '@libp2p/interface/peer-store/tags'\nimport { PeerMap } from '@libp2p/peer-collections'\nimport { defaultAddressSort } from '@libp2p/utils/address-sort'\nimport { type Multiaddr, type Resolver, multiaddr } from '@multiformats/multiaddr'\nimport { dnsaddrResolver } from '@multiformats/multiaddr/resolvers'\nimport { RateLimiterMemory } from 'rate-limiter-flexible'\nimport { codes } from '../errors.js'\nimport { getPeerAddress } from '../get-peer.js'\nimport { AutoDial } from './auto-dial.js'\nimport { ConnectionPruner } from './connection-pruner.js'\nimport { AUTO_DIAL_CONCURRENCY, AUTO_DIAL_MAX_QUEUE_LENGTH, AUTO_DIAL_PRIORITY, DIAL_TIMEOUT, INBOUND_CONNECTION_THRESHOLD, MAX_CONNECTIONS, MAX_INCOMING_PENDING_CONNECTIONS, MAX_PARALLEL_DIALS, MAX_PARALLEL_DIALS_PER_PEER, MAX_PEER_ADDRS_TO_DIAL, MIN_CONNECTIONS } from './constants.js'\nimport { DialQueue } from './dial-queue.js'\nimport type { PendingDial, AddressSorter, Libp2pEvents, AbortOptions, ComponentLogger, Logger } from '@libp2p/interface'\nimport type { Connection, MultiaddrConnection } from '@libp2p/interface/connection'\nimport type { ConnectionGater } from '@libp2p/interface/connection-gater'\nimport type { TypedEventTarget } from '@libp2p/interface/events'\nimport type { Metrics } from '@libp2p/interface/metrics'\nimport type { PeerId } from '@libp2p/interface/peer-id'\nimport type { Peer, PeerStore } from '@libp2p/interface/peer-store'\nimport type { Startable } from '@libp2p/interface/startable'\nimport type { ConnectionManager, OpenConnectionOptions } from '@libp2p/interface-internal/connection-manager'\nimport type { TransportManager } from '@libp2p/interface-internal/transport-manager'\n\nconst DEFAULT_DIAL_PRIORITY = 50\n\nexport interface ConnectionManagerInit {\n  /**\n   * The maximum number of connections libp2p is willing to have before it starts\n   * pruning connections to reduce resource usage. (default: 300, 100 in browsers)\n   */\n  maxConnections?: number\n\n  /**\n   * The minimum number of connections below which libp2p will start to dial peers\n   * from the peer book. Setting this to 0 effectively disables this behaviour.\n   * (default: 50, 5 in browsers)\n   */\n  minConnections?: number\n\n  /**\n   * How long to wait between attempting to keep our number of concurrent connections\n   * above minConnections (default: 5000)\n   */\n  autoDialInterval?: number\n\n  /**\n   * When dialling peers from the peer book to keep the number of open connections\n   * above `minConnections`, add dials for this many peers to the dial queue\n   * at once. (default: 25)\n   */\n  autoDialConcurrency?: number\n\n  /**\n   * To allow user dials to take priority over auto dials, use this value as the\n   * dial priority. (default: 0)\n   */\n  autoDialPriority?: number\n\n  /**\n   * Limit the maximum number of peers to dial when trying to keep the number of\n   * open connections above `minConnections`. (default: 100)\n   */\n  autoDialMaxQueueLength?: number\n\n  /**\n   * When we've failed to dial a peer, do not autodial them again within this\n   * number of ms. (default: 1 minute, 7 minutes in browsers)\n   */\n  autoDialPeerRetryThreshold?: number\n\n  /**\n   * Newly discovered peers may be auto-dialed to increase the number of open\n   * connections, but they can be discovered in quick succession so add a small\n   * delay before attempting to dial them in case more peers have been\n   * discovered. (default: 10ms)\n   */\n  autoDialDiscoveredPeersDebounce?: number\n\n  /**\n   * Sort the known addresses of a peer before trying to dial, By default public\n   * addresses will be dialled before private (e.g. loopback or LAN) addresses.\n   */\n  addressSorter?: AddressSorter\n\n  /**\n   * The maximum number of dials across all peers to execute in parallel.\n   * (default: 100, 50 in browsers)\n   */\n  maxParallelDials?: number\n\n  /**\n   * To prevent individual peers with large amounts of multiaddrs swamping the\n   * dial queue, this value controls how many addresses to dial in parallel per\n   * peer. So for example if two peers have 10 addresses and this value is set\n   * at 5, we will dial 5 addresses from each at a time. (default: 1)\n   */\n  maxParallelDialsPerPeer?: number\n\n  /**\n   * Maximum number of addresses allowed for a given peer - if a peer has more\n   * addresses than this then the dial will fail. (default: 25)\n   */\n  maxPeerAddrsToDial?: number\n\n  /**\n   * How long a dial attempt is allowed to take, including DNS resolution\n   * of the multiaddr, opening a socket and upgrading it to a Connection.\n   */\n  dialTimeout?: number\n\n  /**\n   * When a new inbound connection is opened, the upgrade process (e.g. protect,\n   * encrypt, multiplex etc) must complete within this number of ms. (default: 30s)\n   */\n  inboundUpgradeTimeout?: number\n\n  /**\n   * Multiaddr resolvers to use when dialling\n   */\n  resolvers?: Record<string, Resolver>\n\n  /**\n   * A list of multiaddrs that will always be allowed (except if they are in the\n   * deny list) to open connections to this node even if we've reached maxConnections\n   */\n  allow?: string[]\n\n  /**\n   * A list of multiaddrs that will never be allowed to open connections to\n   * this node under any circumstances\n   */\n  deny?: string[]\n\n  /**\n   * If more than this many connections are opened per second by a single\n   * host, reject subsequent connections. (default: 5)\n   */\n  inboundConnectionThreshold?: number\n\n  /**\n   * The maximum number of parallel incoming connections allowed that have yet to\n   * complete the connection upgrade - e.g. choosing connection encryption, muxer, etc.\n   * (default: 10)\n   */\n  maxIncomingPendingConnections?: number\n}\n\nconst defaultOptions = {\n  minConnections: MIN_CONNECTIONS,\n  maxConnections: MAX_CONNECTIONS,\n  inboundConnectionThreshold: INBOUND_CONNECTION_THRESHOLD,\n  maxIncomingPendingConnections: MAX_INCOMING_PENDING_CONNECTIONS,\n  autoDialConcurrency: AUTO_DIAL_CONCURRENCY,\n  autoDialPriority: AUTO_DIAL_PRIORITY,\n  autoDialMaxQueueLength: AUTO_DIAL_MAX_QUEUE_LENGTH\n}\n\nexport interface DefaultConnectionManagerComponents {\n  peerId: PeerId\n  metrics?: Metrics\n  peerStore: PeerStore\n  transportManager: TransportManager\n  connectionGater: ConnectionGater\n  events: TypedEventTarget<Libp2pEvents>\n  logger: ComponentLogger\n}\n\n/**\n * Responsible for managing known connections.\n */\nexport class DefaultConnectionManager implements ConnectionManager, Startable {\n  private started: boolean\n  private readonly connections: PeerMap<Connection[]>\n  private readonly allow: Multiaddr[]\n  private readonly deny: Multiaddr[]\n  private readonly maxIncomingPendingConnections: number\n  private incomingPendingConnections: number\n  private readonly maxConnections: number\n\n  public readonly dialQueue: DialQueue\n  public readonly autoDial: AutoDial\n  public readonly connectionPruner: ConnectionPruner\n  private readonly inboundConnectionRateLimiter: RateLimiterMemory\n\n  private readonly peerStore: PeerStore\n  private readonly metrics?: Metrics\n  private readonly events: TypedEventTarget<Libp2pEvents>\n  readonly #log: Logger\n\n  constructor (components: DefaultConnectionManagerComponents, init: ConnectionManagerInit = {}) {\n    this.maxConnections = init.maxConnections ?? defaultOptions.maxConnections\n    const minConnections = init.minConnections ?? defaultOptions.minConnections\n\n    if (this.maxConnections < minConnections) {\n      throw new CodeError('Connection Manager maxConnections must be greater than minConnections', codes.ERR_INVALID_PARAMETERS)\n    }\n\n    /**\n     * Map of connections per peer\n     */\n    this.connections = new PeerMap()\n\n    this.started = false\n    this.peerStore = components.peerStore\n    this.metrics = components.metrics\n    this.events = components.events\n    this.#log = components.logger.forComponent('libp2p:connection-manager')\n\n    this.onConnect = this.onConnect.bind(this)\n    this.onDisconnect = this.onDisconnect.bind(this)\n    this.events.addEventListener('connection:open', this.onConnect)\n    this.events.addEventListener('connection:close', this.onDisconnect)\n\n    // allow/deny lists\n    this.allow = (init.allow ?? []).map(ma => multiaddr(ma))\n    this.deny = (init.deny ?? []).map(ma => multiaddr(ma))\n\n    this.incomingPendingConnections = 0\n    this.maxIncomingPendingConnections = init.maxIncomingPendingConnections ?? defaultOptions.maxIncomingPendingConnections\n\n    // controls individual peers trying to dial us too quickly\n    this.inboundConnectionRateLimiter = new RateLimiterMemory({\n      points: init.inboundConnectionThreshold ?? defaultOptions.inboundConnectionThreshold,\n      duration: 1\n    })\n\n    // controls what happens when we don't have enough connections\n    this.autoDial = new AutoDial({\n      connectionManager: this,\n      peerStore: components.peerStore,\n      events: components.events,\n      logger: components.logger\n    }, {\n      minConnections,\n      autoDialConcurrency: init.autoDialConcurrency ?? defaultOptions.autoDialConcurrency,\n      autoDialPriority: init.autoDialPriority ?? defaultOptions.autoDialPriority,\n      maxQueueLength: init.autoDialMaxQueueLength ?? defaultOptions.autoDialMaxQueueLength\n    })\n\n    // controls what happens when we have too many connections\n    this.connectionPruner = new ConnectionPruner({\n      connectionManager: this,\n      peerStore: components.peerStore,\n      events: components.events,\n      logger: components.logger\n    }, {\n      maxConnections: this.maxConnections,\n      allow: this.allow\n    })\n\n    this.dialQueue = new DialQueue({\n      peerId: components.peerId,\n      metrics: components.metrics,\n      peerStore: components.peerStore,\n      transportManager: components.transportManager,\n      connectionGater: components.connectionGater,\n      logger: components.logger\n    }, {\n      addressSorter: init.addressSorter ?? defaultAddressSort,\n      maxParallelDials: init.maxParallelDials ?? MAX_PARALLEL_DIALS,\n      maxPeerAddrsToDial: init.maxPeerAddrsToDial ?? MAX_PEER_ADDRS_TO_DIAL,\n      maxParallelDialsPerPeer: init.maxParallelDialsPerPeer ?? MAX_PARALLEL_DIALS_PER_PEER,\n      dialTimeout: init.dialTimeout ?? DIAL_TIMEOUT,\n      resolvers: init.resolvers ?? {\n        dnsaddr: dnsaddrResolver\n      },\n      connections: this.connections\n    })\n  }\n\n  isStarted (): boolean {\n    return this.started\n  }\n\n  /**\n   * Starts the Connection Manager. If Metrics are not enabled on libp2p\n   * only event loop and connection limits will be monitored.\n   */\n  async start (): Promise<void> {\n    // track inbound/outbound connections\n    this.metrics?.registerMetricGroup('libp2p_connection_manager_connections', {\n      calculate: () => {\n        const metric = {\n          inbound: 0,\n          outbound: 0\n        }\n\n        for (const conns of this.connections.values()) {\n          for (const conn of conns) {\n            if (conn.direction === 'inbound') {\n              metric.inbound++\n            } else {\n              metric.outbound++\n            }\n          }\n        }\n\n        return metric\n      }\n    })\n\n    // track total number of streams per protocol\n    this.metrics?.registerMetricGroup('libp2p_protocol_streams_total', {\n      label: 'protocol',\n      calculate: () => {\n        const metric: Record<string, number> = {}\n\n        for (const conns of this.connections.values()) {\n          for (const conn of conns) {\n            for (const stream of conn.streams) {\n              const key = `${stream.direction} ${stream.protocol ?? 'unnegotiated'}`\n\n              metric[key] = (metric[key] ?? 0) + 1\n            }\n          }\n        }\n\n        return metric\n      }\n    })\n\n    // track 90th percentile of streams per protocol\n    this.metrics?.registerMetricGroup('libp2p_connection_manager_protocol_streams_per_connection_90th_percentile', {\n      label: 'protocol',\n      calculate: () => {\n        const allStreams: Record<string, number[]> = {}\n\n        for (const conns of this.connections.values()) {\n          for (const conn of conns) {\n            const streams: Record<string, number> = {}\n\n            for (const stream of conn.streams) {\n              const key = `${stream.direction} ${stream.protocol ?? 'unnegotiated'}`\n\n              streams[key] = (streams[key] ?? 0) + 1\n            }\n\n            for (const [protocol, count] of Object.entries(streams)) {\n              allStreams[protocol] = allStreams[protocol] ?? []\n              allStreams[protocol].push(count)\n            }\n          }\n        }\n\n        const metric: Record<string, number> = {}\n\n        for (let [protocol, counts] of Object.entries(allStreams)) {\n          counts = counts.sort((a, b) => a - b)\n\n          const index = Math.floor(counts.length * 0.9)\n          metric[protocol] = counts[index]\n        }\n\n        return metric\n      }\n    })\n\n    this.autoDial.start()\n\n    this.started = true\n    this.#log('started')\n  }\n\n  async afterStart (): Promise<void> {\n    // re-connect to any peers with the KEEP_ALIVE tag\n    void Promise.resolve()\n      .then(async () => {\n        const keepAlivePeers: Peer[] = await this.peerStore.all({\n          filters: [(peer) => {\n            return peer.tags.has(KEEP_ALIVE)\n          }]\n        })\n\n        await Promise.all(\n          keepAlivePeers.map(async peer => {\n            await this.openConnection(peer.id)\n              .catch(err => {\n                this.#log.error(err)\n              })\n          })\n        )\n      })\n      .catch(err => {\n        this.#log.error(err)\n      })\n\n    this.autoDial.afterStart()\n  }\n\n  /**\n   * Stops the Connection Manager\n   */\n  async stop (): Promise<void> {\n    this.dialQueue.stop()\n    this.autoDial.stop()\n\n    // Close all connections we're tracking\n    const tasks: Array<Promise<void>> = []\n    for (const connectionList of this.connections.values()) {\n      for (const connection of connectionList) {\n        tasks.push((async () => {\n          try {\n            await connection.close()\n          } catch (err) {\n            this.#log.error(err)\n          }\n        })())\n      }\n    }\n\n    this.#log('closing %d connections', tasks.length)\n    await Promise.all(tasks)\n    this.connections.clear()\n\n    this.#log('stopped')\n  }\n\n  onConnect (evt: CustomEvent<Connection>): void {\n    void this._onConnect(evt).catch(err => {\n      this.#log.error(err)\n    })\n  }\n\n  /**\n   * Tracks the incoming connection and check the connection limit\n   */\n  async _onConnect (evt: CustomEvent<Connection>): Promise<void> {\n    const { detail: connection } = evt\n\n    if (!this.started) {\n      // This can happen when we are in the process of shutting down the node\n      await connection.close()\n      return\n    }\n\n    const peerId = connection.remotePeer\n    const storedConns = this.connections.get(peerId)\n    let isNewPeer = false\n\n    if (storedConns != null) {\n      storedConns.push(connection)\n    } else {\n      isNewPeer = true\n      this.connections.set(peerId, [connection])\n    }\n\n    // only need to store RSA public keys, all other types are embedded in the peer id\n    if (peerId.publicKey != null && peerId.type === 'RSA') {\n      await this.peerStore.patch(peerId, {\n        publicKey: peerId.publicKey\n      })\n    }\n\n    if (isNewPeer) {\n      this.events.safeDispatchEvent('peer:connect', { detail: connection.remotePeer })\n    }\n  }\n\n  /**\n   * Removes the connection from tracking\n   */\n  onDisconnect (evt: CustomEvent<Connection>): void {\n    const { detail: connection } = evt\n\n    if (!this.started) {\n      // This can happen when we are in the process of shutting down the node\n      return\n    }\n\n    const peerId = connection.remotePeer\n    let storedConn = this.connections.get(peerId)\n\n    if (storedConn != null && storedConn.length > 1) {\n      storedConn = storedConn.filter((conn) => conn.id !== connection.id)\n      this.connections.set(peerId, storedConn)\n    } else if (storedConn != null) {\n      this.connections.delete(peerId)\n      this.events.safeDispatchEvent('peer:disconnect', { detail: connection.remotePeer })\n    }\n  }\n\n  getConnections (peerId?: PeerId): Connection[] {\n    if (peerId != null) {\n      return this.connections.get(peerId) ?? []\n    }\n\n    let conns: Connection[] = []\n\n    for (const c of this.connections.values()) {\n      conns = conns.concat(c)\n    }\n\n    return conns\n  }\n\n  getConnectionsMap (): PeerMap<Connection[]> {\n    return this.connections\n  }\n\n  async openConnection (peerIdOrMultiaddr: PeerId | Multiaddr | Multiaddr[], options: OpenConnectionOptions = {}): Promise<Connection> {\n    if (!this.isStarted()) {\n      throw new CodeError('Not started', codes.ERR_NODE_NOT_STARTED)\n    }\n\n    options.signal?.throwIfAborted()\n\n    const { peerId } = getPeerAddress(peerIdOrMultiaddr)\n\n    if (peerId != null && options.force !== true) {\n      this.#log('dial %p', peerId)\n      const existingConnection = this.getConnections(peerId)\n        .find(conn => !conn.transient)\n\n      if (existingConnection != null) {\n        this.#log('had an existing non-transient connection to %p', peerId)\n\n        return existingConnection\n      }\n    }\n\n    const connection = await this.dialQueue.dial(peerIdOrMultiaddr, {\n      ...options,\n      priority: options.priority ?? DEFAULT_DIAL_PRIORITY\n    })\n    let peerConnections = this.connections.get(connection.remotePeer)\n\n    if (peerConnections == null) {\n      peerConnections = []\n      this.connections.set(connection.remotePeer, peerConnections)\n    }\n\n    // we get notified of connections via the Upgrader emitting \"connection\"\n    // events, double check we aren't already tracking this connection before\n    // storing it\n    let trackedConnection = false\n\n    for (const conn of peerConnections) {\n      if (conn.id === connection.id) {\n        trackedConnection = true\n      }\n    }\n\n    if (!trackedConnection) {\n      peerConnections.push(connection)\n    }\n\n    return connection\n  }\n\n  async closeConnections (peerId: PeerId, options: AbortOptions = {}): Promise<void> {\n    const connections = this.connections.get(peerId) ?? []\n\n    await Promise.all(\n      connections.map(async connection => {\n        try {\n          await connection.close(options)\n        } catch (err: any) {\n          connection.abort(err)\n        }\n      })\n    )\n  }\n\n  async acceptIncomingConnection (maConn: MultiaddrConnection): Promise<boolean> {\n    // check deny list\n    const denyConnection = this.deny.some(ma => {\n      return maConn.remoteAddr.toString().startsWith(ma.toString())\n    })\n\n    if (denyConnection) {\n      this.#log('connection from %a refused - connection remote address was in deny list', maConn.remoteAddr)\n      return false\n    }\n\n    // check allow list\n    const allowConnection = this.allow.some(ma => {\n      return maConn.remoteAddr.toString().startsWith(ma.toString())\n    })\n\n    if (allowConnection) {\n      this.incomingPendingConnections++\n\n      return true\n    }\n\n    // check pending connections\n    if (this.incomingPendingConnections === this.maxIncomingPendingConnections) {\n      this.#log('connection from %a refused - incomingPendingConnections exceeded by host', maConn.remoteAddr)\n      return false\n    }\n\n    if (maConn.remoteAddr.isThinWaistAddress()) {\n      const host = maConn.remoteAddr.nodeAddress().address\n\n      try {\n        await this.inboundConnectionRateLimiter.consume(host, 1)\n      } catch {\n        this.#log('connection from %a refused - inboundConnectionThreshold exceeded by host %s', maConn.remoteAddr, host)\n        return false\n      }\n    }\n\n    if (this.getConnections().length < this.maxConnections) {\n      this.incomingPendingConnections++\n\n      return true\n    }\n\n    this.#log('connection from %a refused - maxConnections exceeded', maConn.remoteAddr)\n    return false\n  }\n\n  afterUpgradeInbound (): void {\n    this.incomingPendingConnections--\n  }\n\n  getDialQueue (): PendingDial[] {\n    return this.dialQueue.pendingDials\n  }\n}\n", "import { CodeError } from '@libp2p/interface/errors'\nimport { isPeerId } from '@libp2p/interface/peer-id'\nimport { logger } from '@libp2p/logger'\nimport { peerIdFromString } from '@libp2p/peer-id'\nimport { isMultiaddr } from '@multiformats/multiaddr'\nimport { codes } from './errors.js'\nimport type { PeerId } from '@libp2p/interface/peer-id'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nconst log = logger('libp2p:get-peer')\n\nexport interface PeerAddress {\n  peerId?: PeerId\n  multiaddrs: Multiaddr[]\n}\n\n/**\n * Extracts a PeerId and/or multiaddr from the passed PeerId or Multiaddr or an array of Multiaddrs\n */\nexport function getPeerAddress (peer: PeerId | Multiaddr | Multiaddr[]): PeerAddress {\n  if (isPeerId(peer)) {\n    return { peerId: peer, multiaddrs: [] }\n  }\n\n  if (!Array.isArray(peer)) {\n    peer = [peer]\n  }\n\n  let peerId: PeerId | undefined\n\n  if (peer.length > 0) {\n    const peerIdStr = peer[0].getPeerId()\n    peerId = peerIdStr == null ? undefined : peerIdFromString(peerIdStr)\n\n    // ensure PeerId is either not set or is consistent\n    peer.forEach(ma => {\n      if (!isMultiaddr(ma)) {\n        log.error('multiaddr %s was invalid', ma)\n        throw new CodeError('Invalid Multiaddr', codes.ERR_INVALID_MULTIADDR)\n      }\n\n      const maPeerIdStr = ma.getPeerId()\n\n      if (maPeerIdStr == null) {\n        if (peerId != null) {\n          throw new CodeError('Multiaddrs must all have the same peer id or have no peer id', codes.ERR_INVALID_PARAMETERS)\n        }\n      } else {\n        const maPeerId = peerIdFromString(maPeerIdStr)\n\n        if (peerId == null || !peerId.equals(maPeerId)) {\n          throw new CodeError('Multiaddrs must all have the same peer id or have no peer id', codes.ERR_INVALID_PARAMETERS)\n        }\n      }\n    })\n  }\n\n  return {\n    peerId,\n    multiaddrs: peer\n  }\n}\n", "/* eslint-disable @typescript-eslint/no-non-null-assertion */\n\nimport { CodeError } from '@libp2p/interface/errors'\nimport PQueue from 'p-queue'\nimport { codes } from '../errors.js'\nimport type { PeerId } from '@libp2p/interface/peer-id'\nimport type { QueueAddOptions, Options, Queue } from 'p-queue'\n\n// Port of lower_bound from https://en.cppreference.com/w/cpp/algorithm/lower_bound\n// Used to compute insertion index to keep queue sorted after insertion\nfunction lowerBound<T> (array: readonly T[], value: T, comparator: (a: T, b: T) => number): number {\n  let first = 0\n  let count = array.length\n\n  while (count > 0) {\n    const step = Math.trunc(count / 2)\n    let it = first + step\n\n    if (comparator(array[it]!, value) <= 0) {\n      first = ++it\n      count -= step + 1\n    } else {\n      count = step\n    }\n  }\n\n  return first\n}\n\ninterface RunFunction { (): Promise<unknown> }\n\nexport interface PeerPriorityQueueOptions extends QueueAddOptions {\n  peerId: PeerId\n}\n\ninterface PeerJob {\n  priority: number\n  peerId: PeerId\n  run: RunFunction\n}\n\n/**\n * Port of https://github.com/sindresorhus/p-queue/blob/main/source/priority-queue.ts\n * that adds support for filtering jobs by peer id\n */\nclass PeerPriorityQueue implements Queue<RunFunction, PeerPriorityQueueOptions> {\n  readonly #queue: PeerJob[] = []\n\n  enqueue (run: RunFunction, options?: Partial<PeerPriorityQueueOptions>): void {\n    const peerId = options?.peerId\n    const priority = options?.priority ?? 0\n\n    if (peerId == null) {\n      throw new CodeError('missing peer id', codes.ERR_INVALID_PARAMETERS)\n    }\n\n    const element: PeerJob = {\n      priority,\n      peerId,\n      run\n    }\n\n    if (this.size > 0 && this.#queue[this.size - 1]!.priority >= priority) {\n      this.#queue.push(element)\n      return\n    }\n\n    const index = lowerBound(\n      this.#queue, element,\n      (a: Readonly<PeerPriorityQueueOptions>, b: Readonly<PeerPriorityQueueOptions>) => b.priority! - a.priority!\n    )\n    this.#queue.splice(index, 0, element)\n  }\n\n  dequeue (): RunFunction | undefined {\n    const item = this.#queue.shift()\n    return item?.run\n  }\n\n  filter (options: Readonly<Partial<PeerPriorityQueueOptions>>): RunFunction[] {\n    if (options.peerId != null) {\n      const peerId = options.peerId\n\n      return this.#queue.filter(\n        (element: Readonly<PeerPriorityQueueOptions>) => peerId.equals(element.peerId)\n      ).map((element: Readonly<{ run: RunFunction }>) => element.run)\n    }\n\n    return this.#queue.filter(\n      (element: Readonly<PeerPriorityQueueOptions>) => element.priority === options.priority\n    ).map((element: Readonly<{ run: RunFunction }>) => element.run)\n  }\n\n  get size (): number {\n    return this.#queue.length\n  }\n}\n\n/**\n * Extends PQueue to add support for querying queued jobs by peer id\n */\nexport class PeerJobQueue extends PQueue<PeerPriorityQueue, PeerPriorityQueueOptions> {\n  constructor (options: Options<PeerPriorityQueue, PeerPriorityQueueOptions> = {}) {\n    super({\n      ...options,\n      queueClass: PeerPriorityQueue\n    })\n  }\n\n  /**\n   * Returns true if this queue has a job for the passed peer id that has not yet\n   * started to run\n   */\n  hasJob (peerId: PeerId): boolean {\n    return this.sizeBy({\n      peerId\n    }) > 0\n  }\n}\n", "/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#dialTimeout\n */\nexport const DIAL_TIMEOUT = 30e3\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#inboundUpgradeTimeout\n */\nexport const INBOUND_UPGRADE_TIMEOUT = 30e3\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#maxPeerAddrsToDial\n */\nexport const MAX_PEER_ADDRS_TO_DIAL = 25\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#maxParallelDialsPerPeer\n */\nexport const MAX_PARALLEL_DIALS_PER_PEER = 1\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#autoDialInterval\n */\nexport const AUTO_DIAL_INTERVAL = 5000\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#autoDialConcurrency\n */\nexport const AUTO_DIAL_CONCURRENCY = 25\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#autoDialPriority\n */\nexport const AUTO_DIAL_PRIORITY = 0\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#autoDialMaxQueueLength\n */\nexport const AUTO_DIAL_MAX_QUEUE_LENGTH = 100\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/libp2p.index.unknown.ConnectionManagerInit.html#autoDialDiscoveredPeersDebounce\n */\nexport const AUTO_DIAL_DISCOVERED_PEERS_DEBOUNCE = 10\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#inboundConnectionThreshold\n */\nexport const INBOUND_CONNECTION_THRESHOLD = 5\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#maxIncomingPendingConnections\n */\nexport const MAX_INCOMING_PENDING_CONNECTIONS = 10\n\n/**\n * Store as part of the peer store metadata for a given peer, the value for this\n * key is a timestamp of the last time a dial attempted failed with the relevant\n * peer stored as a string.\n *\n * Used to insure we do not endlessly try to auto dial peers we have recently\n * failed to dial.\n */\nexport const LAST_DIAL_FAILURE_KEY = 'last-dial-failure'\n", "export * from './constants.defaults.js'\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#minConnections\n */\nexport const MIN_CONNECTIONS = 5\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#maxConnections\n */\nexport const MAX_CONNECTIONS = 100\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#maxParallelDials\n */\nexport const MAX_PARALLEL_DIALS = 50\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/libp2p.index.unknown.ConnectionManagerInit.html#autoDialPeerRetryThreshold\n */\nexport const AUTO_DIAL_PEER_RETRY_THRESHOLD = 1000 * 60 * 7\n", "import { PeerMap, PeerSet } from '@libp2p/peer-collections'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { PeerJobQueue } from '../utils/peer-job-queue.js'\nimport { AUTO_DIAL_CONCURRENCY, AUTO_DIAL_DISCOVERED_PEERS_DEBOUNCE, AUTO_DIAL_INTERVAL, AUTO_DIAL_MAX_QUEUE_LENGTH, AUTO_DIAL_PEER_RETRY_THRESHOLD, AUTO_DIAL_PRIORITY, LAST_DIAL_FAILURE_KEY, MIN_CONNECTIONS } from './constants.js'\nimport type { Libp2pEvents, Logger, ComponentLogger } from '@libp2p/interface'\nimport type { TypedEventTarget } from '@libp2p/interface/events'\nimport type { PeerStore } from '@libp2p/interface/peer-store'\nimport type { Startable } from '@libp2p/interface/startable'\nimport type { ConnectionManager } from '@libp2p/interface-internal/connection-manager'\n\ninterface AutoDialInit {\n  minConnections?: number\n  maxQueueLength?: number\n  autoDialConcurrency?: number\n  autoDialPriority?: number\n  autoDialInterval?: number\n  autoDialPeerRetryThreshold?: number\n  autoDialDiscoveredPeersDebounce?: number\n}\n\ninterface AutoDialComponents {\n  connectionManager: ConnectionManager\n  peerStore: PeerStore\n  events: TypedEventTarget<Libp2pEvents>\n  logger: ComponentLogger\n}\n\nconst defaultOptions = {\n  minConnections: MIN_CONNECTIONS,\n  maxQueueLength: AUTO_DIAL_MAX_QUEUE_LENGTH,\n  autoDialConcurrency: AUTO_DIAL_CONCURRENCY,\n  autoDialPriority: AUTO_DIAL_PRIORITY,\n  autoDialInterval: AUTO_DIAL_INTERVAL,\n  autoDialPeerRetryThreshold: AUTO_DIAL_PEER_RETRY_THRESHOLD,\n  autoDialDiscoveredPeersDebounce: AUTO_DIAL_DISCOVERED_PEERS_DEBOUNCE\n}\n\nexport class AutoDial implements Startable {\n  private readonly connectionManager: ConnectionManager\n  private readonly peerStore: PeerStore\n  private readonly queue: PeerJobQueue\n  private readonly minConnections: number\n  private readonly autoDialPriority: number\n  private readonly autoDialIntervalMs: number\n  private readonly autoDialMaxQueueLength: number\n  private readonly autoDialPeerRetryThresholdMs: number\n  private readonly autoDialDiscoveredPeersDebounce: number\n  private autoDialInterval?: ReturnType<typeof setInterval>\n  private started: boolean\n  private running: boolean\n  readonly #log: Logger\n\n  /**\n   * Proactively tries to connect to known peers stored in the PeerStore.\n   * It will keep the number of connections below the upper limit and sort\n   * the peers to connect based on whether we know their keys and protocols.\n   */\n  constructor (components: AutoDialComponents, init: AutoDialInit) {\n    this.connectionManager = components.connectionManager\n    this.peerStore = components.peerStore\n    this.minConnections = init.minConnections ?? defaultOptions.minConnections\n    this.autoDialPriority = init.autoDialPriority ?? defaultOptions.autoDialPriority\n    this.autoDialIntervalMs = init.autoDialInterval ?? defaultOptions.autoDialInterval\n    this.autoDialMaxQueueLength = init.maxQueueLength ?? defaultOptions.maxQueueLength\n    this.autoDialPeerRetryThresholdMs = init.autoDialPeerRetryThreshold ?? defaultOptions.autoDialPeerRetryThreshold\n    this.autoDialDiscoveredPeersDebounce = init.autoDialDiscoveredPeersDebounce ?? defaultOptions.autoDialDiscoveredPeersDebounce\n    this.#log = components.logger.forComponent('libp2p:connection-manager:auto-dial')\n    this.started = false\n    this.running = false\n    this.queue = new PeerJobQueue({\n      concurrency: init.autoDialConcurrency ?? defaultOptions.autoDialConcurrency\n    })\n    this.queue.addListener('error', (err) => {\n      this.#log.error('error during auto-dial', err)\n    })\n\n    // check the min connection limit whenever a peer disconnects\n    components.events.addEventListener('connection:close', () => {\n      this.autoDial()\n        .catch(err => {\n          this.#log.error(err)\n        })\n    })\n\n    // sometimes peers are discovered in quick succession so add a small\n    // debounce to ensure all eligible peers are autodialed\n    let debounce: ReturnType<typeof setTimeout>\n\n    // when new peers are discovered, dial them if we don't have\n    // enough connections\n    components.events.addEventListener('peer:discovery', () => {\n      clearTimeout(debounce)\n      debounce = setTimeout(() => {\n        this.autoDial()\n          .catch(err => {\n            this.#log.error(err)\n          })\n      }, this.autoDialDiscoveredPeersDebounce)\n    })\n  }\n\n  isStarted (): boolean {\n    return this.started\n  }\n\n  start (): void {\n    this.autoDialInterval = setTimeout(() => {\n      this.autoDial()\n        .catch(err => {\n          this.#log.error('error while autodialing', err)\n        })\n    }, this.autoDialIntervalMs)\n    this.started = true\n  }\n\n  afterStart (): void {\n    this.autoDial()\n      .catch(err => {\n        this.#log.error('error while autodialing', err)\n      })\n  }\n\n  stop (): void {\n    // clear the queue\n    this.queue.clear()\n    clearTimeout(this.autoDialInterval)\n    this.started = false\n    this.running = false\n  }\n\n  async autoDial (): Promise<void> {\n    if (!this.started) {\n      return\n    }\n\n    const connections = this.connectionManager.getConnectionsMap()\n    const numConnections = connections.size\n\n    // Already has enough connections\n    if (numConnections >= this.minConnections) {\n      if (this.minConnections > 0) {\n        this.#log.trace('have enough connections %d/%d', numConnections, this.minConnections)\n      }\n      return\n    }\n\n    if (this.queue.size > this.autoDialMaxQueueLength) {\n      this.#log('not enough connections %d/%d but auto dial queue is full', numConnections, this.minConnections)\n      return\n    }\n\n    if (this.running) {\n      this.#log('not enough connections %d/%d - but skipping autodial as it is already running', numConnections, this.minConnections)\n      return\n    }\n\n    this.running = true\n\n    this.#log('not enough connections %d/%d - will dial peers to increase the number of connections', numConnections, this.minConnections)\n\n    const dialQueue = new PeerSet(\n      // @ts-expect-error boolean filter removes falsy peer IDs\n      this.connectionManager.getDialQueue()\n        .map(queue => queue.peerId)\n        .filter(Boolean)\n    )\n\n    // Sort peers on whether we know protocols or public keys for them\n    const peers = await this.peerStore.all({\n      filters: [\n        // Remove some peers\n        (peer) => {\n          // Remove peers without addresses\n          if (peer.addresses.length === 0) {\n            this.#log.trace('not autodialing %p because they have no addresses', peer.id)\n            return false\n          }\n\n          // remove peers we are already connected to\n          if (connections.has(peer.id)) {\n            this.#log.trace('not autodialing %p because they are already connected', peer.id)\n            return false\n          }\n\n          // remove peers we are already dialling\n          if (dialQueue.has(peer.id)) {\n            this.#log.trace('not autodialing %p because they are already being dialed', peer.id)\n            return false\n          }\n\n          // remove peers already in the autodial queue\n          if (this.queue.hasJob(peer.id)) {\n            this.#log.trace('not autodialing %p because they are already being autodialed', peer.id)\n            return false\n          }\n\n          return true\n        }\n      ]\n    })\n\n    // shuffle the peers - this is so peers with the same tag values will be\n    // dialled in a different order each time\n    const shuffledPeers = peers.sort(() => Math.random() > 0.5 ? 1 : -1)\n\n    // Sort shuffled peers by tag value\n    const peerValues = new PeerMap<number>()\n    for (const peer of shuffledPeers) {\n      if (peerValues.has(peer.id)) {\n        continue\n      }\n\n      // sum all tag values\n      peerValues.set(peer.id, [...peer.tags.values()].reduce((acc, curr) => {\n        return acc + curr.value\n      }, 0))\n    }\n\n    // sort by value, highest to lowest\n    const sortedPeers = shuffledPeers.sort((a, b) => {\n      const peerAValue = peerValues.get(a.id) ?? 0\n      const peerBValue = peerValues.get(b.id) ?? 0\n\n      if (peerAValue > peerBValue) {\n        return -1\n      }\n\n      if (peerAValue < peerBValue) {\n        return 1\n      }\n\n      return 0\n    })\n\n    const peersThatHaveNotFailed = sortedPeers.filter(peer => {\n      const lastDialFailure = peer.metadata.get(LAST_DIAL_FAILURE_KEY)\n\n      if (lastDialFailure == null) {\n        return true\n      }\n\n      const lastDialFailureTimestamp = parseInt(uint8ArrayToString(lastDialFailure))\n\n      if (isNaN(lastDialFailureTimestamp)) {\n        return true\n      }\n\n      // only dial if the time since the last failure is above the retry threshold\n      return Date.now() - lastDialFailureTimestamp > this.autoDialPeerRetryThresholdMs\n    })\n\n    this.#log('selected %d/%d peers to dial', peersThatHaveNotFailed.length, peers.length)\n\n    for (const peer of peersThatHaveNotFailed) {\n      this.queue.add(async () => {\n        const numConnections = this.connectionManager.getConnectionsMap().size\n\n        // Check to see if we still need to auto dial\n        if (numConnections >= this.minConnections) {\n          this.#log('got enough connections now %d/%d', numConnections, this.minConnections)\n          this.queue.clear()\n          return\n        }\n\n        this.#log('connecting to a peerStore stored peer %p', peer.id)\n        await this.connectionManager.openConnection(peer.id, {\n          priority: this.autoDialPriority\n        })\n      }, {\n        peerId: peer.id\n      }).catch(err => {\n        this.#log.error('could not connect to peerStore stored peer', err)\n      })\n    }\n\n    this.running = false\n\n    if (this.started) {\n      this.autoDialInterval = setTimeout(() => {\n        this.autoDial()\n          .catch(err => {\n            this.#log.error('error while autodialing', err)\n          })\n      }, this.autoDialIntervalMs)\n    }\n  }\n}\n", "import { PeerMap } from '@libp2p/peer-collections'\nimport { MAX_CONNECTIONS } from './constants.js'\nimport type { Libp2pEvents, Logger, ComponentLogger } from '@libp2p/interface'\nimport type { TypedEventTarget } from '@libp2p/interface/events'\nimport type { PeerStore } from '@libp2p/interface/peer-store'\nimport type { ConnectionManager } from '@libp2p/interface-internal/connection-manager'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\ninterface ConnectionPrunerInit {\n  maxConnections?: number\n  allow?: Multiaddr[]\n}\n\ninterface ConnectionPrunerComponents {\n  connectionManager: ConnectionManager\n  peerStore: PeerStore\n  events: TypedEventTarget<Libp2pEvents>\n  logger: ComponentLogger\n}\n\nconst defaultOptions = {\n  maxConnections: MAX_CONNECTIONS,\n  allow: []\n}\n\n/**\n * If we go over the max connections limit, choose some connections to close\n */\nexport class ConnectionPruner {\n  private readonly maxConnections: number\n  private readonly connectionManager: ConnectionManager\n  private readonly peerStore: PeerStore\n  private readonly allow: Multiaddr[]\n  private readonly events: TypedEventTarget<Libp2pEvents>\n  readonly #log: Logger\n\n  constructor (components: ConnectionPrunerComponents, init: ConnectionPrunerInit = {}) {\n    this.maxConnections = init.maxConnections ?? defaultOptions.maxConnections\n    this.allow = init.allow ?? defaultOptions.allow\n    this.connectionManager = components.connectionManager\n    this.peerStore = components.peerStore\n    this.events = components.events\n    this.#log = components.logger.forComponent('libp2p:connection-manager:connection-pruner')\n\n    // check the max connection limit whenever a peer connects\n    components.events.addEventListener('connection:open', () => {\n      this.maybePruneConnections()\n        .catch(err => {\n          this.#log.error(err)\n        })\n    })\n  }\n\n  /**\n   * If we have more connections than our maximum, select some excess connections\n   * to prune based on peer value\n   */\n  async maybePruneConnections (): Promise<void> {\n    const connections = this.connectionManager.getConnections()\n    const numConnections = connections.length\n    const toPrune = Math.max(numConnections - this.maxConnections, 0)\n\n    this.#log('checking max connections limit %d/%d', numConnections, this.maxConnections)\n    if (numConnections <= this.maxConnections) {\n      return\n    }\n\n    this.#log('max connections limit exceeded %d/%d, pruning %d connection(s)', numConnections, this.maxConnections, toPrune)\n    const peerValues = new PeerMap<number>()\n\n    // work out peer values\n    for (const connection of connections) {\n      const remotePeer = connection.remotePeer\n\n      if (peerValues.has(remotePeer)) {\n        continue\n      }\n\n      peerValues.set(remotePeer, 0)\n\n      try {\n        const peer = await this.peerStore.get(remotePeer)\n\n        // sum all tag values\n        peerValues.set(remotePeer, [...peer.tags.values()].reduce((acc, curr) => {\n          return acc + curr.value\n        }, 0))\n      } catch (err: any) {\n        if (err.code !== 'ERR_NOT_FOUND') {\n          this.#log.error('error loading peer tags', err)\n        }\n      }\n    }\n\n    // sort by value, lowest to highest\n    const sortedConnections = connections.sort((a, b) => {\n      const peerAValue = peerValues.get(a.remotePeer) ?? 0\n      const peerBValue = peerValues.get(b.remotePeer) ?? 0\n\n      if (peerAValue > peerBValue) {\n        return 1\n      }\n\n      if (peerAValue < peerBValue) {\n        return -1\n      }\n\n      // if the peers have an equal tag value then we want to close short-lived connections first\n      const connectionALifespan = a.timeline.open\n      const connectionBLifespan = b.timeline.open\n\n      if (connectionALifespan < connectionBLifespan) {\n        return 1\n      }\n\n      if (connectionALifespan > connectionBLifespan) {\n        return -1\n      }\n\n      return 0\n    })\n\n    // close some connections\n    const toClose = []\n\n    for (const connection of sortedConnections) {\n      this.#log('too many connections open - closing a connection to %p', connection.remotePeer)\n      // check allow list\n      const connectionInAllowList = this.allow.some((ma) => {\n        return connection.remoteAddr.toString().startsWith(ma.toString())\n      })\n\n      // Connections in the allow list should be excluded from pruning\n      if (!connectionInAllowList) {\n        toClose.push(connection)\n      }\n\n      if (toClose.length === toPrune) {\n        break\n      }\n    }\n\n    // close connections\n    await Promise.all(\n      toClose.map(async connection => {\n        try {\n          await connection.close()\n        } catch (err) {\n          this.#log.error(err)\n        }\n      })\n    )\n\n    // despatch prune event\n    this.events.safeDispatchEvent('connection:prune', { detail: toClose })\n  }\n}\n", "\nexport interface ClearableSignal extends AbortSignal {\n  clear: () => void\n}\n\n/**\n * Takes an array of AbortSignals and returns a single signal.\n * If any signals are aborted, the returned signal will be aborted.\n */\nexport function anySignal (signals: Array<AbortSignal | undefined | null>): ClearableSignal {\n  const controller = new globalThis.AbortController()\n\n  function onAbort (): void {\n    controller.abort()\n\n    for (const signal of signals) {\n      if (signal?.removeEventListener != null) {\n        signal.removeEventListener('abort', onAbort)\n      }\n    }\n  }\n\n  for (const signal of signals) {\n    if (signal?.aborted === true) {\n      onAbort()\n      break\n    }\n\n    if (signal?.addEventListener != null) {\n      signal.addEventListener('abort', onAbort)\n    }\n  }\n\n  function clear (): void {\n    for (const signal of signals) {\n      if (signal?.removeEventListener != null) {\n        signal.removeEventListener('abort', onAbort)\n      }\n    }\n  }\n\n  const signal = controller.signal as ClearableSignal\n  signal.clear = clear\n\n  return signal\n}\n", "import { setMaxListeners } from '@libp2p/interface/events'\nimport { type AbortOptions, multiaddr, type Multiaddr } from '@multiformats/multiaddr'\nimport { type ClearableSignal, anySignal } from 'any-signal'\nimport type { LoggerOptions } from '@libp2p/interface'\n\n/**\n * Resolve multiaddr recursively\n */\nexport async function resolveMultiaddrs (ma: Multiaddr, options: AbortOptions & LoggerOptions): Promise<Multiaddr[]> {\n  // TODO: recursive logic should live in multiaddr once dns4/dns6 support is in place\n  // Now only supporting resolve for dnsaddr\n  const resolvableProto = ma.protoNames().includes('dnsaddr')\n\n  // Multiaddr is not resolvable? End recursion!\n  if (!resolvableProto) {\n    return [ma]\n  }\n\n  const resolvedMultiaddrs = await resolveRecord(ma, options)\n  const recursiveMultiaddrs = await Promise.all(resolvedMultiaddrs.map(async (nm) => {\n    return resolveMultiaddrs(nm, options)\n  }))\n\n  const addrs = recursiveMultiaddrs.flat()\n  const output = addrs.reduce<Multiaddr[]>((array, newM) => {\n    if (array.find(m => m.equals(newM)) == null) {\n      array.push(newM)\n    }\n    return array\n  }, ([]))\n\n  options.log('resolved %s to', ma, output.map(ma => ma.toString()))\n\n  return output\n}\n\n/**\n * Resolve a given multiaddr. If this fails, an empty array will be returned\n */\nasync function resolveRecord (ma: Multiaddr, options: AbortOptions & LoggerOptions): Promise<Multiaddr[]> {\n  try {\n    ma = multiaddr(ma.toString()) // Use current multiaddr module\n    const multiaddrs = await ma.resolve(options)\n    return multiaddrs\n  } catch (err) {\n    options.log.error(`multiaddr ${ma.toString()} could not be resolved`, err)\n    return []\n  }\n}\n\nexport function combineSignals (...signals: Array<AbortSignal | undefined>): ClearableSignal {\n  const sigs: AbortSignal[] = []\n\n  for (const sig of signals) {\n    if (sig != null) {\n      setMaxListeners(Infinity, sig)\n      sigs.push(sig)\n    }\n  }\n\n  // let any signal abort the dial\n  const signal = anySignal(sigs)\n\n  setMaxListeners(Infinity, signal)\n\n  return signal\n}\n", "import { AbortError, CodeError } from '@libp2p/interface/errors'\nimport { setMaxListeners } from '@libp2p/interface/events'\nimport { PeerMap } from '@libp2p/peer-collections'\nimport { defaultAddressSort } from '@libp2p/utils/address-sort'\nimport { type Multiaddr, type Resolver, resolvers } from '@multiformats/multiaddr'\nimport { dnsaddrResolver } from '@multiformats/multiaddr/resolvers'\nimport { type ClearableSignal, anySignal } from 'any-signal'\nimport pDefer from 'p-defer'\nimport PQueue from 'p-queue'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { codes } from '../errors.js'\nimport { getPeerAddress } from '../get-peer.js'\nimport {\n  DIAL_TIMEOUT,\n  MAX_PARALLEL_DIALS_PER_PEER,\n  MAX_PARALLEL_DIALS,\n  MAX_PEER_ADDRS_TO_DIAL,\n  LAST_DIAL_FAILURE_KEY\n} from './constants.js'\nimport { combineSignals, resolveMultiaddrs } from './utils.js'\nimport type { AddressSorter, AbortOptions, PendingDial, ComponentLogger, Logger } from '@libp2p/interface'\nimport type { Connection } from '@libp2p/interface/connection'\nimport type { ConnectionGater } from '@libp2p/interface/connection-gater'\nimport type { Metric, Metrics } from '@libp2p/interface/metrics'\nimport type { PeerId } from '@libp2p/interface/peer-id'\nimport type { Address, PeerStore } from '@libp2p/interface/peer-store'\nimport type { TransportManager } from '@libp2p/interface-internal/transport-manager'\n\nexport interface PendingDialTarget {\n  resolve(value: any): void\n  reject(err: Error): void\n}\n\nexport interface DialOptions extends AbortOptions {\n  priority?: number\n  force?: boolean\n}\n\ninterface PendingDialInternal extends PendingDial {\n  promise: Promise<Connection>\n}\n\ninterface DialerInit {\n  addressSorter?: AddressSorter\n  maxParallelDials?: number\n  maxPeerAddrsToDial?: number\n  maxParallelDialsPerPeer?: number\n  dialTimeout?: number\n  resolvers?: Record<string, Resolver>\n  connections?: PeerMap<Connection[]>\n}\n\nconst defaultOptions = {\n  addressSorter: defaultAddressSort,\n  maxParallelDials: MAX_PARALLEL_DIALS,\n  maxPeerAddrsToDial: MAX_PEER_ADDRS_TO_DIAL,\n  maxParallelDialsPerPeer: MAX_PARALLEL_DIALS_PER_PEER,\n  dialTimeout: DIAL_TIMEOUT,\n  resolvers: {\n    dnsaddr: dnsaddrResolver\n  }\n}\n\ninterface DialQueueComponents {\n  peerId: PeerId\n  metrics?: Metrics\n  peerStore: PeerStore\n  transportManager: TransportManager\n  connectionGater: ConnectionGater\n  logger: ComponentLogger\n}\n\nexport class DialQueue {\n  public pendingDials: PendingDialInternal[]\n  public queue: PQueue\n  private readonly peerId: PeerId\n  private readonly peerStore: PeerStore\n  private readonly connectionGater: ConnectionGater\n  private readonly transportManager: TransportManager\n  private readonly addressSorter: AddressSorter\n  private readonly maxPeerAddrsToDial: number\n  private readonly maxParallelDialsPerPeer: number\n  private readonly dialTimeout: number\n  private readonly inProgressDialCount?: Metric\n  private readonly pendingDialCount?: Metric\n  private readonly shutDownController: AbortController\n  private readonly connections: PeerMap<Connection[]>\n  readonly #log: Logger\n\n  constructor (components: DialQueueComponents, init: DialerInit = {}) {\n    this.addressSorter = init.addressSorter ?? defaultOptions.addressSorter\n    this.maxPeerAddrsToDial = init.maxPeerAddrsToDial ?? defaultOptions.maxPeerAddrsToDial\n    this.maxParallelDialsPerPeer = init.maxParallelDialsPerPeer ?? defaultOptions.maxParallelDialsPerPeer\n    this.dialTimeout = init.dialTimeout ?? defaultOptions.dialTimeout\n    this.connections = init.connections ?? new PeerMap()\n    this.#log = components.logger.forComponent('libp2p:connection-manager:dial-queue')\n\n    this.peerId = components.peerId\n    this.peerStore = components.peerStore\n    this.connectionGater = components.connectionGater\n    this.transportManager = components.transportManager\n    this.shutDownController = new AbortController()\n\n    setMaxListeners(Infinity, this.shutDownController.signal)\n\n    this.pendingDialCount = components.metrics?.registerMetric('libp2p_dialler_pending_dials')\n    this.inProgressDialCount = components.metrics?.registerMetric('libp2p_dialler_in_progress_dials')\n    this.pendingDials = []\n\n    for (const [key, value] of Object.entries(init.resolvers ?? {})) {\n      resolvers.set(key, value)\n    }\n\n    // controls dial concurrency\n    this.queue = new PQueue({\n      concurrency: init.maxParallelDials ?? defaultOptions.maxParallelDials\n    })\n\n    // a job was added to the queue\n    this.queue.on('add', () => {\n      this.pendingDialCount?.update(this.queue.size)\n      this.inProgressDialCount?.update(this.queue.pending)\n    })\n    // a queued job started\n    this.queue.on('active', () => {\n      this.pendingDialCount?.update(this.queue.size)\n      this.inProgressDialCount?.update(this.queue.pending)\n    })\n    // a started job completed without error\n    this.queue.on('completed', () => {\n      this.pendingDialCount?.update(this.queue.size)\n      this.inProgressDialCount?.update(this.queue.pending)\n    })\n    // a started job errored\n    this.queue.on('error', (err) => {\n      this.#log.error('error in dial queue', err)\n      this.pendingDialCount?.update(this.queue.size)\n      this.inProgressDialCount?.update(this.queue.pending)\n    })\n    // all queued jobs have been started\n    this.queue.on('empty', () => {\n      this.pendingDialCount?.update(this.queue.size)\n      this.inProgressDialCount?.update(this.queue.pending)\n    })\n    // add started jobs have run and the queue is empty\n    this.queue.on('idle', () => {\n      this.pendingDialCount?.update(this.queue.size)\n      this.inProgressDialCount?.update(this.queue.pending)\n    })\n  }\n\n  /**\n   * Clears any pending dials\n   */\n  stop (): void {\n    this.shutDownController.abort()\n  }\n\n  /**\n   * Connects to a given peer, multiaddr or list of multiaddrs.\n   *\n   * If a peer is passed, all known multiaddrs will be tried. If a multiaddr or\n   * multiaddrs are passed only those will be dialled.\n   *\n   * Where a list of multiaddrs is passed, if any contain a peer id then all\n   * multiaddrs in the list must contain the same peer id.\n   *\n   * The dial to the first address that is successfully able to upgrade a connection\n   * will be used, all other dials will be aborted when that happens.\n   */\n  async dial (peerIdOrMultiaddr: PeerId | Multiaddr | Multiaddr[], options: DialOptions = {}): Promise<Connection> {\n    const { peerId, multiaddrs } = getPeerAddress(peerIdOrMultiaddr)\n\n    const addrs: Address[] = multiaddrs.map(multiaddr => ({\n      multiaddr,\n      isCertified: false\n    }))\n\n    // create abort conditions - need to do this before `calculateMultiaddrs` as we may be about to\n    // resolve a dns addr which can time out\n    const signal = this.createDialAbortControllers(options.signal)\n    let addrsToDial: Address[]\n\n    try {\n      // load addresses from address book, resolve and dnsaddrs, filter undiallables, add peer IDs, etc\n      addrsToDial = await this.calculateMultiaddrs(peerId, addrs, {\n        ...options,\n        signal\n      })\n    } catch (err) {\n      signal.clear()\n      throw err\n    }\n\n    // make sure we don't have an existing connection to any of the addresses we\n    // are about to dial\n    let existingConnection = Array.from(this.connections.values()).flat().find(conn => {\n      if (options.force === true) {\n        return false\n      }\n\n      return addrsToDial.find(addr => {\n        return addr.multiaddr.equals(conn.remoteAddr)\n      })\n    })\n\n    if (existingConnection != null) {\n      this.#log('already connected to %a', existingConnection.remoteAddr)\n      return existingConnection\n    }\n\n    // ready to dial, all async work finished - make sure we don't have any\n    // pending dials in progress for this peer or set of multiaddrs\n    const existingDial = this.pendingDials.find(dial => {\n      // is the dial for the same peer id?\n      if (dial.peerId != null && peerId != null && dial.peerId.equals(peerId)) {\n        return true\n      }\n\n      // is the dial for the same set of multiaddrs?\n      if (addrsToDial.map(({ multiaddr }) => multiaddr.toString()).join() === dial.multiaddrs.map(multiaddr => multiaddr.toString()).join()) {\n        return true\n      }\n\n      return false\n    })\n\n    if (existingDial != null) {\n      this.#log('joining existing dial target for %p', peerId)\n      signal.clear()\n      return existingDial.promise\n    }\n\n    this.#log('creating dial target for', addrsToDial.map(({ multiaddr }) => multiaddr.toString()))\n    // @ts-expect-error .promise property is set below\n    const pendingDial: PendingDialInternal = {\n      id: randomId(),\n      status: 'queued',\n      peerId,\n      multiaddrs: addrsToDial.map(({ multiaddr }) => multiaddr)\n    }\n\n    pendingDial.promise = this.performDial(pendingDial, {\n      ...options,\n      signal\n    })\n      .finally(() => {\n        // remove our pending dial entry\n        this.pendingDials = this.pendingDials.filter(p => p.id !== pendingDial.id)\n\n        // clean up abort signals/controllers\n        signal.clear()\n      })\n      .catch(async err => {\n        this.#log.error('dial failed to %s', pendingDial.multiaddrs.map(ma => ma.toString()).join(', '), err)\n\n        if (peerId != null) {\n          // record the last failed dial\n          try {\n            await this.peerStore.patch(peerId, {\n              metadata: {\n                [LAST_DIAL_FAILURE_KEY]: uint8ArrayFromString(Date.now().toString())\n              }\n            })\n          } catch (err: any) {\n            this.#log.error('could not update last dial failure key for %p', peerId, err)\n          }\n        }\n\n        // Error is a timeout\n        if (signal.aborted) {\n          const error = new CodeError(err.message, codes.ERR_TIMEOUT)\n          throw error\n        }\n\n        throw err\n      })\n\n    // let other dials join this one\n    this.pendingDials.push(pendingDial)\n\n    const connection = await pendingDial.promise\n\n    // we may have been dialing a multiaddr without a peer id attached but by\n    // this point we have upgraded the connection so the remote peer information\n    // should be available - check again that we don't already have a connection\n    // to the remote multiaddr\n    existingConnection = Array.from(this.connections.values()).flat().find(conn => {\n      if (options.force === true) {\n        return false\n      }\n\n      return conn.id !== connection.id && conn.remoteAddr.equals(connection.remoteAddr)\n    })\n\n    if (existingConnection != null) {\n      this.#log('already connected to %a', existingConnection.remoteAddr)\n      await connection.close()\n      return existingConnection\n    }\n\n    this.#log('connection opened to %a', connection.remoteAddr)\n    return connection\n  }\n\n  private createDialAbortControllers (userSignal?: AbortSignal): ClearableSignal {\n    // let any signal abort the dial\n    const signal = anySignal(\n      [AbortSignal.timeout(this.dialTimeout),\n        this.shutDownController.signal,\n        userSignal\n      ]\n    )\n\n    try {\n      // This emitter gets listened to a lot\n      setMaxListeners?.(Infinity, signal)\n    } catch {}\n\n    return signal\n  }\n\n  // eslint-disable-next-line complexity\n  private async calculateMultiaddrs (peerId?: PeerId, addrs: Address[] = [], options: DialOptions = {}): Promise<Address[]> {\n    // if a peer id or multiaddr(s) with a peer id, make sure it isn't our peer id and that we are allowed to dial it\n    if (peerId != null) {\n      if (this.peerId.equals(peerId)) {\n        throw new CodeError('Tried to dial self', codes.ERR_DIALED_SELF)\n      }\n\n      if ((await this.connectionGater.denyDialPeer?.(peerId)) === true) {\n        throw new CodeError('The dial request is blocked by gater.allowDialPeer', codes.ERR_PEER_DIAL_INTERCEPTED)\n      }\n\n      // if just a peer id was passed, load available multiaddrs for this peer from the address book\n      if (addrs.length === 0) {\n        this.#log('loading multiaddrs for %p', peerId)\n        try {\n          const peer = await this.peerStore.get(peerId)\n          addrs.push(...peer.addresses)\n          this.#log('loaded multiaddrs for %p', peerId, addrs.map(({ multiaddr }) => multiaddr.toString()))\n        } catch (err: any) {\n          if (err.code !== codes.ERR_NOT_FOUND) {\n            throw err\n          }\n        }\n      }\n    }\n\n    // resolve addresses - this can result in a one-to-many translation when dnsaddrs are resolved\n    let resolvedAddresses = (await Promise.all(\n      addrs.map(async addr => {\n        const result = await resolveMultiaddrs(addr.multiaddr, {\n          ...options,\n          log: this.#log\n        })\n\n        if (result.length === 1 && result[0].equals(addr.multiaddr)) {\n          return addr\n        }\n\n        return result.map(multiaddr => ({\n          multiaddr,\n          isCertified: false\n        }))\n      })\n    ))\n      .flat()\n\n    // ensure the peer id is appended to the multiaddr\n    if (peerId != null) {\n      const peerIdMultiaddr = `/p2p/${peerId.toString()}`\n      resolvedAddresses = resolvedAddresses.map(addr => {\n        const lastProto = addr.multiaddr.protos().pop()\n\n        // do not append peer id to path multiaddrs\n        if (lastProto?.path === true) {\n          return addr\n        }\n\n        // append peer id to multiaddr if it is not already present\n        if (addr.multiaddr.getPeerId() == null) {\n          return {\n            multiaddr: addr.multiaddr.encapsulate(peerIdMultiaddr),\n            isCertified: addr.isCertified\n          }\n        }\n\n        return addr\n      })\n    }\n\n    const filteredAddrs = resolvedAddresses.filter(addr => {\n      // filter out any multiaddrs that we do not have transports for\n      if (this.transportManager.transportForMultiaddr(addr.multiaddr) == null) {\n        return false\n      }\n\n      // if the resolved multiaddr has a PeerID but it's the wrong one, ignore it\n      // - this can happen with addresses like bootstrap.libp2p.io that resolve\n      // to multiple different peers\n      const addrPeerId = addr.multiaddr.getPeerId()\n      if (peerId != null && addrPeerId != null) {\n        return peerId.equals(addrPeerId)\n      }\n\n      return true\n    })\n\n    // deduplicate addresses\n    const dedupedAddrs = new Map<string, Address>()\n\n    for (const addr of filteredAddrs) {\n      const maStr = addr.multiaddr.toString()\n      const existing = dedupedAddrs.get(maStr)\n\n      if (existing != null) {\n        existing.isCertified = existing.isCertified || addr.isCertified || false\n        continue\n      }\n\n      dedupedAddrs.set(maStr, addr)\n    }\n\n    const dedupedMultiaddrs = [...dedupedAddrs.values()]\n\n    if (dedupedMultiaddrs.length === 0 || dedupedMultiaddrs.length > this.maxPeerAddrsToDial) {\n      this.#log('addresses for %p before filtering', peerId ?? 'unknown peer', resolvedAddresses.map(({ multiaddr }) => multiaddr.toString()))\n      this.#log('addresses for %p after filtering', peerId ?? 'unknown peer', dedupedMultiaddrs.map(({ multiaddr }) => multiaddr.toString()))\n    }\n\n    // make sure we actually have some addresses to dial\n    if (dedupedMultiaddrs.length === 0) {\n      throw new CodeError('The dial request has no valid addresses', codes.ERR_NO_VALID_ADDRESSES)\n    }\n\n    // make sure we don't have too many addresses to dial\n    if (dedupedMultiaddrs.length > this.maxPeerAddrsToDial) {\n      throw new CodeError('dial with more addresses than allowed', codes.ERR_TOO_MANY_ADDRESSES)\n    }\n\n    const gatedAdrs: Address[] = []\n\n    for (const addr of dedupedMultiaddrs) {\n      if (this.connectionGater.denyDialMultiaddr != null && await this.connectionGater.denyDialMultiaddr(addr.multiaddr)) {\n        continue\n      }\n\n      gatedAdrs.push(addr)\n    }\n\n    const sortedGatedAddrs = gatedAdrs.sort(this.addressSorter)\n\n    // make sure we actually have some addresses to dial\n    if (sortedGatedAddrs.length === 0) {\n      throw new CodeError('The connection gater denied all addresses in the dial request', codes.ERR_NO_VALID_ADDRESSES)\n    }\n\n    return sortedGatedAddrs\n  }\n\n  private async performDial (pendingDial: PendingDialInternal, options: DialOptions = {}): Promise<Connection> {\n    const dialAbortControllers: Array<(AbortController | undefined)> = pendingDial.multiaddrs.map(() => new AbortController())\n\n    try {\n      // internal peer dial queue to ensure we only dial the configured number of addresses\n      // per peer at the same time to prevent one peer with a lot of addresses swamping\n      // the dial queue\n      const peerDialQueue = new PQueue({\n        concurrency: this.maxParallelDialsPerPeer\n      })\n      peerDialQueue.on('error', (err) => {\n        this.#log.error('error dialling', err)\n      })\n\n      const conn = await Promise.any(pendingDial.multiaddrs.map(async (addr, i) => {\n        const controller = dialAbortControllers[i]\n\n        if (controller == null) {\n          throw new CodeError('dialAction did not come with an AbortController', codes.ERR_INVALID_PARAMETERS)\n        }\n\n        // let any signal abort the dial\n        const signal = combineSignals(controller.signal, options.signal)\n        signal.addEventListener('abort', () => {\n          this.#log('dial to %a aborted', addr)\n        })\n        const deferred = pDefer<Connection>()\n\n        await peerDialQueue.add(async () => {\n          if (signal.aborted) {\n            this.#log('dial to %a was aborted before reaching the head of the peer dial queue', addr)\n            deferred.reject(new AbortError())\n            return\n          }\n\n          // add the individual dial to the dial queue so we don't breach maxConcurrentDials\n          await this.queue.add(async () => {\n            try {\n              if (signal.aborted) {\n                this.#log('dial to %a was aborted before reaching the head of the dial queue', addr)\n                deferred.reject(new AbortError())\n                return\n              }\n\n              // update dial status\n              pendingDial.status = 'active'\n\n              const conn = await this.transportManager.dial(addr, {\n                ...options,\n                signal\n              })\n\n              if (controller.signal.aborted) {\n                // another dial succeeded faster than this one\n                this.#log('multiple dials succeeded, closing superfluous connection')\n\n                conn.close().catch(err => {\n                  this.#log.error('error closing superfluous connection', err)\n                })\n\n                deferred.reject(new AbortError())\n                return\n              }\n\n              // remove the successful AbortController so it is not aborted\n              dialAbortControllers[i] = undefined\n\n              // immediately abort any other dials\n              dialAbortControllers.forEach(c => {\n                if (c !== undefined) {\n                  c.abort()\n                }\n              })\n\n              this.#log('dial to %a succeeded', addr)\n\n              // resolve the connection promise\n              deferred.resolve(conn)\n            } catch (err: any) {\n              // something only went wrong if our signal was not aborted\n              this.#log.error('error during dial of %a', addr, err)\n              deferred.reject(err)\n            }\n          }, {\n            ...options,\n            signal\n          }).catch(err => {\n            deferred.reject(err)\n          })\n        }, {\n          signal\n        }).catch(err => {\n          deferred.reject(err)\n        }).finally(() => {\n          signal.clear()\n        })\n\n        return deferred.promise\n      }))\n\n      // dial succeeded or failed\n      if (conn == null) {\n        throw new CodeError('successful dial led to empty object returned from peer dial queue', codes.ERR_TRANSPORT_DIAL_FAILED)\n      }\n\n      pendingDial.status = 'success'\n\n      return conn\n    } catch (err: any) {\n      pendingDial.status = 'error'\n\n      // if we only dialled one address, unwrap the AggregateError to provide more\n      // useful feedback to the user\n      if (pendingDial.multiaddrs.length === 1 && err.name === 'AggregateError') {\n        throw err.errors[0]\n      }\n\n      throw err\n    }\n  }\n}\n\n/**\n * Returns a random string\n */\nfunction randomId (): string {\n  return `${(parseInt(String(Math.random() * 1e9), 10)).toString()}${Date.now()}`\n}\n", "/**\n * @packageDocumentation\n *\n * Convert one value from an (async)iterator into another.\n *\n * @example\n *\n * ```javascript\n * import map from 'it-map'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * const result = map(values, (val) => val++)\n *\n * console.info(result) // [1, 2, 3, 4, 5]\n * ```\n *\n * Async sources and transforms must be awaited:\n *\n * ```javascript\n * import map from 'it-map'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const result = await map(values(), async (val) => val++)\n *\n * console.info(result) // [1, 2, 3, 4, 5]\n * ```\n */\n\nimport peek from 'it-peekable'\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\n/**\n * Takes an (async) iterable and returns one with each item mapped by the passed\n * function\n */\nfunction map <I, O> (source: Iterable<I>, func: (val: I) => Promise<O>): AsyncGenerator<O, void, undefined>\nfunction map <I, O> (source: Iterable<I>, func: (val: I) => O): Generator<O, void, undefined>\nfunction map <I, O> (source: AsyncIterable<I> | Iterable<I>, func: (val: I) => O | Promise<O>): AsyncGenerator<O, void, undefined>\nfunction map <I, O> (source: AsyncIterable<I> | Iterable<I>, func: (val: I) => O | Promise<O>): AsyncGenerator<O, void, undefined> | Generator<O, void, undefined> {\n  if (isAsyncIterable(source)) {\n    return (async function * () {\n      for await (const val of source) {\n        yield func(val)\n      }\n    })()\n  }\n\n  // if mapping function returns a promise we have to return an async generator\n  const peekable = peek(source)\n  const { value, done } = peekable.next()\n\n  if (done === true) {\n    return (function * () {}())\n  }\n\n  const res = func(value)\n\n  // @ts-expect-error .then is not present on O\n  if (typeof res.then === 'function') {\n    return (async function * () {\n      yield await res\n\n      for await (const val of peekable) {\n        yield func(val)\n      }\n    })()\n  }\n\n  const fn = func as (val: I) => O\n\n  return (function * () {\n    yield res as O\n\n    for (const val of peekable) {\n      yield fn(val)\n    }\n  })()\n}\n\nexport default map\n", "import { CodeError } from '@libp2p/interface/errors'\nimport filter from 'it-filter'\nimport map from 'it-map'\nimport type { PeerInfo } from '@libp2p/interface/peer-info'\nimport type { PeerStore } from '@libp2p/interface/peer-store'\nimport type { Source } from 'it-stream-types'\n\n/**\n * Store the multiaddrs from every peer in the passed peer store\n */\nexport async function * storeAddresses (source: Source<PeerInfo>, peerStore: PeerStore): AsyncIterable<PeerInfo> {\n  yield * map(source, async (peer) => {\n    // ensure we have the addresses for a given peer\n    await peerStore.merge(peer.id, {\n      multiaddrs: peer.multiaddrs\n    })\n\n    return peer\n  })\n}\n\n/**\n * Filter peers by unique peer id\n */\nexport function uniquePeers (source: Source<PeerInfo>): AsyncIterable<PeerInfo> {\n  /** @type Set<string> */\n  const seen = new Set()\n\n  return filter(source, (peer) => {\n    // dedupe by peer id\n    if (seen.has(peer.id.toString())) {\n      return false\n    }\n\n    seen.add(peer.id.toString())\n\n    return true\n  })\n}\n\n/**\n * Require at least `min` peers to be yielded from `source`\n */\nexport async function * requirePeers (source: Source<PeerInfo>, min: number = 1): AsyncIterable<PeerInfo> {\n  let seen = 0\n\n  for await (const peer of source) {\n    seen++\n\n    yield peer\n  }\n\n  if (seen < min) {\n    throw new CodeError(`more peers required, seen: ${seen}  min: ${min}`, 'NOT_FOUND')\n  }\n}\n", "import { CodeError } from '@libp2p/interface/errors'\nimport merge from 'it-merge'\nimport { pipe } from 'it-pipe'\nimport { messages, codes } from '../errors.js'\nimport {\n  storeAddresses,\n  uniquePeers,\n  requirePeers\n} from './utils.js'\nimport type { AbortOptions } from '@libp2p/interface'\nimport type { ContentRouting } from '@libp2p/interface/content-routing'\nimport type { PeerInfo } from '@libp2p/interface/peer-info'\nimport type { PeerStore } from '@libp2p/interface/peer-store'\nimport type { Startable } from '@libp2p/interface/startable'\nimport type { CID } from 'multiformats/cid'\n\nexport interface CompoundContentRoutingInit {\n  routers: ContentRouting[]\n}\n\nexport interface CompoundContentRoutingComponents {\n  peerStore: PeerStore\n}\n\nexport class CompoundContentRouting implements ContentRouting, Startable {\n  private readonly routers: ContentRouting[]\n  private started: boolean\n  private readonly components: CompoundContentRoutingComponents\n\n  constructor (components: CompoundContentRoutingComponents, init: CompoundContentRoutingInit) {\n    this.routers = init.routers ?? []\n    this.started = false\n    this.components = components\n  }\n\n  isStarted (): boolean {\n    return this.started\n  }\n\n  async start (): Promise<void> {\n    this.started = true\n  }\n\n  async stop (): Promise<void> {\n    this.started = false\n  }\n\n  /**\n   * Iterates over all content routers in parallel to find providers of the given key\n   */\n  async * findProviders (key: CID, options: AbortOptions = {}): AsyncIterable<PeerInfo> {\n    if (this.routers.length === 0) {\n      throw new CodeError('No content routers available', codes.ERR_NO_ROUTERS_AVAILABLE)\n    }\n\n    yield * pipe(\n      merge(\n        ...this.routers.map(router => router.findProviders(key, options))\n      ),\n      (source) => storeAddresses(source, this.components.peerStore),\n      (source) => uniquePeers(source),\n      (source) => requirePeers(source)\n    )\n  }\n\n  /**\n   * Iterates over all content routers in parallel to notify it is\n   * a provider of the given key\n   */\n  async provide (key: CID, options: AbortOptions = {}): Promise<void> {\n    if (this.routers.length === 0) {\n      throw new CodeError('No content routers available', codes.ERR_NO_ROUTERS_AVAILABLE)\n    }\n\n    await Promise.all(this.routers.map(async (router) => { await router.provide(key, options) }))\n  }\n\n  /**\n   * Store the given key/value pair in the available content routings\n   */\n  async put (key: Uint8Array, value: Uint8Array, options?: AbortOptions): Promise<void> {\n    if (!this.isStarted()) {\n      throw new CodeError(messages.NOT_STARTED_YET, codes.DHT_NOT_STARTED)\n    }\n\n    await Promise.all(this.routers.map(async (router) => {\n      await router.put(key, value, options)\n    }))\n  }\n\n  /**\n   * Get the value to the given key.\n   * Times out after 1 minute by default.\n   */\n  async get (key: Uint8Array, options?: AbortOptions): Promise<Uint8Array> {\n    if (!this.isStarted()) {\n      throw new CodeError(messages.NOT_STARTED_YET, codes.DHT_NOT_STARTED)\n    }\n\n    return Promise.any(this.routers.map(async (router) => {\n      return router.get(key, options)\n    }))\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * Return the first value in an (async)iterable\n *\n * @example\n *\n * ```javascript\n * import first from 'it-first'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * const res = first(values)\n *\n * console.info(res) // 0\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import first from 'it-first'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const res = await first(values())\n *\n * console.info(res) // 0\n * ```\n */\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\n/**\n * Returns the first result from an (async) iterable, unless empty, in which\n * case returns `undefined`\n */\nfunction first <T> (source: Iterable<T>): T | undefined\nfunction first <T> (source: Iterable<T> | AsyncIterable<T>): Promise<T | undefined>\nfunction first <T> (source: Iterable<T> | AsyncIterable<T>): Promise<T | undefined> | T | undefined {\n  if (isAsyncIterable(source)) {\n    return (async () => {\n      for await (const entry of source) { // eslint-disable-line no-unreachable-loop\n        return entry\n      }\n\n      return undefined\n    })()\n  }\n\n  for (const entry of source) { // eslint-disable-line no-unreachable-loop\n    return entry\n  }\n\n  return undefined\n}\n\nexport default first\n", "import { CodeError } from '@libp2p/interface/errors'\nimport { logger } from '@libp2p/logger'\nimport filter from 'it-filter'\nimport first from 'it-first'\nimport merge from 'it-merge'\nimport { pipe } from 'it-pipe'\nimport {\n  storeAddresses,\n  uniquePeers,\n  requirePeers\n} from './content-routing/utils.js'\nimport { codes, messages } from './errors.js'\nimport type { AbortOptions } from '@libp2p/interface'\nimport type { PeerId } from '@libp2p/interface/peer-id'\nimport type { PeerInfo } from '@libp2p/interface/peer-info'\nimport type { PeerRouting } from '@libp2p/interface/peer-routing'\nimport type { PeerStore } from '@libp2p/interface/peer-store'\n\nconst log = logger('libp2p:peer-routing')\n\nexport interface PeerRoutingInit {\n  routers?: PeerRouting[]\n}\n\nexport interface DefaultPeerRoutingComponents {\n  peerId: PeerId\n  peerStore: PeerStore\n}\n\nexport class DefaultPeerRouting implements PeerRouting {\n  private readonly components: DefaultPeerRoutingComponents\n  private readonly routers: PeerRouting[]\n\n  constructor (components: DefaultPeerRoutingComponents, init: PeerRoutingInit) {\n    this.components = components\n    this.routers = init.routers ?? []\n  }\n\n  /**\n   * Iterates over all peer routers in parallel to find the given peer\n   */\n  async findPeer (id: PeerId, options?: AbortOptions): Promise<PeerInfo> {\n    if (this.routers.length === 0) {\n      throw new CodeError('No peer routers available', codes.ERR_NO_ROUTERS_AVAILABLE)\n    }\n\n    if (id.toString() === this.components.peerId.toString()) {\n      throw new CodeError('Should not try to find self', codes.ERR_FIND_SELF)\n    }\n\n    const output = await pipe(\n      merge(\n        ...this.routers.map(router => (async function * () {\n          try {\n            yield await router.findPeer(id, options)\n          } catch (err) {\n            log.error(err)\n          }\n        })())\n      ),\n      (source) => filter(source, Boolean),\n      (source) => storeAddresses(source, this.components.peerStore),\n      async (source) => first(source)\n    )\n\n    if (output != null) {\n      return output\n    }\n\n    throw new CodeError(messages.NOT_FOUND, codes.ERR_NOT_FOUND)\n  }\n\n  /**\n   * Attempt to find the closest peers on the network to the given key\n   */\n  async * getClosestPeers (key: Uint8Array, options?: AbortOptions): AsyncIterable<PeerInfo> {\n    if (this.routers.length === 0) {\n      throw new CodeError('No peer routers available', codes.ERR_NO_ROUTERS_AVAILABLE)\n    }\n\n    yield * pipe(\n      merge(\n        ...this.routers.map(router => router.getClosestPeers(key, options))\n      ),\n      (source) => storeAddresses(source, this.components.peerStore),\n      (source) => uniquePeers(source),\n      (source) => requirePeers(source)\n    )\n  }\n}\n", "import { CodeError } from '@libp2p/interface/errors'\nimport { logger } from '@libp2p/logger'\nimport merge from 'merge-options'\nimport { codes } from './errors.js'\nimport type { IdentifyResult, Libp2pEvents, PeerUpdate } from '@libp2p/interface'\nimport type { TypedEventTarget } from '@libp2p/interface/events'\nimport type { PeerId } from '@libp2p/interface/peer-id'\nimport type { PeerStore } from '@libp2p/interface/peer-store'\nimport type { Topology } from '@libp2p/interface/topology'\nimport type { ConnectionManager } from '@libp2p/interface-internal/connection-manager'\nimport type { StreamHandlerOptions, StreamHandlerRecord, Registrar, StreamHandler } from '@libp2p/interface-internal/registrar'\n\nconst log = logger('libp2p:registrar')\n\nexport const DEFAULT_MAX_INBOUND_STREAMS = 32\nexport const DEFAULT_MAX_OUTBOUND_STREAMS = 64\n\nexport interface RegistrarComponents {\n  peerId: PeerId\n  connectionManager: ConnectionManager\n  peerStore: PeerStore\n  events: TypedEventTarget<Libp2pEvents>\n}\n\n/**\n * Responsible for notifying registered protocols of events in the network.\n */\nexport class DefaultRegistrar implements Registrar {\n  private readonly topologies: Map<string, Map<string, Topology>>\n  private readonly handlers: Map<string, StreamHandlerRecord>\n  private readonly components: RegistrarComponents\n\n  constructor (components: RegistrarComponents) {\n    this.topologies = new Map()\n    this.handlers = new Map()\n    this.components = components\n\n    this._onDisconnect = this._onDisconnect.bind(this)\n    this._onPeerUpdate = this._onPeerUpdate.bind(this)\n    this._onPeerIdentify = this._onPeerIdentify.bind(this)\n\n    this.components.events.addEventListener('peer:disconnect', this._onDisconnect)\n    this.components.events.addEventListener('peer:update', this._onPeerUpdate)\n    this.components.events.addEventListener('peer:identify', this._onPeerIdentify)\n  }\n\n  getProtocols (): string[] {\n    return Array.from(new Set<string>([\n      ...this.handlers.keys()\n    ])).sort()\n  }\n\n  getHandler (protocol: string): StreamHandlerRecord {\n    const handler = this.handlers.get(protocol)\n\n    if (handler == null) {\n      throw new CodeError(`No handler registered for protocol ${protocol}`, codes.ERR_NO_HANDLER_FOR_PROTOCOL)\n    }\n\n    return handler\n  }\n\n  getTopologies (protocol: string): Topology[] {\n    const topologies = this.topologies.get(protocol)\n\n    if (topologies == null) {\n      return []\n    }\n\n    return [\n      ...topologies.values()\n    ]\n  }\n\n  /**\n   * Registers the `handler` for each protocol\n   */\n  async handle (protocol: string, handler: StreamHandler, opts?: StreamHandlerOptions): Promise<void> {\n    if (this.handlers.has(protocol)) {\n      throw new CodeError(`Handler already registered for protocol ${protocol}`, codes.ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED)\n    }\n\n    const options = merge.bind({ ignoreUndefined: true })({\n      maxInboundStreams: DEFAULT_MAX_INBOUND_STREAMS,\n      maxOutboundStreams: DEFAULT_MAX_OUTBOUND_STREAMS\n    }, opts)\n\n    this.handlers.set(protocol, {\n      handler,\n      options\n    })\n\n    // Add new protocol to self protocols in the peer store\n    await this.components.peerStore.merge(this.components.peerId, {\n      protocols: [protocol]\n    })\n  }\n\n  /**\n   * Removes the handler for each protocol. The protocol\n   * will no longer be supported on streams.\n   */\n  async unhandle (protocols: string | string[]): Promise<void> {\n    const protocolList = Array.isArray(protocols) ? protocols : [protocols]\n\n    protocolList.forEach(protocol => {\n      this.handlers.delete(protocol)\n    })\n\n    // Update self protocols in the peer store\n    await this.components.peerStore.patch(this.components.peerId, {\n      protocols: this.getProtocols()\n    })\n  }\n\n  /**\n   * Register handlers for a set of multicodecs given\n   */\n  async register (protocol: string, topology: Topology): Promise<string> {\n    if (topology == null) {\n      throw new CodeError('invalid topology', codes.ERR_INVALID_PARAMETERS)\n    }\n\n    // Create topology\n    const id = `${(Math.random() * 1e9).toString(36)}${Date.now()}`\n\n    let topologies = this.topologies.get(protocol)\n\n    if (topologies == null) {\n      topologies = new Map<string, Topology>()\n      this.topologies.set(protocol, topologies)\n    }\n\n    topologies.set(id, topology)\n\n    return id\n  }\n\n  /**\n   * Unregister topology\n   */\n  unregister (id: string): void {\n    for (const [protocol, topologies] of this.topologies.entries()) {\n      if (topologies.has(id)) {\n        topologies.delete(id)\n\n        if (topologies.size === 0) {\n          this.topologies.delete(protocol)\n        }\n      }\n    }\n  }\n\n  /**\n   * Remove a disconnected peer from the record\n   */\n  _onDisconnect (evt: CustomEvent<PeerId>): void {\n    const remotePeer = evt.detail\n\n    void this.components.peerStore.get(remotePeer)\n      .then(peer => {\n        for (const protocol of peer.protocols) {\n          const topologies = this.topologies.get(protocol)\n\n          if (topologies == null) {\n            // no topologies are interested in this protocol\n            continue\n          }\n\n          for (const topology of topologies.values()) {\n            topology.onDisconnect?.(remotePeer)\n          }\n        }\n      })\n      .catch(err => {\n        if (err.code === codes.ERR_NOT_FOUND) {\n          // peer has not completed identify so they are not in the peer store\n          return\n        }\n\n        log.error('could not inform topologies of disconnecting peer %p', remotePeer, err)\n      })\n  }\n\n  /**\n   * When a peer is updated, if they have removed supported protocols notify any\n   * topologies interested in the removed protocols.\n   */\n  _onPeerUpdate (evt: CustomEvent<PeerUpdate>): void {\n    const { peer, previous } = evt.detail\n    const removed = (previous?.protocols ?? []).filter(protocol => !peer.protocols.includes(protocol))\n\n    for (const protocol of removed) {\n      const topologies = this.topologies.get(protocol)\n\n      if (topologies == null) {\n        // no topologies are interested in this protocol\n        continue\n      }\n\n      for (const topology of topologies.values()) {\n        topology.onDisconnect?.(peer.id)\n      }\n    }\n  }\n\n  /**\n   * After identify has completed and we have received the list of supported\n   * protocols, notify any topologies interested in those protocols.\n   */\n  _onPeerIdentify (evt: CustomEvent<IdentifyResult>): void {\n    const protocols = evt.detail.protocols\n    const connection = evt.detail.connection\n    const peerId = evt.detail.peerId\n\n    for (const protocol of protocols) {\n      const topologies = this.topologies.get(protocol)\n\n      if (topologies == null) {\n        // no topologies are interested in this protocol\n        continue\n      }\n\n      for (const topology of topologies.values()) {\n        if (connection.transient && topology.notifyOnTransient !== true) {\n          continue\n        }\n\n        topology.onConnect?.(peerId, connection)\n      }\n    }\n  }\n}\n", "import type { Metric, Metrics } from './index.js'\n\nexport interface TrackedMapInit {\n  name: string\n  metrics: Metrics\n}\n\nclass TrackedMap<K, V> extends Map<K, V> {\n  private readonly metric: Metric\n\n  constructor (init: TrackedMapInit) {\n    super()\n\n    const { name, metrics } = init\n\n    this.metric = metrics.registerMetric(name)\n    this.updateComponentMetric()\n  }\n\n  set (key: K, value: V): this {\n    super.set(key, value)\n    this.updateComponentMetric()\n    return this\n  }\n\n  delete (key: K): boolean {\n    const deleted = super.delete(key)\n    this.updateComponentMetric()\n    return deleted\n  }\n\n  clear (): void {\n    super.clear()\n    this.updateComponentMetric()\n  }\n\n  private updateComponentMetric (): void {\n    this.metric.update(this.size)\n  }\n}\n\nexport interface CreateTrackedMapInit {\n  /**\n   * The metric name to use\n   */\n  name: string\n\n  /**\n   * A metrics implementation\n   */\n  metrics?: Metrics\n}\n\nexport function trackedMap <K, V> (config: CreateTrackedMapInit): Map<K, V> {\n  const { name, metrics } = config\n  let map: Map<K, V>\n\n  if (metrics != null) {\n    map = new TrackedMap<K, V>({ name, metrics })\n  } else {\n    map = new Map<K, V>()\n  }\n\n  return map\n}\n", "import { CodeError } from '@libp2p/interface/errors'\nimport { trackedMap } from '@libp2p/interface/metrics/tracked-map'\nimport { FaultTolerance } from '@libp2p/interface/transport'\nimport { logger } from '@libp2p/logger'\nimport { codes } from './errors.js'\nimport type { Libp2pEvents, AbortOptions } from '@libp2p/interface'\nimport type { Connection } from '@libp2p/interface/connection'\nimport type { TypedEventTarget } from '@libp2p/interface/events'\nimport type { Metrics } from '@libp2p/interface/metrics'\nimport type { Startable } from '@libp2p/interface/startable'\nimport type { Listener, Transport, Upgrader } from '@libp2p/interface/transport'\nimport type { AddressManager } from '@libp2p/interface-internal/address-manager'\nimport type { TransportManager } from '@libp2p/interface-internal/transport-manager'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nconst log = logger('libp2p:transports')\n\nexport interface TransportManagerInit {\n  faultTolerance?: FaultTolerance\n}\n\nexport interface DefaultTransportManagerComponents {\n  metrics?: Metrics\n  addressManager: AddressManager\n  upgrader: Upgrader\n  events: TypedEventTarget<Libp2pEvents>\n}\n\nexport class DefaultTransportManager implements TransportManager, Startable {\n  private readonly components: DefaultTransportManagerComponents\n  private readonly transports: Map<string, Transport>\n  private readonly listeners: Map<string, Listener[]>\n  private readonly faultTolerance: FaultTolerance\n  private started: boolean\n\n  constructor (components: DefaultTransportManagerComponents, init: TransportManagerInit = {}) {\n    this.components = components\n    this.started = false\n    this.transports = new Map<string, Transport>()\n    this.listeners = trackedMap({\n      name: 'libp2p_transport_manager_listeners',\n      metrics: this.components.metrics\n    })\n    this.faultTolerance = init.faultTolerance ?? FaultTolerance.FATAL_ALL\n  }\n\n  /**\n   * Adds a `Transport` to the manager\n   */\n  add (transport: Transport): void {\n    const tag = transport[Symbol.toStringTag]\n\n    if (tag == null) {\n      throw new CodeError('Transport must have a valid tag', codes.ERR_INVALID_KEY)\n    }\n\n    if (this.transports.has(tag)) {\n      throw new CodeError(`There is already a transport with the tag ${tag}`, codes.ERR_DUPLICATE_TRANSPORT)\n    }\n\n    log('adding transport %s', tag)\n\n    this.transports.set(tag, transport)\n\n    if (!this.listeners.has(tag)) {\n      this.listeners.set(tag, [])\n    }\n  }\n\n  isStarted (): boolean {\n    return this.started\n  }\n\n  start (): void {\n    this.started = true\n  }\n\n  async afterStart (): Promise<void> {\n    // Listen on the provided transports for the provided addresses\n    const addrs = this.components.addressManager.getListenAddrs()\n\n    await this.listen(addrs)\n  }\n\n  /**\n   * Stops all listeners\n   */\n  async stop (): Promise<void> {\n    const tasks = []\n    for (const [key, listeners] of this.listeners) {\n      log('closing listeners for %s', key)\n      while (listeners.length > 0) {\n        const listener = listeners.pop()\n\n        if (listener == null) {\n          continue\n        }\n\n        tasks.push(listener.close())\n      }\n    }\n\n    await Promise.all(tasks)\n    log('all listeners closed')\n    for (const key of this.listeners.keys()) {\n      this.listeners.set(key, [])\n    }\n\n    this.started = false\n  }\n\n  /**\n   * Dials the given Multiaddr over it's supported transport\n   */\n  async dial (ma: Multiaddr, options?: AbortOptions): Promise<Connection> {\n    const transport = this.transportForMultiaddr(ma)\n\n    if (transport == null) {\n      throw new CodeError(`No transport available for address ${String(ma)}`, codes.ERR_TRANSPORT_UNAVAILABLE)\n    }\n\n    try {\n      return await transport.dial(ma, {\n        ...options,\n        upgrader: this.components.upgrader\n      })\n    } catch (err: any) {\n      if (err.code == null) {\n        err.code = codes.ERR_TRANSPORT_DIAL_FAILED\n      }\n\n      throw err\n    }\n  }\n\n  /**\n   * Returns all Multiaddr's the listeners are using\n   */\n  getAddrs (): Multiaddr[] {\n    let addrs: Multiaddr[] = []\n    for (const listeners of this.listeners.values()) {\n      for (const listener of listeners) {\n        addrs = [...addrs, ...listener.getAddrs()]\n      }\n    }\n    return addrs\n  }\n\n  /**\n   * Returns all the transports instances\n   */\n  getTransports (): Transport[] {\n    return Array.of(...this.transports.values())\n  }\n\n  /**\n   * Returns all the listener instances\n   */\n  getListeners (): Listener[] {\n    return Array.of(...this.listeners.values()).flat()\n  }\n\n  /**\n   * Finds a transport that matches the given Multiaddr\n   */\n  transportForMultiaddr (ma: Multiaddr): Transport | undefined {\n    for (const transport of this.transports.values()) {\n      const addrs = transport.filter([ma])\n\n      if (addrs.length > 0) {\n        return transport\n      }\n    }\n  }\n\n  /**\n   * Starts listeners for each listen Multiaddr\n   */\n  async listen (addrs: Multiaddr[]): Promise<void> {\n    if (!this.isStarted()) {\n      throw new CodeError('Not started', codes.ERR_NODE_NOT_STARTED)\n    }\n\n    if (addrs == null || addrs.length === 0) {\n      log('no addresses were provided for listening, this node is dial only')\n      return\n    }\n\n    const couldNotListen = []\n\n    for (const [key, transport] of this.transports.entries()) {\n      const supportedAddrs = transport.filter(addrs)\n      const tasks = []\n\n      // For each supported multiaddr, create a listener\n      for (const addr of supportedAddrs) {\n        log('creating listener for %s on %a', key, addr)\n        const listener = transport.createListener({\n          upgrader: this.components.upgrader\n        })\n\n        let listeners: Listener[] = this.listeners.get(key) ?? []\n\n        if (listeners == null) {\n          listeners = []\n          this.listeners.set(key, listeners)\n        }\n\n        listeners.push(listener)\n\n        // Track listen/close events\n        listener.addEventListener('listening', () => {\n          this.components.events.safeDispatchEvent('transport:listening', {\n            detail: listener\n          })\n        })\n        listener.addEventListener('close', () => {\n          const index = listeners.findIndex(l => l === listener)\n\n          // remove the listener\n          listeners.splice(index, 1)\n\n          this.components.events.safeDispatchEvent('transport:close', {\n            detail: listener\n          })\n        })\n\n        // We need to attempt to listen on everything\n        tasks.push(listener.listen(addr))\n      }\n\n      // Keep track of transports we had no addresses for\n      if (tasks.length === 0) {\n        couldNotListen.push(key)\n        continue\n      }\n\n      const results = await Promise.allSettled(tasks)\n      // If we are listening on at least 1 address, succeed.\n      // TODO: we should look at adding a retry (`p-retry`) here to better support\n      // listening on remote addresses as they may be offline. We could then potentially\n      // just wait for any (`p-any`) listener to succeed on each transport before returning\n      const isListening = results.find(r => r.status === 'fulfilled')\n      if ((isListening == null) && this.faultTolerance !== FaultTolerance.NO_FATAL) {\n        throw new CodeError(`Transport (${key}) could not listen on any available address`, codes.ERR_NO_VALID_ADDRESSES)\n      }\n    }\n\n    // If no transports were able to listen, throw an error. This likely\n    // means we were given addresses we do not have transports for\n    if (couldNotListen.length === this.transports.size) {\n      const message = `no valid addresses were provided for transports [${couldNotListen.join(', ')}]`\n      if (this.faultTolerance === FaultTolerance.FATAL_ALL) {\n        throw new CodeError(message, codes.ERR_NO_VALID_ADDRESSES)\n      }\n      log(`libp2p in dial mode only: ${message}`)\n    }\n  }\n\n  /**\n   * Removes the given transport from the manager.\n   * If a transport has any running listeners, they will be closed.\n   */\n  async remove (key: string): Promise<void> {\n    const listeners = this.listeners.get(key) ?? []\n    log.trace('removing transport %s', key)\n\n    // Close any running listeners\n    const tasks = []\n    log.trace('closing listeners for %s', key)\n    while (listeners.length > 0) {\n      const listener = listeners.pop()\n\n      if (listener == null) {\n        continue\n      }\n\n      tasks.push(listener.close())\n    }\n    await Promise.all(tasks)\n\n    this.transports.delete(key)\n    this.listeners.delete(key)\n  }\n\n  /**\n   * Removes all transports from the manager.\n   * If any listeners are running, they will be closed.\n   *\n   * @async\n   */\n  async removeAll (): Promise<void> {\n    const tasks = []\n    for (const key of this.transports.keys()) {\n      tasks.push(this.remove(key))\n    }\n\n    await Promise.all(tasks)\n  }\n}\n", "export const PROTOCOL_ID = '/multistream/1.0.0'\n\n// Conforming to go-libp2p\n// See https://github.com/multiformats/go-multistream/blob/master/multistream.go#L297\nexport const MAX_PROTOCOL_LENGTH = 1024\n", "import { Uint8ArrayList } from 'uint8arraylist'\nimport type { Source } from 'it-stream-types'\n\n/**\n * A specialized `AsyncGenerator` that lets you pass a number to the `.next` method which\n * will attempt to return only that many bytes.\n */\nexport interface Reader extends AsyncGenerator<Uint8ArrayList, void, any> {\n  next: (...args: [] | [number | undefined]) => Promise<IteratorResult<Uint8ArrayList, void>>\n}\n\n/**\n * Returns an `AsyncGenerator` that allows reading a set number of bytes from the passed source.\n *\n * @example\n *\n * ```javascript\n * import { reader } from 'it-reader'\n *\n * const stream = reader(source)\n *\n * // read 10 bytes from the stream\n * const { done, value } = await stream.next(10)\n *\n * if (done === true) {\n *   // stream finished\n * }\n *\n * if (value != null) {\n *   // do something with value\n * }\n * ```\n */\nexport function reader (source: Source<Uint8Array | Uint8ArrayList>): Reader {\n  const reader: Reader = (async function * (): AsyncGenerator<Uint8ArrayList, void, any> {\n    // @ts-expect-error first yield in stream is ignored\n    let bytes: number | undefined = yield // Allows us to receive 8 when reader.next(8) is called\n    let bl = new Uint8ArrayList()\n\n    for await (const chunk of source) {\n      if (bytes == null) {\n        bl.append(chunk)\n        bytes = yield bl\n        bl = new Uint8ArrayList()\n        continue\n      }\n\n      bl.append(chunk)\n\n      while (bl.length >= bytes) {\n        const data = bl.sublist(0, bytes)\n        bl.consume(bytes)\n        bytes = yield data\n\n        // If we no longer want a specific byte length, we yield the rest now\n        if (bytes == null) {\n          if (bl.length > 0) {\n            bytes = yield bl\n            bl = new Uint8ArrayList()\n          }\n          break // bytes is null and/or no more buffer to yield\n        }\n      }\n    }\n\n    // Consumer wants more bytes but the source has ended and our buffer\n    // is not big enough to satisfy.\n    if (bytes != null) {\n      throw Object.assign(\n        new Error(`stream ended before ${bytes} bytes became available`),\n        { code: 'ERR_UNDER_READ', buffer: bl }\n      )\n    }\n  })()\n\n  void reader.next()\n  return reader\n}\n", "/**\n * @packageDocumentation\n *\n * @example\n *\n * ```js\n *\n * import { pipe } from 'it-pipe'\n * import { duplexPair } from 'it-pair/duplex'\n * import { handshake } from 'it-handshake'\n *\n * // Create connected duplex streams\n * const [client, server] = duplexPair()\n * const clientShake = handshake(client)\n * const serverShake = handshake(server)\n *\n * clientShake.write('hello')\n * console.log('client: %s', await serverShake.read())\n * // > client: hello\n * serverShake.write('hi')\n * serverShake.rest() // the server has finished the handshake\n * console.log('server: %s', await clientShake.read())\n * // > server: hi\n * clientShake.rest() // the client has finished the handshake\n *\n * // Make the server echo responses\n * pipe(\n *   serverShake.stream,\n *   async function * (source) {\n *     for await (const message of source) {\n *       yield message\n *     }\n *   },\n *   serverShake.stream\n * )\n *\n * // Send and receive an echo through the handshake stream\n * pipe(\n *   ['echo'],\n *   clientShake.stream,\n *   async function * (source) {\n *     for await (const bufferList of source) {\n *       console.log('Echo response: %s', bufferList.slice())\n *       // > Echo response: echo\n *     }\n *   }\n * )\n * ```\n */\n\nimport { Reader, reader } from 'it-reader'\nimport { pushable } from 'it-pushable'\nimport defer from 'p-defer'\nimport type { Duplex, Source } from 'it-stream-types'\nimport type { Pushable } from 'it-pushable'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface Handshake<TSink = Uint8Array | Uint8ArrayList> {\n  reader: Reader\n  writer: Pushable<TSink>\n  stream: Duplex<AsyncGenerator<Uint8ArrayList | Uint8Array>, Source<TSink>, Promise<void>>\n  rest: () => Source<TSink>\n  write: (data: TSink) => void\n  read: () => Promise<Uint8ArrayList | undefined>\n}\n\n// Convert a duplex stream into a reader and writer and rest stream\nexport function handshake<TSink extends Uint8ArrayList | Uint8Array = Uint8ArrayList> (stream: Duplex<AsyncIterable<Uint8ArrayList | Uint8Array>, Source<TSink>, Promise<void>>): Handshake<TSink> {\n  const writer = pushable<TSink>() // Write bytes on demand to the sink\n  const source = reader(stream.source) // Read bytes on demand from the source\n\n  // Waits for a source to be passed to the rest stream's sink\n  const sourcePromise = defer<Source<TSink>>()\n  let sinkErr: Error\n\n  const sinkPromise = stream.sink((async function * () {\n    yield * writer\n    const source = await sourcePromise.promise\n    yield * source\n  })())\n\n  sinkPromise.catch(err => {\n    sinkErr = err\n  })\n\n  const rest: Duplex<AsyncGenerator<Uint8ArrayList>, Source<TSink>, Promise<void>> = {\n    sink: async source => {\n      if (sinkErr != null) {\n        await Promise.reject(sinkErr); return\n      }\n\n      sourcePromise.resolve(source)\n      await sinkPromise\n    },\n    source\n  }\n\n  return {\n    reader: source,\n    writer,\n    stream: rest,\n    rest: () => writer.end(),\n    write: writer.push,\n    read: async () => {\n      const res = await source.next()\n\n      if (res.value != null) {\n        return res.value\n      }\n    }\n  }\n}\n", "import { CodeError } from '@libp2p/interface/errors'\nimport { logger } from '@libp2p/logger'\nimport { abortableSource } from 'abortable-iterator'\nimport first from 'it-first'\nimport * as lp from 'it-length-prefixed'\nimport { pipe } from 'it-pipe'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { MAX_PROTOCOL_LENGTH } from './constants.js'\nimport type { MultistreamSelectInit } from '.'\nimport type { AbortOptions } from '@libp2p/interface'\nimport type { Pushable } from 'it-pushable'\nimport type { Reader } from 'it-reader'\nimport type { Source } from 'it-stream-types'\n\nconst log = logger('libp2p:mss')\n\nconst NewLine = uint8ArrayFromString('\\n')\n\nexport function encode (buffer: Uint8Array | Uint8ArrayList): Uint8ArrayList {\n  const list = new Uint8ArrayList(buffer, NewLine)\n\n  return lp.encode.single(list)\n}\n\n/**\n * `write` encodes and writes a single buffer\n */\nexport function write (writer: Pushable<any>, buffer: Uint8Array | Uint8ArrayList, options: MultistreamSelectInit = {}): void {\n  const encoded = encode(buffer)\n\n  if (options.writeBytes === true) {\n    writer.push(encoded.subarray())\n  } else {\n    writer.push(encoded)\n  }\n}\n\n/**\n * `writeAll` behaves like `write`, except it encodes an array of items as a single write\n */\nexport function writeAll (writer: Pushable<any>, buffers: Uint8Array[], options: MultistreamSelectInit = {}): void {\n  const list = new Uint8ArrayList()\n\n  for (const buf of buffers) {\n    list.append(encode(buf))\n  }\n\n  if (options.writeBytes === true) {\n    writer.push(list.subarray())\n  } else {\n    writer.push(list)\n  }\n}\n\nexport async function read (reader: Reader, options?: AbortOptions): Promise<Uint8ArrayList> {\n  let byteLength = 1 // Read single byte chunks until the length is known\n  const varByteSource = { // No return impl - we want the reader to remain readable\n    [Symbol.asyncIterator]: () => varByteSource,\n    next: async () => reader.next(byteLength)\n  }\n\n  let input: Source<Uint8ArrayList> = varByteSource\n\n  // If we have been passed an abort signal, wrap the input source in an abortable\n  // iterator that will throw if the operation is aborted\n  if (options?.signal != null) {\n    input = abortableSource(varByteSource, options.signal)\n  }\n\n  // Once the length has been parsed, read chunk for that length\n  const onLength = (l: number): void => {\n    byteLength = l\n  }\n\n  const buf = await pipe(\n    input,\n    (source) => lp.decode(source, { onLength, maxDataLength: MAX_PROTOCOL_LENGTH }),\n    async (source) => first(source)\n  )\n\n  if (buf == null || buf.length === 0) {\n    throw new CodeError('no buffer returned', 'ERR_INVALID_MULTISTREAM_SELECT_MESSAGE')\n  }\n\n  if (buf.get(buf.byteLength - 1) !== NewLine[0]) {\n    log.error('Invalid mss message - missing newline - %s', buf.subarray())\n    throw new CodeError('missing newline', 'ERR_INVALID_MULTISTREAM_SELECT_MESSAGE')\n  }\n\n  return buf.sublist(0, -1) // Remove newline\n}\n\nexport async function readString (reader: Reader, options?: AbortOptions): Promise<string> {\n  const buf = await read(reader, options)\n\n  return uint8ArrayToString(buf.subarray())\n}\n", "import { CodeError } from '@libp2p/interface/errors'\nimport { logger } from '@libp2p/logger'\nimport { handshake } from 'it-handshake'\nimport merge from 'it-merge'\nimport { pushable } from 'it-pushable'\nimport { reader } from 'it-reader'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport * as multistream from './multistream.js'\nimport { PROTOCOL_ID } from './index.js'\nimport type { ByteArrayInit, ByteListInit, MultistreamSelectInit, ProtocolStream } from './index.js'\nimport type { Duplex, Source } from 'it-stream-types'\n\nconst log = logger('libp2p:mss:select')\n\n/**\n * Negotiate a protocol to use from a list of protocols.\n *\n * @param stream - A duplex iterable stream to dial on\n * @param protocols - A list of protocols (or single protocol) to negotiate with. Protocols are attempted in order until a match is made.\n * @param options - An options object containing an AbortSignal and an optional boolean `writeBytes` - if this is true, `Uint8Array`s will be written into `duplex`, otherwise `Uint8ArrayList`s will\n * @returns A stream for the selected protocol and the protocol that was selected from the list of protocols provided to `select`.\n * @example\n *\n * ```js\n * import { pipe } from 'it-pipe'\n * import * as mss from '@libp2p/multistream-select'\n * import { Mplex } from '@libp2p/mplex'\n *\n * const muxer = new Mplex()\n * const muxedStream = muxer.newStream()\n *\n * // mss.select(protocol(s))\n * // Select from one of the passed protocols (in priority order)\n * // Returns selected stream and protocol\n * const { stream: dhtStream, protocol } = await mss.select(muxedStream, [\n *   // This might just be different versions of DHT, but could be different impls\n *   '/ipfs-dht/2.0.0', // Most of the time this will probably just be one item.\n *   '/ipfs-dht/1.0.0'\n * ])\n *\n * // Typically this stream will be passed back to the caller of libp2p.dialProtocol\n * //\n * // ...it might then do something like this:\n * // try {\n * //   await pipe(\n * //     [uint8ArrayFromString('Some DHT data')]\n * //     dhtStream,\n * //     async source => {\n * //       for await (const chunk of source)\n * //         // DHT response data\n * //     }\n * //   )\n * // } catch (err) {\n * //   // Error in stream\n * // }\n * ```\n */\nexport async function select (stream: Duplex<AsyncGenerator<Uint8Array>, Source<Uint8Array>>, protocols: string | string[], options: ByteArrayInit): Promise<ProtocolStream<Uint8Array>>\nexport async function select (stream: Duplex<AsyncGenerator<Uint8ArrayList | Uint8Array>, Source<Uint8ArrayList | Uint8Array>>, protocols: string | string[], options?: ByteListInit): Promise<ProtocolStream<Uint8ArrayList, Uint8ArrayList | Uint8Array>>\nexport async function select (stream: any, protocols: string | string[], options: MultistreamSelectInit = {}): Promise<ProtocolStream<any>> {\n  protocols = Array.isArray(protocols) ? [...protocols] : [protocols]\n  const { reader, writer, rest, stream: shakeStream } = handshake(stream)\n\n  const protocol = protocols.shift()\n\n  if (protocol == null) {\n    throw new Error('At least one protocol must be specified')\n  }\n\n  log.trace('select: write [\"%s\", \"%s\"]', PROTOCOL_ID, protocol)\n  const p1 = uint8ArrayFromString(PROTOCOL_ID)\n  const p2 = uint8ArrayFromString(protocol)\n  multistream.writeAll(writer, [p1, p2], options)\n\n  let response = await multistream.readString(reader, options)\n  log.trace('select: read \"%s\"', response)\n\n  // Read the protocol response if we got the protocolId in return\n  if (response === PROTOCOL_ID) {\n    response = await multistream.readString(reader, options)\n    log.trace('select: read \"%s\"', response)\n  }\n\n  // We're done\n  if (response === protocol) {\n    rest()\n    return { stream: shakeStream, protocol }\n  }\n\n  // We haven't gotten a valid ack, try the other protocols\n  for (const protocol of protocols) {\n    log.trace('select: write \"%s\"', protocol)\n    multistream.write(writer, uint8ArrayFromString(protocol), options)\n    const response = await multistream.readString(reader, options)\n    log.trace('select: read \"%s\" for \"%s\"', response, protocol)\n\n    if (response === protocol) {\n      rest() // End our writer so others can start writing to stream\n      return { stream: shakeStream, protocol }\n    }\n  }\n\n  rest()\n  throw new CodeError('protocol selection failed', 'ERR_UNSUPPORTED_PROTOCOL')\n}\n\n/**\n * Lazily negotiates a protocol.\n *\n * It *does not* block writes waiting for the other end to respond. Instead, it\n * simply assumes the negotiation went successfully and starts writing data.\n *\n * Use when it is known that the receiver supports the desired protocol.\n */\nexport function lazySelect (stream: Duplex<Source<Uint8Array>, Source<Uint8Array>>, protocol: string): ProtocolStream<Uint8Array>\nexport function lazySelect (stream: Duplex<Source<Uint8ArrayList | Uint8Array>, Source<Uint8ArrayList | Uint8Array>>, protocol: string): ProtocolStream<Uint8ArrayList, Uint8ArrayList | Uint8Array>\nexport function lazySelect (stream: Duplex<any>, protocol: string): ProtocolStream<any> {\n  // This is a signal to write the multistream headers if the consumer tries to\n  // read from the source\n  const negotiateTrigger = pushable()\n  let negotiated = false\n  return {\n    stream: {\n      sink: async source => {\n        await stream.sink((async function * () {\n          let first = true\n          for await (const chunk of merge(source, negotiateTrigger)) {\n            if (first) {\n              first = false\n              negotiated = true\n              negotiateTrigger.end()\n              const p1 = uint8ArrayFromString(PROTOCOL_ID)\n              const p2 = uint8ArrayFromString(protocol)\n              const list = new Uint8ArrayList(multistream.encode(p1), multistream.encode(p2))\n              if (chunk.length > 0) list.append(chunk)\n              yield * list\n            } else {\n              yield chunk\n            }\n          }\n        })())\n      },\n      source: (async function * () {\n        if (!negotiated) negotiateTrigger.push(new Uint8Array())\n        const byteReader = reader(stream.source)\n        let response = await multistream.readString(byteReader)\n        if (response === PROTOCOL_ID) {\n          response = await multistream.readString(byteReader)\n        }\n        if (response !== protocol) {\n          throw new CodeError('protocol selection failed', 'ERR_UNSUPPORTED_PROTOCOL')\n        }\n        for await (const chunk of byteReader) {\n          yield * chunk\n        }\n      })()\n    },\n    protocol\n  }\n}\n", "import { logger } from '@libp2p/logger'\nimport { handshake } from 'it-handshake'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { PROTOCOL_ID } from './constants.js'\nimport * as multistream from './multistream.js'\nimport type { ByteArrayInit, ByteListInit, MultistreamSelectInit, ProtocolStream } from './index.js'\nimport type { Duplex, Source } from 'it-stream-types'\n\nconst log = logger('libp2p:mss:handle')\n\n/**\n * Handle multistream protocol selections for the given list of protocols.\n *\n * Note that after a protocol is handled `listener` can no longer be used.\n *\n * @param stream - A duplex iterable stream to listen on\n * @param protocols - A list of protocols (or single protocol) that this listener is able to speak.\n * @param options - an options object containing an AbortSignal and an optional boolean `writeBytes` - if this is true, `Uint8Array`s will be written into `duplex`, otherwise `Uint8ArrayList`s will\n * @returns A stream for the selected protocol and the protocol that was selected from the list of protocols provided to `select`\n * @example\n *\n * ```js\n * import { pipe } from 'it-pipe'\n * import * as mss from '@libp2p/multistream-select'\n * import { Mplex } from '@libp2p/mplex'\n *\n * const muxer = new Mplex({\n *   async onStream (muxedStream) {\n *   // mss.handle(handledProtocols)\n *   // Returns selected stream and protocol\n *   const { stream, protocol } = await mss.handle(muxedStream, [\n *     '/ipfs-dht/1.0.0',\n *     '/ipfs-bitswap/1.0.0'\n *   ])\n *\n *   // Typically here we'd call the handler function that was registered in\n *   // libp2p for the given protocol:\n *   // e.g. handlers[protocol].handler(stream)\n *   //\n *   // If protocol was /ipfs-dht/1.0.0 it might do something like this:\n *   // try {\n *   //   await pipe(\n *   //     dhtStream,\n *   //     source => (async function * () {\n *   //       for await (const chunk of source)\n *   //         // Incoming DHT data -> process and yield to respond\n *   //     })(),\n *   //     dhtStream\n *   //   )\n *   // } catch (err) {\n *   //   // Error in stream\n *   // }\n *   }\n * })\n * ```\n */\nexport async function handle (stream: Duplex<Source<Uint8Array>, Source<Uint8Array>>, protocols: string | string[], options: ByteArrayInit): Promise<ProtocolStream<Uint8Array>>\nexport async function handle (stream: Duplex<Source<Uint8ArrayList | Uint8Array>, Source<Uint8ArrayList | Uint8Array>>, protocols: string | string[], options?: ByteListInit): Promise<ProtocolStream<Uint8ArrayList, Uint8ArrayList | Uint8Array>>\nexport async function handle (stream: any, protocols: string | string[], options?: MultistreamSelectInit): Promise<ProtocolStream<any>> {\n  protocols = Array.isArray(protocols) ? protocols : [protocols]\n  const { writer, reader, rest, stream: shakeStream } = handshake(stream)\n\n  while (true) {\n    const protocol = await multistream.readString(reader, options)\n    log.trace('read \"%s\"', protocol)\n\n    if (protocol === PROTOCOL_ID) {\n      log.trace('respond with \"%s\" for \"%s\"', PROTOCOL_ID, protocol)\n      multistream.write(writer, uint8ArrayFromString(PROTOCOL_ID), options)\n      continue\n    }\n\n    if (protocols.includes(protocol)) {\n      multistream.write(writer, uint8ArrayFromString(protocol), options)\n      log.trace('respond with \"%s\" for \"%s\"', protocol, protocol)\n      rest()\n      return { stream: shakeStream, protocol }\n    }\n\n    if (protocol === 'ls') {\n      // <varint-msg-len><varint-proto-name-len><proto-name>\\n<varint-proto-name-len><proto-name>\\n\\n\n      multistream.write(writer, new Uint8ArrayList(...protocols.map(p => multistream.encode(uint8ArrayFromString(p)))), options)\n      // multistream.writeAll(writer, protocols.map(p => uint8ArrayFromString(p)))\n      log.trace('respond with \"%s\" for %s', protocols, protocol)\n      continue\n    }\n\n    multistream.write(writer, uint8ArrayFromString('na'), options)\n    log('respond with \"na\" for \"%s\"', protocol)\n  }\n}\n", "import type { AbortOptions } from '../index.js'\nimport type { PeerId } from '../peer-id/index.js'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { Duplex, Source } from 'it-stream-types'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface ConnectionTimeline {\n  /**\n   * When the connection was opened\n   */\n  open: number\n\n  /**\n   * When the MultiaddrConnection was upgraded to a Connection - e.g. the type\n   * of connection encryption and multiplexing was negotiated.\n   */\n  upgraded?: number\n\n  /**\n   * When the connection was closed.\n   */\n  close?: number\n}\n\n/**\n * Outbound connections are opened by the local node, inbound streams are opened by the remote\n */\nexport type Direction = 'inbound' | 'outbound'\n\nexport interface StreamTimeline {\n  /**\n   * A timestamp of when the stream was opened\n   */\n  open: number\n\n  /**\n   * A timestamp of when the stream was closed for both reading and writing\n   */\n  close?: number\n\n  /**\n   * A timestamp of when the stream was closed for reading\n   */\n  closeRead?: number\n\n  /**\n   * A timestamp of when the stream was closed for writing\n   */\n  closeWrite?: number\n\n  /**\n   * A timestamp of when the stream was reset\n   */\n  reset?: number\n\n  /**\n   * A timestamp of when the stream was aborted\n   */\n  abort?: number\n}\n\n/**\n * The states a stream can be in\n */\nexport type StreamStatus = 'open' | 'closing' | 'closed' | 'aborted' | 'reset'\n\n/**\n * The states the readable end of a stream can be in\n *\n * ready - the readable end is ready for reading\n * closing - the readable end is closing\n * closed - the readable end has closed\n */\nexport type ReadStatus = 'ready' | 'closing' | 'closed'\n\n/**\n * The states the writable end of a stream can be in\n *\n * ready - the writable end is ready for writing\n * writing - the writable end is in the process of being written to\n * done - the source passed to the `.sink` function yielded all values without error\n * closing - the writable end is closing\n * closed - the writable end has closed\n */\nexport type WriteStatus = 'ready' | 'writing' | 'done' | 'closing' | 'closed'\n\n/**\n * A Stream is a data channel between two peers that\n * can be written to and read from at both ends.\n *\n * It may be encrypted and multiplexed depending on the\n * configuration of the nodes.\n */\nexport interface Stream extends Duplex<AsyncGenerator<Uint8ArrayList>, Source<Uint8ArrayList | Uint8Array>, Promise<void>> {\n  /**\n   * Closes the stream for **reading** *and* **writing**.\n   *\n   * Any buffered data in the source can still be consumed and the stream will end normally.\n   *\n   * This will cause a `CLOSE` message to be sent to the remote, *unless* the sink has already ended.\n   *\n   * The sink and the source will return normally.\n   */\n  close(options?: AbortOptions): Promise<void>\n\n  /**\n   * Closes the stream for **reading**. If iterating over the source of this stream in a `for await of` loop, it will return (exit the loop) after any buffered data has been consumed.\n   *\n   * This function is called automatically by the muxer when it receives a `CLOSE` message from the remote.\n   *\n   * The source will return normally, the sink will continue to consume.\n   */\n  closeRead(options?: AbortOptions): Promise<void>\n\n  /**\n   * Closes the stream for **writing**. If iterating over the source of this stream in a `for await of` loop, it will return (exit the loop) after any buffered data has been consumed.\n   *\n   * The source will return normally, the sink will continue to consume.\n   */\n  closeWrite(options?: AbortOptions): Promise<void>\n\n  /**\n   * Closes the stream for **reading** *and* **writing**. This should be called when a *local error* has occurred.\n   *\n   * Note, if called without an error any buffered data in the source can still be consumed and the stream will end normally.\n   *\n   * This will cause a `RESET` message to be sent to the remote, *unless* the sink has already ended.\n   *\n   * The sink will return and the source will throw if an error is passed or return normally if not.\n   */\n  abort(err: Error): void\n\n  /**\n   * Unique identifier for a stream. Identifiers are not unique across muxers.\n   */\n  id: string\n\n  /**\n   * Outbound streams are opened by the local node, inbound streams are opened by the remote\n   */\n  direction: Direction\n\n  /**\n   * Lifecycle times for the stream\n   */\n  timeline: StreamTimeline\n\n  /**\n   * The protocol negotiated for this stream\n   */\n  protocol?: string\n\n  /**\n   * User defined stream metadata\n   */\n  metadata: Record<string, any>\n\n  /**\n   * The current status of the stream\n   */\n  status: StreamStatus\n\n  /**\n   * The current status of the readable end of the stream\n   */\n  readStatus: ReadStatus\n\n  /**\n   * The current status of the writable end of the stream\n   */\n  writeStatus: WriteStatus\n}\n\nexport interface NewStreamOptions extends AbortOptions {\n  /**\n   * If specified, and no handler has been registered with the registrar for the\n   * successfully negotiated protocol, use this as the max outbound stream limit\n   * for the protocol\n   */\n  maxOutboundStreams?: number\n\n  /**\n   * Opt-in to running over a transient connection - one that has time/data limits\n   * placed on it.\n   */\n  runOnTransientConnection?: boolean\n}\n\nexport type ConnectionStatus = 'open' | 'closing' | 'closed'\n\n/**\n * A Connection is a high-level representation of a connection\n * to a remote peer that may have been secured by encryption and\n * multiplexed, depending on the configuration of the nodes\n * between which the connection is made.\n */\nexport interface Connection {\n  /**\n   * The unique identifier for this connection\n   */\n  id: string\n\n  /**\n   * The address of the remote end of the connection\n   */\n  remoteAddr: Multiaddr\n\n  /**\n   * The id of the peer at the remote end of the connection\n   */\n  remotePeer: PeerId\n\n  /**\n   * A list of tags applied to this connection\n   */\n  tags: string[]\n\n  /**\n   * A list of open streams on this connection\n   */\n  streams: Stream[]\n\n  /**\n   * Outbound conections are opened by the local node, inbound streams are opened by the remote\n   */\n  direction: Direction\n\n  /**\n   * Lifecycle times for the connection\n   */\n  timeline: ConnectionTimeline\n\n  /**\n   * The multiplexer negotiated for this connection\n   */\n  multiplexer?: string\n\n  /**\n   * The encryption protocol negotiated for this connection\n   */\n  encryption?: string\n\n  /**\n   * The current status of the connection\n   */\n  status: ConnectionStatus\n\n  /**\n   * A transient connection is one that is not expected to be open for very long\n   * or one that cannot transfer very much data, such as one being used as a\n   * circuit relay connection. Protocols need to explicitly opt-in to being run\n   * over transient connections.\n   */\n  transient: boolean\n\n  /**\n   * Create a new stream on this connection and negotiate one of the passed protocols\n   */\n  newStream(protocols: string | string[], options?: NewStreamOptions): Promise<Stream>\n\n  /**\n   * Gracefully close the connection. All queued data will be written to the\n   * underlying transport.\n   */\n  close(options?: AbortOptions): Promise<void>\n\n  /**\n   * Immediately close the connection, any queued data will be discarded\n   */\n  abort(err: Error): void\n}\n\nexport const symbol = Symbol.for('@libp2p/connection')\n\nexport function isConnection (other: any): other is Connection {\n  return other != null && Boolean(other[symbol])\n}\n\nexport interface ConnectionProtector {\n  /**\n   * Takes a given Connection and creates a private encryption stream\n   * between its two peers from the PSK the Protector instance was\n   * created with.\n   */\n  protect(connection: MultiaddrConnection): Promise<MultiaddrConnection>\n}\n\nexport interface MultiaddrConnectionTimeline {\n  /**\n   * When the connection was opened\n   */\n  open: number\n\n  /**\n   * When the MultiaddrConnection was upgraded to a Connection - the type of\n   * connection encryption and multiplexing was negotiated.\n   */\n  upgraded?: number\n\n  /**\n   * When the connection was closed.\n   */\n  close?: number\n}\n\n/**\n * A MultiaddrConnection is returned by transports after dialing\n * a peer. It is a low-level primitive and is the raw connection\n * without encryption or stream multiplexing.\n */\nexport interface MultiaddrConnection extends Duplex<AsyncGenerator<Uint8Array>, Source<Uint8Array>, Promise<void>> {\n  /**\n   * Gracefully close the connection. All queued data will be written to the\n   * underlying transport.\n   */\n  close(options?: AbortOptions): Promise<void>\n\n  /**\n   * Immediately close the connection, any queued data will be discarded\n   */\n  abort(err: Error): void\n\n  /**\n   * The address of the remote end of the connection\n   */\n  remoteAddr: Multiaddr\n\n  /**\n   * When connection lifecycle events occurred\n   */\n  timeline: MultiaddrConnectionTimeline\n}\n", "import { symbol } from '@libp2p/interface/connection'\nimport { CodeError } from '@libp2p/interface/errors'\nimport { setMaxListeners } from '@libp2p/interface/events'\nimport type { AbortOptions, Logger, ComponentLogger } from '@libp2p/interface'\nimport type { Direction, Connection, Stream, ConnectionTimeline, ConnectionStatus, NewStreamOptions } from '@libp2p/interface/connection'\nimport type { PeerId } from '@libp2p/interface/peer-id'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nconst CLOSE_TIMEOUT = 500\n\ninterface ConnectionInit {\n  remoteAddr: Multiaddr\n  remotePeer: PeerId\n  newStream(protocols: string[], options?: AbortOptions): Promise<Stream>\n  close(options?: AbortOptions): Promise<void>\n  abort(err: Error): void\n  getStreams(): Stream[]\n  status: ConnectionStatus\n  direction: Direction\n  timeline: ConnectionTimeline\n  multiplexer?: string\n  encryption?: string\n  transient?: boolean\n  logger: ComponentLogger\n}\n\n/**\n * An implementation of the js-libp2p connection.\n * Any libp2p transport should use an upgrader to return this connection.\n */\nexport class ConnectionImpl implements Connection {\n  /**\n   * Connection identifier.\n   */\n  public readonly id: string\n\n  /**\n   * Observed multiaddr of the remote peer\n   */\n  public readonly remoteAddr: Multiaddr\n\n  /**\n   * Remote peer id\n   */\n  public readonly remotePeer: PeerId\n\n  public direction: Direction\n  public timeline: ConnectionTimeline\n  public multiplexer?: string\n  public encryption?: string\n  public status: ConnectionStatus\n  public transient: boolean\n\n  /**\n   * User provided tags\n   *\n   */\n  public tags: string[]\n\n  /**\n   * Reference to the new stream function of the multiplexer\n   */\n  private readonly _newStream: (protocols: string[], options?: NewStreamOptions) => Promise<Stream>\n\n  /**\n   * Reference to the close function of the raw connection\n   */\n  private readonly _close: (options?: AbortOptions) => Promise<void>\n\n  private readonly _abort: (err: Error) => void\n\n  /**\n   * Reference to the getStreams function of the muxer\n   */\n  private readonly _getStreams: () => Stream[]\n\n  readonly #log: Logger\n\n  /**\n   * An implementation of the js-libp2p connection.\n   * Any libp2p transport should use an upgrader to return this connection.\n   */\n  constructor (init: ConnectionInit) {\n    const { remoteAddr, remotePeer, newStream, close, abort, getStreams } = init\n\n    this.id = `${(parseInt(String(Math.random() * 1e9))).toString(36)}${Date.now()}`\n    this.remoteAddr = remoteAddr\n    this.remotePeer = remotePeer\n    this.direction = init.direction\n    this.status = 'open'\n    this.timeline = init.timeline\n    this.multiplexer = init.multiplexer\n    this.encryption = init.encryption\n    this.transient = init.transient ?? false\n    this.#log = init.logger.forComponent('libp2p:connection')\n\n    if (this.remoteAddr.getPeerId() == null) {\n      this.remoteAddr = this.remoteAddr.encapsulate(`/p2p/${this.remotePeer}`)\n    }\n\n    this._newStream = newStream\n    this._close = close\n    this._abort = abort\n    this._getStreams = getStreams\n    this.tags = []\n  }\n\n  readonly [Symbol.toStringTag] = 'Connection'\n\n  readonly [symbol] = true\n\n  /**\n   * Get all the streams of the muxer\n   */\n  get streams (): Stream[] {\n    return this._getStreams()\n  }\n\n  /**\n   * Create a new stream from this connection\n   */\n  async newStream (protocols: string | string[], options?: NewStreamOptions): Promise<Stream> {\n    if (this.status === 'closing') {\n      throw new CodeError('the connection is being closed', 'ERR_CONNECTION_BEING_CLOSED')\n    }\n\n    if (this.status === 'closed') {\n      throw new CodeError('the connection is closed', 'ERR_CONNECTION_CLOSED')\n    }\n\n    if (!Array.isArray(protocols)) {\n      protocols = [protocols]\n    }\n\n    if (this.transient && options?.runOnTransientConnection !== true) {\n      throw new CodeError('Cannot open protocol stream on transient connection', 'ERR_TRANSIENT_CONNECTION')\n    }\n\n    const stream = await this._newStream(protocols, options)\n\n    stream.direction = 'outbound'\n\n    return stream\n  }\n\n  /**\n   * Close the connection\n   */\n  async close (options: AbortOptions = {}): Promise<void> {\n    if (this.status === 'closed' || this.status === 'closing') {\n      return\n    }\n\n    this.#log('closing connection to %a', this.remoteAddr)\n\n    this.status = 'closing'\n\n    if (options.signal == null) {\n      const signal = AbortSignal.timeout(CLOSE_TIMEOUT)\n      setMaxListeners(Infinity, signal)\n\n      options = {\n        ...options,\n        signal\n      }\n    }\n\n    try {\n      this.#log.trace('closing all streams')\n\n      // close all streams gracefully - this can throw if we're not multiplexed\n      await Promise.all(\n        this.streams.map(async s => s.close(options))\n      )\n\n      this.#log.trace('closing underlying transport')\n\n      // close raw connection\n      await this._close(options)\n\n      this.#log.trace('updating timeline with close time')\n\n      this.status = 'closed'\n      this.timeline.close = Date.now()\n    } catch (err: any) {\n      this.#log.error('error encountered during graceful close of connection to %a', this.remoteAddr, err)\n      this.abort(err)\n    }\n  }\n\n  abort (err: Error): void {\n    this.#log.error('aborting connection to %a due to error', this.remoteAddr, err)\n\n    this.status = 'closing'\n    this.streams.forEach(s => { s.abort(err) })\n\n    this.#log.error('all streams aborted', this.streams.length)\n\n    // Abort raw connection\n    this._abort(err)\n\n    this.timeline.close = Date.now()\n    this.status = 'closed'\n  }\n}\n\nexport function createConnection (init: ConnectionInit): Connection {\n  return new ConnectionImpl(init)\n}\n", "import { CodeError } from '@libp2p/interface/errors'\nimport { setMaxListeners } from '@libp2p/interface/events'\nimport * as mss from '@libp2p/multistream-select'\nimport { peerIdFromString } from '@libp2p/peer-id'\nimport { createConnection } from './connection/index.js'\nimport { INBOUND_UPGRADE_TIMEOUT } from './connection-manager/constants.js'\nimport { codes } from './errors.js'\nimport { DEFAULT_MAX_INBOUND_STREAMS, DEFAULT_MAX_OUTBOUND_STREAMS } from './registrar.js'\nimport type { Libp2pEvents, AbortOptions, ComponentLogger, Logger } from '@libp2p/interface'\nimport type { MultiaddrConnection, Connection, Stream, ConnectionProtector, NewStreamOptions } from '@libp2p/interface/connection'\nimport type { ConnectionEncrypter, SecuredConnection } from '@libp2p/interface/connection-encrypter'\nimport type { ConnectionGater } from '@libp2p/interface/connection-gater'\nimport type { TypedEventTarget } from '@libp2p/interface/events'\nimport type { Metrics } from '@libp2p/interface/metrics'\nimport type { PeerId } from '@libp2p/interface/peer-id'\nimport type { PeerStore } from '@libp2p/interface/peer-store'\nimport type { StreamMuxer, StreamMuxerFactory } from '@libp2p/interface/stream-muxer'\nimport type { Upgrader, UpgraderOptions } from '@libp2p/interface/transport'\nimport type { ConnectionManager } from '@libp2p/interface-internal/connection-manager'\nimport type { Registrar } from '@libp2p/interface-internal/registrar'\nimport type { Duplex, Source } from 'it-stream-types'\n\nconst DEFAULT_PROTOCOL_SELECT_TIMEOUT = 30000\n\ninterface CreateConnectionOptions {\n  cryptoProtocol: string\n  direction: 'inbound' | 'outbound'\n  maConn: MultiaddrConnection\n  upgradedConn: Duplex<AsyncGenerator<Uint8Array>, Source<Uint8Array>, Promise<void>>\n  remotePeer: PeerId\n  muxerFactory?: StreamMuxerFactory\n  transient?: boolean\n}\n\ninterface OnStreamOptions {\n  connection: Connection\n  stream: Stream\n  protocol: string\n}\n\nexport interface CryptoResult extends SecuredConnection {\n  protocol: string\n}\n\nexport interface UpgraderInit {\n  connectionEncryption: ConnectionEncrypter[]\n  muxers: StreamMuxerFactory[]\n\n  /**\n   * An amount of ms by which an inbound connection upgrade\n   * must complete\n   */\n  inboundUpgradeTimeout?: number\n}\n\nfunction findIncomingStreamLimit (protocol: string, registrar: Registrar): number | undefined {\n  try {\n    const { options } = registrar.getHandler(protocol)\n\n    return options.maxInboundStreams\n  } catch (err: any) {\n    if (err.code !== codes.ERR_NO_HANDLER_FOR_PROTOCOL) {\n      throw err\n    }\n  }\n\n  return DEFAULT_MAX_INBOUND_STREAMS\n}\n\nfunction findOutgoingStreamLimit (protocol: string, registrar: Registrar, options: NewStreamOptions = {}): number {\n  try {\n    const { options } = registrar.getHandler(protocol)\n\n    if (options.maxOutboundStreams != null) {\n      return options.maxOutboundStreams\n    }\n  } catch (err: any) {\n    if (err.code !== codes.ERR_NO_HANDLER_FOR_PROTOCOL) {\n      throw err\n    }\n  }\n\n  return options.maxOutboundStreams ?? DEFAULT_MAX_OUTBOUND_STREAMS\n}\n\nfunction countStreams (protocol: string, direction: 'inbound' | 'outbound', connection: Connection): number {\n  let streamCount = 0\n\n  connection.streams.forEach(stream => {\n    if (stream.direction === direction && stream.protocol === protocol) {\n      streamCount++\n    }\n  })\n\n  return streamCount\n}\n\nexport interface DefaultUpgraderComponents {\n  peerId: PeerId\n  metrics?: Metrics\n  connectionManager: ConnectionManager\n  connectionGater: ConnectionGater\n  connectionProtector?: ConnectionProtector\n  registrar: Registrar\n  peerStore: PeerStore\n  events: TypedEventTarget<Libp2pEvents>\n  logger: ComponentLogger\n}\n\ntype EncryptedConn = Duplex<AsyncGenerator<Uint8Array, any, unknown>, Source<Uint8Array>, Promise<void>>\n\ntype ConnectionDeniedType = keyof Pick<ConnectionGater, 'denyOutboundConnection' | 'denyInboundEncryptedConnection' | 'denyOutboundEncryptedConnection' | 'denyInboundUpgradedConnection' | 'denyOutboundUpgradedConnection'>\n\nexport class DefaultUpgrader implements Upgrader {\n  private readonly components: DefaultUpgraderComponents\n  private readonly connectionEncryption: Map<string, ConnectionEncrypter>\n  private readonly muxers: Map<string, StreamMuxerFactory>\n  private readonly inboundUpgradeTimeout: number\n  private readonly events: TypedEventTarget<Libp2pEvents>\n  readonly #log: Logger\n\n  constructor (components: DefaultUpgraderComponents, init: UpgraderInit) {\n    this.components = components\n    this.connectionEncryption = new Map()\n    this.#log = components.logger.forComponent('libp2p:upgrader')\n\n    init.connectionEncryption.forEach(encrypter => {\n      this.connectionEncryption.set(encrypter.protocol, encrypter)\n    })\n\n    this.muxers = new Map()\n\n    init.muxers.forEach(muxer => {\n      this.muxers.set(muxer.protocol, muxer)\n    })\n\n    this.inboundUpgradeTimeout = init.inboundUpgradeTimeout ?? INBOUND_UPGRADE_TIMEOUT\n    this.events = components.events\n  }\n\n  async shouldBlockConnection (remotePeer: PeerId, maConn: MultiaddrConnection, connectionType: ConnectionDeniedType): Promise<void> {\n    const connectionGater = this.components.connectionGater[connectionType]\n\n    if (connectionGater !== undefined) {\n      if (await connectionGater(remotePeer, maConn)) {\n        throw new CodeError(`The multiaddr connection is blocked by gater.${connectionType}`, codes.ERR_CONNECTION_INTERCEPTED)\n      }\n    }\n  }\n\n  /**\n   * Upgrades an inbound connection\n   */\n  async upgradeInbound (maConn: MultiaddrConnection, opts?: UpgraderOptions): Promise<Connection> {\n    const accept = await this.components.connectionManager.acceptIncomingConnection(maConn)\n\n    if (!accept) {\n      throw new CodeError('connection denied', codes.ERR_CONNECTION_DENIED)\n    }\n\n    let encryptedConn: EncryptedConn\n    let remotePeer\n    let upgradedConn: Duplex<AsyncGenerator<Uint8Array>, Source<Uint8Array>, Promise<void>>\n    let muxerFactory: StreamMuxerFactory | undefined\n    let cryptoProtocol\n\n    const signal = AbortSignal.timeout(this.inboundUpgradeTimeout)\n\n    const onAbort = (): void => {\n      maConn.abort(new CodeError('inbound upgrade timeout', codes.ERR_TIMEOUT))\n    }\n\n    signal.addEventListener('abort', onAbort, { once: true })\n\n    setMaxListeners(Infinity, signal)\n\n    try {\n      if ((await this.components.connectionGater.denyInboundConnection?.(maConn)) === true) {\n        throw new CodeError('The multiaddr connection is blocked by gater.acceptConnection', codes.ERR_CONNECTION_INTERCEPTED)\n      }\n\n      this.components.metrics?.trackMultiaddrConnection(maConn)\n\n      this.#log('starting the inbound connection upgrade')\n\n      // Protect\n      let protectedConn = maConn\n\n      if (opts?.skipProtection !== true) {\n        const protector = this.components.connectionProtector\n\n        if (protector != null) {\n          this.#log('protecting the inbound connection')\n          protectedConn = await protector.protect(maConn)\n        }\n      }\n\n      try {\n        // Encrypt the connection\n        encryptedConn = protectedConn\n        if (opts?.skipEncryption !== true) {\n          ({\n            conn: encryptedConn,\n            remotePeer,\n            protocol: cryptoProtocol\n          } = await this._encryptInbound(protectedConn))\n\n          const maConn: MultiaddrConnection = {\n            ...protectedConn,\n            ...encryptedConn\n          }\n\n          await this.shouldBlockConnection(remotePeer, maConn, 'denyInboundEncryptedConnection')\n        } else {\n          const idStr = maConn.remoteAddr.getPeerId()\n\n          if (idStr == null) {\n            throw new CodeError('inbound connection that skipped encryption must have a peer id', codes.ERR_INVALID_MULTIADDR)\n          }\n\n          const remotePeerId = peerIdFromString(idStr)\n\n          cryptoProtocol = 'native'\n          remotePeer = remotePeerId\n        }\n\n        upgradedConn = encryptedConn\n        if (opts?.muxerFactory != null) {\n          muxerFactory = opts.muxerFactory\n        } else if (this.muxers.size > 0) {\n          // Multiplex the connection\n          const multiplexed = await this._multiplexInbound({\n            ...protectedConn,\n            ...encryptedConn\n          }, this.muxers)\n          muxerFactory = multiplexed.muxerFactory\n          upgradedConn = multiplexed.stream\n        }\n      } catch (err: any) {\n        this.#log.error('Failed to upgrade inbound connection', err)\n        throw err\n      }\n\n      await this.shouldBlockConnection(remotePeer, maConn, 'denyInboundUpgradedConnection')\n\n      this.#log('Successfully upgraded inbound connection')\n\n      return this._createConnection({\n        cryptoProtocol,\n        direction: 'inbound',\n        maConn,\n        upgradedConn,\n        muxerFactory,\n        remotePeer,\n        transient: opts?.transient\n      })\n    } finally {\n      signal.removeEventListener('abort', onAbort)\n\n      this.components.connectionManager.afterUpgradeInbound()\n    }\n  }\n\n  /**\n   * Upgrades an outbound connection\n   */\n  async upgradeOutbound (maConn: MultiaddrConnection, opts?: UpgraderOptions): Promise<Connection> {\n    const idStr = maConn.remoteAddr.getPeerId()\n    let remotePeerId: PeerId | undefined\n\n    if (idStr != null) {\n      remotePeerId = peerIdFromString(idStr)\n\n      await this.shouldBlockConnection(remotePeerId, maConn, 'denyOutboundConnection')\n    }\n\n    let encryptedConn\n    let remotePeer: PeerId\n    let upgradedConn: Duplex<AsyncGenerator<Uint8Array>, Source<Uint8Array>, Promise<void>>\n    let cryptoProtocol\n    let muxerFactory\n\n    this.components.metrics?.trackMultiaddrConnection(maConn)\n\n    this.#log('Starting the outbound connection upgrade')\n\n    // If the transport natively supports encryption, skip connection\n    // protector and encryption\n\n    // Protect\n    let protectedConn = maConn\n    if (opts?.skipProtection !== true) {\n      const protector = this.components.connectionProtector\n\n      if (protector != null) {\n        protectedConn = await protector.protect(maConn)\n      }\n    }\n\n    try {\n      // Encrypt the connection\n      encryptedConn = protectedConn\n      if (opts?.skipEncryption !== true) {\n        ({\n          conn: encryptedConn,\n          remotePeer,\n          protocol: cryptoProtocol\n        } = await this._encryptOutbound(protectedConn, remotePeerId))\n\n        const maConn: MultiaddrConnection = {\n          ...protectedConn,\n          ...encryptedConn\n        }\n\n        await this.shouldBlockConnection(remotePeer, maConn, 'denyOutboundEncryptedConnection')\n      } else {\n        if (remotePeerId == null) {\n          throw new CodeError('Encryption was skipped but no peer id was passed', codes.ERR_INVALID_PEER)\n        }\n\n        cryptoProtocol = 'native'\n        remotePeer = remotePeerId\n      }\n\n      upgradedConn = encryptedConn\n      if (opts?.muxerFactory != null) {\n        muxerFactory = opts.muxerFactory\n      } else if (this.muxers.size > 0) {\n        // Multiplex the connection\n        const multiplexed = await this._multiplexOutbound({\n          ...protectedConn,\n          ...encryptedConn\n        }, this.muxers)\n        muxerFactory = multiplexed.muxerFactory\n        upgradedConn = multiplexed.stream\n      }\n    } catch (err: any) {\n      this.#log.error('Failed to upgrade outbound connection', err)\n      await maConn.close(err)\n      throw err\n    }\n\n    await this.shouldBlockConnection(remotePeer, maConn, 'denyOutboundUpgradedConnection')\n\n    this.#log('Successfully upgraded outbound connection')\n\n    return this._createConnection({\n      cryptoProtocol,\n      direction: 'outbound',\n      maConn,\n      upgradedConn,\n      muxerFactory,\n      remotePeer,\n      transient: opts?.transient\n    })\n  }\n\n  /**\n   * A convenience method for generating a new `Connection`\n   */\n  _createConnection (opts: CreateConnectionOptions): Connection {\n    const {\n      cryptoProtocol,\n      direction,\n      maConn,\n      upgradedConn,\n      remotePeer,\n      muxerFactory,\n      transient\n    } = opts\n\n    let muxer: StreamMuxer | undefined\n    let newStream: ((multicodecs: string[], options?: AbortOptions) => Promise<Stream>) | undefined\n    let connection: Connection // eslint-disable-line prefer-const\n\n    if (muxerFactory != null) {\n      // Create the muxer\n      muxer = muxerFactory.createStreamMuxer({\n        direction,\n        // Run anytime a remote stream is created\n        onIncomingStream: muxedStream => {\n          if (connection == null) {\n            return\n          }\n\n          void Promise.resolve()\n            .then(async () => {\n              const protocols = this.components.registrar.getProtocols()\n              const { stream, protocol } = await mss.handle(muxedStream, protocols)\n              this.#log('%s: incoming stream opened on %s', direction, protocol)\n\n              if (connection == null) {\n                return\n              }\n\n              const incomingLimit = findIncomingStreamLimit(protocol, this.components.registrar)\n              const streamCount = countStreams(protocol, 'inbound', connection)\n\n              if (streamCount === incomingLimit) {\n                const err = new CodeError(`Too many inbound protocol streams for protocol \"${protocol}\" - limit ${incomingLimit}`, codes.ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS)\n                muxedStream.abort(err)\n\n                throw err\n              }\n\n              // after the handshake the returned stream can have early data so override\n              // the souce/sink\n              muxedStream.source = stream.source\n              muxedStream.sink = stream.sink\n              muxedStream.protocol = protocol\n\n              // If a protocol stream has been successfully negotiated and is to be passed to the application,\n              // the peerstore should ensure that the peer is registered with that protocol\n              await this.components.peerStore.merge(remotePeer, {\n                protocols: [protocol]\n              })\n\n              this.components.metrics?.trackProtocolStream(muxedStream, connection)\n\n              this._onStream({ connection, stream: muxedStream, protocol })\n            })\n            .catch(async err => {\n              this.#log.error(err)\n\n              if (muxedStream.timeline.close == null) {\n                await muxedStream.close()\n              }\n            })\n        }\n      })\n\n      newStream = async (protocols: string[], options: NewStreamOptions = {}): Promise<Stream> => {\n        if (muxer == null) {\n          throw new CodeError('Stream is not multiplexed', codes.ERR_MUXER_UNAVAILABLE)\n        }\n\n        this.#log('%s-%s: starting new stream on %s', connection.id, direction, protocols)\n        const muxedStream = await muxer.newStream()\n\n        try {\n          if (options.signal == null) {\n            this.#log('No abort signal was passed while trying to negotiate protocols %s falling back to default timeout', protocols)\n\n            const signal = AbortSignal.timeout(DEFAULT_PROTOCOL_SELECT_TIMEOUT)\n            setMaxListeners(Infinity, signal)\n\n            options = {\n              ...options,\n              signal\n            }\n          }\n\n          const { stream, protocol } = await mss.select(muxedStream, protocols, options)\n\n          const outgoingLimit = findOutgoingStreamLimit(protocol, this.components.registrar, options)\n          const streamCount = countStreams(protocol, 'outbound', connection)\n\n          if (streamCount >= outgoingLimit) {\n            const err = new CodeError(`Too many outbound protocol streams for protocol \"${protocol}\" - limit ${outgoingLimit}`, codes.ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS)\n            muxedStream.abort(err)\n\n            throw err\n          }\n\n          // If a protocol stream has been successfully negotiated and is to be passed to the application,\n          // the peerstore should ensure that the peer is registered with that protocol\n          await this.components.peerStore.merge(remotePeer, {\n            protocols: [protocol]\n          })\n\n          // after the handshake the returned stream can have early data so override\n          // the souce/sink\n          muxedStream.source = stream.source\n          muxedStream.sink = stream.sink\n          muxedStream.protocol = protocol\n\n          this.components.metrics?.trackProtocolStream(muxedStream, connection)\n\n          return muxedStream\n        } catch (err: any) {\n          this.#log.error('could not create new stream for protocols %s on connection with address %a', protocols, connection.remoteAddr, err)\n\n          if (muxedStream.timeline.close == null) {\n            muxedStream.abort(err)\n          }\n\n          if (err.code != null) {\n            throw err\n          }\n\n          throw new CodeError(String(err), codes.ERR_UNSUPPORTED_PROTOCOL)\n        }\n      }\n\n      // Pipe all data through the muxer\n      void Promise.all([\n        muxer.sink(upgradedConn.source),\n        upgradedConn.sink(muxer.source)\n      ]).catch(err => {\n        this.#log.error(err)\n      })\n    }\n\n    const _timeline = maConn.timeline\n    maConn.timeline = new Proxy(_timeline, {\n      set: (...args) => {\n        if (connection != null && args[1] === 'close' && args[2] != null && _timeline.close == null) {\n          // Wait for close to finish before notifying of the closure\n          (async () => {\n            try {\n              if (connection.status === 'open') {\n                await connection.close()\n              }\n            } catch (err: any) {\n              this.#log.error(err)\n            } finally {\n              this.events.safeDispatchEvent('connection:close', {\n                detail: connection\n              })\n            }\n          })().catch(err => {\n            this.#log.error(err)\n          })\n        }\n\n        return Reflect.set(...args)\n      }\n    })\n    maConn.timeline.upgraded = Date.now()\n\n    const errConnectionNotMultiplexed = (): any => {\n      throw new CodeError('connection is not multiplexed', codes.ERR_CONNECTION_NOT_MULTIPLEXED)\n    }\n\n    // Create the connection\n    connection = createConnection({\n      remoteAddr: maConn.remoteAddr,\n      remotePeer,\n      status: 'open',\n      direction,\n      timeline: maConn.timeline,\n      multiplexer: muxer?.protocol,\n      encryption: cryptoProtocol,\n      transient,\n      logger: this.components.logger,\n      newStream: newStream ?? errConnectionNotMultiplexed,\n      getStreams: () => { if (muxer != null) { return muxer.streams } else { return [] } },\n      close: async (options?: AbortOptions) => {\n        // Ensure remaining streams are closed gracefully\n        if (muxer != null) {\n          this.#log.trace('close muxer')\n          await muxer.close(options)\n        }\n\n        this.#log.trace('close maconn')\n        // close the underlying transport\n        await maConn.close(options)\n        this.#log.trace('closed maconn')\n      },\n      abort: (err) => {\n        maConn.abort(err)\n        // Ensure remaining streams are aborted\n        if (muxer != null) {\n          muxer.abort(err)\n        }\n      }\n    })\n\n    this.events.safeDispatchEvent('connection:open', {\n      detail: connection\n    })\n\n    return connection\n  }\n\n  /**\n   * Routes incoming streams to the correct handler\n   */\n  _onStream (opts: OnStreamOptions): void {\n    const { connection, stream, protocol } = opts\n    const { handler, options } = this.components.registrar.getHandler(protocol)\n\n    if (connection.transient && options.runOnTransientConnection !== true) {\n      throw new CodeError('Cannot open protocol stream on transient connection', 'ERR_TRANSIENT_CONNECTION')\n    }\n\n    handler({ connection, stream })\n  }\n\n  /**\n   * Attempts to encrypt the incoming `connection` with the provided `cryptos`\n   */\n  async _encryptInbound (connection: Duplex<AsyncGenerator<Uint8Array>, Source<Uint8Array>>): Promise<CryptoResult> {\n    const protocols = Array.from(this.connectionEncryption.keys())\n    this.#log('handling inbound crypto protocol selection', protocols)\n\n    try {\n      const { stream, protocol } = await mss.handle(connection, protocols, {\n        writeBytes: true\n      })\n      const encrypter = this.connectionEncryption.get(protocol)\n\n      if (encrypter == null) {\n        throw new Error(`no crypto module found for ${protocol}`)\n      }\n\n      this.#log('encrypting inbound connection...')\n\n      return {\n        ...await encrypter.secureInbound(this.components.peerId, stream),\n        protocol\n      }\n    } catch (err: any) {\n      throw new CodeError(String(err), codes.ERR_ENCRYPTION_FAILED)\n    }\n  }\n\n  /**\n   * Attempts to encrypt the given `connection` with the provided connection encrypters.\n   * The first `ConnectionEncrypter` module to succeed will be used\n   */\n  async _encryptOutbound (connection: MultiaddrConnection, remotePeerId?: PeerId): Promise<CryptoResult> {\n    const protocols = Array.from(this.connectionEncryption.keys())\n    this.#log('selecting outbound crypto protocol', protocols)\n\n    try {\n      const { stream, protocol } = await mss.select(connection, protocols, {\n        writeBytes: true\n      })\n      const encrypter = this.connectionEncryption.get(protocol)\n\n      if (encrypter == null) {\n        throw new Error(`no crypto module found for ${protocol}`)\n      }\n\n      this.#log('encrypting outbound connection to %p', remotePeerId)\n\n      return {\n        ...await encrypter.secureOutbound(this.components.peerId, stream, remotePeerId),\n        protocol\n      }\n    } catch (err: any) {\n      throw new CodeError(String(err), codes.ERR_ENCRYPTION_FAILED)\n    }\n  }\n\n  /**\n   * Selects one of the given muxers via multistream-select. That\n   * muxer will be used for all future streams on the connection.\n   */\n  async _multiplexOutbound (connection: MultiaddrConnection, muxers: Map<string, StreamMuxerFactory>): Promise<{ stream: Duplex<AsyncGenerator<Uint8Array>, Source<Uint8Array>, Promise<void>>, muxerFactory?: StreamMuxerFactory }> {\n    const protocols = Array.from(muxers.keys())\n    this.#log('outbound selecting muxer %s', protocols)\n    try {\n      const { stream, protocol } = await mss.select(connection, protocols, {\n        writeBytes: true\n      })\n      this.#log('%s selected as muxer protocol', protocol)\n      const muxerFactory = muxers.get(protocol)\n\n      return { stream, muxerFactory }\n    } catch (err: any) {\n      this.#log.error('error multiplexing outbound stream', err)\n      throw new CodeError(String(err), codes.ERR_MUXER_UNAVAILABLE)\n    }\n  }\n\n  /**\n   * Registers support for one of the given muxers via multistream-select. The\n   * selected muxer will be used for all future streams on the connection.\n   */\n  async _multiplexInbound (connection: MultiaddrConnection, muxers: Map<string, StreamMuxerFactory>): Promise<{ stream: Duplex<AsyncGenerator<Uint8Array>, Source<Uint8Array>, Promise<void>>, muxerFactory?: StreamMuxerFactory }> {\n    const protocols = Array.from(muxers.keys())\n    this.#log('inbound handling muxers %s', protocols)\n    try {\n      const { stream, protocol } = await mss.handle(connection, protocols, {\n        writeBytes: true\n      })\n      const muxerFactory = muxers.get(protocol)\n\n      return { stream, muxerFactory }\n    } catch (err: any) {\n      this.#log.error('error multiplexing inbound stream', err)\n      throw new CodeError(String(err), codes.ERR_MUXER_UNAVAILABLE)\n    }\n  }\n}\n", "import { unmarshalPublicKey } from '@libp2p/crypto/keys'\nimport { type ContentRouting, contentRouting } from '@libp2p/interface/content-routing'\nimport { CodeError } from '@libp2p/interface/errors'\nimport { TypedEventEmitter, CustomEvent, setMaxListeners } from '@libp2p/interface/events'\nimport { peerDiscovery } from '@libp2p/interface/peer-discovery'\nimport { type PeerRouting, peerRouting } from '@libp2p/interface/peer-routing'\nimport { DefaultKeyChain } from '@libp2p/keychain'\nimport { defaultLogger } from '@libp2p/logger'\nimport { PeerSet } from '@libp2p/peer-collections'\nimport { peerIdFromString } from '@libp2p/peer-id'\nimport { createEd25519PeerId } from '@libp2p/peer-id-factory'\nimport { PersistentPeerStore } from '@libp2p/peer-store'\nimport { isMultiaddr, type Multiaddr } from '@multiformats/multiaddr'\nimport { MemoryDatastore } from 'datastore-core/memory'\nimport mergeOptions from 'merge-options'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { DefaultAddressManager } from './address-manager/index.js'\nimport { defaultComponents } from './components.js'\nimport { connectionGater } from './config/connection-gater.js'\nimport { validateConfig } from './config.js'\nimport { DefaultConnectionManager } from './connection-manager/index.js'\nimport { CompoundContentRouting } from './content-routing/index.js'\nimport { codes } from './errors.js'\nimport { DefaultPeerRouting } from './peer-routing.js'\nimport { DefaultRegistrar } from './registrar.js'\nimport { DefaultTransportManager } from './transport-manager.js'\nimport { DefaultUpgrader } from './upgrader.js'\nimport type { Components } from './components.js'\nimport type { Libp2p, Libp2pInit, Libp2pOptions } from './index.js'\nimport type { Libp2pEvents, PendingDial, ServiceMap, AbortOptions, ComponentLogger, Logger } from '@libp2p/interface'\nimport type { Connection, NewStreamOptions, Stream } from '@libp2p/interface/connection'\nimport type { KeyChain } from '@libp2p/interface/keychain'\nimport type { Metrics } from '@libp2p/interface/metrics'\nimport type { PeerId } from '@libp2p/interface/peer-id'\nimport type { PeerInfo } from '@libp2p/interface/peer-info'\nimport type { PeerStore } from '@libp2p/interface/peer-store'\nimport type { Topology } from '@libp2p/interface/topology'\nimport type { StreamHandler, StreamHandlerOptions } from '@libp2p/interface-internal/registrar'\nimport type { Datastore } from 'interface-datastore'\n\nexport class Libp2pNode<T extends ServiceMap = Record<string, unknown>> extends TypedEventEmitter<Libp2pEvents> implements Libp2p<T> {\n  public peerId: PeerId\n  public peerStore: PeerStore\n  public contentRouting: ContentRouting\n  public peerRouting: PeerRouting\n  public keychain: KeyChain\n  public metrics?: Metrics\n  public services: T\n  public logger: ComponentLogger\n\n  public components: Components\n  #started: boolean\n  readonly #log: Logger\n\n  constructor (init: Libp2pInit<T>) {\n    super()\n\n    // event bus - components can listen to this emitter to be notified of system events\n    // and also cause them to be emitted\n    const events = new TypedEventEmitter<Libp2pEvents>()\n    const originalDispatch = events.dispatchEvent.bind(events)\n    events.dispatchEvent = (evt: any) => {\n      const internalResult = originalDispatch(evt)\n      const externalResult = this.dispatchEvent(\n        new CustomEvent(evt.type, { detail: evt.detail })\n      )\n\n      return internalResult || externalResult\n    }\n\n    // This emitter gets listened to a lot\n    setMaxListeners(Infinity, events)\n\n    this.#started = false\n    this.peerId = init.peerId\n    this.logger = init.logger ?? defaultLogger()\n    this.#log = this.logger.forComponent('libp2p')\n    // @ts-expect-error {} may not be of type T\n    this.services = {}\n    const components = this.components = defaultComponents({\n      peerId: init.peerId,\n      logger: this.logger,\n      events,\n      datastore: init.datastore ?? new MemoryDatastore(),\n      connectionGater: connectionGater(init.connectionGater)\n    })\n\n    this.peerStore = this.configureComponent('peerStore', new PersistentPeerStore(components, {\n      addressFilter: this.components.connectionGater.filterMultiaddrForPeer,\n      ...init.peerStore\n    }))\n\n    // Create Metrics\n    if (init.metrics != null) {\n      this.metrics = this.configureComponent('metrics', init.metrics(this.components))\n    }\n\n    components.events.addEventListener('peer:update', evt => {\n      // if there was no peer previously in the peer store this is a new peer\n      if (evt.detail.previous == null) {\n        const peerInfo: PeerInfo = {\n          id: evt.detail.peer.id,\n          multiaddrs: evt.detail.peer.addresses.map(a => a.multiaddr),\n          protocols: evt.detail.peer.protocols\n        }\n\n        components.events.safeDispatchEvent('peer:discovery', { detail: peerInfo })\n      }\n    })\n\n    // Set up connection protector if configured\n    if (init.connectionProtector != null) {\n      this.configureComponent('connectionProtector', init.connectionProtector(components))\n    }\n\n    // Set up the Upgrader\n    this.components.upgrader = new DefaultUpgrader(this.components, {\n      connectionEncryption: (init.connectionEncryption ?? []).map((fn, index) => this.configureComponent(`connection-encryption-${index}`, fn(this.components))),\n      muxers: (init.streamMuxers ?? []).map((fn, index) => this.configureComponent(`stream-muxers-${index}`, fn(this.components))),\n      inboundUpgradeTimeout: init.connectionManager.inboundUpgradeTimeout\n    })\n\n    // Setup the transport manager\n    this.configureComponent('transportManager', new DefaultTransportManager(this.components, init.transportManager))\n\n    // Create the Connection Manager\n    this.configureComponent('connectionManager', new DefaultConnectionManager(this.components, init.connectionManager))\n\n    // Create the Registrar\n    this.configureComponent('registrar', new DefaultRegistrar(this.components))\n\n    // Addresses {listen, announce, noAnnounce}\n    this.configureComponent('addressManager', new DefaultAddressManager(this.components, init.addresses))\n\n    // Create keychain\n    const keychainOpts = DefaultKeyChain.generateOptions()\n    this.keychain = this.configureComponent('keyChain', new DefaultKeyChain(this.components, {\n      ...keychainOpts,\n      ...init.keychain\n    }))\n\n    // Peer routers\n    const peerRouters: PeerRouting[] = (init.peerRouters ?? []).map((fn, index) => this.configureComponent(`peer-router-${index}`, fn(this.components)))\n    this.peerRouting = this.components.peerRouting = this.configureComponent('peerRouting', new DefaultPeerRouting(this.components, {\n      routers: peerRouters\n    }))\n\n    // Content routers\n    const contentRouters: ContentRouting[] = (init.contentRouters ?? []).map((fn, index) => this.configureComponent(`content-router-${index}`, fn(this.components)))\n    this.contentRouting = this.components.contentRouting = this.configureComponent('contentRouting', new CompoundContentRouting(this.components, {\n      routers: contentRouters\n    }))\n\n    // Discovery modules\n    ;(init.peerDiscovery ?? []).forEach((fn, index) => {\n      const service = this.configureComponent(`peer-discovery-${index}`, fn(this.components))\n\n      service.addEventListener('peer', (evt) => {\n        this.#onDiscoveryPeer(evt)\n      })\n    })\n\n    // Transport modules\n    init.transports.forEach((fn, index) => {\n      this.components.transportManager.add(this.configureComponent(`transport-${index}`, fn(this.components)))\n    })\n\n    // User defined modules\n    if (init.services != null) {\n      for (const name of Object.keys(init.services)) {\n        const createService = init.services[name]\n        const service: any = createService(this.components)\n\n        if (service == null) {\n          this.#log.error('service factory %s returned null or undefined instance', name)\n          continue\n        }\n\n        this.services[name as keyof T] = service\n        this.configureComponent(name, service)\n\n        if (service[contentRouting] != null) {\n          this.#log('registering service %s for content routing', name)\n          contentRouters.push(service[contentRouting])\n        }\n\n        if (service[peerRouting] != null) {\n          this.#log('registering service %s for peer routing', name)\n          peerRouters.push(service[peerRouting])\n        }\n\n        if (service[peerDiscovery] != null) {\n          this.#log('registering service %s for peer discovery', name)\n          service[peerDiscovery].addEventListener('peer', (evt: CustomEvent<PeerInfo>) => {\n            this.#onDiscoveryPeer(evt)\n          })\n        }\n      }\n    }\n  }\n\n  private configureComponent <T> (name: string, component: T): T {\n    if (component == null) {\n      this.#log.error('component %s was null or undefined', name)\n    }\n\n    this.components[name] = component\n\n    return component\n  }\n\n  /**\n   * Starts the libp2p node and all its subsystems\n   */\n  async start (): Promise<void> {\n    if (this.#started) {\n      return\n    }\n\n    this.#started = true\n\n    this.#log('libp2p is starting')\n\n    const keys = await this.keychain.listKeys()\n\n    if (keys.find(key => key.name === 'self') == null) {\n      this.#log('importing self key into keychain')\n      await this.keychain.importPeer('self', this.components.peerId)\n    }\n\n    try {\n      await this.components.beforeStart?.()\n      await this.components.start()\n      await this.components.afterStart?.()\n\n      this.safeDispatchEvent('start', { detail: this })\n      this.#log('libp2p has started')\n    } catch (err: any) {\n      this.#log.error('An error occurred starting libp2p', err)\n      await this.stop()\n      throw err\n    }\n  }\n\n  /**\n   * Stop the libp2p node by closing its listeners and open connections\n   */\n  async stop (): Promise<void> {\n    if (!this.#started) {\n      return\n    }\n\n    this.#log('libp2p is stopping')\n\n    this.#started = false\n\n    await this.components.beforeStop?.()\n    await this.components.stop()\n    await this.components.afterStop?.()\n\n    this.safeDispatchEvent('stop', { detail: this })\n    this.#log('libp2p has stopped')\n  }\n\n  isStarted (): boolean {\n    return this.#started\n  }\n\n  getConnections (peerId?: PeerId): Connection[] {\n    return this.components.connectionManager.getConnections(peerId)\n  }\n\n  getDialQueue (): PendingDial[] {\n    return this.components.connectionManager.getDialQueue()\n  }\n\n  getPeers (): PeerId[] {\n    const peerSet = new PeerSet()\n\n    for (const conn of this.components.connectionManager.getConnections()) {\n      peerSet.add(conn.remotePeer)\n    }\n\n    return Array.from(peerSet)\n  }\n\n  async dial (peer: PeerId | Multiaddr | Multiaddr[], options: AbortOptions = {}): Promise<Connection> {\n    return this.components.connectionManager.openConnection(peer, options)\n  }\n\n  async dialProtocol (peer: PeerId | Multiaddr | Multiaddr[], protocols: string | string[], options: NewStreamOptions = {}): Promise<Stream> {\n    if (protocols == null) {\n      throw new CodeError('no protocols were provided to open a stream', codes.ERR_INVALID_PROTOCOLS_FOR_STREAM)\n    }\n\n    protocols = Array.isArray(protocols) ? protocols : [protocols]\n\n    if (protocols.length === 0) {\n      throw new CodeError('no protocols were provided to open a stream', codes.ERR_INVALID_PROTOCOLS_FOR_STREAM)\n    }\n\n    const connection = await this.dial(peer, options)\n\n    return connection.newStream(protocols, options)\n  }\n\n  getMultiaddrs (): Multiaddr[] {\n    return this.components.addressManager.getAddresses()\n  }\n\n  getProtocols (): string[] {\n    return this.components.registrar.getProtocols()\n  }\n\n  async hangUp (peer: PeerId | Multiaddr, options: AbortOptions = {}): Promise<void> {\n    if (isMultiaddr(peer)) {\n      peer = peerIdFromString(peer.getPeerId() ?? '')\n    }\n\n    await this.components.connectionManager.closeConnections(peer, options)\n  }\n\n  /**\n   * Get the public key for the given peer id\n   */\n  async getPublicKey (peer: PeerId, options: AbortOptions = {}): Promise<Uint8Array> {\n    this.#log('getPublicKey %p', peer)\n\n    if (peer.publicKey != null) {\n      return peer.publicKey\n    }\n\n    const peerInfo = await this.peerStore.get(peer)\n\n    if (peerInfo.id.publicKey != null) {\n      return peerInfo.id.publicKey\n    }\n\n    const peerKey = uint8ArrayConcat([\n      uint8ArrayFromString('/pk/'),\n      peer.multihash.digest\n    ])\n\n    // search any available content routing methods\n    const bytes = await this.contentRouting.get(peerKey, options)\n    // ensure the returned key is valid\n    unmarshalPublicKey(bytes)\n\n    await this.peerStore.patch(peer, {\n      publicKey: bytes\n    })\n\n    return bytes\n  }\n\n  async handle (protocols: string | string[], handler: StreamHandler, options?: StreamHandlerOptions): Promise<void> {\n    if (!Array.isArray(protocols)) {\n      protocols = [protocols]\n    }\n\n    await Promise.all(\n      protocols.map(async protocol => {\n        await this.components.registrar.handle(protocol, handler, options)\n      })\n    )\n  }\n\n  async unhandle (protocols: string[] | string): Promise<void> {\n    if (!Array.isArray(protocols)) {\n      protocols = [protocols]\n    }\n\n    await Promise.all(\n      protocols.map(async protocol => {\n        await this.components.registrar.unhandle(protocol)\n      })\n    )\n  }\n\n  async register (protocol: string, topology: Topology): Promise<string> {\n    return this.components.registrar.register(protocol, topology)\n  }\n\n  unregister (id: string): void {\n    this.components.registrar.unregister(id)\n  }\n\n  /**\n   * Called whenever peer discovery services emit `peer` events and adds peers\n   * to the peer store.\n   */\n  #onDiscoveryPeer (evt: CustomEvent<PeerInfo>): void {\n    const { detail: peer } = evt\n\n    if (peer.id.toString() === this.peerId.toString()) {\n      this.#log.error(new Error(codes.ERR_DISCOVERED_SELF))\n      return\n    }\n\n    void this.components.peerStore.merge(peer.id, {\n      multiaddrs: peer.multiaddrs,\n      protocols: peer.protocols\n    })\n      .catch(err => { this.#log.error(err) })\n  }\n}\n\n/**\n * Returns a new Libp2pNode instance - this exposes more of the internals than the\n * libp2p interface and is useful for testing and debugging.\n */\nexport async function createLibp2pNode <T extends ServiceMap = Record<string, unknown>> (options: Libp2pOptions<T>): Promise<Libp2pNode<T>> {\n  if (options.peerId == null) {\n    const datastore = options.datastore as Datastore | undefined\n\n    if (datastore != null) {\n      try {\n        // try load the peer id from the keychain\n        const keyChain = new DefaultKeyChain({\n          datastore\n        }, mergeOptions(DefaultKeyChain.generateOptions(), options.keychain))\n\n        options.peerId = await keyChain.exportPeerId('self')\n      } catch (err: any) {\n        if (err.code !== 'ERR_NOT_FOUND') {\n          throw err\n        }\n      }\n    }\n  }\n\n  if (options.peerId == null) {\n    // no peer id in the keychain, create a new peer id\n    options.peerId = await createEd25519PeerId()\n  }\n\n  return new Libp2pNode(validateConfig(options))\n}\n", "/**\n * @packageDocumentation\n *\n * Use the `createLibp2p` function to create a libp2p node.\n *\n * @example\n *\n * ```typescript\n * import { createLibp2p } from 'libp2p'\n *\n * const node = await createLibp2p({\n *   // ...other options\n * })\n * ```\n */\n\nimport { createLibp2pNode } from './libp2p.js'\nimport type { AddressManagerInit } from './address-manager/index.js'\nimport type { Components } from './components.js'\nimport type { ConnectionManagerInit } from './connection-manager/index.js'\nimport type { TransportManagerInit } from './transport-manager.js'\nimport type { Libp2p, ServiceMap, RecursivePartial, ComponentLogger } from '@libp2p/interface'\nimport type { ConnectionProtector } from '@libp2p/interface/connection'\nimport type { ConnectionEncrypter } from '@libp2p/interface/connection-encrypter'\nimport type { ConnectionGater } from '@libp2p/interface/connection-gater'\nimport type { ContentRouting } from '@libp2p/interface/content-routing'\nimport type { Metrics } from '@libp2p/interface/metrics'\nimport type { PeerDiscovery } from '@libp2p/interface/peer-discovery'\nimport type { PeerId } from '@libp2p/interface/peer-id'\nimport type { PeerRouting } from '@libp2p/interface/peer-routing'\nimport type { StreamMuxerFactory } from '@libp2p/interface/stream-muxer'\nimport type { Transport } from '@libp2p/interface/transport'\nimport type { KeyChainInit } from '@libp2p/keychain'\nimport type { PersistentPeerStoreInit } from '@libp2p/peer-store'\nimport type { Datastore } from 'interface-datastore'\n\nexport type ServiceFactoryMap<T extends Record<string, unknown> = Record<string, unknown>> = {\n  [Property in keyof T]: (components: Components) => T[Property]\n}\n\n/**\n * For Libp2p configurations and modules details read the [Configuration Document](./CONFIGURATION.md).\n */\nexport interface Libp2pInit<T extends ServiceMap = { x: Record<string, unknown> }> {\n  /**\n   * peerId instance (it will be created if not provided)\n   */\n  peerId: PeerId\n\n  /**\n   * Addresses for transport listening and to advertise to the network\n   */\n  addresses: AddressManagerInit\n\n  /**\n   * libp2p Connection Manager configuration\n   */\n  connectionManager: ConnectionManagerInit\n\n  /**\n   * A connection gater can deny new connections based on user criteria\n   */\n  connectionGater: ConnectionGater\n\n  /**\n   * libp2p transport manager configuration\n   */\n  transportManager: TransportManagerInit\n\n  /**\n   * An optional datastore to persist peer information, DHT records, etc.\n   *\n   * An in-memory datastore will be used if one is not provided.\n   */\n  datastore: Datastore\n\n  /**\n   * libp2p PeerStore configuration\n   */\n  peerStore: PersistentPeerStoreInit\n\n  /**\n   * keychain configuration\n   */\n  keychain: KeyChainInit\n\n  /**\n   * An array that must include at least 1 compliant transport\n   */\n  transports: Array<(components: Components) => Transport>\n  streamMuxers?: Array<(components: Components) => StreamMuxerFactory>\n  connectionEncryption?: Array<(components: Components) => ConnectionEncrypter>\n  peerDiscovery?: Array<(components: Components) => PeerDiscovery>\n  peerRouters?: Array<(components: Components) => PeerRouting>\n  contentRouters?: Array<(components: Components) => ContentRouting>\n\n  /**\n   * A Metrics implementation can be supplied to collect metrics on this node\n   */\n  metrics?(components: Components): Metrics\n\n  /**\n   * A ConnectionProtector can be used to create a secure overlay on top of the network using pre-shared keys\n   */\n  connectionProtector?(components: Components): ConnectionProtector\n\n  /**\n   * Arbitrary libp2p modules\n   */\n  services: ServiceFactoryMap<T>\n\n  /**\n   * An optional logging implementation that can be used to write runtime logs.\n   *\n   * Set the `DEBUG` env var or the `debug` key on LocalStorage to see logs.\n   *\n   * @example\n   *\n   * Node.js:\n   *\n   * ```console\n   * $ DEBUG=\"*libp2p:*\" node myscript.js\n   * ```\n   *\n   * Browsers:\n   *\n   * ```javascript\n   * localStorage.setItem('debug', '*libp2p:*')\n   * ```\n   */\n  logger?: ComponentLogger\n}\n\nexport type { Libp2p }\n\nexport type Libp2pOptions<T extends ServiceMap = Record<string, unknown>> = RecursivePartial<Libp2pInit<T>> & { start?: boolean }\n\n/**\n * Returns a new instance of the Libp2p interface, generating a new PeerId\n * if one is not passed as part of the options.\n *\n * The node will be started unless `start: false` is passed as an option.\n *\n * @example\n *\n * ```js\n * import { createLibp2p } from 'libp2p'\n * import { tcp } from '@libp2p/tcp'\n * import { mplex } from '@libp2p/mplex'\n * import { noise } from '@chainsafe/libp2p-noise'\n * import { yamux } from '@chainsafe/libp2p-yamux'\n *\n * // specify options\n * const options = {\n *   transports: [tcp()],\n *   streamMuxers: [yamux(), mplex()],\n *   connectionEncryption: [noise()]\n * }\n *\n * // create libp2p\n * const libp2p = await createLibp2p(options)\n * ```\n */\nexport async function createLibp2p <T extends ServiceMap = { x: Record<string, unknown> }> (options: Libp2pOptions<T>): Promise<Libp2p<T>> {\n  const node = await createLibp2pNode(options)\n\n  if (options.start !== false) {\n    await node.start()\n  }\n\n  return node\n}\n", "export const version = '0.46.21'\nexport const name = 'libp2p'\n", "import { version } from '../version.js'\n\nexport const PROTOCOL_VERSION = 'ipfs/0.1.0' // deprecated\nexport const AGENT_VERSION = `js-libp2p/${version}`\nexport const MULTICODEC_IDENTIFY = '/ipfs/id/1.0.0' // deprecated\nexport const MULTICODEC_IDENTIFY_PUSH = '/ipfs/id/push/1.0.0' // deprecated\n\nexport const IDENTIFY_PROTOCOL_VERSION = '0.1.0'\nexport const MULTICODEC_IDENTIFY_PROTOCOL_NAME = 'id'\nexport const MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME = 'id/push'\nexport const MULTICODEC_IDENTIFY_PROTOCOL_VERSION = '1.0.0'\nexport const MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION = '1.0.0'\n", "/**\n * @packageDocumentation\n *\n * This module makes it easy to send and receive length-prefixed Protobuf encoded\n * messages over streams.\n *\n * @example\n *\n * ```typescript\n * import { pbStream } from 'it-protobuf-stream'\n * import { MessageType } from './src/my-message-type.js'\n *\n * // RequestType and ResponseType have been generate from `.proto` files and have\n * // `.encode` and `.decode` methods for serialization/deserialization\n *\n * const stream = pbStream(duplex)\n *\n * // write a message to the stream\n * stream.write({\n *   foo: 'bar'\n * }, MessageType)\n *\n * // read a message from the stream\n * const res = await stream.read(MessageType)\n * ```\n */\n\nimport { lpStream } from 'it-length-prefixed-stream'\nimport type { LengthPrefixedStreamOpts } from 'it-length-prefixed-stream'\nimport type { Duplex } from 'it-stream-types'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface AbortOptions {\n  signal?: AbortSignal\n}\n\n/**\n * A protobuf decoder - takes a byte array and returns an object\n */\nexport interface Decoder<T> {\n  (data: Uint8Array | Uint8ArrayList): T\n}\n\n/**\n * A protobuf encoder - takes an object and returns a byte array\n */\nexport interface Encoder<T> {\n  (data: T): Uint8Array\n}\n\n/**\n * Convenience methods for working with protobuf streams\n */\nexport interface ProtobufStream <Stream = unknown> {\n  /**\n   * Read the next length-prefixed byte array from the stream and decode it as the passed protobuf format\n   */\n  read<T>(proto: { decode: Decoder<T> }, options?: AbortOptions): Promise<T>\n\n  /**\n   * Encode the passed object as a protobuf message and write it's length-prefixed bytes to the stream\n   */\n  write<T>(data: T, proto: { encode: Encoder<T> }, options?: AbortOptions): Promise<void>\n\n  /**\n   * Encode the passed objects as protobuf messages and write their length-prefixed bytes to the stream as a single write\n   */\n  writeV<T>(input: T[], proto: { encode: Encoder<T> }, options?: AbortOptions): Promise<void>\n\n  /**\n   * Returns an object with read/write methods for operating on one specific type of protobuf message\n   */\n  pb<T>(proto: { encode: Encoder<T>, decode: Decoder<T> }): MessageStream<T, Stream>\n\n  /**\n   * Returns the underlying stream\n   */\n  unwrap(): Stream\n}\n\n/**\n * A message reader/writer that only uses one type of message\n */\nexport interface MessageStream <T, S = unknown> {\n  /**\n   * Read a message from the stream\n   */\n  read(options?: AbortOptions): Promise<T>\n\n  /**\n   * Write a message to the stream\n   */\n  write(d: T, options?: AbortOptions): Promise<void>\n\n  /**\n   * Write several messages to the stream\n   */\n  writeV(d: T[], options?: AbortOptions): Promise<void>\n\n  /**\n   * Unwrap the underlying protobuf stream\n   */\n  unwrap(): ProtobufStream<S>\n}\n\nexport interface ProtobufStreamOpts extends LengthPrefixedStreamOpts {\n\n}\n\nexport function pbStream <Stream extends Duplex<any, any, any>> (duplex: Stream, opts?: Partial<ProtobufStreamOpts>): ProtobufStream<Stream> {\n  const lp = lpStream(duplex, opts)\n\n  const W: ProtobufStream<Stream> = {\n    read: async (proto, options?: AbortOptions) => {\n      // readLP, decode\n      const value = await lp.read(options)\n\n      return proto.decode(value)\n    },\n    write: async (message, proto, options?: AbortOptions) => {\n      // encode, writeLP\n      await lp.write(proto.encode(message), options)\n    },\n    writeV: async (messages, proto, options?: AbortOptions) => {\n      // encode, writeLP\n      await lp.writeV(messages.map(message => proto.encode(message)), options)\n    },\n    pb: (proto) => {\n      return {\n        read: async (options) => W.read(proto, options),\n        write: async (d, options) => W.write(d, proto, options),\n        writeV: async (d, options) => W.writeV(d, proto, options),\n        unwrap: () => W\n      }\n    },\n    unwrap: () => {\n      return lp.unwrap()\n    }\n  }\n\n  return W\n}\n", "/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nimport { encodeMessage, decodeMessage, message } from 'protons-runtime'\nimport type { Codec } from 'protons-runtime'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface Identify {\n  protocolVersion?: string\n  agentVersion?: string\n  publicKey?: Uint8Array\n  listenAddrs: Uint8Array[]\n  observedAddr?: Uint8Array\n  protocols: string[]\n  signedPeerRecord?: Uint8Array\n}\n\nexport namespace Identify {\n  let _codec: Codec<Identify>\n\n  export const codec = (): Codec<Identify> => {\n    if (_codec == null) {\n      _codec = message<Identify>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.protocolVersion != null) {\n          w.uint32(42)\n          w.string(obj.protocolVersion)\n        }\n\n        if (obj.agentVersion != null) {\n          w.uint32(50)\n          w.string(obj.agentVersion)\n        }\n\n        if (obj.publicKey != null) {\n          w.uint32(10)\n          w.bytes(obj.publicKey)\n        }\n\n        if (obj.listenAddrs != null) {\n          for (const value of obj.listenAddrs) {\n            w.uint32(18)\n            w.bytes(value)\n          }\n        }\n\n        if (obj.observedAddr != null) {\n          w.uint32(34)\n          w.bytes(obj.observedAddr)\n        }\n\n        if (obj.protocols != null) {\n          for (const value of obj.protocols) {\n            w.uint32(26)\n            w.string(value)\n          }\n        }\n\n        if (obj.signedPeerRecord != null) {\n          w.uint32(66)\n          w.bytes(obj.signedPeerRecord)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {\n          listenAddrs: [],\n          protocols: []\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 5:\n              obj.protocolVersion = reader.string()\n              break\n            case 6:\n              obj.agentVersion = reader.string()\n              break\n            case 1:\n              obj.publicKey = reader.bytes()\n              break\n            case 2:\n              obj.listenAddrs.push(reader.bytes())\n              break\n            case 4:\n              obj.observedAddr = reader.bytes()\n              break\n            case 3:\n              obj.protocols.push(reader.string())\n              break\n            case 8:\n              obj.signedPeerRecord = reader.bytes()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Identify>): Uint8Array => {\n    return encodeMessage(obj, Identify.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): Identify => {\n    return decodeMessage(buf, Identify.codec())\n  }\n}\n", "import { CodeError } from '@libp2p/interface/errors'\nimport { setMaxListeners } from '@libp2p/interface/events'\nimport { peerIdFromKeys } from '@libp2p/peer-id'\nimport { RecordEnvelope, PeerRecord } from '@libp2p/peer-record'\nimport { type Multiaddr, multiaddr, protocols } from '@multiformats/multiaddr'\nimport { IP_OR_DOMAIN } from '@multiformats/multiaddr-matcher'\nimport { pbStream } from 'it-protobuf-stream'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { isNode, isBrowser, isWebWorker, isElectronMain, isElectronRenderer, isReactNative } from 'wherearewe'\nimport { codes } from '../errors.js'\nimport {\n  AGENT_VERSION,\n  IDENTIFY_PROTOCOL_VERSION,\n  MULTICODEC_IDENTIFY_PROTOCOL_NAME,\n  MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME,\n  MULTICODEC_IDENTIFY_PROTOCOL_VERSION,\n  MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION\n} from './consts.js'\nimport { Identify } from './pb/message.js'\nimport type { IdentifyService, IdentifyServiceComponents, IdentifyServiceInit } from './index.js'\nimport type { Libp2pEvents, IdentifyResult, SignedPeerRecord, AbortOptions, Logger } from '@libp2p/interface'\nimport type { Connection, Stream } from '@libp2p/interface/connection'\nimport type { TypedEventTarget } from '@libp2p/interface/events'\nimport type { PeerId } from '@libp2p/interface/peer-id'\nimport type { Peer, PeerData, PeerStore } from '@libp2p/interface/peer-store'\nimport type { Startable } from '@libp2p/interface/startable'\nimport type { AddressManager } from '@libp2p/interface-internal/address-manager'\nimport type { ConnectionManager } from '@libp2p/interface-internal/connection-manager'\nimport type { IncomingStreamData, Registrar } from '@libp2p/interface-internal/registrar'\n\n// https://github.com/libp2p/go-libp2p/blob/8d2e54e1637041d5cf4fac1e531287560bd1f4ac/p2p/protocol/identify/id.go#L52\nconst MAX_IDENTIFY_MESSAGE_SIZE = 1024 * 8\n\nconst defaultValues = {\n  protocolPrefix: 'ipfs',\n  agentVersion: AGENT_VERSION,\n  // https://github.com/libp2p/go-libp2p/blob/8d2e54e1637041d5cf4fac1e531287560bd1f4ac/p2p/protocol/identify/id.go#L48\n  timeout: 60000,\n  maxInboundStreams: 1,\n  maxOutboundStreams: 1,\n  maxPushIncomingStreams: 1,\n  maxPushOutgoingStreams: 1,\n  maxObservedAddresses: 10,\n  maxIdentifyMessageSize: 8192,\n  runOnConnectionOpen: true,\n  runOnTransientConnection: true\n}\n\nexport class DefaultIdentifyService implements Startable, IdentifyService {\n  private readonly identifyProtocolStr: string\n  private readonly identifyPushProtocolStr: string\n  public readonly host: {\n    protocolVersion: string\n    agentVersion: string\n  }\n\n  private started: boolean\n  private readonly timeout: number\n  private readonly peerId: PeerId\n  private readonly peerStore: PeerStore\n  private readonly registrar: Registrar\n  private readonly connectionManager: ConnectionManager\n  private readonly addressManager: AddressManager\n  private readonly maxInboundStreams: number\n  private readonly maxOutboundStreams: number\n  private readonly maxPushIncomingStreams: number\n  private readonly maxPushOutgoingStreams: number\n  private readonly maxIdentifyMessageSize: number\n  private readonly maxObservedAddresses: number\n  private readonly events: TypedEventTarget<Libp2pEvents>\n  private readonly runOnTransientConnection: boolean\n  readonly #log: Logger\n\n  constructor (components: IdentifyServiceComponents, init: IdentifyServiceInit) {\n    this.started = false\n    this.peerId = components.peerId\n    this.peerStore = components.peerStore\n    this.registrar = components.registrar\n    this.addressManager = components.addressManager\n    this.connectionManager = components.connectionManager\n    this.events = components.events\n    this.#log = components.logger.forComponent('libp2p:identify')\n\n    this.identifyProtocolStr = `/${init.protocolPrefix ?? defaultValues.protocolPrefix}/${MULTICODEC_IDENTIFY_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PROTOCOL_VERSION}`\n    this.identifyPushProtocolStr = `/${init.protocolPrefix ?? defaultValues.protocolPrefix}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION}`\n    this.timeout = init.timeout ?? defaultValues.timeout\n    this.maxInboundStreams = init.maxInboundStreams ?? defaultValues.maxInboundStreams\n    this.maxOutboundStreams = init.maxOutboundStreams ?? defaultValues.maxOutboundStreams\n    this.maxPushIncomingStreams = init.maxPushIncomingStreams ?? defaultValues.maxPushIncomingStreams\n    this.maxPushOutgoingStreams = init.maxPushOutgoingStreams ?? defaultValues.maxPushOutgoingStreams\n    this.maxIdentifyMessageSize = init.maxIdentifyMessageSize ?? defaultValues.maxIdentifyMessageSize\n    this.maxObservedAddresses = init.maxObservedAddresses ?? defaultValues.maxObservedAddresses\n    this.runOnTransientConnection = init.runOnTransientConnection ?? defaultValues.runOnTransientConnection\n\n    // Store self host metadata\n    this.host = {\n      protocolVersion: `${init.protocolPrefix ?? defaultValues.protocolPrefix}/${IDENTIFY_PROTOCOL_VERSION}`,\n      agentVersion: init.agentVersion ?? defaultValues.agentVersion\n    }\n\n    if (init.runOnConnectionOpen ?? defaultValues.runOnConnectionOpen) {\n      // When a new connection happens, trigger identify\n      components.events.addEventListener('connection:open', (evt) => {\n        const connection = evt.detail\n        this.identify(connection).catch(err => { this.#log.error('error during identify trigged by connection:open', err) })\n      })\n    }\n\n    // When self peer record changes, trigger identify-push\n    components.events.addEventListener('self:peer:update', (evt) => {\n      void this.push().catch(err => { this.#log.error(err) })\n    })\n\n    // Append user agent version to default AGENT_VERSION depending on the environment\n    if (this.host.agentVersion === AGENT_VERSION) {\n      if (isNode || isElectronMain) {\n        this.host.agentVersion += ` UserAgent=${globalThis.process.version}`\n      } else if (isBrowser || isWebWorker || isElectronRenderer || isReactNative) {\n        this.host.agentVersion += ` UserAgent=${globalThis.navigator.userAgent}`\n      }\n    }\n  }\n\n  isStarted (): boolean {\n    return this.started\n  }\n\n  async start (): Promise<void> {\n    if (this.started) {\n      return\n    }\n\n    await this.peerStore.merge(this.peerId, {\n      metadata: {\n        AgentVersion: uint8ArrayFromString(this.host.agentVersion),\n        ProtocolVersion: uint8ArrayFromString(this.host.protocolVersion)\n      }\n    })\n\n    await this.registrar.handle(this.identifyProtocolStr, (data) => {\n      void this._handleIdentify(data).catch(err => {\n        this.#log.error(err)\n      })\n    }, {\n      maxInboundStreams: this.maxInboundStreams,\n      maxOutboundStreams: this.maxOutboundStreams,\n      runOnTransientConnection: this.runOnTransientConnection\n    })\n    await this.registrar.handle(this.identifyPushProtocolStr, (data) => {\n      void this._handlePush(data).catch(err => {\n        this.#log.error(err)\n      })\n    }, {\n      maxInboundStreams: this.maxPushIncomingStreams,\n      maxOutboundStreams: this.maxPushOutgoingStreams,\n      runOnTransientConnection: this.runOnTransientConnection\n    })\n\n    this.started = true\n  }\n\n  async stop (): Promise<void> {\n    await this.registrar.unhandle(this.identifyProtocolStr)\n    await this.registrar.unhandle(this.identifyPushProtocolStr)\n\n    this.started = false\n  }\n\n  /**\n   * Send an Identify Push update to the list of connections\n   */\n  async pushToConnections (connections: Connection[]): Promise<void> {\n    const listenAddresses = this.addressManager.getAddresses().map(ma => ma.decapsulateCode(protocols('p2p').code))\n    const peerRecord = new PeerRecord({\n      peerId: this.peerId,\n      multiaddrs: listenAddresses\n    })\n    const signedPeerRecord = await RecordEnvelope.seal(peerRecord, this.peerId)\n    const supportedProtocols = this.registrar.getProtocols()\n    const peer = await this.peerStore.get(this.peerId)\n    const agentVersion = uint8ArrayToString(peer.metadata.get('AgentVersion') ?? uint8ArrayFromString(this.host.agentVersion))\n    const protocolVersion = uint8ArrayToString(peer.metadata.get('ProtocolVersion') ?? uint8ArrayFromString(this.host.protocolVersion))\n\n    const pushes = connections.map(async connection => {\n      let stream: Stream | undefined\n\n      const signal = AbortSignal.timeout(this.timeout)\n\n      setMaxListeners(Infinity, signal)\n\n      try {\n        stream = await connection.newStream([this.identifyPushProtocolStr], {\n          signal,\n          runOnTransientConnection: this.runOnTransientConnection\n        })\n\n        const pb = pbStream(stream, {\n          maxDataLength: this.maxIdentifyMessageSize ?? MAX_IDENTIFY_MESSAGE_SIZE\n        }).pb(Identify)\n\n        await pb.write({\n          listenAddrs: listenAddresses.map(ma => ma.bytes),\n          signedPeerRecord: signedPeerRecord.marshal(),\n          protocols: supportedProtocols,\n          agentVersion,\n          protocolVersion\n        }, {\n          signal\n        })\n\n        await stream.close({\n          signal\n        })\n      } catch (err: any) {\n        // Just log errors\n        this.#log.error('could not push identify update to peer', err)\n        stream?.abort(err)\n      }\n    })\n\n    await Promise.all(pushes)\n  }\n\n  /**\n   * Calls `push` on all peer connections\n   */\n  async push (): Promise<void> {\n    // Do not try to push if we are not running\n    if (!this.isStarted()) {\n      return\n    }\n\n    const connections: Connection[] = []\n\n    await Promise.all(\n      this.connectionManager.getConnections().map(async conn => {\n        try {\n          const peer = await this.peerStore.get(conn.remotePeer)\n\n          if (!peer.protocols.includes(this.identifyPushProtocolStr)) {\n            return\n          }\n\n          connections.push(conn)\n        } catch (err: any) {\n          if (err.code !== codes.ERR_NOT_FOUND) {\n            throw err\n          }\n        }\n      })\n    )\n\n    await this.pushToConnections(connections)\n  }\n\n  async _identify (connection: Connection, options: AbortOptions = {}): Promise<Identify> {\n    let stream: Stream | undefined\n\n    if (options.signal == null) {\n      const signal = AbortSignal.timeout(this.timeout)\n      setMaxListeners(Infinity, signal)\n\n      options = {\n        ...options,\n        signal\n      }\n    }\n\n    try {\n      stream = await connection.newStream([this.identifyProtocolStr], {\n        ...options,\n        runOnTransientConnection: this.runOnTransientConnection\n      })\n\n      const pb = pbStream(stream, {\n        maxDataLength: this.maxIdentifyMessageSize ?? MAX_IDENTIFY_MESSAGE_SIZE\n      }).pb(Identify)\n\n      const message = await pb.read(options)\n\n      await stream.close(options)\n\n      return message\n    } catch (err: any) {\n      this.#log.error('error while reading identify message', err)\n      stream?.abort(err)\n      throw err\n    }\n  }\n\n  async identify (connection: Connection, options: AbortOptions = {}): Promise<IdentifyResult> {\n    const message = await this._identify(connection, options)\n    const {\n      publicKey,\n      protocols,\n      observedAddr\n    } = message\n\n    if (publicKey == null) {\n      throw new CodeError('public key was missing from identify message', codes.ERR_MISSING_PUBLIC_KEY)\n    }\n\n    const id = await peerIdFromKeys(publicKey)\n\n    if (!connection.remotePeer.equals(id)) {\n      throw new CodeError('identified peer does not match the expected peer', codes.ERR_INVALID_PEER)\n    }\n\n    if (this.peerId.equals(id)) {\n      throw new CodeError('identified peer is our own peer id?', codes.ERR_INVALID_PEER)\n    }\n\n    // Get the observedAddr if there is one\n    const cleanObservedAddr = getCleanMultiaddr(observedAddr)\n\n    this.#log('identify completed for peer %p and protocols %o', id, protocols)\n    this.#log('our observed address is %a', cleanObservedAddr)\n\n    if (cleanObservedAddr != null &&\n        this.addressManager.getObservedAddrs().length < (this.maxObservedAddresses ?? Infinity)) {\n      this.#log('storing our observed address %a', cleanObservedAddr)\n      this.addressManager.addObservedAddr(cleanObservedAddr)\n    }\n\n    return this.#consumeIdentifyMessage(connection, message)\n  }\n\n  /**\n   * Sends the `Identify` response with the Signed Peer Record\n   * to the requesting peer over the given `connection`\n   */\n  async _handleIdentify (data: IncomingStreamData): Promise<void> {\n    const { connection, stream } = data\n\n    const signal = AbortSignal.timeout(this.timeout)\n\n    setMaxListeners(Infinity, signal)\n\n    try {\n      const publicKey = this.peerId.publicKey ?? new Uint8Array(0)\n      const peerData = await this.peerStore.get(this.peerId)\n      const multiaddrs = this.addressManager.getAddresses().map(ma => ma.decapsulateCode(protocols('p2p').code))\n      let signedPeerRecord = peerData.peerRecordEnvelope\n\n      if (multiaddrs.length > 0 && signedPeerRecord == null) {\n        const peerRecord = new PeerRecord({\n          peerId: this.peerId,\n          multiaddrs\n        })\n\n        const envelope = await RecordEnvelope.seal(peerRecord, this.peerId)\n        signedPeerRecord = envelope.marshal().subarray()\n      }\n\n      let observedAddr: Uint8Array | undefined = connection.remoteAddr.bytes\n\n      if (!IP_OR_DOMAIN.matches(connection.remoteAddr)) {\n        observedAddr = undefined\n      }\n\n      const pb = pbStream(stream).pb(Identify)\n\n      await pb.write({\n        protocolVersion: this.host.protocolVersion,\n        agentVersion: this.host.agentVersion,\n        publicKey,\n        listenAddrs: multiaddrs.map(addr => addr.bytes),\n        signedPeerRecord,\n        observedAddr,\n        protocols: peerData.protocols\n      }, {\n        signal\n      })\n\n      await stream.close({\n        signal\n      })\n    } catch (err: any) {\n      this.#log.error('could not respond to identify request', err)\n      stream.abort(err)\n    }\n  }\n\n  /**\n   * Reads the Identify Push message from the given `connection`\n   */\n  async _handlePush (data: IncomingStreamData): Promise<void> {\n    const { connection, stream } = data\n\n    try {\n      if (this.peerId.equals(connection.remotePeer)) {\n        throw new Error('received push from ourselves?')\n      }\n\n      const options = {\n        signal: AbortSignal.timeout(this.timeout)\n      }\n\n      const pb = pbStream(stream, {\n        maxDataLength: this.maxIdentifyMessageSize ?? MAX_IDENTIFY_MESSAGE_SIZE\n      }).pb(Identify)\n\n      const message = await pb.read(options)\n      await stream.close(options)\n\n      await this.#consumeIdentifyMessage(connection, message)\n    } catch (err: any) {\n      this.#log.error('received invalid message', err)\n      stream.abort(err)\n      return\n    }\n\n    this.#log('handled push from %p', connection.remotePeer)\n  }\n\n  async #consumeIdentifyMessage (connection: Connection, message: Identify): Promise<IdentifyResult> {\n    this.#log('received identify from %p', connection.remotePeer)\n\n    if (message == null) {\n      throw new CodeError('message was null or undefined', 'ERR_INVALID_MESSAGE')\n    }\n\n    const peer: PeerData = {}\n\n    if (message.listenAddrs.length > 0) {\n      peer.addresses = message.listenAddrs.map(buf => ({\n        isCertified: false,\n        multiaddr: multiaddr(buf)\n      }))\n    }\n\n    if (message.protocols.length > 0) {\n      peer.protocols = message.protocols\n    }\n\n    if (message.publicKey != null) {\n      peer.publicKey = message.publicKey\n\n      const peerId = await peerIdFromKeys(message.publicKey)\n\n      if (!peerId.equals(connection.remotePeer)) {\n        throw new CodeError('public key did not match remote PeerId', 'ERR_INVALID_PUBLIC_KEY')\n      }\n    }\n\n    let output: SignedPeerRecord | undefined\n\n    // if the peer record has been sent, prefer the addresses in the record as they are signed by the remote peer\n    if (message.signedPeerRecord != null) {\n      this.#log('received signedPeerRecord in push from %p', connection.remotePeer)\n\n      let peerRecordEnvelope = message.signedPeerRecord\n      const envelope = await RecordEnvelope.openAndCertify(peerRecordEnvelope, PeerRecord.DOMAIN)\n      let peerRecord = PeerRecord.createFromProtobuf(envelope.payload)\n\n      // Verify peerId\n      if (!peerRecord.peerId.equals(envelope.peerId)) {\n        throw new CodeError('signing key does not match PeerId in the PeerRecord', 'ERR_INVALID_SIGNING_KEY')\n      }\n\n      // Make sure remote peer is the one sending the record\n      if (!connection.remotePeer.equals(peerRecord.peerId)) {\n        throw new CodeError('signing key does not match remote PeerId', 'ERR_INVALID_PEER_RECORD_KEY')\n      }\n\n      let existingPeer: Peer | undefined\n\n      try {\n        existingPeer = await this.peerStore.get(peerRecord.peerId)\n      } catch (err: any) {\n        if (err.code !== 'ERR_NOT_FOUND') {\n          throw err\n        }\n      }\n\n      if (existingPeer != null) {\n        // don't lose any existing metadata\n        peer.metadata = existingPeer.metadata\n\n        // if we have previously received a signed record for this peer, compare it to the incoming one\n        if (existingPeer.peerRecordEnvelope != null) {\n          const storedEnvelope = await RecordEnvelope.createFromProtobuf(existingPeer.peerRecordEnvelope)\n          const storedRecord = PeerRecord.createFromProtobuf(storedEnvelope.payload)\n\n          // ensure seq is greater than, or equal to, the last received\n          if (storedRecord.seqNumber >= peerRecord.seqNumber) {\n            this.#log('sequence number was lower or equal to existing sequence number - stored: %d received: %d', storedRecord.seqNumber, peerRecord.seqNumber)\n            peerRecord = storedRecord\n            peerRecordEnvelope = existingPeer.peerRecordEnvelope\n          }\n        }\n      }\n\n      // store the signed record for next time\n      peer.peerRecordEnvelope = peerRecordEnvelope\n\n      // override the stored addresses with the signed multiaddrs\n      peer.addresses = peerRecord.multiaddrs.map(multiaddr => ({\n        isCertified: true,\n        multiaddr\n      }))\n\n      output = {\n        seq: peerRecord.seqNumber,\n        addresses: peerRecord.multiaddrs\n      }\n    } else {\n      this.#log('%p did not send a signed peer record', connection.remotePeer)\n    }\n\n    this.#log('patching %p with', connection.remotePeer, peer)\n    await this.peerStore.patch(connection.remotePeer, peer)\n\n    if (message.agentVersion != null || message.protocolVersion != null) {\n      const metadata: Record<string, Uint8Array> = {}\n\n      if (message.agentVersion != null) {\n        metadata.AgentVersion = uint8ArrayFromString(message.agentVersion)\n      }\n\n      if (message.protocolVersion != null) {\n        metadata.ProtocolVersion = uint8ArrayFromString(message.protocolVersion)\n      }\n\n      this.#log('merging %p metadata', connection.remotePeer, metadata)\n      await this.peerStore.merge(connection.remotePeer, {\n        metadata\n      })\n    }\n\n    const result: IdentifyResult = {\n      peerId: connection.remotePeer,\n      protocolVersion: message.protocolVersion,\n      agentVersion: message.agentVersion,\n      publicKey: message.publicKey,\n      listenAddrs: message.listenAddrs.map(buf => multiaddr(buf)),\n      observedAddr: message.observedAddr == null ? undefined : multiaddr(message.observedAddr),\n      protocols: message.protocols,\n      signedPeerRecord: output,\n      connection\n    }\n\n    this.events.safeDispatchEvent('peer:identify', { detail: result })\n\n    return result\n  }\n}\n\n/**\n * Takes the `addr` and converts it to a Multiaddr if possible\n */\nfunction getCleanMultiaddr (addr: Uint8Array | string | null | undefined): Multiaddr | undefined {\n  if (addr != null && addr.length > 0) {\n    try {\n      return multiaddr(addr)\n    } catch {\n\n    }\n  }\n}\n", "import {\n  MULTICODEC_IDENTIFY,\n  MULTICODEC_IDENTIFY_PUSH\n} from './consts.js'\nimport { DefaultIdentifyService } from './identify.js'\nimport { Identify } from './pb/message.js'\nimport type { AbortOptions, IdentifyResult, Libp2pEvents, ComponentLogger } from '@libp2p/interface'\nimport type { TypedEventTarget } from '@libp2p/interface/events'\nimport type { PeerId } from '@libp2p/interface/peer-id'\nimport type { PeerStore } from '@libp2p/interface/peer-store'\nimport type { Connection } from '@libp2p/interface/src/connection/index.js'\nimport type { AddressManager } from '@libp2p/interface-internal/address-manager'\nimport type { ConnectionManager } from '@libp2p/interface-internal/connection-manager'\nimport type { Registrar } from '@libp2p/interface-internal/registrar'\n\nexport interface IdentifyServiceInit {\n  /**\n   * The prefix to use for the protocol (default: 'ipfs')\n   */\n  protocolPrefix?: string\n\n  /**\n   * What details we should send as part of an identify message\n   */\n  agentVersion?: string\n\n  /**\n   * How long we should wait for a remote peer to send their identify response\n   */\n  timeout?: number\n\n  /**\n   * Identify responses larger than this in bytes will be rejected (default: 8192)\n   */\n  maxIdentifyMessageSize?: number\n\n  maxInboundStreams?: number\n  maxOutboundStreams?: number\n\n  maxPushIncomingStreams?: number\n  maxPushOutgoingStreams?: number\n  maxObservedAddresses?: number\n\n  /**\n   * Whether to automatically dial identify on newly opened connections (default: true)\n   */\n  runOnConnectionOpen?: boolean\n\n  /**\n   * Whether to run on connections with data or duration limits (default: true)\n   */\n  runOnTransientConnection?: boolean\n}\n\nexport interface IdentifyServiceComponents {\n  peerId: PeerId\n  peerStore: PeerStore\n  connectionManager: ConnectionManager\n  registrar: Registrar\n  addressManager: AddressManager\n  events: TypedEventTarget<Libp2pEvents>\n  logger: ComponentLogger\n}\n\n/**\n * The protocols the IdentifyService supports\n */\nexport const multicodecs = {\n  IDENTIFY: MULTICODEC_IDENTIFY,\n  IDENTIFY_PUSH: MULTICODEC_IDENTIFY_PUSH\n}\n\nexport const Message = { Identify }\n\nexport interface IdentifyService {\n  /**\n   * due to the default limits on inbound/outbound streams for this protocol,\n   * invoking this method when runOnConnectionOpen is true can lead to unpredictable results\n   * as streams may be closed by the local or the remote node.\n   * Please use with caution. If you find yourself needing to call this method to discover other peers that support your protocol,\n   * you may be better off configuring a topology to be notified instead.\n   */\n  identify(connection: Connection, options?: AbortOptions): Promise<IdentifyResult>\n\n  push(): Promise<void>\n}\n\nexport function identifyService (init: IdentifyServiceInit = {}): (components: IdentifyServiceComponents) => IdentifyService {\n  return (components) => new DefaultIdentifyService(components, init)\n}\n", "export const PROTOCOL = '/ipfs/ping/1.0.0'\nexport const PING_LENGTH = 32\nexport const PROTOCOL_VERSION = '1.0.0'\nexport const PROTOCOL_NAME = 'ping'\nexport const PROTOCOL_PREFIX = 'ipfs'\nexport const TIMEOUT = 10000\n\n// See https://github.com/libp2p/specs/blob/d4b5fb0152a6bb86cfd9ea/ping/ping.md?plain=1#L38-L43\n// The dialing peer MUST NOT keep more than one outbound stream for the ping protocol per peer.\n// The listening peer SHOULD accept at most two streams per peer since cross-stream behavior is\n// non-linear and stream writes occur asynchronously. The listening peer may perceive the\n// dialing peer closing and opening the wrong streams (for instance, closing stream B and\n// opening stream A even though the dialing peer is opening stream B and closing stream A).\nexport const MAX_INBOUND_STREAMS = 2\nexport const MAX_OUTBOUND_STREAMS = 1\n", "import { randomBytes } from '@libp2p/crypto'\nimport { CodeError } from '@libp2p/interface/errors'\nimport { logger } from '@libp2p/logger'\nimport first from 'it-first'\nimport { pipe } from 'it-pipe'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { codes } from '../errors.js'\nimport { PROTOCOL_PREFIX, PROTOCOL_NAME, PING_LENGTH, PROTOCOL_VERSION, TIMEOUT, MAX_INBOUND_STREAMS, MAX_OUTBOUND_STREAMS } from './constants.js'\nimport type { AbortOptions } from '@libp2p/interface'\nimport type { Stream } from '@libp2p/interface/connection'\nimport type { PeerId } from '@libp2p/interface/peer-id'\nimport type { Startable } from '@libp2p/interface/startable'\nimport type { ConnectionManager } from '@libp2p/interface-internal/connection-manager'\nimport type { IncomingStreamData, Registrar } from '@libp2p/interface-internal/registrar'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nconst log = logger('libp2p:ping')\n\nexport interface PingService {\n  ping(peer: PeerId | Multiaddr | Multiaddr[], options?: AbortOptions): Promise<number>\n}\n\nexport interface PingServiceInit {\n  protocolPrefix?: string\n  maxInboundStreams?: number\n  maxOutboundStreams?: number\n  runOnTransientConnection?: boolean\n\n  /**\n   * How long we should wait for a ping response\n   */\n  timeout?: number\n}\n\nexport interface PingServiceComponents {\n  registrar: Registrar\n  connectionManager: ConnectionManager\n}\n\nclass DefaultPingService implements Startable, PingService {\n  public readonly protocol: string\n  private readonly components: PingServiceComponents\n  private started: boolean\n  private readonly timeout: number\n  private readonly maxInboundStreams: number\n  private readonly maxOutboundStreams: number\n  private readonly runOnTransientConnection: boolean\n\n  constructor (components: PingServiceComponents, init: PingServiceInit) {\n    this.components = components\n    this.started = false\n    this.protocol = `/${init.protocolPrefix ?? PROTOCOL_PREFIX}/${PROTOCOL_NAME}/${PROTOCOL_VERSION}`\n    this.timeout = init.timeout ?? TIMEOUT\n    this.maxInboundStreams = init.maxInboundStreams ?? MAX_INBOUND_STREAMS\n    this.maxOutboundStreams = init.maxOutboundStreams ?? MAX_OUTBOUND_STREAMS\n    this.runOnTransientConnection = init.runOnTransientConnection ?? true\n  }\n\n  async start (): Promise<void> {\n    await this.components.registrar.handle(this.protocol, this.handleMessage, {\n      maxInboundStreams: this.maxInboundStreams,\n      maxOutboundStreams: this.maxOutboundStreams,\n      runOnTransientConnection: this.runOnTransientConnection\n    })\n    this.started = true\n  }\n\n  async stop (): Promise<void> {\n    await this.components.registrar.unhandle(this.protocol)\n    this.started = false\n  }\n\n  isStarted (): boolean {\n    return this.started\n  }\n\n  /**\n   * A handler to register with Libp2p to process ping messages\n   */\n  handleMessage (data: IncomingStreamData): void {\n    log('incoming ping from %p', data.connection.remotePeer)\n\n    const { stream } = data\n    const start = Date.now()\n\n    void pipe(stream, stream)\n      .catch(err => {\n        log.error('incoming ping from %p failed with error', data.connection.remotePeer, err)\n      })\n      .finally(() => {\n        const ms = Date.now() - start\n\n        log('incoming ping from %p complete in %dms', data.connection.remotePeer, ms)\n      })\n  }\n\n  /**\n   * Ping a given peer and wait for its response, getting the operation latency.\n   *\n   * @param {PeerId|Multiaddr} peer\n   * @returns {Promise<number>}\n   */\n  async ping (peer: PeerId | Multiaddr | Multiaddr[], options: AbortOptions = {}): Promise<number> {\n    log('pinging %p', peer)\n\n    const start = Date.now()\n    const data = randomBytes(PING_LENGTH)\n    const connection = await this.components.connectionManager.openConnection(peer, options)\n    let stream: Stream | undefined\n    let onAbort = (): void => {}\n\n    if (options.signal == null) {\n      const signal = AbortSignal.timeout(this.timeout)\n\n      options = {\n        ...options,\n        signal\n      }\n    }\n\n    try {\n      stream = await connection.newStream(this.protocol, {\n        ...options,\n        runOnTransientConnection: this.runOnTransientConnection\n      })\n\n      onAbort = () => {\n        stream?.abort(new CodeError('ping timeout', codes.ERR_TIMEOUT))\n      }\n\n      // make stream abortable\n      options.signal?.addEventListener('abort', onAbort, { once: true })\n\n      const result = await pipe(\n        [data],\n        stream,\n        async (source) => first(source)\n      )\n\n      const ms = Date.now() - start\n\n      if (result == null) {\n        throw new CodeError(`Did not receive a ping ack after ${ms}ms`, codes.ERR_WRONG_PING_ACK)\n      }\n\n      if (!uint8ArrayEquals(data, result.subarray())) {\n        throw new CodeError(`Received wrong ping ack after ${ms}ms`, codes.ERR_WRONG_PING_ACK)\n      }\n\n      log('ping %p complete in %dms', connection.remotePeer, ms)\n\n      return ms\n    } catch (err: any) {\n      log.error('error while pinging %p', connection.remotePeer, err)\n\n      stream?.abort(err)\n\n      throw err\n    } finally {\n      options.signal?.removeEventListener('abort', onAbort)\n      if (stream != null) {\n        await stream.close()\n      }\n    }\n  }\n}\n\nexport function pingService (init: PingServiceInit = {}): (components: PingServiceComponents) => PingService {\n  return (components) => new DefaultPingService(components, init)\n}\n", "import type { GossipSub } from \"@chainsafe/libp2p-gossipsub\";\nimport { noise } from \"@chainsafe/libp2p-noise\";\nimport type { PeerDiscovery } from \"@libp2p/interface/peer-discovery\";\nimport { mplex } from \"@libp2p/mplex\";\nimport { webSockets } from \"@libp2p/websockets\";\nimport { all as filterAll } from \"@libp2p/websockets/filters\";\nimport {\n  DefaultPubSubTopic,\n  DefaultUserAgent,\n  wakuFilter,\n  wakuLightPush,\n  WakuNode,\n  WakuOptions,\n  wakuStore\n} from \"@waku/core\";\nimport { enrTree, wakuDnsDiscovery } from \"@waku/dns-discovery\";\nimport type {\n  FullNode,\n  Libp2p,\n  Libp2pComponents,\n  LightNode,\n  ProtocolCreateOptions,\n  RelayNode\n} from \"@waku/interfaces\";\nimport { wakuPeerExchangeDiscovery } from \"@waku/peer-exchange\";\nimport { RelayCreateOptions, wakuGossipSub, wakuRelay } from \"@waku/relay\";\nimport { createLibp2p, Libp2pOptions } from \"libp2p\";\nimport { identifyService } from \"libp2p/identify\";\nimport { pingService } from \"libp2p/ping\";\n\nconst DEFAULT_NODE_REQUIREMENTS = {\n  lightPush: 1,\n  filter: 1,\n  store: 1\n};\n\nexport { Libp2pComponents };\n\n/**\n * Create a Waku node that uses Waku Light Push, Filter and Store to send and\n * receive messages, enabling low resource consumption.\n * Uses Waku Filter V2 by default.\n */\nexport async function createLightNode(\n  options?: ProtocolCreateOptions & WakuOptions\n): Promise<LightNode> {\n  options = options ?? {};\n\n  if (!options.pubsubTopics) {\n    options.pubsubTopics = [DefaultPubSubTopic];\n  }\n\n  const libp2pOptions = options?.libp2p ?? {};\n  const peerDiscovery = libp2pOptions.peerDiscovery ?? [];\n  if (options?.defaultBootstrap) {\n    peerDiscovery.push(...defaultPeerDiscoveries());\n    Object.assign(libp2pOptions, { peerDiscovery });\n  }\n\n  const libp2p = await defaultLibp2p(\n    undefined,\n    libp2pOptions,\n    options?.userAgent\n  );\n\n  const store = wakuStore(options);\n  const lightPush = wakuLightPush(options);\n  const filter = wakuFilter(options);\n\n  return new WakuNode(\n    options ?? {},\n    options.pubsubTopics,\n    libp2p,\n    store,\n    lightPush,\n    filter\n  ) as LightNode;\n}\n\n/**\n * Create a Waku node that uses Waku Relay to send and receive messages,\n * enabling some privacy preserving properties.\n */\nexport async function createRelayNode(\n  options?: ProtocolCreateOptions & WakuOptions & Partial<RelayCreateOptions>\n): Promise<RelayNode> {\n  options = options ?? {};\n\n  if (!options.pubsubTopics) {\n    options.pubsubTopics = [DefaultPubSubTopic];\n  }\n\n  const libp2pOptions = options?.libp2p ?? {};\n  const peerDiscovery = libp2pOptions.peerDiscovery ?? [];\n  if (options?.defaultBootstrap) {\n    peerDiscovery.push(...defaultPeerDiscoveries());\n    Object.assign(libp2pOptions, { peerDiscovery });\n  }\n\n  const libp2p = await defaultLibp2p(\n    wakuGossipSub(options),\n    libp2pOptions,\n    options?.userAgent\n  );\n\n  const relay = wakuRelay(options);\n\n  return new WakuNode(\n    options,\n    options.pubsubTopics,\n    libp2p,\n    undefined,\n    undefined,\n    undefined,\n    relay\n  ) as RelayNode;\n}\n\n/**\n * Create a Waku node that uses all Waku protocols.\n *\n * This helper is not recommended except if:\n * - you are interfacing with nwaku v0.11 or below\n * - you are doing some form of testing\n *\n * If you are building a full node, it is recommended to use\n * [nwaku](github.com/status-im/nwaku) and its JSON RPC API or wip REST API.\n *\n * @see https://github.com/status-im/nwaku/issues/1085\n * @internal\n */\nexport async function createFullNode(\n  options?: ProtocolCreateOptions & WakuOptions & Partial<RelayCreateOptions>\n): Promise<FullNode> {\n  options = options ?? {};\n\n  if (!options.pubsubTopics) {\n    options.pubsubTopics = [DefaultPubSubTopic];\n  }\n\n  const libp2pOptions = options?.libp2p ?? {};\n  const peerDiscovery = libp2pOptions.peerDiscovery ?? [];\n  if (options?.defaultBootstrap) {\n    peerDiscovery.push(...defaultPeerDiscoveries());\n    Object.assign(libp2pOptions, { peerDiscovery });\n  }\n\n  const libp2p = await defaultLibp2p(\n    wakuGossipSub(options),\n    libp2pOptions,\n    options?.userAgent\n  );\n\n  const store = wakuStore(options);\n  const lightPush = wakuLightPush(options);\n  const filter = wakuFilter(options);\n  const relay = wakuRelay(options);\n\n  return new WakuNode(\n    options ?? {},\n    options.pubsubTopics,\n    libp2p,\n    store,\n    lightPush,\n    filter,\n    relay\n  ) as FullNode;\n}\n\nexport function defaultPeerDiscoveries(): ((\n  components: Libp2pComponents\n) => PeerDiscovery)[] {\n  const discoveries = [\n    wakuDnsDiscovery([enrTree[\"PROD\"]], DEFAULT_NODE_REQUIREMENTS),\n    wakuPeerExchangeDiscovery()\n  ];\n  return discoveries;\n}\n\ntype PubsubService = {\n  pubsub?: (components: Libp2pComponents) => GossipSub;\n};\n\nexport async function defaultLibp2p(\n  wakuGossipSub?: PubsubService[\"pubsub\"],\n  options?: Partial<Libp2pOptions>,\n  userAgent?: string\n): Promise<Libp2p> {\n  const pubsubService: PubsubService = wakuGossipSub\n    ? { pubsub: wakuGossipSub }\n    : {};\n\n  return createLibp2p({\n    connectionManager: {\n      minConnections: 1\n    },\n    transports: [webSockets({ filter: filterAll })],\n    streamMuxers: [mplex()],\n    connectionEncryption: [noise()],\n    ...options,\n    services: {\n      identify: identifyService({\n        agentVersion: userAgent ?? DefaultUserAgent\n      }),\n      ping: pingService(),\n      ...pubsubService,\n      ...options?.services\n    }\n  }) as any as Libp2p; // TODO: make libp2p include it;\n}\n"],
  "mappings": "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",
  "names": ["key", "require_BlockedKeys", "version", "RateLimiterMemory", "crypto", "RateLimiterMemory", "func", "func", "message", "RateLimiterMemory", "EventIterator", "isReactNative", "URL", "base", "hash", "base", "relative", "isElectron", "RPC", "encode", "decode", "$oneOfFields", "PeerInfo", "Denque", "length", "src", "log2", "string", "require_browser", "string", "require_browser", "sanitize", "output", "EventEmitter", "names", "events", "name", "length", "Netmask", "base", "string", "first", "second", "length", "ipaddr", "bytes", "parse", "name", "Receptacle", "dist_exports", "PageDirection", "message_exports", "filter_exports", "light_push_exports", "store_exports", "Protocols", "SendError", "PageDirection", "Tags", "EPeersByDiscoveryEvents", "CustomEvent", "message", "RateLimitProof", "reader", "length", "WakuMessage", "RateLimitProof", "WakuMessage", "FilterRequest", "ContentFilter", "_codec", "reader", "length", "MessagePush", "WakuMessage", "FilterRpc", "RateLimitProof", "TopicOnlyMessage", "reader", "length", "MessagePush", "RateLimitProof", "WakuMessage", "FilterSubscribeRequest", "FilterSubscribeType", "__FilterSubscribeTypeValues", "reader", "length", "FilterSubscribeResponse", "MessagePush", "WakuMessage", "RateLimitProof", "RateLimitProof", "WakuMessage", "PushRequest", "WakuMessage", "reader", "length", "PushResponse", "PushRpc", "RateLimitProof", "RateLimitProof", "WakuMessage", "Index", "reader", "length", "PagingInfo", "Direction", "__DirectionValues", "ContentFilter", "HistoryQuery", "HistoryResponse", "HistoryError", "__HistoryErrorValues", "WakuMessage", "HistoryRpc", "RateLimitProof", "PeerInfo", "reader", "length", "PeerExchangeQuery", "PeerExchangeResponse", "PeerExchangeRPC", "message", "bytes", "log", "peerId", "_a", "encoder", "log", "peerId", "CustomEvent", "name", "log", "filter", "peerId", "message_exports", "filter_exports", "arr", "length", "bytes", "isAsyncIterable", "length", "encode", "isAsyncIterable", "ReadMode", "length", "decode", "errCode", "isAsyncIterable", "reader", "AbortError", "message", "code", "pushable", "drain", "options", "_pushable", "isAsyncIterable", "output", "src_default", "first", "isAsyncIterable", "source", "src_default", "peerId", "peerId", "bytes", "URL", "name", "version", "bytes", "output", "bytes", "bytes", "FilterSubscribeResponse", "log", "request", "encode", "decode", "FilterSubscribeResponse", "decoders", "message", "bytes", "light_push_exports", "PushRpc", "message", "bytes", "log", "encoder", "message", "log", "PushRpc", "encode", "decode", "bytes", "store_exports", "PageDirection", "OneMillion", "PageDirection", "HistoryRpc", "bytes", "log", "messages", "PageDirection", "_a", "_b", "HistoryRpc", "log", "encode", "decode", "bytes", "message", "digest", "concat", "message", "AbortError", "_a", "events", "event", "log", "_a", "_b", "AbortError", "message", "code", "pushable", "CodeError", "message", "code", "AbortError", "write", "pushable", "source", "bytes", "_a", "_b", "CodeError", "message", "code", "bytes", "encode", "utf8ToBytes", "toBytes", "utf8ToBytes", "ensureBytes", "equalBytes", "isLE", "number", "toBytes", "ensureBytes", "f", "take", "utf8ToBytes", "output", "take", "number", "ensureBytes", "output", "equalBytes", "Fp", "randomBytes", "uvRatio", "adjustScalarBytes", "bytes", "G", "A", "B", "F", "C", "D", "E", "H", "X3", "Y3", "T3", "Z3", "f", "cofactor", "hash", "concatBytes", "_0n", "_1n", "validateOpts", "adjustScalarBytes", "bytes", "_0n", "_1n", "_2n", "bytes", "v3", "pow", "utf8ToBytes", "_2n", "_1n", "number", "bytes", "mod", "_0n", "hash", "length", "allocUnsafe", "message", "encode2", "decode2", "handshake", "import_asn1", "import_forge", "name", "encode", "length", "i", "j", "decode", "string", "Encoder", "name", "bytes", "Decoder", "encode", "decode", "string", "codes", "bits", "encode", "decode", "encodingLength", "code", "digest", "encodingLength", "bytes", "code", "digest", "bytes", "encode", "from", "name", "code", "encode", "digest", "name", "sha256", "from", "sha512", "create", "digest", "crypto", "encrypt", "decrypt", "create", "KeyType", "__KeyTypeValues", "PublicKey", "reader", "length", "PrivateKey", "bytes", "sha256", "message", "privateKeyBytes", "publicKeyBytes", "length", "forge", "create", "generateKeyPair", "import_forge", "import_sha512", "randomBytes", "length", "import_forge", "forge", "import_rsa", "import_forge", "bytes", "forge", "generateKey", "bits", "pair", "hashAndSign", "hashAndVerify", "pair", "handle", "msg", "key", "bytes", "hashAndVerify", "bytes", "sha256", "randomBytes", "message", "hashAndSign", "hash", "forge", "generateKeyPair", "bits", "generateKey", "generateKeyPair", "generateKey", "hashAndSign", "digest", "sha256", "hashAndVerify", "hashAndVerify", "bytes", "sha256", "message", "hashAndSign", "hash", "generateKeyPair", "generateKey", "generateKeyPair", "bits", "unmarshalPrivateKey", "key", "forge", "NoiseExtensions", "reader", "length", "NoiseHandshakePayload", "peerId", "unmarshalPrivateKey", "log", "log", "crypto", "log", "message", "name", "message", "crypto", "handshake", "log", "encode2", "decode2", "crypto", "handshake", "_a", "_b", "decode", "AbortError", "message", "code", "AbortError", "err", "MessageTypes", "Decoder", "length", "MSB", "REST", "isAsyncIterable", "src_default", "allocUnsafe", "Encoder", "allocUnsafe", "encode", "messages", "src_default", "_a", "err", "name", "log", "output", "encode", "name", "Decoder", "message", "stream", "symbol", "FaultTolerance", "_a", "messages", "detectElectron", "CLOSE_TIMEOUT", "all", "log", "options", "_a", "_b", "CLOSE_TIMEOUT", "log", "_a", "_b", "WebSockets", "all", "symbol", "PeerExchangeRPC", "bytes", "log", "PeerExchangeRPC", "encode", "decode", "bytes", "log", "peerId", "dist_exports", "msgId", "_a", "message", "import_rpc", "cjs", "msgId", "TopicValidatorResult", "SignaturePolicy", "PublishConfigType", "RejectReason", "ValidateError", "MessageStatus", "peerId", "unmarshalPrivateKey", "DeliveryRecordStatus", "Denque", "log", "_a", "_b", "from", "from", "msgId", "_a", "MessageSource", "InclusionReason", "ChurnReason", "ScorePenalty", "IHaveIgnoreReason", "ScoreThreshold", "_a", "_b", "import_forge", "import_util", "keySize", "hash", "forgePbkdf2", "forgeUtil", "randomBytes", "bytes", "empty", "encode_1", "encode", "MSB", "REST", "MSBALL", "INT", "decode", "read", "MSB$1", "REST$1", "N1", "N2", "N3", "N4", "N5", "N6", "N7", "N8", "N9", "length", "varint", "_brrp_varint", "varint_default", "encodeTo", "varint_default", "encodingLength", "create", "code", "digest", "encodingLength", "bytes", "encodeTo", "Digest", "Digest", "code", "digest", "bytes", "from", "name", "code", "encode", "Hasher", "create", "digest", "sha", "name", "sha256", "from", "sha512", "empty", "encode_1", "encode", "MSB", "REST", "MSBALL", "INT", "decode", "read", "MSB$1", "REST$1", "N1", "N2", "N3", "N4", "N5", "N6", "N7", "N8", "N9", "length", "varint", "_brrp_varint", "varint_default", "encodeTo", "varint_default", "encodingLength", "create", "code", "digest", "encodingLength", "bytes", "encodeTo", "Digest", "Digest", "code", "digest", "bytes", "from", "name", "code", "encode", "Hasher", "create", "digest", "sha", "name", "sha256", "from", "sha512", "msgId", "sha256", "encode", "decode", "bytes", "protobuf", "decodeMessage", "Protocol", "multiaddr", "GossipStatusCode", "_a", "peerId", "_b", "from", "messages", "subscriptions", "message", "msgId", "errCode", "id", "filter", "second", "minute", "log", "message", "TopicOnlyMessage", "bytes", "log", "encoder", "message", "map", "bytes", "_a", "bytes", "codes", "log", "name", "sanitize", "_a", "_b", "randomBytes", "codes", "exists", "generateKeyPair", "unmarshalPrivateKey", "map", "map", "peerId", "output", "output", "peerId", "str", "PeerIdProto", "reader", "length", "generateKeyPair", "codes", "Envelope", "reader", "length", "peerId", "unmarshalPrivateKey", "codes", "sort", "a", "b", "PeerRecord", "AddressInfo", "_codec", "reader", "length", "peerId", "PeerRecord", "import_index", "TimeoutError", "message", "AbortError", "getDOMException", "getAbortedReason", "pTimeout", "first", "f", "f", "__classPrivateFieldGet", "AbortError", "EventEmitter", "_a", "_b", "pTimeout", "TimeoutError", "_PQueue_doesIntervalAllowAnother_get", "_PQueue_doesConcurrentAllowAnother_get", "_PQueue_next", "_PQueue_onResumeInterval", "_PQueue_isIntervalPaused_get", "_PQueue_tryToStartAnother", "_PQueue_initializeIntervalIfNeeded", "_PQueue_onInterval", "_PQueue_processQueue", "_PQueue_throwOnAbort", "_PQueue_onEvent", "filter", "nanoid", "src_default", "event", "name", "nanoid", "defaultOptions", "src_default", "name", "defaultOptions", "empty", "Encoder", "name", "bytes", "Decoder", "or", "ComposedDecoder", "Codec", "from", "encode", "decode", "decode", "string", "name", "codes", "bits", "encode", "rfc4648", "from", "rfc4648", "codes", "Peer", "Peer$metadataEntry", "_codec", "reader", "length", "Peer$tagsEntry", "Address", "Tag", "peerId", "peerId", "codes", "peerId", "filter", "codes", "multiaddr", "peerId", "codes", "multiaddr", "output", "_a", "peerId", "codes", "log", "peerId", "PeerRecord", "multiaddr", "isAsyncIterable", "src_default", "symbol", "src_default", "isAsyncIterable", "peekable", "src_default", "func", "isAsyncIterable", "src_default", "isAsyncIterable", "src_default", "src_default", "it", "f", "import_err_code", "errCode", "func", "log", "peerId", "_a", "_a", "v4", "parse", "ipaddr", "multiaddr", "base", "name", "encode", "length", "i", "j", "decode", "string", "src", "_brrp__multiformats_scope_baseX", "base_x_default", "empty", "coerce", "Encoder", "name", "bytes", "Decoder", "or", "ComposedDecoder", "Codec", "from", "encode", "decode", "baseX", "base_x_default", "coerce", "string", "codes", "bits", "rfc4648", "base58btc", "baseX", "base58flickr", "base64", "rfc4648", "base64pad", "base64url", "base64urlpad", "number", "base58btc", "base64url", "or", "DNS", "WebSockets", "WebSocketsSecure", "log", "debug", "Receptacle", "src_default", "src_default", "peerId", "messages", "codes", "_a", "_b", "codes", "import_rate_limiter_flexible", "log", "peerId", "codes", "lowerBound", "first", "peerId", "codes", "defaultOptions", "debounce", "numConnections", "defaultOptions", "_log", "signal", "output", "ma", "defaultOptions", "_log", "_a", "_b", "peerId", "multiaddr", "err", "codes", "conn", "defaultOptions", "_log", "codes", "_a", "_b", "peerId", "isAsyncIterable", "map", "func", "peekable", "src_default", "src_default", "codes", "src_default", "isAsyncIterable", "src_default", "log", "codes", "output", "src_default", "log", "codes", "_a", "peerId", "name", "map", "log", "codes", "message", "reader", "bytes", "source", "log", "encode", "read", "reader", "decode", "src_default", "log", "reader", "protocol", "response", "log", "reader", "encode", "symbol", "CLOSE_TIMEOUT", "_log", "_a", "_b", "symbol", "codes", "options", "_log", "connectionGater", "_a", "_b", "maConn", "_log", "events", "name", "_a", "_b", "peerId", "codes", "bytes", "message", "messages", "Identify", "reader", "length", "_log", "PeerRecord", "codes", "message", "peerId", "output", "multiaddr", "log", "_a", "_b", "randomBytes", "codes", "src_default", "peerDiscovery", "filter", "wakuGossipSub", "all"]
}
