import {
  P2P,
  logger
} from "./chunk-U3422VRE.js";
import {
  TypedEventEmitter,
  multiaddr,
  peerDiscovery,
  peerIdFromString
} from "./chunk-DBLPKOPF.js";
import "./chunk-GRGIYPWK.js";
import {
  __publicField
} from "./chunk-P3R5BNFQ.js";

// node_modules/@libp2p/bootstrap/dist/src/index.js
var log = logger("libp2p:bootstrap");
var DEFAULT_BOOTSTRAP_TAG_NAME = "bootstrap";
var DEFAULT_BOOTSTRAP_TAG_VALUE = 50;
var DEFAULT_BOOTSTRAP_TAG_TTL = 12e4;
var DEFAULT_BOOTSTRAP_DISCOVERY_TIMEOUT = 1e3;
var _a, _b;
var Bootstrap = class extends TypedEventEmitter {
  constructor(components, options = { list: [] }) {
    if (options.list == null || options.list.length === 0) {
      throw new Error("Bootstrap requires a list of peer addresses");
    }
    super();
    __publicField(this, "timer");
    __publicField(this, "list");
    __publicField(this, "timeout");
    __publicField(this, "components");
    __publicField(this, "_init");
    __publicField(this, _a, this);
    __publicField(this, _b, "@libp2p/bootstrap");
    this.components = components;
    this.timeout = options.timeout ?? DEFAULT_BOOTSTRAP_DISCOVERY_TIMEOUT;
    this.list = [];
    for (const candidate of options.list) {
      if (!P2P.matches(candidate)) {
        log.error("Invalid multiaddr");
        continue;
      }
      const ma = multiaddr(candidate);
      const peerIdStr = ma.getPeerId();
      if (peerIdStr == null) {
        log.error("Invalid bootstrap multiaddr without peer id");
        continue;
      }
      const peerData = {
        id: peerIdFromString(peerIdStr),
        multiaddrs: [ma],
        protocols: []
      };
      this.list.push(peerData);
    }
    this._init = options;
  }
  isStarted() {
    return Boolean(this.timer);
  }
  /**
   * Start emitting events
   */
  start() {
    if (this.isStarted()) {
      return;
    }
    log("Starting bootstrap node discovery, discovering peers after %s ms", this.timeout);
    this.timer = setTimeout(() => {
      void this._discoverBootstrapPeers().catch((err) => {
        log.error(err);
      });
    }, this.timeout);
  }
  /**
   * Emit each address in the list as a PeerInfo
   */
  async _discoverBootstrapPeers() {
    if (this.timer == null) {
      return;
    }
    for (const peerData of this.list) {
      await this.components.peerStore.merge(peerData.id, {
        tags: {
          [this._init.tagName ?? DEFAULT_BOOTSTRAP_TAG_NAME]: {
            value: this._init.tagValue ?? DEFAULT_BOOTSTRAP_TAG_VALUE,
            ttl: this._init.tagTTL ?? DEFAULT_BOOTSTRAP_TAG_TTL
          }
        }
      });
      if (this.timer == null) {
        return;
      }
      this.safeDispatchEvent("peer", { detail: peerData });
    }
  }
  /**
   * Stop emitting events
   */
  stop() {
    if (this.timer != null) {
      clearTimeout(this.timer);
    }
    this.timer = void 0;
  }
};
_a = peerDiscovery, _b = Symbol.toStringTag;
__publicField(Bootstrap, "tag", "bootstrap");
function bootstrap(init) {
  return (components) => new Bootstrap(components, init);
}
export {
  bootstrap
};
//# sourceMappingURL=@libp2p_bootstrap.js.map
