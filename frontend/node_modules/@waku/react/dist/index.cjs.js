"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("react"),t=require("@waku/sdk");function r(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var o=r(e);const a=(e,r=!1)=>{const[a,s]=o.default.useState(t.createEncoder({contentTopic:e,ephemeral:r})),[u,n]=o.default.useState(t.createDecoder(e));return o.default.useEffect((()=>{s(t.createEncoder({contentTopic:e,ephemeral:r})),n(t.createDecoder(e))}),[e,r]),{encoder:a,decoder:u}},s=o.default.createContext({decoder:void 0,encoder:void 0}),u=e=>{const{factory:r,options:a,protocols:s=[]}=e,[u,n]=o.default.useState(void 0),[d,l]=o.default.useState(!0),[c,i]=o.default.useState(void 0);return o.default.useEffect((()=>{let e=!1;return l(!0),r(a).then((async r=>{e||(await r.start(),await t.waitForRemotePeer(r,s),n(r),l(!1))})).catch((e=>{l(!1),i(`Failed at creating node: ${(null==e?void 0:e.message)||"no message"}`)})),()=>{e=!0}}),[]),{node:u,error:c,isLoading:d}},n=e=>u({...e,factory:t.createLightNode}),d=e=>u({...e,factory:t.createRelayNode}),l=o.default.createContext({node:void 0,isLoading:!1,error:void 0});exports.ContentPairProvider=e=>{const t=a(e.contentTopic,e.ephemeral);return o.default.createElement(s.Provider,{value:t},e.children)},exports.LightNodeProvider=e=>{const t=n({options:e.options,protocols:e.protocols});return o.default.createElement(l.Provider,{value:t},e.children)},exports.RelayNodeProvider=e=>{const t=d({options:e.options,protocols:e.protocols});return o.default.createElement(l.Provider,{value:t},e.children)},exports.useContentPair=()=>o.default.useContext(s),exports.useCreateContentPair=a,exports.useCreateLightNode=n,exports.useCreateRelayNode=d,exports.useFilterMessages=e=>{const{node:t,decoder:r}=e,[a,s]=o.default.useState(void 0),[u,n]=o.default.useState(!1),[d,l]=o.default.useState([]),c=o.default.useCallback((e=>{e&&l((t=>[...t,e]))}),[l]);return o.default.useEffect((()=>{if(!t||!r)return;let e=null;return n(!0),t.filter.subscribe([r],c).then((t=>{n(!1),e=t})).catch((e=>{n(!1),s(`Failed to subscribe to filer: ${(null==e?void 0:e.message)||"no message"}`)})),()=>{null==e||e()}}),[t,r,c,s,n]),{error:a,messages:d,isLoading:u}},exports.useLightPush=e=>{const{node:t,encoder:r}=e,a=o.default.useCallback((e=>t.lightPush.send(r,e)),[t,r]);return t||r?{push:a}:{}},exports.useStoreMessages=e=>{const{node:t,decoder:r,options:a}=e,[s,u]=o.default.useState(void 0),[n,d]=o.default.useState(!1),[l,c]=o.default.useState([]),i=o.default.useCallback((e=>{e&&e.length&&c((t=>[...t,...e]))}),[c]);return o.default.useEffect((()=>{if(!t||!r)return;let e=!1;return d(!0),Promise.resolve().then((async()=>{for await(const o of t.store.queryGenerator([r],a)){if(e)return;const t=(await Promise.all(o)).filter((e=>!!e));i(t)}d(!1)})).catch((e=>{d(!1),u(`Failed to query messages from store: ${(null==e?void 0:e.message)||"no message"}`)})),()=>{e=!0}}),[t,r,i,u,d]),{error:s,isLoading:n,messages:l}},exports.useWaku=()=>o.default.useContext(l);
//# sourceMappingURL=index.cjs.js.map
