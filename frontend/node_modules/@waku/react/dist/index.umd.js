!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("react"),require("@waku/sdk")):"function"==typeof define&&define.amd?define(["exports","react","@waku/sdk"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self)["@waku/react"]={},e.React,e.sdk)}(this,(function(e,t,o){"use strict";function r(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var a=r(t);const s=(e,t=!1)=>{const[r,s]=a.default.useState(o.createEncoder({contentTopic:e,ephemeral:t})),[n,u]=a.default.useState(o.createDecoder(e));return a.default.useEffect((()=>{s(o.createEncoder({contentTopic:e,ephemeral:t})),u(o.createDecoder(e))}),[e,t]),{encoder:r,decoder:n}},n=a.default.createContext({decoder:void 0,encoder:void 0}),u=e=>{const{factory:t,options:r,protocols:s=[]}=e,[n,u]=a.default.useState(void 0),[d,l]=a.default.useState(!0),[i,c]=a.default.useState(void 0);return a.default.useEffect((()=>{let e=!1;return l(!0),t(r).then((async t=>{e||(await t.start(),await o.waitForRemotePeer(t,s),u(t),l(!1))})).catch((e=>{l(!1),c(`Failed at creating node: ${(null==e?void 0:e.message)||"no message"}`)})),()=>{e=!0}}),[]),{node:n,error:i,isLoading:d}},d=e=>u({...e,factory:o.createLightNode}),l=e=>u({...e,factory:o.createRelayNode}),i=a.default.createContext({node:void 0,isLoading:!1,error:void 0});e.ContentPairProvider=e=>{const t=s(e.contentTopic,e.ephemeral);return a.default.createElement(n.Provider,{value:t},e.children)},e.LightNodeProvider=e=>{const t=d({options:e.options,protocols:e.protocols});return a.default.createElement(i.Provider,{value:t},e.children)},e.RelayNodeProvider=e=>{const t=l({options:e.options,protocols:e.protocols});return a.default.createElement(i.Provider,{value:t},e.children)},e.useContentPair=()=>a.default.useContext(n),e.useCreateContentPair=s,e.useCreateLightNode=d,e.useCreateRelayNode=l,e.useFilterMessages=e=>{const{node:t,decoder:o}=e,[r,s]=a.default.useState(void 0),[n,u]=a.default.useState(!1),[d,l]=a.default.useState([]),i=a.default.useCallback((e=>{e&&l((t=>[...t,e]))}),[l]);return a.default.useEffect((()=>{if(!t||!o)return;let e=null;return u(!0),t.filter.subscribe([o],i).then((t=>{u(!1),e=t})).catch((e=>{u(!1),s(`Failed to subscribe to filer: ${(null==e?void 0:e.message)||"no message"}`)})),()=>{null==e||e()}}),[t,o,i,s,u]),{error:r,messages:d,isLoading:n}},e.useLightPush=e=>{const{node:t,encoder:o}=e,r=a.default.useCallback((e=>t.lightPush.send(o,e)),[t,o]);return t||o?{push:r}:{}},e.useStoreMessages=e=>{const{node:t,decoder:o,options:r}=e,[s,n]=a.default.useState(void 0),[u,d]=a.default.useState(!1),[l,i]=a.default.useState([]),c=a.default.useCallback((e=>{e&&e.length&&i((t=>[...t,...e]))}),[i]);return a.default.useEffect((()=>{if(!t||!o)return;let e=!1;return d(!0),Promise.resolve().then((async()=>{for await(const a of t.store.queryGenerator([o],r)){if(e)return;const t=(await Promise.all(a)).filter((e=>!!e));c(t)}d(!1)})).catch((e=>{d(!1),n(`Failed to query messages from store: ${(null==e?void 0:e.message)||"no message"}`)})),()=>{e=!0}}),[t,o,c,n,d]),{error:s,isLoading:u,messages:l}},e.useWaku=()=>a.default.useContext(i),Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=index.umd.js.map
