import React from 'react';
import { createEncoder, createDecoder, createLightNode, createRelayNode, waitForRemotePeer } from '@waku/sdk';

/**
 * Creates Encoder / Decoder pair for a given contentTopic.
 * @param {string} contentTopic - topic to orient to
 * @param {boolean} ephemeral - makes messages ephemeral, default to false
 * @returns {Object} Encoder / Decoder pair
 */
const useCreateContentPair = (contentTopic, ephemeral = false) => {
    const [encoder, setEncoder] = React.useState(createEncoder({ contentTopic, ephemeral }));
    const [decoder, setDecoder] = React.useState(createDecoder(contentTopic));
    React.useEffect(() => {
        setEncoder(createEncoder({ contentTopic, ephemeral }));
        setDecoder(createDecoder(contentTopic));
    }, [contentTopic, ephemeral]);
    return {
        encoder,
        decoder,
    };
};

const ContentPairContext = React.createContext({
    decoder: undefined,
    encoder: undefined,
});
/**
 * Hook to retrieve Encoder/Decoder pair from Context.
 * @example
 * const { encoder, decoder } = useContentPair();
 * @returns {Object} { encoder, decoder }
 */
const useContentPair = () => React.useContext(ContentPairContext);
/**
 * Provider for creating Encoder/Decoder pair based on contentTopic
 * @example
 * const App = (props) => (
 *  <ContentPairProvider contentTopic="/toy-chat/2/huilong/proto">
 *      <Component />
 *  </ContentPairProvider>
 * );
 * const Component = (props) => {
 *  const { encoder, decoder } = useContentPair();
 *  ...
 * };
 * @param {string} contentTopic - content topic for configuring the pair
 * @param {boolean} ephemeral - flag to set messages ephemeral according to RFC https://rfc.vac.dev/spec/14/
 * @returns React ContentPair Provider component
 */
const ContentPairProvider = (props) => {
    const result = useCreateContentPair(props.contentTopic, props.ephemeral);
    return (React.createElement(ContentPairContext.Provider, { value: result }, props.children));
};

const useCreateNode = (params) => {
    const { factory, options, protocols = [] } = params;
    const [node, setNode] = React.useState(undefined);
    const [isLoading, setLoading] = React.useState(true);
    const [error, setError] = React.useState(undefined);
    React.useEffect(() => {
        let cancelled = false;
        setLoading(true);
        factory(options)
            .then(async (node) => {
            if (cancelled) {
                return;
            }
            await node.start();
            await waitForRemotePeer(node, protocols);
            setNode(node);
            setLoading(false);
        })
            .catch((err) => {
            setLoading(false);
            setError(`Failed at creating node: ${(err === null || err === void 0 ? void 0 : err.message) || "no message"}`);
        });
        return () => {
            cancelled = true;
        };
        // TODO: missing any dependencies, it will prevent consecutive update if options change
    }, []);
    return {
        node,
        error,
        isLoading,
    };
};
/**
 * Create Light Node helper hook.
 * @param {Object} params - optional params to configure & bootstrap node
 * @returns {CrateWakuHook} node, loading state and error
 */
const useCreateLightNode = (params) => {
    return useCreateNode({
        ...params,
        factory: createLightNode,
    });
};
/**
 * Create Relay Node helper hook.
 * @param {Object} params - optional params to configure & bootstrap node
 * @returns {CrateWakuHook} node, loading state and error
 */
const useCreateRelayNode = (params) => {
    return useCreateNode({
        ...params,
        factory: createRelayNode,
    });
};

/**
 * Returns messages from Filter subscription and keeps them up to date
 * @example
 * const { isLoading, error, message } = useFilterMessages({node, decoder});
 * @param {Object} node - node that implements Filter, hook does nothing if undefined
 * @param {Object} decoder - decoder to use for subscribing, hook does nothing if undefined
 * @returns {Object} hook state (isLoading, error) and messages array
 */
const useFilterMessages = (params) => {
    const { node, decoder } = params;
    const [error, setError] = React.useState(undefined);
    const [isLoading, setLoading] = React.useState(false);
    const [messages, setMessage] = React.useState([]);
    const pushMessage = React.useCallback((message) => {
        if (!message) {
            return;
        }
        setMessage((prev) => [...prev, message]);
    }, [setMessage]);
    React.useEffect(() => {
        if (!node || !decoder) {
            return;
        }
        let unsubscribe = null;
        setLoading(true);
        node.filter.subscribe([decoder], pushMessage)
            .then((unsubscribeFn) => {
            setLoading(false);
            unsubscribe = unsubscribeFn;
        })
            .catch((err) => {
            setLoading(false);
            setError(`Failed to subscribe to filer: ${(err === null || err === void 0 ? void 0 : err.message) || "no message"}`);
        });
        return () => {
            unsubscribe === null || unsubscribe === void 0 ? void 0 : unsubscribe();
        };
    }, [node, decoder, pushMessage, setError, setLoading]);
    return {
        error,
        messages,
        isLoading,
    };
};

/**
 * Returns light push methods bound to node and encoder
 * @param {Object} params.node - node that implements ILightPush, hook does nothing if empty
 * @param {Object} params.encoder - encoder for processing messages, hook does nothing if empty
 * @returns {Object} methods of ILightPush such as push
 */
const useLightPush = (params) => {
    const { node, encoder } = params;
    const push = React.useCallback((message) => {
        return node.lightPush.send(encoder, message);
    }, [node, encoder]);
    if (!node && !encoder) {
        return {};
    }
    return {
        push,
    };
};

/**
 * Hook for retrieving messages from Store protocol based on options
 * @example
 * const { isLoading, error, messages } = useStoreMessages({node, decoder, options});
 * @param {Object} node - node that implement Store, hook does nothing if undefined
 * @param {Object} decoder - decoder to use for getting messages, hook does nothing if undefined
 * @param {StoreQueryOptions} options - options to initiate query to get messages
 * @returns {Object} hook state (isLoading, error) and messages array
 */
const useStoreMessages = (params) => {
    const { node, decoder, options } = params;
    const [error, setError] = React.useState(undefined);
    const [isLoading, setLoading] = React.useState(false);
    const [messages, setMessage] = React.useState([]);
    const pushMessage = React.useCallback((newMessages) => {
        if (!newMessages || !newMessages.length) {
            return;
        }
        setMessage((prev) => [...prev, ...newMessages]);
    }, [setMessage]);
    React.useEffect(() => {
        if (!node || !decoder) {
            return;
        }
        let cancelled = false;
        setLoading(true);
        Promise.resolve()
            .then(async () => {
            for await (const promises of node.store.queryGenerator([decoder], options)) {
                if (cancelled) {
                    return;
                }
                const messagesRaw = await Promise.all(promises);
                const filteredMessages = messagesRaw.filter((v) => !!v);
                pushMessage(filteredMessages);
            }
            setLoading(false);
        })
            .catch((err) => {
            setLoading(false);
            setError(`Failed to query messages from store: ${(err === null || err === void 0 ? void 0 : err.message) || "no message"}`);
        });
        return () => {
            cancelled = true;
        };
        // TODO: missing dependency on options, it will prevent consecutive update if options change
    }, [node, decoder, pushMessage, setError, setLoading]);
    return {
        error,
        isLoading,
        messages,
    };
};

const WakuContext = React.createContext({
    node: undefined,
    isLoading: false,
    error: undefined,
});
/**
 * Hook to retrieve Waku node from Context. By default generic Waku type will be used.
 * @example
 * const { node, isLoading, error } = useWaku<LightNode>();
 * @example
 * const { node, isLoading, error } = useWaku<RelayNode>();
 * @example
 * const { node, isLoading, error } = useWaku<FullNode>();
 * @example
 * const { node, isLoading, error } = useWaku();
 * @returns WakuContext
 */
const useWaku = () => React.useContext(WakuContext);
/**
 * Provider for creating Light Node based on options passed.
 * @example
 * const App = (props) => (
 *  <LightNodeProvider options={{...}}>
 *      <Component />
 *  </LightNodeProvider>
 * );
 * const Component = (props) => {
 *  const { node, isLoading, error } = useWaku<LightNode>();
 *  ...
 * };
 * @param {Object} props - options to create a node and other React props
 * @param {LightNodeOptions} props.options - optional options for creating Light Node
 * @param {Protocols} props.protocols - optional protocols list to initiate node with
 * @returns React Light Node provider component
 */
const LightNodeProvider = (props) => {
    const result = useCreateLightNode({
        options: props.options,
        protocols: props.protocols,
    });
    return (React.createElement(WakuContext.Provider, { value: result }, props.children));
};
/**
 * Provider for creating Relay Node based on options passed.
 * @example
 * const App = (props) => (
 *  <RelayNodeProvider options={{...}}>
 *      <Component />
 *  </RelayNodeProvider>
 * );
 * const Component = (props) => {
 *  const { node, isLoading, error } = useWaku<RelayNode>();
 *  ...
 * };
 * @param {Object} props - options to create a node and other React props
 * @param {RelayNodeOptions} props.options - optional options for creating Relay Node
 * @param {Protocols} props.protocols - optional protocols list to initiate node with
 * @returns React Relay Node provider component
 */
const RelayNodeProvider = (props) => {
    const result = useCreateRelayNode({
        options: props.options,
        protocols: props.protocols,
    });
    return (React.createElement(WakuContext.Provider, { value: result }, props.children));
};

export { ContentPairProvider, LightNodeProvider, RelayNodeProvider, useContentPair, useCreateContentPair, useCreateLightNode, useCreateRelayNode, useFilterMessages, useLightPush, useStoreMessages, useWaku };
//# sourceMappingURL=index.esm.mjs.map
