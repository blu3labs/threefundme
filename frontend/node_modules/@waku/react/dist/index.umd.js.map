{"version":3,"file":"index.umd.js","sources":["../src/useCreatContentPair.ts","../src/ContentPairProvider.tsx","../src/useCreateWaku.ts","../src/WakuProvider.tsx","../src/useFilterMessages.ts","../src/useLightPush.ts","../src/useStoreMessages.ts"],"sourcesContent":["import React from \"react\";\nimport { createDecoder, createEncoder, waku } from \"@waku/sdk\";\n\nimport type { ContentPair } from \"./types\";\n\n/**\n * Creates Encoder / Decoder pair for a given contentTopic.\n * @param {string} contentTopic - topic to orient to\n * @param {boolean} ephemeral - makes messages ephemeral, default to false\n * @returns {Object} Encoder / Decoder pair\n */\nexport const useCreateContentPair = (\n  contentTopic: string,\n  ephemeral = false,\n): ContentPair => {\n  const [encoder, setEncoder] = React.useState<waku.Encoder>(\n    createEncoder({ contentTopic, ephemeral }),\n  );\n  const [decoder, setDecoder] = React.useState<waku.Decoder>(\n    createDecoder(contentTopic),\n  );\n\n  React.useEffect(() => {\n    setEncoder(createEncoder({ contentTopic, ephemeral }));\n    setDecoder(createDecoder(contentTopic));\n  }, [contentTopic, ephemeral]);\n\n  return {\n    encoder,\n    decoder,\n  };\n};\n","import React from \"react\";\n\nimport type { ContentPair, ReactChildrenProps } from \"./types\";\nimport { useCreateContentPair } from \"./useCreatContentPair\";\n\ntype ContentPairContextType = Partial<ContentPair>;\n\nconst ContentPairContext = React.createContext<ContentPairContextType>({\n  decoder: undefined,\n  encoder: undefined,\n});\n\n/**\n * Hook to retrieve Encoder/Decoder pair from Context.\n * @example\n * const { encoder, decoder } = useContentPair();\n * @returns {Object} { encoder, decoder }\n */\nexport const useContentPair = (): ContentPairContextType =>\n  React.useContext(ContentPairContext);\n\ntype ContentPairProviderProps = ReactChildrenProps & {\n  contentTopic: string;\n  ephemeral?: boolean;\n};\n\n/**\n * Provider for creating Encoder/Decoder pair based on contentTopic\n * @example\n * const App = (props) => (\n *  <ContentPairProvider contentTopic=\"/toy-chat/2/huilong/proto\">\n *      <Component />\n *  </ContentPairProvider>\n * );\n * const Component = (props) => {\n *  const { encoder, decoder } = useContentPair();\n *  ...\n * };\n * @param {string} contentTopic - content topic for configuring the pair\n * @param {boolean} ephemeral - flag to set messages ephemeral according to RFC https://rfc.vac.dev/spec/14/\n * @returns React ContentPair Provider component\n */\nexport const ContentPairProvider: React.FunctionComponent<\n  ContentPairProviderProps\n> = (props) => {\n  const result = useCreateContentPair(props.contentTopic, props.ephemeral);\n\n  return (\n    <ContentPairContext.Provider value={result}>\n      {props.children}\n    </ContentPairContext.Provider>\n  );\n};\n","import React from \"react\";\nimport type { LightNode, RelayNode, Waku } from \"@waku/interfaces\";\nimport { createLightNode, createRelayNode, waitForRemotePeer } from \"@waku/sdk\";\n\nimport type {\n  BootstrapNodeOptions,\n  CrateNodeResult,\n  LightNodeOptions,\n  RelayNodeOptions,\n} from \"./types\";\n\ntype NodeFactory<N, T = {}> = (options?: T) => Promise<N>;\n\ntype CreateNodeParams<N extends Waku, T = {}> = BootstrapNodeOptions<T> & {\n  factory: NodeFactory<N, T>;\n};\n\nconst useCreateNode = <N extends Waku, T = {}>(\n  params: CreateNodeParams<N, T>,\n): CrateNodeResult<N> => {\n  const { factory, options, protocols = [] } = params;\n\n  const [node, setNode] = React.useState<N | undefined>(undefined);\n  const [isLoading, setLoading] = React.useState<boolean>(true);\n  const [error, setError] = React.useState<undefined | string>(undefined);\n\n  React.useEffect(() => {\n    let cancelled = false;\n    setLoading(true);\n\n    factory(options)\n      .then(async (node) => {\n        if (cancelled) {\n          return;\n        }\n\n        await node.start();\n        await waitForRemotePeer(node, protocols);\n\n        setNode(node);\n        setLoading(false);\n      })\n      .catch((err) => {\n        setLoading(false);\n        setError(`Failed at creating node: ${err?.message || \"no message\"}`);\n      });\n\n    return () => {\n      cancelled = true;\n    };\n    // TODO: missing any dependencies, it will prevent consecutive update if options change\n  }, []);\n\n  return {\n    node,\n    error,\n    isLoading,\n  };\n};\n\n/**\n * Create Light Node helper hook.\n * @param {Object} params - optional params to configure & bootstrap node\n * @returns {CrateWakuHook} node, loading state and error\n */\nexport const useCreateLightNode = (\n  params?: BootstrapNodeOptions<LightNodeOptions>,\n) => {\n  return useCreateNode<LightNode, LightNodeOptions>({\n    ...params,\n    factory: createLightNode,\n  });\n};\n\n/**\n * Create Relay Node helper hook.\n * @param {Object} params - optional params to configure & bootstrap node\n * @returns {CrateWakuHook} node, loading state and error\n */\nexport const useCreateRelayNode = (\n  params?: BootstrapNodeOptions<RelayNodeOptions>,\n) => {\n  return useCreateNode<RelayNode, RelayNodeOptions>({\n    ...params,\n    factory: createRelayNode,\n  });\n};\n","import React from \"react\";\nimport type { Waku } from \"@waku/interfaces\";\n\nimport type {\n  BootstrapNodeOptions,\n  CrateNodeResult,\n  LightNodeOptions,\n  ReactChildrenProps,\n  RelayNodeOptions,\n} from \"./types\";\nimport { useCreateLightNode, useCreateRelayNode } from \"./useCreateWaku\";\n\ntype WakuContextType<T extends Waku> = CrateNodeResult<T>;\n\nconst WakuContext = React.createContext<WakuContextType<Waku>>({\n  node: undefined,\n  isLoading: false,\n  error: undefined,\n});\n\n/**\n * Hook to retrieve Waku node from Context. By default generic Waku type will be used.\n * @example\n * const { node, isLoading, error } = useWaku<LightNode>();\n * @example\n * const { node, isLoading, error } = useWaku<RelayNode>();\n * @example\n * const { node, isLoading, error } = useWaku<FullNode>();\n * @example\n * const { node, isLoading, error } = useWaku();\n * @returns WakuContext\n */\nexport const useWaku = <T extends Waku>(): WakuContextType<T> =>\n  React.useContext(WakuContext) as WakuContextType<T>;\n\ntype ProviderProps<T> = ReactChildrenProps & BootstrapNodeOptions<T>;\n\n/**\n * Provider for creating Light Node based on options passed.\n * @example\n * const App = (props) => (\n *  <LightNodeProvider options={{...}}>\n *      <Component />\n *  </LightNodeProvider>\n * );\n * const Component = (props) => {\n *  const { node, isLoading, error } = useWaku<LightNode>();\n *  ...\n * };\n * @param {Object} props - options to create a node and other React props\n * @param {LightNodeOptions} props.options - optional options for creating Light Node\n * @param {Protocols} props.protocols - optional protocols list to initiate node with\n * @returns React Light Node provider component\n */\nexport const LightNodeProvider: React.FunctionComponent<\n  ProviderProps<LightNodeOptions>\n> = (props) => {\n  const result = useCreateLightNode({\n    options: props.options,\n    protocols: props.protocols,\n  });\n\n  return (\n    <WakuContext.Provider value={result}>{props.children}</WakuContext.Provider>\n  );\n};\n\n/**\n * Provider for creating Relay Node based on options passed.\n * @example\n * const App = (props) => (\n *  <RelayNodeProvider options={{...}}>\n *      <Component />\n *  </RelayNodeProvider>\n * );\n * const Component = (props) => {\n *  const { node, isLoading, error } = useWaku<RelayNode>();\n *  ...\n * };\n * @param {Object} props - options to create a node and other React props\n * @param {RelayNodeOptions} props.options - optional options for creating Relay Node\n * @param {Protocols} props.protocols - optional protocols list to initiate node with\n * @returns React Relay Node provider component\n */\nexport const RelayNodeProvider: React.FunctionComponent<\n  ProviderProps<RelayNodeOptions>\n> = (props) => {\n  const result = useCreateRelayNode({\n    options: props.options,\n    protocols: props.protocols,\n  });\n\n  return (\n    <WakuContext.Provider value={result}>{props.children}</WakuContext.Provider>\n  );\n};\n","import React from \"react\";\nimport type {\n  IDecodedMessage,\n  IDecoder,\n  IFilter,\n  Unsubscribe,\n  Waku,\n} from \"@waku/interfaces\";\n\nimport type { HookState } from \"./types\";\n\ntype AbstractFilterNode = Waku & {\n  filter: IFilter;\n};\n\ntype UseFilterMessagesParams = {\n  node: undefined | AbstractFilterNode;\n  decoder: undefined | IDecoder<IDecodedMessage>;\n};\n\ntype UseFilterMessagesResult = HookState & {\n  messages: IDecodedMessage[];\n};\n\n/**\n * Returns messages from Filter subscription and keeps them up to date\n * @example\n * const { isLoading, error, message } = useFilterMessages({node, decoder});\n * @param {Object} node - node that implements Filter, hook does nothing if undefined\n * @param {Object} decoder - decoder to use for subscribing, hook does nothing if undefined\n * @returns {Object} hook state (isLoading, error) and messages array\n */\nexport const useFilterMessages = (\n  params: UseFilterMessagesParams,\n): UseFilterMessagesResult => {\n  const { node, decoder } = params;\n\n  const [error, setError] = React.useState<undefined | string>(undefined);\n  const [isLoading, setLoading] = React.useState<boolean>(false);\n  const [messages, setMessage] = React.useState<IDecodedMessage[]>([]);\n\n  const pushMessage = React.useCallback(\n    (message: IDecodedMessage): void => {\n      if (!message) {\n        return;\n      }\n\n      setMessage((prev) => [...prev, message]);\n    },\n    [setMessage],\n  );\n\n  React.useEffect(() => {\n    if (!node || !decoder) {\n      return;\n    }\n\n    let unsubscribe: null | Unsubscribe = null;\n    setLoading(true);\n\n    (node.filter.subscribe([decoder], pushMessage) as Promise<Unsubscribe>)\n      .then((unsubscribeFn) => {\n        setLoading(false);\n        unsubscribe = unsubscribeFn;\n      })\n      .catch((err) => {\n        setLoading(false);\n        setError(\n          `Failed to subscribe to filer: ${err?.message || \"no message\"}`,\n        );\n      });\n\n    return () => {\n      unsubscribe?.();\n    };\n  }, [node, decoder, pushMessage, setError, setLoading]);\n\n  return {\n    error,\n    messages,\n    isLoading,\n  };\n};\n","import React from \"react\";\nimport type {\n  IEncoder,\n  ILightPush,\n  IMessage,\n  SendResult,\n  Waku,\n} from \"@waku/interfaces\";\n\ntype AbstractLightPushNode = Waku & {\n  lightPush: ILightPush;\n};\n\ntype UseLightPushParams = {\n  encoder: undefined | IEncoder;\n  node: undefined | AbstractLightPushNode;\n};\n\ntype PushFn = (message: IMessage) => Promise<SendResult>;\n\ntype UseLightPushResult = {\n  push?: undefined | PushFn;\n};\n\n/**\n * Returns light push methods bound to node and encoder\n * @param {Object} params.node - node that implements ILightPush, hook does nothing if empty\n * @param {Object} params.encoder - encoder for processing messages, hook does nothing if empty\n * @returns {Object} methods of ILightPush such as push\n */\nexport const useLightPush = (\n  params: UseLightPushParams,\n): UseLightPushResult => {\n  const { node, encoder } = params;\n\n  const push = React.useCallback<PushFn>(\n    (message) => {\n      return node!.lightPush.send(encoder as IEncoder, message);\n    },\n    [node, encoder],\n  );\n\n  if (!node && !encoder) {\n    return {};\n  }\n\n  return {\n    push,\n  };\n};\n","import React from \"react\";\nimport type {\n  IDecodedMessage,\n  IDecoder,\n  IStore,\n  StoreQueryOptions,\n  Waku,\n} from \"@waku/interfaces\";\n\nimport type { HookState } from \"./types\";\n\ntype AbstractStoreNode = Waku & {\n  store: IStore;\n};\n\ntype UseStoreMessagesParams = {\n  node: undefined | AbstractStoreNode;\n  decoder: undefined | IDecoder<IDecodedMessage>;\n  options: StoreQueryOptions;\n};\n\ntype UseStoreMessagesResult = HookState & {\n  messages: IDecodedMessage[];\n};\n\n/**\n * Hook for retrieving messages from Store protocol based on options\n * @example\n * const { isLoading, error, messages } = useStoreMessages({node, decoder, options});\n * @param {Object} node - node that implement Store, hook does nothing if undefined\n * @param {Object} decoder - decoder to use for getting messages, hook does nothing if undefined\n * @param {StoreQueryOptions} options - options to initiate query to get messages\n * @returns {Object} hook state (isLoading, error) and messages array\n */\nexport const useStoreMessages = (\n  params: UseStoreMessagesParams,\n): UseStoreMessagesResult => {\n  const { node, decoder, options } = params;\n\n  const [error, setError] = React.useState<undefined | string>(undefined);\n  const [isLoading, setLoading] = React.useState<boolean>(false);\n  const [messages, setMessage] = React.useState<IDecodedMessage[]>([]);\n\n  const pushMessage = React.useCallback(\n    (newMessages: IDecodedMessage[]): void => {\n      if (!newMessages || !newMessages.length) {\n        return;\n      }\n\n      setMessage((prev) => [...prev, ...newMessages]);\n    },\n    [setMessage],\n  );\n\n  React.useEffect(() => {\n    if (!node || !decoder) {\n      return;\n    }\n\n    let cancelled = false;\n    setLoading(true);\n\n    Promise.resolve()\n      .then(async () => {\n        for await (const promises of node.store.queryGenerator(\n          [decoder],\n          options,\n        )) {\n          if (cancelled) {\n            return;\n          }\n\n          const messagesRaw = await Promise.all(promises);\n          const filteredMessages = messagesRaw.filter(\n            (v): v is IDecodedMessage => !!v,\n          );\n\n          pushMessage(filteredMessages);\n        }\n\n        setLoading(false);\n      })\n      .catch((err) => {\n        setLoading(false);\n        setError(\n          `Failed to query messages from store: ${\n            err?.message || \"no message\"\n          }`,\n        );\n      });\n\n    return () => {\n      cancelled = true;\n    };\n    // TODO: missing dependency on options, it will prevent consecutive update if options change\n  }, [node, decoder, pushMessage, setError, setLoading]);\n\n  return {\n    error,\n    isLoading,\n    messages,\n  };\n};\n"],"names":["useCreateContentPair","contentTopic","ephemeral","encoder","setEncoder","React","useState","createEncoder","decoder","setDecoder","createDecoder","useEffect","ContentPairContext","createContext","undefined","useCreateNode","params","factory","options","protocols","node","setNode","isLoading","setLoading","error","setError","cancelled","then","async","start","waitForRemotePeer","catch","err","message","useCreateLightNode","createLightNode","useCreateRelayNode","createRelayNode","WakuContext","props","result","createElement","Provider","value","children","useContext","messages","setMessage","pushMessage","useCallback","prev","unsubscribe","filter","subscribe","unsubscribeFn","push","lightPush","send","newMessages","length","Promise","resolve","promises","store","queryGenerator","filteredMessages","all","v"],"mappings":"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"}