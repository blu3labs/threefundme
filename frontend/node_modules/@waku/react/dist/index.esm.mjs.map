{"version":3,"file":"index.esm.mjs","sources":["../src/useCreatContentPair.ts","../src/ContentPairProvider.tsx","../src/useCreateWaku.ts","../src/useFilterMessages.ts","../src/useLightPush.ts","../src/useStoreMessages.ts","../src/WakuProvider.tsx"],"sourcesContent":["import React from \"react\";\nimport { createDecoder, createEncoder, waku } from \"@waku/sdk\";\n\nimport type { ContentPair } from \"./types\";\n\n/**\n * Creates Encoder / Decoder pair for a given contentTopic.\n * @param {string} contentTopic - topic to orient to\n * @param {boolean} ephemeral - makes messages ephemeral, default to false\n * @returns {Object} Encoder / Decoder pair\n */\nexport const useCreateContentPair = (\n  contentTopic: string,\n  ephemeral = false,\n): ContentPair => {\n  const [encoder, setEncoder] = React.useState<waku.Encoder>(\n    createEncoder({ contentTopic, ephemeral }),\n  );\n  const [decoder, setDecoder] = React.useState<waku.Decoder>(\n    createDecoder(contentTopic),\n  );\n\n  React.useEffect(() => {\n    setEncoder(createEncoder({ contentTopic, ephemeral }));\n    setDecoder(createDecoder(contentTopic));\n  }, [contentTopic, ephemeral]);\n\n  return {\n    encoder,\n    decoder,\n  };\n};\n","import React from \"react\";\n\nimport type { ContentPair, ReactChildrenProps } from \"./types\";\nimport { useCreateContentPair } from \"./useCreatContentPair\";\n\ntype ContentPairContextType = Partial<ContentPair>;\n\nconst ContentPairContext = React.createContext<ContentPairContextType>({\n  decoder: undefined,\n  encoder: undefined,\n});\n\n/**\n * Hook to retrieve Encoder/Decoder pair from Context.\n * @example\n * const { encoder, decoder } = useContentPair();\n * @returns {Object} { encoder, decoder }\n */\nexport const useContentPair = (): ContentPairContextType =>\n  React.useContext(ContentPairContext);\n\ntype ContentPairProviderProps = ReactChildrenProps & {\n  contentTopic: string;\n  ephemeral?: boolean;\n};\n\n/**\n * Provider for creating Encoder/Decoder pair based on contentTopic\n * @example\n * const App = (props) => (\n *  <ContentPairProvider contentTopic=\"/toy-chat/2/huilong/proto\">\n *      <Component />\n *  </ContentPairProvider>\n * );\n * const Component = (props) => {\n *  const { encoder, decoder } = useContentPair();\n *  ...\n * };\n * @param {string} contentTopic - content topic for configuring the pair\n * @param {boolean} ephemeral - flag to set messages ephemeral according to RFC https://rfc.vac.dev/spec/14/\n * @returns React ContentPair Provider component\n */\nexport const ContentPairProvider: React.FunctionComponent<\n  ContentPairProviderProps\n> = (props) => {\n  const result = useCreateContentPair(props.contentTopic, props.ephemeral);\n\n  return (\n    <ContentPairContext.Provider value={result}>\n      {props.children}\n    </ContentPairContext.Provider>\n  );\n};\n","import React from \"react\";\nimport type { LightNode, RelayNode, Waku } from \"@waku/interfaces\";\nimport { createLightNode, createRelayNode, waitForRemotePeer } from \"@waku/sdk\";\n\nimport type {\n  BootstrapNodeOptions,\n  CrateNodeResult,\n  LightNodeOptions,\n  RelayNodeOptions,\n} from \"./types\";\n\ntype NodeFactory<N, T = {}> = (options?: T) => Promise<N>;\n\ntype CreateNodeParams<N extends Waku, T = {}> = BootstrapNodeOptions<T> & {\n  factory: NodeFactory<N, T>;\n};\n\nconst useCreateNode = <N extends Waku, T = {}>(\n  params: CreateNodeParams<N, T>,\n): CrateNodeResult<N> => {\n  const { factory, options, protocols = [] } = params;\n\n  const [node, setNode] = React.useState<N | undefined>(undefined);\n  const [isLoading, setLoading] = React.useState<boolean>(true);\n  const [error, setError] = React.useState<undefined | string>(undefined);\n\n  React.useEffect(() => {\n    let cancelled = false;\n    setLoading(true);\n\n    factory(options)\n      .then(async (node) => {\n        if (cancelled) {\n          return;\n        }\n\n        await node.start();\n        await waitForRemotePeer(node, protocols);\n\n        setNode(node);\n        setLoading(false);\n      })\n      .catch((err) => {\n        setLoading(false);\n        setError(`Failed at creating node: ${err?.message || \"no message\"}`);\n      });\n\n    return () => {\n      cancelled = true;\n    };\n    // TODO: missing any dependencies, it will prevent consecutive update if options change\n  }, []);\n\n  return {\n    node,\n    error,\n    isLoading,\n  };\n};\n\n/**\n * Create Light Node helper hook.\n * @param {Object} params - optional params to configure & bootstrap node\n * @returns {CrateWakuHook} node, loading state and error\n */\nexport const useCreateLightNode = (\n  params?: BootstrapNodeOptions<LightNodeOptions>,\n) => {\n  return useCreateNode<LightNode, LightNodeOptions>({\n    ...params,\n    factory: createLightNode,\n  });\n};\n\n/**\n * Create Relay Node helper hook.\n * @param {Object} params - optional params to configure & bootstrap node\n * @returns {CrateWakuHook} node, loading state and error\n */\nexport const useCreateRelayNode = (\n  params?: BootstrapNodeOptions<RelayNodeOptions>,\n) => {\n  return useCreateNode<RelayNode, RelayNodeOptions>({\n    ...params,\n    factory: createRelayNode,\n  });\n};\n","import React from \"react\";\nimport type {\n  IDecodedMessage,\n  IDecoder,\n  IFilter,\n  Unsubscribe,\n  Waku,\n} from \"@waku/interfaces\";\n\nimport type { HookState } from \"./types\";\n\ntype AbstractFilterNode = Waku & {\n  filter: IFilter;\n};\n\ntype UseFilterMessagesParams = {\n  node: undefined | AbstractFilterNode;\n  decoder: undefined | IDecoder<IDecodedMessage>;\n};\n\ntype UseFilterMessagesResult = HookState & {\n  messages: IDecodedMessage[];\n};\n\n/**\n * Returns messages from Filter subscription and keeps them up to date\n * @example\n * const { isLoading, error, message } = useFilterMessages({node, decoder});\n * @param {Object} node - node that implements Filter, hook does nothing if undefined\n * @param {Object} decoder - decoder to use for subscribing, hook does nothing if undefined\n * @returns {Object} hook state (isLoading, error) and messages array\n */\nexport const useFilterMessages = (\n  params: UseFilterMessagesParams,\n): UseFilterMessagesResult => {\n  const { node, decoder } = params;\n\n  const [error, setError] = React.useState<undefined | string>(undefined);\n  const [isLoading, setLoading] = React.useState<boolean>(false);\n  const [messages, setMessage] = React.useState<IDecodedMessage[]>([]);\n\n  const pushMessage = React.useCallback(\n    (message: IDecodedMessage): void => {\n      if (!message) {\n        return;\n      }\n\n      setMessage((prev) => [...prev, message]);\n    },\n    [setMessage],\n  );\n\n  React.useEffect(() => {\n    if (!node || !decoder) {\n      return;\n    }\n\n    let unsubscribe: null | Unsubscribe = null;\n    setLoading(true);\n\n    (node.filter.subscribe([decoder], pushMessage) as Promise<Unsubscribe>)\n      .then((unsubscribeFn) => {\n        setLoading(false);\n        unsubscribe = unsubscribeFn;\n      })\n      .catch((err) => {\n        setLoading(false);\n        setError(\n          `Failed to subscribe to filer: ${err?.message || \"no message\"}`,\n        );\n      });\n\n    return () => {\n      unsubscribe?.();\n    };\n  }, [node, decoder, pushMessage, setError, setLoading]);\n\n  return {\n    error,\n    messages,\n    isLoading,\n  };\n};\n","import React from \"react\";\nimport type {\n  IEncoder,\n  ILightPush,\n  IMessage,\n  SendResult,\n  Waku,\n} from \"@waku/interfaces\";\n\ntype AbstractLightPushNode = Waku & {\n  lightPush: ILightPush;\n};\n\ntype UseLightPushParams = {\n  encoder: undefined | IEncoder;\n  node: undefined | AbstractLightPushNode;\n};\n\ntype PushFn = (message: IMessage) => Promise<SendResult>;\n\ntype UseLightPushResult = {\n  push?: undefined | PushFn;\n};\n\n/**\n * Returns light push methods bound to node and encoder\n * @param {Object} params.node - node that implements ILightPush, hook does nothing if empty\n * @param {Object} params.encoder - encoder for processing messages, hook does nothing if empty\n * @returns {Object} methods of ILightPush such as push\n */\nexport const useLightPush = (\n  params: UseLightPushParams,\n): UseLightPushResult => {\n  const { node, encoder } = params;\n\n  const push = React.useCallback<PushFn>(\n    (message) => {\n      return node!.lightPush.send(encoder as IEncoder, message);\n    },\n    [node, encoder],\n  );\n\n  if (!node && !encoder) {\n    return {};\n  }\n\n  return {\n    push,\n  };\n};\n","import React from \"react\";\nimport type {\n  IDecodedMessage,\n  IDecoder,\n  IStore,\n  StoreQueryOptions,\n  Waku,\n} from \"@waku/interfaces\";\n\nimport type { HookState } from \"./types\";\n\ntype AbstractStoreNode = Waku & {\n  store: IStore;\n};\n\ntype UseStoreMessagesParams = {\n  node: undefined | AbstractStoreNode;\n  decoder: undefined | IDecoder<IDecodedMessage>;\n  options: StoreQueryOptions;\n};\n\ntype UseStoreMessagesResult = HookState & {\n  messages: IDecodedMessage[];\n};\n\n/**\n * Hook for retrieving messages from Store protocol based on options\n * @example\n * const { isLoading, error, messages } = useStoreMessages({node, decoder, options});\n * @param {Object} node - node that implement Store, hook does nothing if undefined\n * @param {Object} decoder - decoder to use for getting messages, hook does nothing if undefined\n * @param {StoreQueryOptions} options - options to initiate query to get messages\n * @returns {Object} hook state (isLoading, error) and messages array\n */\nexport const useStoreMessages = (\n  params: UseStoreMessagesParams,\n): UseStoreMessagesResult => {\n  const { node, decoder, options } = params;\n\n  const [error, setError] = React.useState<undefined | string>(undefined);\n  const [isLoading, setLoading] = React.useState<boolean>(false);\n  const [messages, setMessage] = React.useState<IDecodedMessage[]>([]);\n\n  const pushMessage = React.useCallback(\n    (newMessages: IDecodedMessage[]): void => {\n      if (!newMessages || !newMessages.length) {\n        return;\n      }\n\n      setMessage((prev) => [...prev, ...newMessages]);\n    },\n    [setMessage],\n  );\n\n  React.useEffect(() => {\n    if (!node || !decoder) {\n      return;\n    }\n\n    let cancelled = false;\n    setLoading(true);\n\n    Promise.resolve()\n      .then(async () => {\n        for await (const promises of node.store.queryGenerator(\n          [decoder],\n          options,\n        )) {\n          if (cancelled) {\n            return;\n          }\n\n          const messagesRaw = await Promise.all(promises);\n          const filteredMessages = messagesRaw.filter(\n            (v): v is IDecodedMessage => !!v,\n          );\n\n          pushMessage(filteredMessages);\n        }\n\n        setLoading(false);\n      })\n      .catch((err) => {\n        setLoading(false);\n        setError(\n          `Failed to query messages from store: ${\n            err?.message || \"no message\"\n          }`,\n        );\n      });\n\n    return () => {\n      cancelled = true;\n    };\n    // TODO: missing dependency on options, it will prevent consecutive update if options change\n  }, [node, decoder, pushMessage, setError, setLoading]);\n\n  return {\n    error,\n    isLoading,\n    messages,\n  };\n};\n","import React from \"react\";\nimport type { Waku } from \"@waku/interfaces\";\n\nimport type {\n  BootstrapNodeOptions,\n  CrateNodeResult,\n  LightNodeOptions,\n  ReactChildrenProps,\n  RelayNodeOptions,\n} from \"./types\";\nimport { useCreateLightNode, useCreateRelayNode } from \"./useCreateWaku\";\n\ntype WakuContextType<T extends Waku> = CrateNodeResult<T>;\n\nconst WakuContext = React.createContext<WakuContextType<Waku>>({\n  node: undefined,\n  isLoading: false,\n  error: undefined,\n});\n\n/**\n * Hook to retrieve Waku node from Context. By default generic Waku type will be used.\n * @example\n * const { node, isLoading, error } = useWaku<LightNode>();\n * @example\n * const { node, isLoading, error } = useWaku<RelayNode>();\n * @example\n * const { node, isLoading, error } = useWaku<FullNode>();\n * @example\n * const { node, isLoading, error } = useWaku();\n * @returns WakuContext\n */\nexport const useWaku = <T extends Waku>(): WakuContextType<T> =>\n  React.useContext(WakuContext) as WakuContextType<T>;\n\ntype ProviderProps<T> = ReactChildrenProps & BootstrapNodeOptions<T>;\n\n/**\n * Provider for creating Light Node based on options passed.\n * @example\n * const App = (props) => (\n *  <LightNodeProvider options={{...}}>\n *      <Component />\n *  </LightNodeProvider>\n * );\n * const Component = (props) => {\n *  const { node, isLoading, error } = useWaku<LightNode>();\n *  ...\n * };\n * @param {Object} props - options to create a node and other React props\n * @param {LightNodeOptions} props.options - optional options for creating Light Node\n * @param {Protocols} props.protocols - optional protocols list to initiate node with\n * @returns React Light Node provider component\n */\nexport const LightNodeProvider: React.FunctionComponent<\n  ProviderProps<LightNodeOptions>\n> = (props) => {\n  const result = useCreateLightNode({\n    options: props.options,\n    protocols: props.protocols,\n  });\n\n  return (\n    <WakuContext.Provider value={result}>{props.children}</WakuContext.Provider>\n  );\n};\n\n/**\n * Provider for creating Relay Node based on options passed.\n * @example\n * const App = (props) => (\n *  <RelayNodeProvider options={{...}}>\n *      <Component />\n *  </RelayNodeProvider>\n * );\n * const Component = (props) => {\n *  const { node, isLoading, error } = useWaku<RelayNode>();\n *  ...\n * };\n * @param {Object} props - options to create a node and other React props\n * @param {RelayNodeOptions} props.options - optional options for creating Relay Node\n * @param {Protocols} props.protocols - optional protocols list to initiate node with\n * @returns React Relay Node provider component\n */\nexport const RelayNodeProvider: React.FunctionComponent<\n  ProviderProps<RelayNodeOptions>\n> = (props) => {\n  const result = useCreateRelayNode({\n    options: props.options,\n    protocols: props.protocols,\n  });\n\n  return (\n    <WakuContext.Provider value={result}>{props.children}</WakuContext.Provider>\n  );\n};\n"],"names":[],"mappings":"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"}