import { L as Logger } from './index-27b91e3b.js';

// base-x encoding / decoding
// Copyright (c) 2018 base-x contributors
// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
// Distributed under the MIT software license, see the accompanying
// file LICENSE or http://www.opensource.org/licenses/mit-license.php.
function base (ALPHABET, name) {
  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up
  var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up
  function encode (source) {
    if (source instanceof Uint8Array) ; else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }
    if (source.length === 0) { return '' }
        // Skip & count leading zeroes.
    var zeroes = 0;
    var length = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
        // Allocate enough space in big-endian base58 representation.
    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;
    var b58 = new Uint8Array(size);
        // Process the bytes.
    while (pbegin !== pend) {
      var carry = source[pbegin];
            // Apply "b58 = b58 * 256 + ch".
      var i = 0;
      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {
        carry += (256 * b58[it1]) >>> 0;
        b58[it1] = (carry % BASE) >>> 0;
        carry = (carry / BASE) >>> 0;
      }
      if (carry !== 0) { throw new Error('Non-zero carry') }
      length = i;
      pbegin++;
    }
        // Skip leading zeroes in base58 result.
    var it2 = size - length;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
        // Translate the result into a string.
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }
    return str
  }
  function decodeUnsafe (source) {
    if (typeof source !== 'string') { throw new TypeError('Expected String') }
    if (source.length === 0) { return new Uint8Array() }
    var psz = 0;
        // Skip leading spaces.
    if (source[psz] === ' ') { return }
        // Skip and count leading '1's.
    var zeroes = 0;
    var length = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
        // Allocate enough space in big-endian base256 representation.
    var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.
    var b256 = new Uint8Array(size);
        // Process the characters.
    while (source[psz]) {
            // Decode character
      var carry = BASE_MAP[source.charCodeAt(psz)];
            // Invalid character
      if (carry === 255) { return }
      var i = 0;
      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {
        carry += (BASE * b256[it3]) >>> 0;
        b256[it3] = (carry % 256) >>> 0;
        carry = (carry / 256) >>> 0;
      }
      if (carry !== 0) { throw new Error('Non-zero carry') }
      length = i;
      psz++;
    }
        // Skip trailing spaces.
    if (source[psz] === ' ') { return }
        // Skip leading zeroes in b256.
    var it4 = size - length;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j = zeroes;
    while (it4 !== size) {
      vch[j++] = b256[it4++];
    }
    return vch
  }
  function decode (string) {
    var buffer = decodeUnsafe(string);
    if (buffer) { return buffer }
    throw new Error(`Non-${name} character`)
  }
  return {
    encode: encode,
    decodeUnsafe: decodeUnsafe,
    decode: decode
  }
}
var src = base;

var _brrp__multiformats_scope_baseX = src;

/**
 * @param {Uint8Array} aa
 * @param {Uint8Array} bb
 */
const equals = (aa, bb) => {
  if (aa === bb) return true
  if (aa.byteLength !== bb.byteLength) {
    return false
  }

  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false
    }
  }

  return true
};

/**
 * @param {ArrayBufferView|ArrayBuffer|Uint8Array} o
 * @returns {Uint8Array}
 */
const coerce = o => {
  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o
  if (o instanceof ArrayBuffer) return new Uint8Array(o)
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)
  }
  throw new Error('Unknown type, must be binary type')
};

/**
 * @param {string} str
 * @returns {Uint8Array}
 */
const fromString$1 = str => (new TextEncoder()).encode(str);

/**
 * @param {Uint8Array} b
 * @returns {string}
 */
const toString$1 = b => (new TextDecoder()).decode(b);

/**
 * Class represents both BaseEncoder and MultibaseEncoder meaning it
 * can be used to encode to multibase or base encode without multibase
 * prefix.
 *
 * @class
 * @template {string} Base
 * @template {string} Prefix
 * @implements {API.MultibaseEncoder<Prefix>}
 * @implements {API.BaseEncoder}
 */
class Encoder {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor (name, prefix, baseEncode) {
    this.name = name;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }

  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode (bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`
    } else {
      throw Error('Unknown type, must be binary type')
    }
  }
}

/**
 * @template {string} Prefix
 */
/**
 * Class represents both BaseDecoder and MultibaseDecoder so it could be used
 * to decode multibases (with matching prefix) or just base decode strings
 * with corresponding base encoding.
 *
 * @class
 * @template {string} Base
 * @template {string} Prefix
 * @implements {API.MultibaseDecoder<Prefix>}
 * @implements {API.UnibaseDecoder<Prefix>}
 * @implements {API.BaseDecoder}
 */
class Decoder {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor (name, prefix, baseDecode) {
    this.name = name;
    this.prefix = prefix;
    /* c8 ignore next 3 */
    if (prefix.codePointAt(0) === undefined) {
      throw new Error('Invalid prefix character')
    }
    /** @private */
    this.prefixCodePoint = /** @type {number} */ (prefix.codePointAt(0));
    this.baseDecode = baseDecode;
  }

  /**
   * @param {string} text
   */
  decode (text) {
    if (typeof text === 'string') {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`)
      }
      return this.baseDecode(text.slice(this.prefix.length))
    } else {
      throw Error('Can only multibase decode strings')
    }
  }

  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or (decoder) {
    return or(this, decoder)
  }
}

/**
 * @template {string} Prefix
 * @typedef {Record<Prefix, API.UnibaseDecoder<Prefix>>} Decoders
 */

/**
 * @template {string} Prefix
 * @implements {API.MultibaseDecoder<Prefix>}
 * @implements {API.CombobaseDecoder<Prefix>}
 */
class ComposedDecoder {
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor (decoders) {
    this.decoders = decoders;
  }

  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or (decoder) {
    return or(this, decoder)
  }

  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode (input) {
    const prefix = /** @type {Prefix} */ (input[0]);
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input)
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)
    }
  }
}

/**
 * @template {string} L
 * @template {string} R
 * @param {API.UnibaseDecoder<L>|API.CombobaseDecoder<L>} left
 * @param {API.UnibaseDecoder<R>|API.CombobaseDecoder<R>} right
 * @returns {ComposedDecoder<L|R>}
 */
const or = (left, right) => new ComposedDecoder(/** @type {Decoders<L|R>} */({
  ...(left.decoders || { [/** @type API.UnibaseDecoder<L> */(left).prefix]: left }),
  ...(right.decoders || { [/** @type API.UnibaseDecoder<R> */(right).prefix]: right })
}));

/**
 * @class
 * @template {string} Base
 * @template {string} Prefix
 * @implements {API.MultibaseCodec<Prefix>}
 * @implements {API.MultibaseEncoder<Prefix>}
 * @implements {API.MultibaseDecoder<Prefix>}
 * @implements {API.BaseCodec}
 * @implements {API.BaseEncoder}
 * @implements {API.BaseDecoder}
 */
class Codec {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor (name, prefix, baseEncode, baseDecode) {
    this.name = name;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder(name, prefix, baseEncode);
    this.decoder = new Decoder(name, prefix, baseDecode);
  }

  /**
   * @param {Uint8Array} input
   */
  encode (input) {
    return this.encoder.encode(input)
  }

  /**
   * @param {string} input
   */
  decode (input) {
    return this.decoder.decode(input)
  }
}

/**
 * @template {string} Base
 * @template {string} Prefix
 * @param {object} options
 * @param {Base} options.name
 * @param {Prefix} options.prefix
 * @param {(bytes:Uint8Array) => string} options.encode
 * @param {(input:string) => Uint8Array} options.decode
 * @returns {Codec<Base, Prefix>}
 */
const from = ({ name, prefix, encode, decode }) =>
  new Codec(name, prefix, encode, decode);

/**
 * @template {string} Base
 * @template {string} Prefix
 * @param {object} options
 * @param {Base} options.name
 * @param {Prefix} options.prefix
 * @param {string} options.alphabet
 * @returns {Codec<Base, Prefix>}
 */
const baseX = ({ prefix, name, alphabet }) => {
  const { encode, decode } = _brrp__multiformats_scope_baseX(alphabet, name);
  return from({
    prefix,
    name,
    encode,
    /**
     * @param {string} text
     */
    decode: text => coerce(decode(text))
  })
};

/**
 * @param {string} string
 * @param {string} alphabet
 * @param {number} bitsPerChar
 * @param {string} name
 * @returns {Uint8Array}
 */
const decode$1 = (string, alphabet, bitsPerChar, name) => {
  // Build the character lookup table:
  /** @type {Record<string, number>} */
  const codes = {};
  for (let i = 0; i < alphabet.length; ++i) {
    codes[alphabet[i]] = i;
  }

  // Count the padding bytes:
  let end = string.length;
  while (string[end - 1] === '=') {
    --end;
  }

  // Allocate the output:
  const out = new Uint8Array((end * bitsPerChar / 8) | 0);

  // Parse the data:
  let bits = 0; // Number of bits currently in the buffer
  let buffer = 0; // Bits waiting to be written out, MSB first
  let written = 0; // Next byte to write
  for (let i = 0; i < end; ++i) {
    // Read one character from the string:
    const value = codes[string[i]];
    if (value === undefined) {
      throw new SyntaxError(`Non-${name} character`)
    }

    // Append the bits to the buffer:
    buffer = (buffer << bitsPerChar) | value;
    bits += bitsPerChar;

    // Write out some bits if the buffer has a byte's worth:
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 0xff & (buffer >> bits);
    }
  }

  // Verify that we have received just enough bits:
  if (bits >= bitsPerChar || 0xff & (buffer << (8 - bits))) {
    throw new SyntaxError('Unexpected end of data')
  }

  return out
};

/**
 * @param {Uint8Array} data
 * @param {string} alphabet
 * @param {number} bitsPerChar
 * @returns {string}
 */
const encode$1 = (data, alphabet, bitsPerChar) => {
  const pad = alphabet[alphabet.length - 1] === '=';
  const mask = (1 << bitsPerChar) - 1;
  let out = '';

  let bits = 0; // Number of bits currently in the buffer
  let buffer = 0; // Bits waiting to be written out, MSB first
  for (let i = 0; i < data.length; ++i) {
    // Slurp data into the buffer:
    buffer = (buffer << 8) | data[i];
    bits += 8;

    // Write out as much as we can:
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet[mask & (buffer >> bits)];
    }
  }

  // Partial character:
  if (bits) {
    out += alphabet[mask & (buffer << (bitsPerChar - bits))];
  }

  // Add padding characters until we hit a byte boundary:
  if (pad) {
    while ((out.length * bitsPerChar) & 7) {
      out += '=';
    }
  }

  return out
};

/**
 * RFC4648 Factory
 *
 * @template {string} Base
 * @template {string} Prefix
 * @param {object} options
 * @param {Base} options.name
 * @param {Prefix} options.prefix
 * @param {string} options.alphabet
 * @param {number} options.bitsPerChar
 */
const rfc4648 = ({ name, prefix, bitsPerChar, alphabet }) => {
  return from({
    prefix,
    name,
    encode (input) {
      return encode$1(input, alphabet, bitsPerChar)
    },
    decode (input) {
      return decode$1(input, alphabet, bitsPerChar, name)
    }
  })
};

const base58btc = baseX({
  name: 'base58btc',
  prefix: 'z',
  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
});

const base58flickr = baseX({
  name: 'base58flickr',
  prefix: 'Z',
  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'
});

var base58 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  base58btc: base58btc,
  base58flickr: base58flickr
});

const base32 = rfc4648({
  prefix: 'b',
  name: 'base32',
  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',
  bitsPerChar: 5
});

const base32upper = rfc4648({
  prefix: 'B',
  name: 'base32upper',
  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',
  bitsPerChar: 5
});

const base32pad = rfc4648({
  prefix: 'c',
  name: 'base32pad',
  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',
  bitsPerChar: 5
});

const base32padupper = rfc4648({
  prefix: 'C',
  name: 'base32padupper',
  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',
  bitsPerChar: 5
});

const base32hex = rfc4648({
  prefix: 'v',
  name: 'base32hex',
  alphabet: '0123456789abcdefghijklmnopqrstuv',
  bitsPerChar: 5
});

const base32hexupper = rfc4648({
  prefix: 'V',
  name: 'base32hexupper',
  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',
  bitsPerChar: 5
});

const base32hexpad = rfc4648({
  prefix: 't',
  name: 'base32hexpad',
  alphabet: '0123456789abcdefghijklmnopqrstuv=',
  bitsPerChar: 5
});

const base32hexpadupper = rfc4648({
  prefix: 'T',
  name: 'base32hexpadupper',
  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',
  bitsPerChar: 5
});

const base32z = rfc4648({
  prefix: 'h',
  name: 'base32z',
  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',
  bitsPerChar: 5
});

var base32$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  base32: base32,
  base32hex: base32hex,
  base32hexpad: base32hexpad,
  base32hexpadupper: base32hexpadupper,
  base32hexupper: base32hexupper,
  base32pad: base32pad,
  base32padupper: base32padupper,
  base32upper: base32upper,
  base32z: base32z
});

const base10 = baseX({
  prefix: '9',
  name: 'base10',
  alphabet: '0123456789'
});

var base10$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  base10: base10
});

// @ts-check


const base16 = rfc4648({
  prefix: 'f',
  name: 'base16',
  alphabet: '0123456789abcdef',
  bitsPerChar: 4
});

const base16upper = rfc4648({
  prefix: 'F',
  name: 'base16upper',
  alphabet: '0123456789ABCDEF',
  bitsPerChar: 4
});

var base16$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  base16: base16,
  base16upper: base16upper
});

// @ts-check


const base2 = rfc4648({
  prefix: '0',
  name: 'base2',
  alphabet: '01',
  bitsPerChar: 1
});

var base2$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  base2: base2
});

const alphabet = Array.from('🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂');
const alphabetBytesToChars = /** @type {string[]} */ (alphabet.reduce((p, c, i) => { p[i] = c; return p }, /** @type {string[]} */([])));
const alphabetCharsToBytes = /** @type {number[]} */ (alphabet.reduce((p, c, i) => { p[/** @type {number} */ (c.codePointAt(0))] = i; return p }, /** @type {number[]} */([])));

/**
 * @param {Uint8Array} data
 * @returns {string}
 */
function encode (data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars[c];
    return p
  }, '')
}

/**
 * @param {string} str
 * @returns {Uint8Array}
 */
function decode (str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes[/** @type {number} */ (char.codePointAt(0))];
    if (byt === undefined) {
      throw new Error(`Non-base256emoji character: ${char}`)
    }
    byts.push(byt);
  }
  return new Uint8Array(byts)
}

const base256emoji = from({
  prefix: '🚀',
  name: 'base256emoji',
  encode,
  decode
});

var base256emoji$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  base256emoji: base256emoji
});

const base36 = baseX({
  prefix: 'k',
  name: 'base36',
  alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'
});

const base36upper = baseX({
  prefix: 'K',
  name: 'base36upper',
  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'
});

var base36$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  base36: base36,
  base36upper: base36upper
});

// @ts-check


const base64 = rfc4648({
  prefix: 'm',
  name: 'base64',
  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
  bitsPerChar: 6
});

const base64pad = rfc4648({
  prefix: 'M',
  name: 'base64pad',
  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
  bitsPerChar: 6
});

const base64url = rfc4648({
  prefix: 'u',
  name: 'base64url',
  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',
  bitsPerChar: 6
});

const base64urlpad = rfc4648({
  prefix: 'U',
  name: 'base64urlpad',
  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',
  bitsPerChar: 6
});

var base64$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  base64: base64,
  base64pad: base64pad,
  base64url: base64url,
  base64urlpad: base64urlpad
});

// @ts-check


const base8 = rfc4648({
  prefix: '7',
  name: 'base8',
  alphabet: '01234567',
  bitsPerChar: 3
});

var base8$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  base8: base8
});

// @ts-check


const identity = from({
  prefix: '\x00',
  name: 'identity',
  encode: (buf) => toString$1(buf),
  decode: (str) => fromString$1(str)
});

var identityBase = /*#__PURE__*/Object.freeze({
  __proto__: null,
  identity: identity
});

// @ts-check

/**
 * @template T
 * @typedef {import('./interface.js').ByteView<T>} ByteView
 */

new TextEncoder();
new TextDecoder();

// @ts-check


const bases = { ...identityBase, ...base2$1, ...base8$1, ...base10$1, ...base16$1, ...base32$1, ...base36$1, ...base58, ...base64$1, ...base256emoji$1 };

/**
 * To guarantee Uint8Array semantics, convert nodejs Buffers
 * into vanilla Uint8Arrays
 */
function asUint8Array(buf) {
    if (globalThis.Buffer != null) {
        return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
    }
    return buf;
}

/**
 * Returns a `Uint8Array` of the requested size. Referenced memory will
 * be initialized to 0.
 */
function alloc(size = 0) {
    if (globalThis.Buffer?.alloc != null) {
        return asUint8Array(globalThis.Buffer.alloc(size));
    }
    return new Uint8Array(size);
}
/**
 * Where possible returns a Uint8Array of the requested size that references
 * uninitialized memory. Only use if you are certain you will immediately
 * overwrite every value in the returned `Uint8Array`.
 */
function allocUnsafe(size = 0) {
    if (globalThis.Buffer?.allocUnsafe != null) {
        return asUint8Array(globalThis.Buffer.allocUnsafe(size));
    }
    return new Uint8Array(size);
}

function createCodec(name, prefix, encode, decode) {
    return {
        name,
        prefix,
        encoder: {
            name,
            prefix,
            encode
        },
        decoder: {
            decode
        }
    };
}
const string = createCodec('utf8', 'u', (buf) => {
    const decoder = new TextDecoder('utf8');
    return 'u' + decoder.decode(buf);
}, (str) => {
    const encoder = new TextEncoder();
    return encoder.encode(str.substring(1));
});
const ascii = createCodec('ascii', 'a', (buf) => {
    let string = 'a';
    for (let i = 0; i < buf.length; i++) {
        string += String.fromCharCode(buf[i]);
    }
    return string;
}, (str) => {
    str = str.substring(1);
    const buf = allocUnsafe(str.length);
    for (let i = 0; i < str.length; i++) {
        buf[i] = str.charCodeAt(i);
    }
    return buf;
});
const BASES = {
    utf8: string,
    'utf-8': string,
    hex: bases.base16,
    latin1: ascii,
    ascii,
    binary: ascii,
    ...bases
};

/**
 * Turns a `Uint8Array` into a string.
 *
 * Supports `utf8`, `utf-8` and any encoding supported by the multibase module.
 *
 * Also `ascii` which is similar to node's 'binary' encoding.
 */
function toString(array, encoding = 'utf8') {
    const base = BASES[encoding];
    if (base == null) {
        throw new Error(`Unsupported encoding "${encoding}"`);
    }
    if ((encoding === 'utf8' || encoding === 'utf-8') && globalThis.Buffer != null && globalThis.Buffer.from != null) {
        return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString('utf8');
    }
    // strip multibase prefix
    return base.encoder.encode(array).substring(1);
}

/**
 * Create a `Uint8Array` from the passed string
 *
 * Supports `utf8`, `utf-8`, `hex`, and any encoding supported by the multiformats module.
 *
 * Also `ascii` which is similar to node's 'binary' encoding.
 */
function fromString(string, encoding = 'utf8') {
    const base = BASES[encoding];
    if (base == null) {
        throw new Error(`Unsupported encoding "${encoding}"`);
    }
    if ((encoding === 'utf8' || encoding === 'utf-8') && globalThis.Buffer != null && globalThis.Buffer.from != null) {
        return asUint8Array(globalThis.Buffer.from(string, 'utf-8'));
    }
    // add multibase prefix
    return base.decoder.decode(`${base.prefix}${string}`); // eslint-disable-line @typescript-eslint/restrict-template-expressions
}

var Protocols;
(function (Protocols) {
    Protocols["Relay"] = "relay";
    Protocols["Store"] = "store";
    Protocols["LightPush"] = "lightpush";
    Protocols["Filter"] = "filter";
})(Protocols || (Protocols = {}));
var SendError;
(function (SendError) {
    /** Could not determine the origin of the fault. Best to check connectivity and try again */
    SendError["GENERIC_FAIL"] = "Generic error";
    /**
     * Failure to protobuf encode the message. This is not recoverable and needs
     * further investigation.
     */
    SendError["ENCODE_FAILED"] = "Failed to encode";
    /**
     * Failure to protobuf decode the message. May be due to a remote peer issue,
     * ensuring that messages are sent via several peer enable mitigation of this error.
     */
    SendError["DECODE_FAILED"] = "Failed to decode";
    /**
     * The message payload is empty, making the message invalid. Ensure that a non-empty
     * payload is set on the outgoing message.
     */
    SendError["EMPTY_PAYLOAD"] = "Payload is empty";
    /**
     * The message size is above the maximum message size allowed on the Waku Network.
     * Compressing the message or using an alternative strategy for large messages is recommended.
     */
    SendError["SIZE_TOO_BIG"] = "Size is too big";
    /**
     * The PubSubTopic passed to the send function is not configured on the Waku node.
     * Please ensure that the PubSubTopic is used when initializing the Waku node.
     */
    SendError["TOPIC_NOT_CONFIGURED"] = "Topic not configured";
    /**
     * Failure to find a peer with suitable protocols. This may due to a connection issue.
     * Mitigation can be: retrying after a given time period, display connectivity issue
     * to user or listening for `peer:connected:bootstrap` or `peer:connected:peer-exchange`
     * on the connection manager before retrying.
     */
    SendError["NO_PEER_AVAILABLE"] = "No peer available";
    /**
     * The remote peer did not behave as expected. Mitigation for `NO_PEER_AVAILABLE`
     * or `DECODE_FAILED` can be used.
     */
    SendError["REMOTE_PEER_FAULT"] = "Remote peer fault";
    /**
     * The remote peer rejected the message. Information provided by the remote peer
     * is logged. Review message validity, or mitigation for `NO_PEER_AVAILABLE`
     * or `DECODE_FAILED` can be used.
     */
    SendError["REMOTE_PEER_REJECTED"] = "Remote peer rejected";
})(SendError || (SendError = {}));

var PageDirection;
(function (PageDirection) {
    PageDirection["BACKWARD"] = "backward";
    PageDirection["FORWARD"] = "forward";
})(PageDirection || (PageDirection = {}));

var Tags;
(function (Tags) {
    Tags["BOOTSTRAP"] = "bootstrap";
    Tags["PEER_EXCHANGE"] = "peer-exchange";
})(Tags || (Tags = {}));
var EPeersByDiscoveryEvents;
(function (EPeersByDiscoveryEvents) {
    EPeersByDiscoveryEvents["PEER_DISCOVERY_BOOTSTRAP"] = "peer:discovery:bootstrap";
    EPeersByDiscoveryEvents["PEER_DISCOVERY_PEER_EXCHANGE"] = "peer:discovery:peer-exchange";
    EPeersByDiscoveryEvents["PEER_CONNECT_BOOTSTRAP"] = "peer:connected:bootstrap";
    EPeersByDiscoveryEvents["PEER_CONNECT_PEER_EXCHANGE"] = "peer:connected:peer-exchange";
})(EPeersByDiscoveryEvents || (EPeersByDiscoveryEvents = {}));

/**
 * Decode byte array to utf-8 string.
 */
const bytesToUtf8 = (b) => toString(b, "utf8");
/**
 * Encode utf-8 string to byte array.
 */
const utf8ToBytes = (s) => fromString(s, "utf8");
/**
 * Concatenate using Uint8Arrays as `Buffer` has a different behavior with `DataView`
 */
function concat(byteArrays, totalLength) {
    const len = totalLength ?? byteArrays.reduce((acc, curr) => acc + curr.length, 0);
    const res = new Uint8Array(len);
    let offset = 0;
    for (const bytes of byteArrays) {
        res.set(bytes, offset);
        offset += bytes.length;
    }
    return res;
}

/**
 * Returns a pseudo-random peer that supports the given protocol.
 * Useful for protocols such as store and light push
 */
function selectRandomPeer(peers) {
    if (peers.length === 0)
        return;
    const index = Math.round(Math.random() * (peers.length - 1));
    return peers[index];
}
/**
 * Returns the peer with the lowest latency.
 * @param peerStore - The Libp2p PeerStore
 * @param peers - The list of peers to choose from
 * @returns The peer with the lowest latency, or undefined if no peer could be reached
 */
async function selectLowestLatencyPeer(peerStore, peers) {
    if (peers.length === 0)
        return;
    const results = await Promise.all(peers.map(async (peer) => {
        const pingBytes = (await peerStore.get(peer.id)).metadata.get("ping");
        if (!pingBytes)
            return { peer, ping: Infinity };
        const ping = Number(bytesToUtf8(pingBytes)) ?? Infinity;
        return { peer, ping };
    }));
    const lowestLatencyResult = results.sort((a, b) => a.ping - b.ping)[0];
    if (!lowestLatencyResult) {
        return undefined;
    }
    return lowestLatencyResult.ping !== Infinity
        ? lowestLatencyResult.peer
        : undefined;
}
/**
 * Returns the list of peers that supports the given protocol.
 */
async function getPeersForProtocol(peerStore, protocols) {
    const peers = [];
    await peerStore.forEach((peer) => {
        for (let i = 0; i < protocols.length; i++) {
            if (peer.protocols.includes(protocols[i])) {
                peers.push(peer);
                break;
            }
        }
    });
    return peers;
}
/**
 * Returns a peer that supports the given protocol.
 * If peerId is provided, the peer with that id is returned.
 * Otherwise, the peer with the lowest latency is returned.
 * If no peer is found from the above criteria, a random peer is returned.
 */
async function selectPeerForProtocol(peerStore, protocols, peerId) {
    let peer;
    if (peerId) {
        peer = await peerStore.get(peerId);
        if (!peer) {
            throw new Error(`Failed to retrieve connection details for provided peer in peer store: ${peerId.toString()}`);
        }
    }
    else {
        const peers = await getPeersForProtocol(peerStore, protocols);
        peer = await selectLowestLatencyPeer(peerStore, peers);
        if (!peer) {
            peer = selectRandomPeer(peers);
            if (!peer)
                throw new Error(`Failed to find known peer that registers protocols: ${protocols}`);
        }
    }
    let protocol;
    for (const codec of protocols) {
        if (peer.protocols.includes(codec)) {
            protocol = codec;
            // Do not break as we want to keep the last value
        }
    }
    if (!protocol) {
        throw new Error(`Peer does not register required protocols (${peer.id.toString()}): ${protocols}`);
    }
    return { peer, protocol };
}
function selectConnection(connections) {
    if (!connections.length)
        return;
    if (connections.length === 1)
        return connections[0];
    let latestConnection;
    connections.forEach((connection) => {
        if (connection.status === "open") {
            if (!latestConnection) {
                latestConnection = connection;
            }
            else if (connection.timeline.open > latestConnection.timeline.open) {
                latestConnection = connection;
            }
        }
    });
    return latestConnection;
}

/**
 * Retrieves a list of peers based on the specified criteria.
 *
 * @param peers - The list of peers to filter from.
 * @param numPeers - The total number of peers to retrieve. If 0, all peers are returned.
 * @param maxBootstrapPeers - The maximum number of bootstrap peers to retrieve.
 * @returns A Promise that resolves to an array of peers based on the specified criteria.
 */
async function filterPeers(peers, numPeers, maxBootstrapPeers) {
    // Collect the bootstrap peers up to the specified maximum
    const bootstrapPeers = peers
        .filter((peer) => peer.tags.has(Tags.BOOTSTRAP))
        .slice(0, maxBootstrapPeers);
    // Collect non-bootstrap peers
    const nonBootstrapPeers = peers.filter((peer) => !peer.tags.has(Tags.BOOTSTRAP));
    // If numPeers is 0, return all peers
    if (numPeers === 0) {
        return [...bootstrapPeers, ...nonBootstrapPeers];
    }
    // Initialize the list of selected peers with the bootstrap peers
    const selectedPeers = [...bootstrapPeers];
    // Fill up to numPeers with remaining random peers if needed
    while (selectedPeers.length < numPeers && nonBootstrapPeers.length > 0) {
        const randomIndex = Math.floor(Math.random() * nonBootstrapPeers.length);
        const randomPeer = nonBootstrapPeers.splice(randomIndex, 1)[0];
        selectedPeers.push(randomPeer);
    }
    return selectedPeers;
}

class StreamManager {
    multicodec;
    getConnections;
    addEventListener;
    streamPool;
    log;
    constructor(multicodec, getConnections, addEventListener) {
        this.multicodec = multicodec;
        this.getConnections = getConnections;
        this.addEventListener = addEventListener;
        this.log = new Logger(`stream-manager:${multicodec}`);
        this.addEventListener("peer:update", this.handlePeerUpdateStreamPool.bind(this));
        this.getStream = this.getStream.bind(this);
        this.streamPool = new Map();
    }
    async getStream(peer) {
        const peerIdStr = peer.id.toString();
        const streamPromise = this.streamPool.get(peerIdStr);
        if (!streamPromise) {
            return this.newStream(peer); // fallback by creating a new stream on the spot
        }
        // We have the stream, let's remove it from the map
        this.streamPool.delete(peerIdStr);
        this.prepareNewStream(peer);
        const stream = await streamPromise;
        if (!stream || stream.status === "closed") {
            return this.newStream(peer); // fallback by creating a new stream on the spot
        }
        return stream;
    }
    async newStream(peer) {
        const connections = this.getConnections(peer.id);
        const connection = selectConnection(connections);
        if (!connection) {
            throw new Error("Failed to get a connection to the peer");
        }
        return connection.newStream(this.multicodec);
    }
    prepareNewStream(peer) {
        const streamPromise = this.newStream(peer).catch(() => {
            // No error thrown as this call is not triggered by the user
            this.log.error(`Failed to prepare a new stream for ${peer.id.toString()}`);
        });
        this.streamPool.set(peer.id.toString(), streamPromise);
    }
    handlePeerUpdateStreamPool = (evt) => {
        const peer = evt.detail.peer;
        if (peer.protocols.includes(this.multicodec)) {
            this.log.info(`Preemptively opening a stream to ${peer.id.toString()}`);
            this.prepareNewStream(peer);
        }
    };
}

/**
 * A class with predefined helpers, to be used as a base to implement Waku
 * Protocols.
 */
class BaseProtocol {
    multicodec;
    components;
    addLibp2pEventListener;
    removeLibp2pEventListener;
    streamManager;
    constructor(multicodec, components) {
        this.multicodec = multicodec;
        this.components = components;
        this.addLibp2pEventListener = components.events.addEventListener.bind(components.events);
        this.removeLibp2pEventListener = components.events.removeEventListener.bind(components.events);
        this.streamManager = new StreamManager(multicodec, components.connectionManager.getConnections.bind(components.connectionManager), this.addLibp2pEventListener);
    }
    async getStream(peer) {
        return this.streamManager.getStream(peer);
    }
    get peerStore() {
        return this.components.peerStore;
    }
    /**
     * Returns known peers from the address book (`libp2p.peerStore`) that support
     * the class protocol. Waku may or may not be currently connected to these
     * peers.
     */
    async peers() {
        return getPeersForProtocol(this.peerStore, [this.multicodec]);
    }
    async getPeer(peerId) {
        const { peer } = await selectPeerForProtocol(this.peerStore, [this.multicodec], peerId);
        return peer;
    }
    /**
     * Retrieves a list of peers based on the specified criteria.
     *
     * @param numPeers - The total number of peers to retrieve. If 0, all peers are returned.
     * @param maxBootstrapPeers - The maximum number of bootstrap peers to retrieve.
     * @returns A Promise that resolves to an array of peers based on the specified criteria.
     */
    async getPeers({ numPeers, maxBootstrapPeers } = {
        maxBootstrapPeers: 1,
        numPeers: 0
    }) {
        // Retrieve all peers that support the protocol
        const allPeersForProtocol = await getPeersForProtocol(this.peerStore, [
            this.multicodec
        ]);
        // Filter the peers based on the specified criteria
        return filterPeers(allPeersForProtocol, numPeers, maxBootstrapPeers);
    }
}

export { BaseProtocol as B, EPeersByDiscoveryEvents as E, Protocols as P, SendError as S, Tags as T, base58btc as a, base32 as b, coerce as c, allocUnsafe as d, equals as e, asUint8Array as f, bases as g, fromString as h, alloc as i, concat as j, StreamManager as k, toString as t, utf8ToBytes as u };
