import { ensurePubsubTopicIsConfigured, groupByContentTopic, toAsyncIterator } from "@waku/utils";
import { Logger } from "@waku/utils";
import all from "it-all";
import * as lp from "it-length-prefixed";
import { pipe } from "it-pipe";
import { BaseProtocol } from "../base_protocol.js";
import { DefaultPubSubTopic } from "../constants.js";
import { FilterPushRpc, FilterSubscribeResponse, FilterSubscribeRpc } from "./filter_rpc.js";
const log = new Logger("filter:v2");
export const FilterCodecs = {
    SUBSCRIBE: "/vac/waku/filter-subscribe/2.0.0-beta1",
    PUSH: "/vac/waku/filter-push/2.0.0-beta1"
};
class Subscription {
    peer;
    pubsubTopic;
    newStream;
    subscriptionCallbacks;
    constructor(pubsubTopic, remotePeer, newStream) {
        this.peer = remotePeer;
        this.pubsubTopic = pubsubTopic;
        this.newStream = newStream;
        this.subscriptionCallbacks = new Map();
    }
    async subscribe(decoders, callback) {
        const decodersArray = Array.isArray(decoders) ? decoders : [decoders];
        // check that all decoders are configured for the same pubsub topic as this subscription
        decodersArray.forEach((decoder) => {
            if (decoder.pubsubTopic !== this.pubsubTopic) {
                throw new Error(`Pubsub topic not configured: decoder is configured for pubsub topic ${decoder.pubsubTopic} but this subscription is for pubsub topic ${this.pubsubTopic}. Please create a new Subscription for the different pubsub topic.`);
            }
        });
        const decodersGroupedByCT = groupByContentTopic(decodersArray);
        const contentTopics = Array.from(decodersGroupedByCT.keys());
        const stream = await this.newStream(this.peer);
        const request = FilterSubscribeRpc.createSubscribeRequest(this.pubsubTopic, contentTopics);
        try {
            const res = await pipe([request.encode()], lp.encode, stream, lp.decode, async (source) => await all(source));
            if (!res || !res.length) {
                throw Error(`No response received for request ${request.requestId}: ${res}`);
            }
            const { statusCode, requestId, statusDesc } = FilterSubscribeResponse.decode(res[0].slice());
            if (statusCode < 200 || statusCode >= 300) {
                throw new Error(`Filter subscribe request ${requestId} failed with status code ${statusCode}: ${statusDesc}`);
            }
            log.info("Subscribed to peer ", this.peer.id.toString(), "for content topics", contentTopics);
        }
        catch (e) {
            throw new Error("Error subscribing to peer: " +
                this.peer.id.toString() +
                " for content topics: " +
                contentTopics +
                ": " +
                e);
        }
        // Save the callback functions by content topics so they
        // can easily be removed (reciprocally replaced) if `unsubscribe` (reciprocally `subscribe`)
        // is called for those content topics
        decodersGroupedByCT.forEach((decoders, contentTopic) => {
            // Cast the type because a given `subscriptionCallbacks` map may hold
            // Decoder that decode to different implementations of `IDecodedMessage`
            const subscriptionCallback = {
                decoders,
                callback
            };
            // The callback and decoder may override previous values, this is on
            // purpose as the user may call `subscribe` to refresh the subscription
            this.subscriptionCallbacks.set(contentTopic, subscriptionCallback);
        });
    }
    async unsubscribe(contentTopics) {
        const stream = await this.newStream(this.peer);
        const unsubscribeRequest = FilterSubscribeRpc.createUnsubscribeRequest(this.pubsubTopic, contentTopics);
        try {
            await pipe([unsubscribeRequest.encode()], lp.encode, stream.sink);
        }
        catch (error) {
            throw new Error("Error subscribing: " + error);
        }
        contentTopics.forEach((contentTopic) => {
            this.subscriptionCallbacks.delete(contentTopic);
        });
    }
    async ping() {
        const stream = await this.newStream(this.peer);
        const request = FilterSubscribeRpc.createSubscriberPingRequest();
        try {
            const res = await pipe([request.encode()], lp.encode, stream, lp.decode, async (source) => await all(source));
            if (!res || !res.length) {
                throw Error(`No response received for request ${request.requestId}: ${res}`);
            }
            const { statusCode, requestId, statusDesc } = FilterSubscribeResponse.decode(res[0].slice());
            if (statusCode < 200 || statusCode >= 300) {
                throw new Error(`Filter ping request ${requestId} failed with status code ${statusCode}: ${statusDesc}`);
            }
            log.info("Ping successful");
        }
        catch (error) {
            log.error("Error pinging: ", error);
            throw new Error("Error pinging: " + error);
        }
    }
    async unsubscribeAll() {
        const stream = await this.newStream(this.peer);
        const request = FilterSubscribeRpc.createUnsubscribeAllRequest(this.pubsubTopic);
        try {
            const res = await pipe([request.encode()], lp.encode, stream, lp.decode, async (source) => await all(source));
            if (!res || !res.length) {
                throw Error(`No response received for request ${request.requestId}: ${res}`);
            }
            const { statusCode, requestId, statusDesc } = FilterSubscribeResponse.decode(res[0].slice());
            if (statusCode < 200 || statusCode >= 300) {
                throw new Error(`Filter unsubscribe all request ${requestId} failed with status code ${statusCode}: ${statusDesc}`);
            }
            this.subscriptionCallbacks.clear();
            log.info("Unsubscribed from all content topics");
        }
        catch (error) {
            throw new Error("Error unsubscribing from all content topics: " + error);
        }
    }
    async processMessage(message) {
        const contentTopic = message.contentTopic;
        const subscriptionCallback = this.subscriptionCallbacks.get(contentTopic);
        if (!subscriptionCallback) {
            log.error("No subscription callback available for ", contentTopic);
            return;
        }
        await pushMessage(subscriptionCallback, this.pubsubTopic, message);
    }
}
class Filter extends BaseProtocol {
    pubsubTopics = [];
    activeSubscriptions = new Map();
    NUM_PEERS_PROTOCOL = 1;
    getActiveSubscription(pubsubTopic, peerIdStr) {
        return this.activeSubscriptions.get(`${pubsubTopic}_${peerIdStr}`);
    }
    setActiveSubscription(pubsubTopic, peerIdStr, subscription) {
        this.activeSubscriptions.set(`${pubsubTopic}_${peerIdStr}`, subscription);
        return subscription;
    }
    constructor(libp2p, options) {
        super(FilterCodecs.SUBSCRIBE, libp2p.components);
        this.pubsubTopics = options?.pubsubTopics || [DefaultPubSubTopic];
        libp2p.handle(FilterCodecs.PUSH, this.onRequest.bind(this)).catch((e) => {
            log.error("Failed to register ", FilterCodecs.PUSH, e);
        });
        this.activeSubscriptions = new Map();
    }
    async createSubscription(pubsubTopic = DefaultPubSubTopic) {
        ensurePubsubTopicIsConfigured(pubsubTopic, this.pubsubTopics);
        //TODO: get a relevant peer for the topic/shard
        // https://github.com/waku-org/js-waku/pull/1586#discussion_r1336428230
        const peer = (await this.getPeers({
            maxBootstrapPeers: 1,
            numPeers: this.NUM_PEERS_PROTOCOL
        }))[0];
        const subscription = this.getActiveSubscription(pubsubTopic, peer.id.toString()) ??
            this.setActiveSubscription(pubsubTopic, peer.id.toString(), new Subscription(pubsubTopic, peer, this.getStream.bind(this, peer)));
        return subscription;
    }
    toSubscriptionIterator(decoders) {
        return toAsyncIterator(this, decoders);
    }
    /**
     * This method is used to satisfy the `IReceiver` interface.
     *
     * @hidden
     *
     * @param decoders The decoders to use for the subscription.
     * @param callback The callback function to use for the subscription.
     * @param opts Optional protocol options for the subscription.
     *
     * @returns A Promise that resolves to a function that unsubscribes from the subscription.
     *
     * @remarks
     * This method should not be used directly.
     * Instead, use `createSubscription` to create a new subscription.
     */
    async subscribe(decoders, callback) {
        const subscription = await this.createSubscription();
        await subscription.subscribe(decoders, callback);
        const contentTopics = Array.from(groupByContentTopic(Array.isArray(decoders) ? decoders : [decoders]).keys());
        return async () => {
            await subscription.unsubscribe(contentTopics);
        };
    }
    onRequest(streamData) {
        try {
            pipe(streamData.stream, lp.decode, async (source) => {
                for await (const bytes of source) {
                    const response = FilterPushRpc.decode(bytes.slice());
                    const { pubsubTopic, wakuMessage } = response;
                    if (!wakuMessage) {
                        log.error("Received empty message");
                        return;
                    }
                    if (!pubsubTopic) {
                        log.error("PubSub topic missing from push message");
                        return;
                    }
                    const peerIdStr = streamData.connection.remotePeer.toString();
                    const subscription = this.getActiveSubscription(pubsubTopic, peerIdStr);
                    if (!subscription) {
                        log.error(`No subscription locally registered for topic ${pubsubTopic}`);
                        return;
                    }
                    await subscription.processMessage(wakuMessage);
                }
            }).then(() => {
                log.info("Receiving pipe closed.");
            }, (e) => {
                log.error("Error with receiving pipe", e);
            });
        }
        catch (e) {
            log.error("Error decoding message", e);
        }
    }
}
export function wakuFilter(init = {}) {
    return (libp2p) => new Filter(libp2p, init);
}
async function pushMessage(subscriptionCallback, pubsubTopic, message) {
    const { decoders, callback } = subscriptionCallback;
    const { contentTopic } = message;
    if (!contentTopic) {
        log.warn("Message has no content topic, skipping");
        return;
    }
    try {
        const decodePromises = decoders.map((dec) => dec
            .fromProtoObj(pubsubTopic, message)
            .then((decoded) => decoded || Promise.reject("Decoding failed")));
        const decodedMessage = await Promise.any(decodePromises);
        await callback(decodedMessage);
    }
    catch (e) {
        log.error("Error decoding message", e);
    }
}
//# sourceMappingURL=index.js.map