import { isPeerId } from "@libp2p/interface/peer-id";
import { multiaddr } from "@multiformats/multiaddr";
import { Protocols } from "@waku/interfaces";
import { Logger } from "@waku/utils";
import { ConnectionManager } from "./connection_manager.js";
export const DefaultPingKeepAliveValueSecs = 5 * 60;
export const DefaultRelayKeepAliveValueSecs = 5 * 60;
export const DefaultUserAgent = "js-waku";
const log = new Logger("waku");
export class WakuNode {
    pubsubTopics;
    libp2p;
    relay;
    store;
    filter;
    lightPush;
    connectionManager;
    constructor(options, pubsubTopics, libp2p, store, lightPush, filter, relay) {
        this.pubsubTopics = pubsubTopics;
        this.libp2p = libp2p;
        if (store) {
            this.store = store(libp2p);
        }
        if (filter) {
            this.filter = filter(libp2p);
        }
        if (lightPush) {
            this.lightPush = lightPush(libp2p);
        }
        if (relay) {
            this.relay = relay(libp2p);
        }
        const pingKeepAlive = options.pingKeepAlive || DefaultPingKeepAliveValueSecs;
        const relayKeepAlive = this.relay
            ? options.relayKeepAlive || DefaultRelayKeepAliveValueSecs
            : 0;
        const peerId = this.libp2p.peerId.toString();
        this.connectionManager = ConnectionManager.create(peerId, libp2p, { pingKeepAlive, relayKeepAlive }, pubsubTopics, this.relay);
        log.info("Waku node created", peerId, `relay: ${!!this.relay}, store: ${!!this.store}, light push: ${!!this
            .lightPush}, filter: ${!!this.filter}`);
    }
    /**
     * Dials to the provided peer.
     *
     * @param peer The peer to dial
     * @param protocols Waku protocols we expect from the peer; Defaults to mounted protocols
     */
    async dial(peer, protocols) {
        const _protocols = protocols ?? [];
        const peerId = mapToPeerIdOrMultiaddr(peer);
        if (typeof protocols === "undefined") {
            this.relay && _protocols.push(Protocols.Relay);
            this.store && _protocols.push(Protocols.Store);
            this.filter && _protocols.push(Protocols.Filter);
            this.lightPush && _protocols.push(Protocols.LightPush);
        }
        const codecs = [];
        if (_protocols.includes(Protocols.Relay)) {
            if (this.relay) {
                this.relay.gossipSub.multicodecs.forEach((codec) => codecs.push(codec));
            }
            else {
                log.error("Relay codec not included in dial codec: protocol not mounted locally");
            }
        }
        if (_protocols.includes(Protocols.Store)) {
            if (this.store) {
                codecs.push(this.store.multicodec);
            }
            else {
                log.error("Store codec not included in dial codec: protocol not mounted locally");
            }
        }
        if (_protocols.includes(Protocols.LightPush)) {
            if (this.lightPush) {
                codecs.push(this.lightPush.multicodec);
            }
            else {
                log.error("Light Push codec not included in dial codec: protocol not mounted locally");
            }
        }
        if (_protocols.includes(Protocols.Filter)) {
            if (this.filter) {
                codecs.push(this.filter.multicodec);
            }
            else {
                log.error("Filter codec not included in dial codec: protocol not mounted locally");
            }
        }
        log.info(`Dialing to ${peerId.toString()} with protocols ${_protocols}`);
        return this.libp2p.dialProtocol(peerId, codecs);
    }
    async start() {
        await this.libp2p.start();
    }
    async stop() {
        this.connectionManager.stop();
        await this.libp2p.stop();
    }
    isStarted() {
        return this.libp2p.isStarted();
    }
    /**
     * Return the local multiaddr with peer id on which libp2p is listening.
     *
     * @throws if libp2p is not listening on localhost.
     */
    getLocalMultiaddrWithID() {
        const localMultiaddr = this.libp2p
            .getMultiaddrs()
            .find((addr) => addr.toString().match(/127\.0\.0\.1/));
        if (!localMultiaddr || localMultiaddr.toString() === "") {
            throw "Not listening on localhost";
        }
        return localMultiaddr + "/p2p/" + this.libp2p.peerId.toString();
    }
}
function mapToPeerIdOrMultiaddr(peerId) {
    return isPeerId(peerId) ? peerId : multiaddr(peerId);
}
//# sourceMappingURL=waku.js.map