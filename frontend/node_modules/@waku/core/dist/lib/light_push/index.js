import { SendError } from "@waku/interfaces";
import { PushResponse } from "@waku/proto";
import { ensurePubsubTopicIsConfigured, isMessageSizeUnderCap } from "@waku/utils";
import { Logger } from "@waku/utils";
import all from "it-all";
import * as lp from "it-length-prefixed";
import { pipe } from "it-pipe";
import { Uint8ArrayList } from "uint8arraylist";
import { BaseProtocol } from "../base_protocol.js";
import { DefaultPubSubTopic } from "../constants.js";
import { PushRpc } from "./push_rpc.js";
const log = new Logger("light-push");
export const LightPushCodec = "/vac/waku/lightpush/2.0.0-beta1";
export { PushResponse };
/**
 * Implements the [Waku v2 Light Push protocol](https://rfc.vac.dev/spec/19/).
 */
class LightPush extends BaseProtocol {
    pubsubTopics;
    NUM_PEERS_PROTOCOL = 1;
    constructor(libp2p, options) {
        super(LightPushCodec, libp2p.components);
        this.pubsubTopics = options?.pubsubTopics ?? [DefaultPubSubTopic];
    }
    async preparePushMessage(encoder, message, pubsubTopic) {
        try {
            if (!message.payload || message.payload.length === 0) {
                log.error("Failed to send waku light push: payload is empty");
                return { query: null, error: SendError.EMPTY_PAYLOAD };
            }
            if (!(await isMessageSizeUnderCap(encoder, message))) {
                log.error("Failed to send waku light push: message is bigger than 1MB");
                return { query: null, error: SendError.SIZE_TOO_BIG };
            }
            const protoMessage = await encoder.toProtoObj(message);
            if (!protoMessage) {
                log.error("Failed to encode to protoMessage, aborting push");
                return {
                    query: null,
                    error: SendError.ENCODE_FAILED
                };
            }
            const query = PushRpc.createRequest(protoMessage, pubsubTopic);
            return { query, error: null };
        }
        catch (error) {
            log.error("Failed to prepare push message", error);
            return {
                query: null,
                error: SendError.GENERIC_FAIL
            };
        }
    }
    async send(encoder, message) {
        const { pubsubTopic } = encoder;
        ensurePubsubTopicIsConfigured(pubsubTopic, this.pubsubTopics);
        const recipients = [];
        const { query, error: preparationError } = await this.preparePushMessage(encoder, message, pubsubTopic);
        if (preparationError || !query) {
            return {
                recipients,
                errors: [preparationError]
            };
        }
        //TODO: get a relevant peer for the topic/shard
        const peers = await this.getPeers({
            maxBootstrapPeers: 1,
            numPeers: this.NUM_PEERS_PROTOCOL
        });
        if (!peers.length) {
            return {
                recipients,
                errors: [SendError.NO_PEER_AVAILABLE]
            };
        }
        const promises = peers.map(async (peer) => {
            let stream;
            try {
                stream = await this.getStream(peer);
            }
            catch (err) {
                log.error(`Failed to get a stream for remote peer${peer.id.toString()}`, err);
                return { recipients, error: SendError.REMOTE_PEER_FAULT };
            }
            let res;
            try {
                res = await pipe([query.encode()], lp.encode, stream, lp.decode, async (source) => await all(source));
            }
            catch (err) {
                log.error("Failed to send waku light push request", err);
                return { recipients, error: SendError.GENERIC_FAIL };
            }
            const bytes = new Uint8ArrayList();
            res.forEach((chunk) => {
                bytes.append(chunk);
            });
            let response;
            try {
                response = PushRpc.decode(bytes).response;
            }
            catch (err) {
                log.error("Failed to decode push reply", err);
                return { recipients, error: SendError.DECODE_FAILED };
            }
            if (!response) {
                log.error("Remote peer fault: No response in PushRPC");
                return { recipients, error: SendError.REMOTE_PEER_FAULT };
            }
            if (!response.isSuccess) {
                log.error("Remote peer rejected the message: ", response.info);
                return { recipients, error: SendError.REMOTE_PEER_REJECTED };
            }
            recipients.some((recipient) => recipient.equals(peer.id)) ||
                recipients.push(peer.id);
            return { recipients };
        });
        const results = await Promise.allSettled(promises);
        const errors = results
            .filter((result) => result.status === "fulfilled")
            .map((result) => result.value.error)
            .filter((error) => error !== undefined);
        return {
            recipients,
            errors
        };
    }
}
export function wakuLightPush(init = {}) {
    return (libp2p) => new LightPush(libp2p, init);
}
//# sourceMappingURL=index.js.map