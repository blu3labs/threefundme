import { noise } from "@chainsafe/libp2p-noise";
import { mplex } from "@libp2p/mplex";
import { webSockets } from "@libp2p/websockets";
import { all as filterAll } from "@libp2p/websockets/filters";
import { DefaultPubSubTopic, DefaultUserAgent, wakuFilter, wakuLightPush, WakuNode, wakuStore } from "@waku/core";
import { enrTree, wakuDnsDiscovery } from "@waku/dns-discovery";
import { wakuPeerExchangeDiscovery } from "@waku/peer-exchange";
import { wakuGossipSub, wakuRelay } from "@waku/relay";
import { createLibp2p } from "libp2p";
import { identifyService } from "libp2p/identify";
import { pingService } from "libp2p/ping";
const DEFAULT_NODE_REQUIREMENTS = {
    lightPush: 1,
    filter: 1,
    store: 1
};
/**
 * Create a Waku node that uses Waku Light Push, Filter and Store to send and
 * receive messages, enabling low resource consumption.
 * Uses Waku Filter V2 by default.
 */
export async function createLightNode(options) {
    options = options ?? {};
    if (!options.pubsubTopics) {
        options.pubsubTopics = [DefaultPubSubTopic];
    }
    const libp2pOptions = options?.libp2p ?? {};
    const peerDiscovery = libp2pOptions.peerDiscovery ?? [];
    if (options?.defaultBootstrap) {
        peerDiscovery.push(...defaultPeerDiscoveries());
        Object.assign(libp2pOptions, { peerDiscovery });
    }
    const libp2p = await defaultLibp2p(undefined, libp2pOptions, options?.userAgent);
    const store = wakuStore(options);
    const lightPush = wakuLightPush(options);
    const filter = wakuFilter(options);
    return new WakuNode(options ?? {}, options.pubsubTopics, libp2p, store, lightPush, filter);
}
/**
 * Create a Waku node that uses Waku Relay to send and receive messages,
 * enabling some privacy preserving properties.
 */
export async function createRelayNode(options) {
    options = options ?? {};
    if (!options.pubsubTopics) {
        options.pubsubTopics = [DefaultPubSubTopic];
    }
    const libp2pOptions = options?.libp2p ?? {};
    const peerDiscovery = libp2pOptions.peerDiscovery ?? [];
    if (options?.defaultBootstrap) {
        peerDiscovery.push(...defaultPeerDiscoveries());
        Object.assign(libp2pOptions, { peerDiscovery });
    }
    const libp2p = await defaultLibp2p(wakuGossipSub(options), libp2pOptions, options?.userAgent);
    const relay = wakuRelay(options);
    return new WakuNode(options, options.pubsubTopics, libp2p, undefined, undefined, undefined, relay);
}
/**
 * Create a Waku node that uses all Waku protocols.
 *
 * This helper is not recommended except if:
 * - you are interfacing with nwaku v0.11 or below
 * - you are doing some form of testing
 *
 * If you are building a full node, it is recommended to use
 * [nwaku](github.com/status-im/nwaku) and its JSON RPC API or wip REST API.
 *
 * @see https://github.com/status-im/nwaku/issues/1085
 * @internal
 */
export async function createFullNode(options) {
    options = options ?? {};
    if (!options.pubsubTopics) {
        options.pubsubTopics = [DefaultPubSubTopic];
    }
    const libp2pOptions = options?.libp2p ?? {};
    const peerDiscovery = libp2pOptions.peerDiscovery ?? [];
    if (options?.defaultBootstrap) {
        peerDiscovery.push(...defaultPeerDiscoveries());
        Object.assign(libp2pOptions, { peerDiscovery });
    }
    const libp2p = await defaultLibp2p(wakuGossipSub(options), libp2pOptions, options?.userAgent);
    const store = wakuStore(options);
    const lightPush = wakuLightPush(options);
    const filter = wakuFilter(options);
    const relay = wakuRelay(options);
    return new WakuNode(options ?? {}, options.pubsubTopics, libp2p, store, lightPush, filter, relay);
}
export function defaultPeerDiscoveries() {
    const discoveries = [
        wakuDnsDiscovery([enrTree["PROD"]], DEFAULT_NODE_REQUIREMENTS),
        wakuPeerExchangeDiscovery()
    ];
    return discoveries;
}
export async function defaultLibp2p(wakuGossipSub, options, userAgent) {
    const pubsubService = wakuGossipSub
        ? { pubsub: wakuGossipSub }
        : {};
    return createLibp2p({
        connectionManager: {
            minConnections: 1
        },
        transports: [webSockets({ filter: filterAll })],
        streamMuxers: [mplex()],
        connectionEncryption: [noise()],
        ...options,
        services: {
            identify: identifyService({
                agentVersion: userAgent ?? DefaultUserAgent
            }),
            ping: pingService(),
            ...pubsubService,
            ...options?.services
        }
    }); // TODO: make libp2p include it;
}
//# sourceMappingURL=create.js.map